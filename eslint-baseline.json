[
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/api-client-wrapper.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/client.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/backup.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"enabled\"] is better written in dot notation.",
        "line": 626,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 626,
        "endColumn": 46,
        "fix": { "range": [21411, 21422], "text": ".enabled" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"enabled\"] is better written in dot notation.",
        "line": 628,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 628,
        "endColumn": 47,
        "fix": { "range": [21518, 21529], "text": ".enabled" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"limit\"] is better written in dot notation.",
        "line": 630,
        "column": 35,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 630,
        "endColumn": 42,
        "fix": { "range": [21623, 21632], "text": ".limit" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/boards.ts",
    "messages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 442,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 442,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [13035, 13086], "text": "" },
            "desc": "Remove the console.error()."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"name\"] is better written in dot notation.",
        "line": 619,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 619,
        "endColumn": 43,
        "fix": { "range": [18592, 18600], "text": ".name" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"description\"] is better written in dot notation.",
        "line": 621,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 621,
        "endColumn": 57,
        "fix": { "range": [18710, 18725], "text": ".description" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @module cli/commands/boards\n * @description Board management commands for the CLI.\n *\n * Provides comprehensive board operations including creating, updating, listing,\n * archiving, and viewing boards. Supports interactive board setup with templates\n * and real-time board visualization.\n *\n * @example\n * ```bash\n * # List all boards\n * kanban board list\n *\n * # Create a board interactively\n * kanban board create --interactive\n *\n * # Quick setup with template\n * kanban board quick-setup --template scrum --name \"Dev Sprint\"\n *\n * # View board in interactive mode\n * kanban board view board123\n *\n * # Set default board\n * kanban board use board123\n * ```\n */\n\nimport type { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport * as React from 'react';\nimport { render } from 'ink';\nimport chalk from 'chalk';\nimport type { CliComponents, CreateBoardRequest } from '../types';\nimport type { Task, Board, Column } from '../../types';\nimport { isSuccessResponse } from '../api-client-wrapper';\nimport BoardView from '../ui/components/BoardView';\nimport { SpinnerManager } from '../utils/spinner';\n\ninterface ListBoardOptions {\n  active?: boolean;\n  archived?: boolean;\n}\n\ninterface ShowBoardOptions {\n  tasks?: boolean;\n  stats?: boolean;\n}\n\ninterface BoardData {\n  id: string;\n  name: string;\n  description?: string;\n  archived: boolean;\n  createdAt: string;\n  updatedAt?: string;\n  columns?: Column[];\n  tasks?: Task[];\n}\n\ninterface ApiColumnData {\n  id: string;\n  name: string;\n  wip_limit?: number;\n  tasks?: ApiTaskData[];\n}\n\ninterface ApiTaskData {\n  id: string;\n  title: string;\n  status: string;\n  priority: string;\n  assignee?: string;\n  tags?: string[];\n  due_date?: string;\n}\n\ninterface ApiBoardResponse {\n  id: string;\n  name: string;\n  description?: string;\n  columns?: ApiColumnData[];\n}\n\ninterface ViewBoardOptions {\n  interactive?: boolean;\n  wipLimits?: boolean;\n  refresh?: string;\n  maxHeight?: string;\n  columnWidth?: string;\n}\n\ninterface CreateBoardData {\n  name?: string;\n  description?: string;\n}\n\ninterface CreateBoardOptions {\n  name?: string;\n  description?: string;\n  interactive?: boolean;\n}\n\ninterface CreateBoardPromptResult {\n  name?: string;\n  description?: string;\n  useAsDefault?: boolean;\n}\n\ninterface UpdateBoardOptions {\n  name?: string;\n  description?: string;\n  interactive?: boolean;\n}\n\ninterface UpdateBoardPromptResult {\n  name?: string;\n  description?: string;\n}\n\ninterface DeleteBoardOptions {\n  force?: boolean;\n}\n\ninterface ConfirmPromptResult {\n  confirm: boolean;\n}\n\ninterface QuickSetupOptions {\n  name?: string;\n  description?: string;\n  template?: string;\n  public?: boolean;\n  setDefault?: boolean;\n}\n\ninterface QuickSetupDefaults {\n  name?: string;\n  description?: string;\n  isPublic?: boolean;\n  columns?: Array<{ name: string; order: number }>;\n}\n\n/**\n * Register all board-related commands with the CLI program.\n *\n * @param program - The commander program instance\n *\n * Available commands:\n * - `list` (alias: `ls`) - List boards with filtering\n * - `show <id>` - Display board details and statistics\n * - `view [id]` - Interactive board visualization\n * - `create` (alias: `new`) - Create a new board\n * - `update <id>` - Update board properties\n * - `delete <id>` (alias: `rm`) - Delete a board\n * - `use <id>` - Set board as default\n * - `archive <id>` - Archive a board\n * - `unarchive <id>` - Restore archived board\n * - `quick-setup` (alias: `setup`) - Quick board setup with templates\n */\nexport function registerBoardCommands(program: Command): void {\n  const boardCmd = program.command('board').alias('b').description('Manage boards');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  /**\n   * List all boards with optional filtering.\n   *\n   * @command list\n   * @alias ls\n   *\n   * @option --active - Show only active (non-archived) boards\n   * @option --archived - Show only archived boards\n   *\n   * @example\n   * ```bash\n   * # List all boards\n   * kanban board list\n   *\n   * # List only active boards\n   * kanban board list --active\n   *\n   * # List archived boards\n   * kanban board list --archived\n   * ```\n   *\n   * Output columns:\n   * - ID: Board identifier\n   * - Name: Board name\n   * - Description: Board description\n   * - Archived: Archive status\n   * - Created: Creation timestamp\n   */\n  boardCmd\n    .command('list')\n    .alias('ls')\n    .description('List boards')\n    .option('--active', 'show only active boards')\n    .option('--archived', 'show only archived boards')\n    .action(async (options: ListBoardOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const response = await apiClient.getBoards();\n        const boards = 'data' in response ? (response.data as BoardData[]) : [];\n\n        if (!boards || boards.length === 0) {\n          formatter.info('No boards found');\n          return;\n        }\n\n        // Filter based on options\n        let filteredBoards = boards;\n        if (options.active) {\n          filteredBoards = boards.filter((board: BoardData) => !board.archived);\n        } else if (options.archived) {\n          filteredBoards = boards.filter((board: BoardData) => board.archived);\n        }\n\n        formatter.output(filteredBoards, {\n          fields: ['id', 'name', 'description', 'archived', 'createdAt'],\n          headers: ['ID', 'Name', 'Description', 'Archived', 'Created'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to list boards: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Show detailed information about a specific board.\n   *\n   * @command show <id>\n   *\n   * @param id - The board ID to display\n   * @option --tasks - Include all tasks in the board\n   * @option --stats - Include board statistics and analytics\n   *\n   * @example\n   * ```bash\n   * # Show basic board details\n   * kanban board show board123\n   *\n   * # Show board with tasks\n   * kanban board show board123 --tasks\n   *\n   * # Show board with statistics\n   * kanban board show board123 --stats\n   * ```\n   *\n   * Statistics include:\n   * - Total tasks by status\n   * - Task completion rate\n   * - Average task age\n   * - Overdue task count\n   * - Team productivity metrics\n   */\n  boardCmd\n    .command('show <id>')\n    .description('Show board details')\n    .option('--tasks', 'include tasks in board')\n    .option('--stats', 'include board statistics')\n    .action(async (id: string, options: ShowBoardOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const response = await apiClient.getBoard(id);\n        const board = 'data' in response ? (response.data as BoardData) : undefined;\n\n        if (!board) {\n          formatter.error(`Board ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        formatter.output(board);\n\n        if (options.tasks && board.tasks) {\n          formatter.info('\\n--- Tasks ---');\n          formatter.output(board.tasks, {\n            fields: ['id', 'title', 'status', 'priority'],\n            headers: ['ID', 'Title', 'Status', 'Priority'],\n          });\n        }\n\n        if (options.stats) {\n          formatter.info('\\n--- Statistics ---');\n          try {\n            const statsResponse = await apiClient.getBoardStats(id);\n            if ('data' in statsResponse) {\n              formatter.output(statsResponse.data);\n            } else {\n              formatter.warn('No statistics data available');\n            }\n          } catch (error) {\n            formatter.warn('Could not retrieve board statistics');\n          }\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get board: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Interactive board view with real-time updates.\n   *\n   * @command view [id]\n   *\n   * @param id - Board ID (uses default board if not specified)\n   * @option -i, --interactive - Enable interactive mode (default: true)\n   * @option --no-interactive - Disable interactive mode\n   * @option --wip-limits - Show Work-In-Progress limits (default: true)\n   * @option --refresh <seconds> - Auto-refresh interval in seconds (default: 30)\n   * @option --max-height <number> - Maximum tasks shown per column (default: 8)\n   * @option --column-width <number> - Column display width (default: 25)\n   *\n   * @example\n   * ```bash\n   * # View default board interactively\n   * kanban board view\n   *\n   * # View specific board with custom refresh\n   * kanban board view board123 --refresh 10\n   *\n   * # Non-interactive view (static display)\n   * kanban board view board123 --no-interactive\n   * ```\n   *\n   * Interactive controls:\n   * - ‚Üê/‚Üí or h/l: Switch columns\n   * - ‚Üë/‚Üì or j/k: Navigate tasks\n   * - Enter: Select task/column\n   * - r: Manual refresh\n   * - n: New task in column\n   * - e: Edit selected task\n   * - d: Delete selected task\n   * - ?: Show help\n   * - q: Quit\n   *\n   * @note Interactive mode is temporarily disabled pending Ink/React ESM resolution\n   */\n  boardCmd\n    .command('view [id]')\n    .description('Interactive board view with live updates')\n    .option('-i, --interactive', 'enable interactive mode (default)', true)\n    .option('--no-interactive', 'disable interactive mode')\n    .option('--wip-limits', 'show WIP limits', true)\n    .option('--refresh <seconds>', 'auto-refresh interval', '30')\n    .option('--max-height <number>', 'maximum column height', '8')\n    .option('--column-width <number>', 'column width', '25')\n    .action(async (id?: string, options?: ViewBoardOptions) => {\n      const { config, apiClient, formatter } = getComponents();\n\n      try {\n        // Determine board ID\n        const boardId = id ?? config.getDefaultBoard();\n        if (!boardId) {\n          formatter.error(\n            'Board ID is required. Specify an ID or set default board with \"kanban board use <id>\"'\n          );\n          process.exit(1);\n        }\n\n        // Fetch board data with spinner\n        const spinner = new SpinnerManager();\n        const boardData = await spinner.withSpinner(\n          `Loading board: ${String(boardId)}`,\n          apiClient.getBoard(boardId),\n          {\n            successText: 'Board loaded successfully',\n            failText: 'Failed to load board',\n          }\n        );\n\n        if (!boardData) {\n          formatter.error(`Board ${String(boardId)} not found`);\n          process.exit(1);\n        }\n\n        // Transform API data to component format\n        const apiResponse = boardData as ApiBoardResponse;\n        const board: Board = {\n          id: apiResponse.id,\n          name: apiResponse.name,\n          description: apiResponse.description,\n          color: '#007acc',\n          created_at: new Date(),\n          updated_at: new Date(),\n          archived: false,\n        };\n\n        if (!options?.interactive) {\n          // Non-interactive mode - just show board data\n          formatter.output(board);\n          return;\n        }\n\n        // Interactive mode with React component\n        spinner.info(`Starting interactive board view for: ${board.name}`);\n\n        let refreshInterval: NodeJS.Timeout | null = null;\n        let shouldRefresh = false;\n\n        const InteractiveBoardView = (): React.ReactElement => {\n          const [currentBoard, setCurrentBoard] = React.useState<Board>(board);\n\n          // Auto-refresh functionality\n          React.useEffect(() => {\n            if (options?.refresh && parseInt(options.refresh, 10) > 0) {\n              const interval = parseInt(options.refresh, 10) * 1000;\n              refreshInterval = setInterval(() => {\n                if (!shouldRefresh) return;\n\n                (async (): Promise<void> => {\n                  try {\n                    const refreshedData = await apiClient.getBoard(boardId);\n                    if (refreshedData) {\n                      const refreshedApiResponse = refreshedData as ApiBoardResponse;\n                      const refreshedBoard: Board = {\n                        id: refreshedApiResponse.id,\n                        name: refreshedApiResponse.name,\n                        description: refreshedApiResponse.description,\n                        color: '#2196F3', // Default color\n                        created_at: new Date(),\n                        updated_at: new Date(),\n                        archived: false,\n                      };\n\n                      // TODO: Process refreshed columns and tasks when needed\n                      // const refreshedColumns: Column[] = (apiResponse.columns ?? []).map(...);\n                      // const refreshedTasks: Task[] = (apiResponse.columns ?? []).flatMap(...);\n                      setCurrentBoard(refreshedBoard);\n                    }\n                  } catch (error) {\n                    // Silently fail refresh\n                  }\n                })().catch((err: Error) => {\n                  console.error('Auto-refresh failed:', err.message);\n                });\n              }, interval);\n            }\n\n            return () => {\n              if (refreshInterval) {\n                clearInterval(refreshInterval);\n              }\n            };\n          }, []);\n\n          // Enable refresh after initial render\n          React.useEffect(() => {\n            shouldRefresh = true;\n          }, []);\n\n          return React.createElement(BoardView, {\n            board: currentBoard,\n            columns: [], // TODO: Get columns from API\n            tasks: [], // TODO: Get tasks from API\n            showDetails: false,\n          });\n        };\n\n        // Show loading indicator and instructions\n        formatter.info(`Starting interactive board view for: ${String(board.name)}`);\n        formatter.info('Press ? for help, q to quit');\n\n        // Render the interactive board view\n        render(React.createElement(InteractiveBoardView));\n      } catch (error) {\n        formatter.error(\n          `Failed to start board view: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Create a new board.\n   *\n   * @command create\n   * @alias new\n   *\n   * @option -n, --name <name> - Board name (required in non-interactive mode)\n   * @option -d, --description <desc> - Board description\n   * @option -i, --interactive - Use interactive prompts\n   *\n   * @example\n   * ```bash\n   * # Create board with options\n   * kanban board create --name \"Q4 Sprint\" --description \"Fourth quarter development\"\n   *\n   * # Create board interactively\n   * kanban board create --interactive\n   * ```\n   *\n   * Interactive mode prompts:\n   * - Board name (required)\n   * - Description (optional)\n   * - Set as default board\n   */\n  boardCmd\n    .command('create')\n    .alias('new')\n    .description('Create a new board')\n    .option('-n, --name <name>', 'board name')\n    .option('-d, --description <desc>', 'board description')\n    .option('-i, --interactive', 'interactive mode')\n    .action(async (options: CreateBoardOptions) => {\n      const { config, apiClient, formatter } = getComponents();\n\n      let boardData: CreateBoardData = {};\n\n      if (options.interactive ?? !options.name) {\n        const questions: Array<{\n          type: string;\n          name: string;\n          message: string;\n          validate?: (input: string) => boolean | string;\n          default?: boolean;\n        }> = [];\n\n        if (!options.name) {\n          questions.push({\n            type: 'input',\n            name: 'name',\n            message: 'Board name:',\n            validate: (input: string) => input.length > 0 || 'Name is required',\n          });\n        }\n\n        if (!options.description) {\n          questions.push({\n            type: 'input',\n            name: 'description',\n            message: 'Board description (optional):',\n          });\n        }\n\n        questions.push({\n          type: 'confirm',\n          name: 'useAsDefault',\n          message: 'Set as default board?',\n          default: false,\n        });\n\n        const answers = await inquirer.prompt<CreateBoardPromptResult>(questions);\n        boardData = { ...boardData, ...answers };\n      }\n\n      // Use command line options or answers\n      boardData.name = options.name ?? boardData.name;\n      boardData.description = options.description ?? boardData.description;\n\n      try {\n        const board = await apiClient.createBoard(boardData as CreateBoardRequest);\n        if (isSuccessResponse(board)) {\n          formatter.success(`Board created successfully: ${String(board.data.id)}`);\n          formatter.output(board.data);\n        } else {\n          formatter.error('Failed to create board');\n          process.exit(1);\n        }\n\n        // Set as default if requested\n        if (boardData.useAsDefault && isSuccessResponse(board)) {\n          config.setDefaultBoard(board.data.id);\n          formatter.info(`Set as default board`);\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to create board: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  boardCmd\n    .command('update <id>')\n    .description('Update a board')\n    .option('-n, --name <name>', 'board name')\n    .option('-d, --description <desc>', 'board description')\n    .option('-i, --interactive', 'interactive mode')\n    .action(async (id: string, options: UpdateBoardOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        // Get current board data\n        const currentBoard = await apiClient.getBoard(id);\n        if (!isSuccessResponse(currentBoard)) {\n          formatter.error(`Board ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        let updates: Record<string, unknown> = {};\n\n        if (options.interactive) {\n          const answers = await inquirer.prompt<UpdateBoardPromptResult>([\n            {\n              type: 'input',\n              name: 'name',\n              message: 'Board name:',\n              default: (currentBoard.data as Board).name,\n            },\n            {\n              type: 'input',\n              name: 'description',\n              message: 'Board description:',\n              default: (currentBoard.data as Board).description ?? '',\n            },\n          ]);\n          updates = answers;\n        } else {\n          // Use command line options\n          // eslint-disable-next-line dot-notation\n          if (options.name) updates['name'] = options.name;\n          // eslint-disable-next-line dot-notation\n          if (options.description) updates['description'] = options.description;\n        }\n\n        if (Object.keys(updates).length === 0) {\n          formatter.warn('No updates specified');\n          return;\n        }\n\n        const updatedBoard = await apiClient.updateBoard(id, updates);\n        formatter.success('Board updated successfully');\n        formatter.output(updatedBoard);\n      } catch (error) {\n        formatter.error(\n          `Failed to update board: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  boardCmd\n    .command('delete <id>')\n    .alias('rm')\n    .description('Delete a board')\n    .option('-f, --force', 'skip confirmation')\n    .action(async (id: string, options: DeleteBoardOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          const board = await apiClient.getBoard(id);\n          if (!isSuccessResponse(board)) {\n            formatter.error(`Board ${String(id)} not found`);\n            process.exit(1);\n          }\n\n          const { confirm } = await inquirer.prompt<ConfirmPromptResult>([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: `Delete board \"${String((board.data as Board).name)}\"? This will also delete all tasks in the board.`,\n              default: false,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Delete cancelled');\n            return;\n          }\n        }\n\n        await apiClient.deleteBoard(id);\n        formatter.success(`Board ${String(id)} deleted successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to delete board: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Set a board as the default for all CLI operations.\n   *\n   * @command use <id>\n   *\n   * @param id - The board ID to set as default\n   *\n   * @example\n   * ```bash\n   * # Set default board\n   * kanban board use board123\n   *\n   * # Now all task operations use this board by default\n   * kanban task list  # Lists tasks from board123\n   * ```\n   */\n  boardCmd\n    .command('use <id>')\n    .description('Set board as default')\n    .action(async (id: string) => {\n      const { config, apiClient, formatter } = getComponents();\n\n      try {\n        // Verify board exists\n        const board = await apiClient.getBoard(id);\n        if (!isSuccessResponse(board)) {\n          formatter.error(`Board ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        config.setDefaultBoard(id);\n        formatter.success(\n          `Default board set to \"${String(String((board.data as Board).name))}\" (${String(id)})`\n        );\n      } catch (error) {\n        formatter.error(\n          `Failed to set default board: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Archive a board to hide it from active board lists.\n   *\n   * @command archive <id>\n   *\n   * @param id - The board ID to archive\n   *\n   * @example\n   * ```bash\n   * kanban board archive board123\n   * ```\n   *\n   * @note Archived boards can be restored using the `unarchive` command.\n   * Tasks within archived boards remain accessible.\n   */\n  boardCmd\n    .command('archive <id>')\n    .description('Archive a board')\n    .action(async (id: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        await apiClient.updateBoard(id, { archived: true });\n        formatter.success(`Board ${String(id)} archived successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to archive board: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  boardCmd\n    .command('unarchive <id>')\n    .description('Unarchive a board')\n    .action(async (id: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        await apiClient.updateBoard(id, { archived: false });\n        formatter.success(`Board ${String(id)} unarchived successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to unarchive board: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Quick board setup with pre-configured templates.\n   *\n   * @command quick-setup\n   * @alias setup\n   *\n   * @option -n, --name <name> - Board name\n   * @option -d, --description <desc> - Board description\n   * @option --template <type> - Template type: basic, scrum, bugs, content\n   * @option --public - Make board publicly accessible\n   * @option --set-default - Automatically set as default board\n   *\n   * @example\n   * ```bash\n   * # Interactive setup\n   * kanban board quick-setup\n   *\n   * # Use Scrum template\n   * kanban board quick-setup --template scrum --name \"Sprint Board\"\n   *\n   * # Quick setup with all options\n   * kanban board quick-setup --template bugs --name \"Bug Tracker\" --public --set-default\n   * ```\n   *\n   * Available templates:\n   * - **basic**: To Do ‚Üí In Progress ‚Üí Done\n   * - **scrum**: Backlog ‚Üí To Do ‚Üí In Progress ‚Üí Review ‚Üí Done\n   * - **bugs**: New ‚Üí Confirmed ‚Üí In Progress ‚Üí Testing ‚Üí Resolved\n   * - **content**: Ideas ‚Üí Writing ‚Üí Editing ‚Üí Review ‚Üí Published\n   *\n   * After creation:\n   * - View board: `kanban board view <id>`\n   * - Create task: `kanban task create --interactive`\n   * - List tasks: `kanban task list`\n   */\n  boardCmd\n    .command('quick-setup')\n    .alias('setup')\n    .description('Quick interactive board setup with templates')\n    .option('-n, --name <name>', 'board name')\n    .option('-d, --description <desc>', 'board description')\n    .option('--template <type>', 'use template (basic, scrum, bugs, content)')\n    .option('--public', 'make board public')\n    .option('--set-default', 'set as default board after creation')\n    .action(async (options: QuickSetupOptions) => {\n      const { config, apiClient, formatter } = getComponents();\n\n      try {\n        // Import the quick setup function\n        const { quickBoardSetup, confirmAction } = await import('../prompts/board-prompts');\n\n        // Prepare defaults from command line options\n        const defaults: QuickSetupDefaults = {};\n        if (options.name) defaults.name = options.name;\n        if (options.description) defaults.description = options.description;\n        if (options.public) defaults.isPublic = true;\n\n        // If template is specified, we'll handle it differently\n        if (options.template) {\n          const templates = {\n            basic: [\n              { name: 'To Do', order: 0 },\n              { name: 'In Progress', order: 1 },\n              { name: 'Done', order: 2 },\n            ],\n            scrum: [\n              { name: 'Backlog', order: 0 },\n              { name: 'To Do', order: 1 },\n              { name: 'In Progress', order: 2 },\n              { name: 'Review', order: 3 },\n              { name: 'Done', order: 4 },\n            ],\n            bugs: [\n              { name: 'New', order: 0 },\n              { name: 'Confirmed', order: 1 },\n              { name: 'In Progress', order: 2 },\n              { name: 'Testing', order: 3 },\n              { name: 'Resolved', order: 4 },\n            ],\n            content: [\n              { name: 'Ideas', order: 0 },\n              { name: 'Writing', order: 1 },\n              { name: 'Editing', order: 2 },\n              { name: 'Review', order: 3 },\n              { name: 'Published', order: 4 },\n            ],\n          };\n\n          const templateKey = options.template as keyof typeof templates;\n          if (!templates[templateKey]) {\n            formatter.error(\n              `Invalid template: ${String(String(options.template))}. Available: ${String(String(Object.keys(templates).join(', ')))}`\n            );\n            process.exit(1);\n          }\n\n          defaults.columns = templates[templateKey];\n        }\n\n        formatter.info('Starting quick board setup...');\n\n        // Run the interactive setup\n        const boardData = await quickBoardSetup(defaults);\n\n        // Show confirmation if not using command line options\n        if (!options.name || !options.template) {\n          const confirmed = await confirmAction('Create board with these settings?', true);\n\n          if (!confirmed) {\n            formatter.warn('Board creation cancelled');\n            return;\n          }\n        }\n\n        // Transform data for API\n        const createData: CreateBoardRequest = {\n          name: boardData.name,\n          ...(boardData.description && { description: boardData.description }),\n          columns: boardData.columns.map(col => ({\n            name: col.name,\n            position: col.order,\n          })),\n        };\n\n        // Create the board with spinner\n        const spinner = new SpinnerManager();\n        const board = await spinner.withSpinner(\n          `Creating board: ${String(String(boardData.name))}`,\n          apiClient.createBoard(createData),\n          {\n            successText: 'Board created successfully! üéâ',\n            failText: 'Failed to create board',\n          }\n        );\n\n        if (isSuccessResponse(board)) {\n          formatter.success(\n            `Board \"${String(String(boardData.name))}\" created with ID: ${String(board.data.id)}`\n          );\n        } else {\n          formatter.error('Failed to create board');\n          process.exit(1);\n        }\n\n        // Show board details\n        formatter.info('\\nüìä Board Summary:');\n        formatter.info(`Name: ${String(String(chalk.bold(boardData.name)))}`);\n        if (boardData.description) {\n          formatter.info(`Description: ${String(String(boardData.description))}`);\n        }\n        formatter.info(`Visibility: ${String(String(boardData.isPublic ? 'Public' : 'Private'))}`);\n        formatter.info(\n          `Columns: ${String(String(boardData.columns.map(c => c.name).join(' ‚Üí ')))}`\n        );\n\n        // Set as default if requested\n        if (options.setDefault && isSuccessResponse(board)) {\n          config.setDefaultBoard(board.data.id);\n          formatter.success('Set as default board');\n        } else if (!options.setDefault && isSuccessResponse(board)) {\n          // Ask if they want to set it as default\n          const setAsDefault = await confirmAction('Set this board as your default?', false);\n\n          if (setAsDefault) {\n            config.setDefaultBoard(board.data.id);\n            formatter.success('Set as default board');\n          }\n        }\n\n        // Offer quick actions\n        if (isSuccessResponse(board)) {\n          formatter.info('\\nüí° Quick Actions:');\n          formatter.info(`  View board: kanban board view ${String(board.data.id)}`);\n          formatter.info(`  Create task: kanban task create --interactive`);\n          formatter.info(`  List tasks: kanban task list`);\n\n          formatter.output(board.data);\n        }\n      } catch (error) {\n        if (error instanceof Error && error.message === 'Board setup cancelled') {\n          formatter.warn('Board setup cancelled');\n          return;\n        }\n\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        formatter.error(`Failed to setup board: ${String(errorMessage)}`);\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/config.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 110,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 117,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 128,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 154,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .serverUrl on an `any` value.",
        "line": 157,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 157,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .apiKey on an `any` value.",
        "line": 158,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 158,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .apiKey on an `any` value.",
        "line": 158,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 158,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .defaultBoard on an `any` value.",
        "line": 159,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 159,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .defaultBoard on an `any` value.",
        "line": 159,
        "column": 70,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 159,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .autoRefresh on an `any` value.",
        "line": 160,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 160,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .force on an `any` value.",
        "line": 213,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 213,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 214,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 221,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport { logger } from '@/utils/logger';\nimport type { CliComponents } from '../types';\n\nexport function registerConfigCommands(program: Command): void {\n  const configCmd = program.command('config').alias('c').description('Manage configuration');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  configCmd\n    .command('show')\n    .alias('ls')\n    .description('Show current configuration')\n    .option('--path', 'show config file path')\n    .action((options: { path?: boolean }) => {\n      const { config, formatter } = getComponents();\n\n      if (options.path) {\n        logger.info(config.getConfigPath());\n        return;\n      }\n\n      if (!config.exists()) {\n        formatter.warn('No configuration file found');\n        logger.info('Run \"kanban config init\" to create initial configuration');\n        return;\n      }\n\n      const configData = config.getAll();\n      const validation = config.validate();\n\n      if (!validation.valid) {\n        formatter.warn('Configuration has issues:');\n        validation.errors.forEach(error => formatter.error(error));\n        logger.info('');\n      }\n\n      formatter.output(configData);\n    });\n\n  configCmd\n    .command('set <key> <value>')\n    .description('Set configuration value')\n    .action((key: string, value: string) => {\n      const { config, formatter, apiClient } = getComponents();\n\n      try {\n        // Parse value based on type\n        let parsedValue: string | number | boolean = value;\n\n        if (value === 'true') parsedValue = true;\n        else if (value === 'false') parsedValue = false;\n        else if (/^\\d+$/.test(value)) parsedValue = parseInt(value, 10);\n        else if (/^\\d*\\.\\d+$/.test(value)) parsedValue = parseFloat(value);\n\n        config.set(key, parsedValue);\n        config.save();\n\n        // Update API client if server config changed\n        if (key.startsWith('server.') || key.startsWith('auth.')) {\n          apiClient.updateConfig();\n        }\n\n        formatter.success(`Set ${String(key)} = ${String(parsedValue)}`);\n\n        // Validate after setting\n        const validation = config.validate();\n        if (!validation.valid) {\n          formatter.warn('Configuration validation failed:');\n          validation.errors.forEach(error => formatter.error(error));\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to set configuration: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  configCmd\n    .command('get <key>')\n    .description('Get configuration value')\n    .action((key: string) => {\n      const { config, formatter } = getComponents();\n\n      if (!config.exists()) {\n        formatter.error('No configuration found');\n        process.exit(1);\n      }\n\n      const value = config.get(key);\n      if (value === undefined) {\n        formatter.error(`Configuration key \"${String(key)}\" not found`);\n        process.exit(1);\n      }\n\n      formatter.output({ [key]: value });\n    });\n\n  configCmd\n    .command('init')\n    .description('Initialize configuration interactively')\n    .option('--force', 'overwrite existing configuration')\n    .action(async (options: { force?: boolean }) => {\n      const { config, formatter, apiClient } = getComponents();\n\n      if (config.exists() && !options.force) {\n        const { overwrite } = await inquirer.prompt([\n          {\n            type: 'confirm',\n            name: 'overwrite',\n            message: 'Configuration already exists. Overwrite?',\n            default: false,\n          },\n        ]);\n\n        if (!overwrite) {\n          formatter.info('Configuration initialization cancelled');\n          return;\n        }\n      }\n\n      try {\n        formatter.info('Initializing configuration...');\n\n        const answers = await inquirer.prompt([\n          {\n            type: 'input',\n            name: 'serverUrl',\n            message: 'Server URL:',\n            default: 'http://localhost:3000',\n            validate: (input: string) => input.length > 0 || 'Server URL is required',\n          },\n          {\n            type: 'input',\n            name: 'apiKey',\n            message: 'API Key (optional):',\n            default: '',\n          },\n          {\n            type: 'input',\n            name: 'defaultBoard',\n            message: 'Default board ID (optional):',\n            default: '',\n          },\n          {\n            type: 'confirm',\n            name: 'autoRefresh',\n            message: 'Enable auto-refresh for real-time updates?',\n            default: true,\n          },\n        ]);\n\n        // Set configuration values\n        config.set('server.url', answers.serverUrl);\n        if (answers.apiKey) config.set('auth.apiKey', answers.apiKey);\n        if (answers.defaultBoard) config.set('defaultBoard', answers.defaultBoard);\n        config.set('ui.autoRefresh', answers.autoRefresh);\n\n        config.save();\n\n        // Update API client\n        apiClient.updateConfig();\n\n        formatter.success('Configuration initialized successfully');\n        formatter.info(`Config file: ${String(config.getConfigPath())}`);\n\n        // Validate configuration\n        const validation = config.validate();\n        if (!validation.valid) {\n          formatter.warn('Configuration validation failed:');\n          validation.errors.forEach(error => formatter.error(error));\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to initialize configuration: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  configCmd\n    .command('validate')\n    .description('Validate configuration')\n    .action(() => {\n      const { config, formatter } = getComponents();\n\n      if (!config.exists()) {\n        formatter.error('No configuration found');\n        process.exit(1);\n      }\n\n      const validation = config.validate();\n\n      if (validation.valid) {\n        formatter.success('Configuration is valid');\n      } else {\n        formatter.error('Configuration validation failed:');\n        validation.errors.forEach(error => formatter.error(`  ${String(error)}`));\n        process.exit(1);\n      }\n    });\n\n  configCmd\n    .command('reset')\n    .description('Reset configuration to defaults')\n    .option('--force', 'skip confirmation')\n    .action(async options => {\n      const { config, formatter } = getComponents();\n\n      if (!options.force) {\n        const { confirm } = await inquirer.prompt([\n          {\n            type: 'confirm',\n            name: 'confirm',\n            message: 'Are you sure you want to reset configuration to defaults?',\n            default: false,\n          },\n        ]);\n\n        if (!confirm) {\n          formatter.info('Reset cancelled');\n          return;\n        }\n      }\n\n      try {\n        config.reset();\n        config.save();\n        formatter.success('Configuration reset to defaults');\n      } catch (error) {\n        formatter.error(\n          `Failed to reset configuration: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  configCmd\n    .command('test')\n    .description('Test connection to server')\n    .action(async () => {\n      const { config, formatter, apiClient } = getComponents();\n\n      if (!config.exists()) {\n        formatter.error('No configuration found. Run \"kanban config init\" first');\n        process.exit(1);\n      }\n\n      const validation = config.validate();\n      if (!validation.valid) {\n        formatter.error('Configuration is invalid:');\n        validation.errors.forEach(error => formatter.error(`  ${String(error)}`));\n        process.exit(1);\n      }\n\n      formatter.info(`Testing connection to ${String(String(config.getServerUrl()))}...`);\n\n      try {\n        const connected = await apiClient.testConnection();\n\n        if (connected) {\n          formatter.success('‚úì Connection successful');\n\n          // Get detailed health info\n          try {\n            const health = await apiClient.getHealth();\n            formatter.info('Server information:');\n            formatter.output(health);\n          } catch (error) {\n            formatter.warn('Could not get detailed server information');\n          }\n        } else {\n          formatter.error('‚úó Connection failed');\n          process.exit(1);\n        }\n      } catch (error) {\n        formatter.error(\n          `‚úó Connection failed: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/context.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 350,
        "column": 76,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 350,
        "endColumn": 79,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11037, 11040], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11037, 11040], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 360,
        "column": 62,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 360,
        "endColumn": 65,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11424, 11427], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11424, 11427], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 362,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 362,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11522, 11525], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11522, 11525], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 362,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 362,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11547, 11550], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11547, 11550], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 363,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 363,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 379,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 379,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12137, 12140], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12137, 12140], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 379,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 379,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12160, 12163], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12160, 12163], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .date on an `any` value.",
        "line": 380,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 380,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 380,
        "column": 84,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 380,
        "endColumn": 95
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 476,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 476,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15247, 15250], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15247, 15250], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 478,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 478,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .impact on an `any` value.",
        "line": 478,
        "column": 96,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 478,
        "endColumn": 102
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"overview\"] is better written in dot notation.",
        "line": 234,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 234,
        "endColumn": 31,
        "fix": { "range": [7073, 7085], "text": ".overview" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"overview\"] is better written in dot notation.",
        "line": 236,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 236,
        "endColumn": 44,
        "fix": { "range": [7172, 7184], "text": ".overview" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"progress\"] is better written in dot notation.",
        "line": 241,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 241,
        "endColumn": 31,
        "fix": { "range": [7306, 7318], "text": ".progress" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"progress\"] is better written in dot notation.",
        "line": 244,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 244,
        "endColumn": 44,
        "fix": { "range": [7456, 7468], "text": ".progress" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"recentActivity\"] is better written in dot notation.",
        "line": 251,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 251,
        "endColumn": 37,
        "fix": { "range": [7714, 7732], "text": ".recentActivity" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"recentActivity\"] is better written in dot notation.",
        "line": 254,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 254,
        "endColumn": 36,
        "fix": { "range": [7854, 7872], "text": ".recentActivity" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"metrics\"] is better written in dot notation.",
        "line": 263,
        "column": 47,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 263,
        "endColumn": 56,
        "fix": { "range": [8213, 8224], "text": ".metrics" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"metrics\"] is better written in dot notation.",
        "line": 266,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 266,
        "endColumn": 45,
        "fix": { "range": [8366, 8377], "text": ".metrics" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"keyInsights\"] is better written in dot notation.",
        "line": 270,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 270,
        "endColumn": 34,
        "fix": { "range": [8459, 8474], "text": ".keyInsights" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"keyInsights\"] is better written in dot notation.",
        "line": 273,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 273,
        "endColumn": 33,
        "fix": { "range": [8593, 8608], "text": ".keyInsights" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"title\"] is better written in dot notation.",
        "line": 340,
        "column": 64,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 340,
        "endColumn": 71,
        "fix": { "range": [10631, 10640], "text": ".title" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"description\"] is better written in dot notation.",
        "line": 343,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 343,
        "endColumn": 38,
        "fix": { "range": [10738, 10753], "text": ".description" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"description\"] is better written in dot notation.",
        "line": 345,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 345,
        "endColumn": 51,
        "fix": { "range": [10844, 10859], "text": ".description" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"dependencies\"] is better written in dot notation.",
        "line": 350,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 350,
        "endColumn": 39,
        "fix": { "range": [10985, 11001], "text": ".dependencies" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"dependencies\"] is better written in dot notation.",
        "line": 350,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 350,
        "endColumn": 71,
        "fix": { "range": [11017, 11033], "text": ".dependencies" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"dependencies\"] is better written in dot notation.",
        "line": 353,
        "column": 40,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 353,
        "endColumn": 54,
        "fix": { "range": [11193, 11209], "text": ".dependencies" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @module cli/commands/context\n * @description AI context and insights commands for the CLI.\n *\n * Provides AI-powered analysis of work patterns, task relationships,\n * and productivity insights. Helps users understand their current work\n * context and get intelligent recommendations.\n *\n * @example\n * ```bash\n * # Show current work context\n * kanban context show\n *\n * # Get detailed context with all information\n * kanban context show --detailed\n *\n * # Get AI insights about work patterns\n * kanban context insights --productivity\n *\n * # Get context for specific task\n * kanban context task task123 --related\n * ```\n */\n\nimport type { Command } from 'commander';\n\nimport type { CliComponents, ContextData } from '../types';\n\ninterface ShowContextOptions {\n  detailed?: boolean;\n  format?: string;\n}\n\ninterface TaskContextOptions {\n  suggestions?: boolean;\n  related?: boolean;\n  history?: boolean;\n}\n\ninterface SummaryContextOptions {\n  boards?: string;\n  timeframe?: string;\n  format?: string;\n  includeMetrics?: boolean;\n}\n\n/**\n * Register all context-related commands with the CLI program.\n *\n * @param program - The commander program instance\n *\n * Available commands:\n * - `show` - Display current work context and recommendations\n * - `summary` (alias: `project`) - Get project-wide summary and metrics\n * - `task <id>` - Get AI context for a specific task\n * - `insights` - Analyze work patterns and identify bottlenecks\n */\nexport function registerContextCommands(program: Command): void {\n  const contextCmd = program.command('context').alias('ctx').description('AI context and insights');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  /**\n   * Show current work context with AI-generated insights.\n   *\n   * @command show\n   *\n   * @option -d, --detailed - Show detailed context information\n   * @option --format <type> - Output format: summary, detailed, raw (default: summary)\n   *\n   * @example\n   * ```bash\n   * # Show context summary\n   * kanban context show\n   *\n   * # Show detailed context\n   * kanban context show --detailed\n   *\n   * # Get raw JSON output\n   * kanban context show --format raw\n   * ```\n   *\n   * Summary format includes:\n   * - Current work summary\n   * - Key statistics\n   * - AI recommendations\n   *\n   * Detailed format includes:\n   * - Active tasks list\n   * - Blocked tasks with reasons\n   * - Upcoming deadlines\n   * - AI insights and patterns\n   */\n  contextCmd\n    .command('show')\n    .description('Show current work context')\n    .option('-d, --detailed', 'show detailed context information')\n    .option('--format <type>', 'output format: summary, detailed, raw', 'summary')\n    .action(async (options: ShowContextOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info('Generating current work context...');\n        const response = await apiClient.getContext();\n        const context = 'data' in response ? (response.data as ContextData) : undefined;\n\n        if (!context) {\n          formatter.info('No context available');\n          return;\n        }\n\n        if (options.format === 'raw') {\n          formatter.output(context);\n        } else if (options.format === 'detailed' || options.detailed) {\n          // Display detailed context\n          formatter.success('Current Work Context');\n\n          if (context.activeTasks) {\n            formatter.info('\\n--- Active Tasks ---');\n            formatter.output(context.activeTasks, {\n              fields: ['id', 'title', 'priority', 'status'],\n              headers: ['ID', 'Title', 'Priority', 'Status'],\n            });\n          }\n\n          if (context.blockedTasks) {\n            formatter.info('\\n--- Blocked Tasks ---');\n            formatter.output(context.blockedTasks, {\n              fields: ['id', 'title', 'blockedBy'],\n              headers: ['ID', 'Title', 'Blocked By'],\n            });\n          }\n\n          if (context.upcomingDeadlines) {\n            formatter.info('\\n--- Upcoming Deadlines ---');\n            formatter.output(context.upcomingDeadlines, {\n              fields: ['id', 'title', 'dueDate', 'daysLeft'],\n              headers: ['ID', 'Title', 'Due Date', 'Days Left'],\n            });\n          }\n\n          if (context.insights) {\n            formatter.info('\\n--- AI Insights ---');\n            context.insights.forEach((insight: string) => {\n              formatter.info(`‚Ä¢ ${String(insight)}`);\n            });\n          }\n        } else {\n          // Summary format\n          formatter.info('üìã Current Work Context Summary\\n');\n\n          if (context.summary) {\n            formatter.info(context.summary as string);\n          }\n\n          if (context.statistics) {\n            formatter.info('\\nüìä Statistics:');\n            Object.entries(context.statistics).forEach(([key, value]) => {\n              formatter.info(`  ${String(key)}: ${String(value)}`);\n            });\n          }\n\n          if (context.recommendations) {\n            formatter.info('\\nüí° Recommendations:');\n            context.recommendations.forEach((rec: string) => {\n              formatter.info(`‚Ä¢ ${String(rec)}`);\n            });\n          }\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get context: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Get comprehensive project summary with analytics.\n   *\n   * @command summary\n   * @alias project\n   *\n   * @option --include-metrics - Include detailed performance metrics\n   * @option --timeframe <days> - Analysis timeframe in days (default: 30)\n   *\n   * @example\n   * ```bash\n   * # Get 30-day project summary\n   * kanban context summary\n   *\n   * # Get summary with performance metrics\n   * kanban context summary --include-metrics\n   *\n   * # Analyze last 7 days\n   * kanban context summary --timeframe 7\n   * ```\n   *\n   * Summary includes:\n   * - Project overview and status\n   * - Progress tracking\n   * - Recent activity timeline\n   * - Key insights and trends\n   *\n   * Performance metrics (when included):\n   * - Task completion rate\n   * - Average task duration\n   * - Team velocity\n   * - Bottleneck analysis\n   */\n  contextCmd\n    .command('summary')\n    .alias('project')\n    .description('Get project summary')\n    .option('--include-metrics', 'include performance metrics')\n    .option('--timeframe <days>', 'timeframe for analysis (days)', '30')\n    .action(async (options: SummaryContextOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info('Generating project summary...');\n        const response = await apiClient.getProjectSummary();\n        const summary = 'data' in response ? (response.data as Record<string, unknown>) : undefined;\n\n        if (!summary) {\n          formatter.info('No project summary available');\n          return;\n        }\n\n        formatter.info('üìä Project Summary\\n');\n\n        // eslint-disable-next-line dot-notation\n        if (summary['overview']) {\n          // eslint-disable-next-line dot-notation\n          formatter.info(summary['overview'] as string);\n          formatter.info('');\n        }\n\n        // eslint-disable-next-line dot-notation\n        if (summary['progress']) {\n          formatter.info('üìà Progress Overview:');\n          // eslint-disable-next-line dot-notation\n          Object.entries(summary['progress'] as Record<string, unknown>).forEach(([key, value]) => {\n            formatter.info(`  ${String(key)}: ${String(value)}`);\n          });\n          formatter.info('');\n        }\n\n        // eslint-disable-next-line dot-notation\n        if (summary['recentActivity']) {\n          formatter.info('üîÑ Recent Activity:');\n          // eslint-disable-next-line dot-notation\n          (summary['recentActivity'] as Array<{ description: string; date: string }>).forEach(\n            activity => {\n              formatter.info(`‚Ä¢ ${String(activity.description)} (${String(activity.date)})`);\n            }\n          );\n          formatter.info('');\n        }\n\n        // eslint-disable-next-line dot-notation\n        if (options.includeMetrics && summary['metrics']) {\n          formatter.info('üìä Performance Metrics:');\n          // eslint-disable-next-line dot-notation\n          formatter.output(summary['metrics']);\n        }\n\n        // eslint-disable-next-line dot-notation\n        if (summary['keyInsights']) {\n          formatter.info('üîç Key Insights:');\n          // eslint-disable-next-line dot-notation\n          (summary['keyInsights'] as string[]).forEach((insight: string) => {\n            formatter.info(`‚Ä¢ ${String(insight)}`);\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get project summary: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Get AI-powered context and insights for a specific task.\n   *\n   * @command task <id>\n   *\n   * @param id - The task ID to analyze\n   * @option --related - Include similar and related tasks\n   * @option --history - Include task history and timeline\n   *\n   * @example\n   * ```bash\n   * # Get basic task context\n   * kanban context task task123\n   *\n   * # Include related tasks\n   * kanban context task task123 --related\n   *\n   * # Full analysis with history\n   * kanban context task task123 --related --history\n   * ```\n   *\n   * Context includes:\n   * - Task description and current state\n   * - Dependencies and blockers\n   * - AI-generated insights\n   * - Actionable suggestions\n   *\n   * Related tasks (when included):\n   * - Similar tasks by content\n   * - Tasks with shared tags\n   * - Dependency relationships\n   *\n   * History (when included):\n   * - Status changes\n   * - Assignment history\n   * - Time in each state\n   */\n  contextCmd\n    .command('task <id>')\n    .description('Get AI context for a specific task')\n    .option('--related', 'include related tasks')\n    .option('--history', 'include task history')\n    .action(async (id: string, options: TaskContextOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info(`Generating context for task ${String(id)}...`);\n        const taskContext = (await apiClient.getTaskContext(id)) as Record<string, unknown>;\n\n        if (!taskContext) {\n          formatter.error(`No context available for task ${String(id)}`);\n          process.exit(1);\n        }\n\n        // eslint-disable-next-line dot-notation\n        formatter.info(`üéØ Task Context: ${String((taskContext['title'] as string) ?? id)}\\n`);\n\n        // eslint-disable-next-line dot-notation\n        if (taskContext['description']) {\n          // eslint-disable-next-line dot-notation\n          formatter.info(taskContext['description'] as string);\n          formatter.info('');\n        }\n\n        // eslint-disable-next-line dot-notation\n        if (taskContext['dependencies'] && (taskContext['dependencies'] as any[]).length > 0) {\n          formatter.info('üîó Dependencies:');\n          // eslint-disable-next-line dot-notation\n          formatter.output(taskContext['dependencies'], {\n            fields: ['id', 'title', 'status'],\n            headers: ['ID', 'Title', 'Status'],\n          });\n          formatter.info('');\n        }\n\n        if (taskContext.blockers && (taskContext.blockers as any[]).length > 0) {\n          formatter.info('üö´ Blockers:');\n          (taskContext.blockers as any[]).forEach((blocker: any) => {\n            formatter.warn(`‚Ä¢ ${String(String(blocker.description))}`);\n          });\n          formatter.info('');\n        }\n\n        if (options.related && taskContext.relatedTasks) {\n          formatter.info('üîÑ Related Tasks:');\n          formatter.output(taskContext.relatedTasks, {\n            fields: ['id', 'title', 'similarity'],\n            headers: ['ID', 'Title', 'Similarity'],\n          });\n          formatter.info('');\n        }\n\n        if (options.history && taskContext.history) {\n          formatter.info('üìú Task History:');\n          (taskContext.history as any[]).forEach((event: any) => {\n            formatter.info(`‚Ä¢ ${String(String(event.date))}: ${String(String(event.description))}`);\n          });\n          formatter.info('');\n        }\n\n        if (taskContext.aiInsights) {\n          formatter.info('ü§ñ AI Insights:');\n          (taskContext.aiInsights as string[]).forEach((insight: string) => {\n            formatter.info(`‚Ä¢ ${String(insight)}`);\n          });\n        }\n\n        if (taskContext.suggestions) {\n          formatter.info('\\nüí° Suggestions:');\n          (taskContext.suggestions as string[]).forEach((suggestion: string) => {\n            formatter.success(`‚Ä¢ ${String(suggestion)}`);\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get task context: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Get AI insights about work patterns and productivity.\n   *\n   * @command insights\n   *\n   * @option --productivity - Focus on productivity patterns and recommendations\n   * @option --bottlenecks - Identify workflow bottlenecks and blockers\n   *\n   * @example\n   * ```bash\n   * # Get general work insights\n   * kanban context insights\n   *\n   * # Focus on productivity patterns\n   * kanban context insights --productivity\n   *\n   * # Identify bottlenecks\n   * kanban context insights --bottlenecks\n   *\n   * # Full analysis\n   * kanban context insights --productivity --bottlenecks\n   * ```\n   *\n   * General insights include:\n   * - Work pattern analysis\n   * - Task flow observations\n   * - Time management insights\n   * - Team collaboration patterns\n   *\n   * Productivity insights:\n   * - Peak productivity times\n   * - Task completion patterns\n   * - Focus time analysis\n   * - Efficiency recommendations\n   *\n   * Bottleneck analysis:\n   * - Blocked task patterns\n   * - Process inefficiencies\n   * - Resource constraints\n   * - Workflow optimization suggestions\n   */\n  contextCmd\n    .command('insights')\n    .description('Get AI insights about work patterns')\n    .option('--productivity', 'focus on productivity insights')\n    .option('--bottlenecks', 'identify bottlenecks')\n    .action(async (options: { productivity?: boolean; bottlenecks?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info('Analyzing work patterns...');\n        const context = (await apiClient.getContext()) as ContextData;\n\n        if (!context?.insights) {\n          formatter.info('No insights available');\n          return;\n        }\n\n        formatter.info('üîç AI Work Pattern Insights\\n');\n\n        if (options.productivity && context.productivityInsights) {\n          formatter.info('üìà Productivity Insights:');\n          context.productivityInsights.forEach((insight: string) => {\n            formatter.success(`‚Ä¢ ${String(insight)}`);\n          });\n          formatter.info('');\n        }\n\n        if (options.bottlenecks && context.bottlenecks) {\n          formatter.info('üöß Identified Bottlenecks:');\n          context.bottlenecks.forEach((bottleneck: any) => {\n            formatter.warn(\n              `‚Ä¢ ${String(String(bottleneck.description))} (Impact: ${String(String(bottleneck.impact))})`\n            );\n          });\n          formatter.info('');\n        }\n\n        formatter.info('üí° General Insights:');\n        context.insights.forEach((insight: string) => {\n          formatter.info(`‚Ä¢ ${String(insight)}`);\n        });\n\n        if (context.actionableRecommendations) {\n          formatter.info('\\nüéØ Actionable Recommendations:');\n          context.actionableRecommendations.forEach((rec: string) => {\n            formatter.success(`‚Ä¢ ${String(rec)}`);\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get insights: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/dashboard-demo.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/dashboard.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 38,
        "column": 53,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 38,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1464, 1466], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 50,
        "column": 53,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 50,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1952, 1954], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 51,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 51,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2004, 2006], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 28,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 28,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [1079, 1137], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 31,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 31,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [1246, 1293], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 40,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 40,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [1533, 1593], "text": "" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 42,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 42,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [1653, 1728], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 47,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 47,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [1813, 1873], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 72,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 72,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "warn" },
            "fix": { "range": [2663, 2744], "text": "" },
            "desc": "Remove the console.warn()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 80,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 80,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [2918, 2998], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 83,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 83,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [3078, 3221], "text": "" },
            "desc": "Remove the console.error()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Command } from 'commander';\nimport chalk from 'chalk';\nimport { DashboardManager } from '../utils/dashboard-manager';\nimport { getThemeNames } from '../ui/themes/dashboard-themes';\n\n/**\n * Dashboard command for launching terminal dashboards\n */\nexport const dashboardCommand = new Command('dashboard')\n  .description('Launch interactive terminal dashboard')\n  .option('-l, --layout <layout>', 'Initial layout: overview, velocity, or personal', 'overview')\n  .option('-r, --refresh <seconds>', 'Auto-refresh interval in seconds', '30')\n  .option('-t, --theme <theme>', `Dashboard theme: ${getThemeNames().join(', ')}`, 'dark')\n  .option('--no-auto-refresh', 'Disable auto-refresh')\n  .option('--list-themes', 'List available themes')\n  .action(\n    (options: {\n      layout?: 'overview' | 'velocity' | 'personal';\n      refresh?: string;\n      theme?: string;\n      autoRefresh?: boolean;\n      listThemes?: boolean;\n    }) => {\n      try {\n        // Handle list themes option\n        if (options.listThemes) {\n          // eslint-disable-next-line no-console\n          console.log(chalk.cyan('üé® Available Dashboard Themes:'));\n          getThemeNames().forEach(theme => {\n            // eslint-disable-next-line no-console\n            console.log(`  ${chalk.yellow('‚Ä¢')} ${theme}`);\n          });\n          return;\n        }\n\n        // Validate theme\n        const availableThemes = getThemeNames();\n        if (!availableThemes.includes(options.theme || '')) {\n          // eslint-disable-next-line no-console\n          console.error(chalk.red(`Invalid theme: ${options.theme}`));\n          // eslint-disable-next-line no-console\n          console.log(chalk.yellow('Available themes:'), availableThemes.join(', '));\n          return;\n        }\n\n        // eslint-disable-next-line no-console\n        console.log(chalk.cyan('üöÄ Launching Kanban Dashboard...'));\n\n        const config = {\n          refreshInterval: parseInt(options.refresh || '30', 10) * 1000,\n          theme: options.theme || 'dark',\n          autoRefresh: options.autoRefresh !== false,\n          showHelp: true,\n        };\n\n        // Get API client from global components if available\n        const apiClient = global.cliComponents?.apiClient;\n        const dashboard = new DashboardManager(\n          config,\n          apiClient ? apiClient.getApiClient() : undefined\n        );\n\n        // Set initial layout\n        switch (options.layout) {\n          case 'overview':\n          case 'velocity':\n          case 'personal':\n            dashboard.switchLayout(options.layout);\n            break;\n          default:\n            // eslint-disable-next-line no-console\n            console.warn(chalk.yellow(`Unknown layout: ${options.layout}. Using overview.`));\n            dashboard.switchLayout('overview');\n        }\n\n        // Start the dashboard\n        dashboard.start();\n\n        // eslint-disable-next-line no-console\n        console.log(chalk.green('Dashboard started! Press \"h\" for help, \"q\" to quit.'));\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(\n          chalk.red('Failed to start dashboard:'),\n          error instanceof Error ? error.message : 'Unknown error'\n        );\n        process.exit(1);\n      }\n    }\n  );\n\n// Subcommands for specific dashboard types\ndashboardCommand\n  .command('overview')\n  .description('Launch overview dashboard with task statistics')\n  .action(() => {\n    const apiClient = global.cliComponents?.apiClient;\n    const dashboard = new DashboardManager({}, apiClient ? apiClient.getApiClient() : undefined);\n    dashboard.switchLayout('overview');\n    dashboard.start();\n  });\n\ndashboardCommand\n  .command('velocity')\n  .description('Launch velocity dashboard with team performance metrics')\n  .action(() => {\n    const apiClient = global.cliComponents?.apiClient;\n    const dashboard = new DashboardManager({}, apiClient ? apiClient.getApiClient() : undefined);\n    dashboard.switchLayout('velocity');\n    dashboard.start();\n  });\n\ndashboardCommand\n  .command('personal')\n  .description('Launch personal productivity dashboard')\n  .action(() => {\n    const apiClient = global.cliComponents?.apiClient;\n    const dashboard = new DashboardManager({}, apiClient ? apiClient.getApiClient() : undefined);\n    dashboard.switchLayout('personal');\n    dashboard.start();\n  });\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/database.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 49,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 56,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 149,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 149,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5190, 5193], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5190, 5193], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .healthy on an `any` value.",
        "line": 149,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 149,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 162,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 162,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5587, 5590], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5587, 5590], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .issues on an `any` value.",
        "line": 162,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 162,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 163,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 163,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5628, 5631], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5628, 5631], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .issues on an `any` value.",
        "line": 163,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 163,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 166,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 166,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5755, 5758], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5755, 5758], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .issues on an `any` value.",
        "line": 166,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 166,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 191,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 198,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 246,
        "column": 72,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 246,
        "endColumn": 75,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8170, 8173], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8170, 8173], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 246,
        "column": 77,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 246,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 305,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 312,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 353,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 355,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 355,
        "column": 16,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 355,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11535, 11538], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11535, 11538], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .filename on an `any` value.",
        "line": 357,
        "column": 66,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 357,
        "endColumn": 74
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport type { CliComponents, AnyApiResponse } from '../types';\nimport { logger } from '../../utils/logger';\nimport { isSuccessResponse } from '../api-client-wrapper';\n\nexport function registerDatabaseCommands(program: Command): void {\n  const dbCmd = program.command('database').alias('db').description('Database management');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  dbCmd\n    .command('optimize')\n    .description('Optimize database performance')\n    .option('--verbose', 'show detailed output')\n    .action(async (options: { verbose?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info('Optimizing database...');\n\n        const result = await apiClient.request('POST', '/api/database/optimize', {\n          verbose: options.verbose ?? false,\n        });\n\n        formatter.success('Database optimization completed');\n        formatter.output(result, {\n          fields: ['operation', 'duration', 'before', 'after', 'improvement'],\n          headers: ['Operation', 'Duration', 'Before', 'After', 'Improvement'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to optimize database: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dbCmd\n    .command('vacuum')\n    .description('Vacuum database to reclaim space')\n    .option('-f, --force', 'skip confirmation')\n    .action(async (options: { force?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          const { confirm } = await inquirer.prompt([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: 'Vacuum database? This may take some time.',\n              default: true,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Vacuum cancelled');\n            return;\n          }\n        }\n\n        formatter.info('Vacuuming database...');\n\n        const result = await apiClient.request('POST', '/api/database/vacuum');\n\n        formatter.success('Database vacuum completed');\n        formatter.output(result, {\n          fields: ['sizeBefore', 'sizeAfter', 'spaceReclaimed', 'duration'],\n          headers: ['Size Before', 'Size After', 'Space Reclaimed', 'Duration'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to vacuum database: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dbCmd\n    .command('analyze')\n    .description('Analyze database and update statistics')\n    .action(async () => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info('Analyzing database...');\n\n        const result = await apiClient.request('POST', '/api/database/analyze');\n\n        formatter.success('Database analysis completed');\n        formatter.output(result, {\n          fields: ['table', 'rowCount', 'indexCount', 'avgRowSize', 'totalSize'],\n          headers: ['Table', 'Rows', 'Indexes', 'Avg Row Size', 'Total Size'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to analyze database: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dbCmd\n    .command('stats')\n    .description('Show database statistics')\n    .option('--tables', 'include table statistics')\n    .option('--indexes', 'include index statistics')\n    .option('--performance', 'include performance metrics')\n    .action(async (options: { tables?: boolean; indexes?: boolean; performance?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const params: Record<string, string> = {};\n        if (options.tables) params.tables = 'true';\n        if (options.indexes) params.indexes = 'true';\n        if (options.performance) params.performance = 'true';\n\n        const result = await apiClient.request('GET', '/api/database/stats', undefined, params);\n\n        formatter.success('Database statistics:');\n        formatter.output(result, {\n          fields: ['metric', 'value', 'unit', 'description'],\n          headers: ['Metric', 'Value', 'Unit', 'Description'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to get database stats: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dbCmd\n    .command('check')\n    .description('Check database integrity')\n    .option('--repair', 'attempt to repair corruption if found')\n    .action(async (options: { repair?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info('Checking database integrity...');\n\n        const result = await apiClient.request<AnyApiResponse>('POST', '/api/database/check', {\n          repair: options.repair ?? false,\n        });\n\n        if (isSuccessResponse(result) && (result.data as any).healthy) {\n          formatter.success('Database integrity check passed');\n        } else {\n          formatter.error('Database integrity issues found');\n        }\n\n        formatter.output(result, {\n          fields: ['check', 'status', 'details'],\n          headers: ['Check', 'Status', 'Details'],\n        });\n\n        if (\n          isSuccessResponse(result) &&\n          (result.data as any).issues &&\n          (result.data as any).issues.length > 0\n        ) {\n          logger.info('\\n--- Issues Found ---');\n          formatter.output((result.data as any).issues, {\n            fields: ['type', 'severity', 'message', 'suggestion'],\n            headers: ['Type', 'Severity', 'Message', 'Suggestion'],\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to check database: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dbCmd\n    .command('repair')\n    .description('Repair database corruption')\n    .option('-f, --force', 'skip confirmation')\n    .option('--backup', 'create backup before repair')\n    .action(async (options: { force?: boolean; backup?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          formatter.warn('WARNING: Database repair may cause data loss!');\n\n          const { confirm } = await inquirer.prompt([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: 'Proceed with database repair?',\n              default: false,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Repair cancelled');\n            return;\n          }\n        }\n\n        const repairData = {\n          createBackup: options.backup ?? false,\n        };\n\n        formatter.info('Repairing database...');\n\n        const result = await apiClient.request<AnyApiResponse>(\n          'POST',\n          '/api/database/repair',\n          repairData\n        );\n\n        formatter.success('Database repair completed');\n        formatter.output(result, {\n          fields: ['operation', 'status', 'recordsFixed', 'backupCreated'],\n          headers: ['Operation', 'Status', 'Records Fixed', 'Backup Created'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to repair database: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  // Migration commands\n  const migrateCmd = dbCmd.command('migrate').description('Database migration management');\n\n  migrateCmd\n    .command('status')\n    .description('Show migration status')\n    .action(async () => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const migrations = await apiClient.request<AnyApiResponse>(\n          'GET',\n          '/api/database/migrations/status'\n        );\n\n        if (!migrations || !('length' in migrations) || (migrations as any).length === 0) {\n          formatter.info('No migrations found');\n          return;\n        }\n\n        formatter.output(migrations, {\n          fields: ['name', 'version', 'status', 'appliedAt'],\n          headers: ['Migration', 'Version', 'Status', 'Applied At'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to get migration status: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  migrateCmd\n    .command('up')\n    .description('Run pending migrations')\n    .option('--to <version>', 'migrate to specific version')\n    .action(async (options: { to?: string }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const migrateData: { targetVersion?: string } = {};\n        if (options.to) {\n          migrateData.targetVersion = options.to;\n        }\n\n        formatter.info('Running migrations...');\n\n        const result = await apiClient.request('POST', '/api/database/migrations/up', migrateData);\n\n        formatter.success('Migrations completed');\n        formatter.output(result, {\n          fields: ['migration', 'status', 'duration'],\n          headers: ['Migration', 'Status', 'Duration'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to run migrations: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  migrateCmd\n    .command('down')\n    .description('Rollback migrations')\n    .option('--to <version>', 'rollback to specific version')\n    .option('-f, --force', 'skip confirmation')\n    .action(async (options: { to?: string; force?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          formatter.warn('WARNING: Rolling back migrations may cause data loss!');\n\n          const { confirm } = await inquirer.prompt([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: 'Proceed with migration rollback?',\n              default: false,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Rollback cancelled');\n            return;\n          }\n        }\n\n        const rollbackData: { targetVersion?: string } = {};\n        if (options.to) {\n          rollbackData.targetVersion = options.to;\n        }\n\n        formatter.info('Rolling back migrations...');\n\n        const result = await apiClient.request(\n          'POST',\n          '/api/database/migrations/down',\n          rollbackData\n        );\n\n        formatter.success('Migration rollback completed');\n        formatter.output(result, {\n          fields: ['migration', 'status', 'duration'],\n          headers: ['Migration', 'Status', 'Duration'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to rollback migrations: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  migrateCmd\n    .command('create <name>')\n    .description('Create a new migration')\n    .action(async (name: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const migration = (await apiClient.request('POST', '/api/database/migrations/create', {\n          name,\n        })) as any;\n\n        formatter.success(`Migration created: ${String(migration.filename || 'Unknown')}`);\n        formatter.output(migration, {\n          fields: ['name', 'version', 'filename', 'createdAt'],\n          headers: ['Name', 'Version', 'Filename', 'Created At'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to create migration: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/export.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 92,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 92,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3533, 3536], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3533, 3536], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 92,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 92,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 93,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 93,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3597, 3600], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3597, 3600], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 93,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 93,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 98,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 98,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3813, 3816], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3813, 3816], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 98,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 98,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 171,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 171,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6562, 6565], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6562, 6565], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .filePath on an `any` value.",
        "line": 171,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 171,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 172,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 172,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6636, 6639], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6636, 6639], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .itemCount on an `any` value.",
        "line": 172,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 172,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 200,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 200,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7964, 7967], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7964, 7967], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .format on an `any` value.",
        "line": 204,
        "column": 71,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 204,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 207,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 207,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .format on an `any` value.",
        "line": 207,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 207,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .boards on an `any` value.",
        "line": 208,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 208,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tasks on an `any` value.",
        "line": 209,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 209,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tags on an `any` value.",
        "line": 210,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 210,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .notes on an `any` value.",
        "line": 211,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 211,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 214,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 214,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .anonymizeUserData on an `any` value.",
        "line": 214,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 214,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 215,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 215,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .anonymizeTaskTitles on an `any` value.",
        "line": 215,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 215,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 216,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 216,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .anonymizeDescriptions on an `any` value.",
        "line": 216,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 216,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 217,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 217,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .anonymizeNotes on an `any` value.",
        "line": 217,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 217,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 218,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 218,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .preserveStructure on an `any` value.",
        "line": 218,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 218,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 219,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 219,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .hashSeed on an `any` value.",
        "line": 219,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 219,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .boardIds on an `any` value.",
        "line": 223,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 223,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 224,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 224,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .boardIds on an `any` value.",
        "line": 224,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 224,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .format on an `any` value.",
        "line": 235,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 235,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pretty on an `any` value.",
        "line": 237,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 237,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .format on an `any` value.",
        "line": 243,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 271,
        "column": 60,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 271,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10792, 10795], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10792, 10795], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 274,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 274,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 274,
        "column": 28,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 274,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .from on an `any` value.",
        "line": 274,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 274,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 275,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 275,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 275,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 275,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .to on an `any` value.",
        "line": 275,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 275,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 277,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 277,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 277,
        "column": 78,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 277,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 288,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 288,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ExportData | ExportFileFormat`.",
        "line": 289,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 289,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 289,
        "column": 38,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 289,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .delimiter on an `any` value.",
        "line": 289,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 289,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 291,
        "column": 43,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 291,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .delimiter on an `any` value.",
        "line": 291,
        "column": 62,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 291,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 293,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 293,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ExportData | ExportFileFormat`.",
        "line": 294,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 294,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pretty on an `any` value.",
        "line": 306,
        "column": 68,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 306,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 336,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 336,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | Blob`.",
        "line": 347,
        "column": 47,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 347,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .conflict on an `any` value.",
        "line": 347,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 347,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .validateOnly on an `any` value.",
        "line": 349,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 349,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .validateOnly on an `any` value.",
        "line": 353,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 353,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .validateOnly on an `any` value.",
        "line": 356,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 356,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 54,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Command } from 'commander';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport { jsonToCsv, csvToJson, jsonToXml, getSupportedConversions } from '@/utils/formatConverters';\nimport type {\n  CliComponents,\n  ImportValidationResponse,\n  ImportResponse,\n  AnyApiResponse,\n  ExportResponse,\n} from '../types';\nimport { isSuccessResponse } from '../api-client-wrapper';\n\nexport function registerExportCommands(program: Command): void {\n  const exportCmd = program.command('export').alias('e').description('Export data');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n  const importCmd = program.command('import').description('Import kanban data');\n\n  // Export to JSON\n  exportCmd\n    .command('json [file]')\n    .description('Export data to JSON file or stdout')\n    .option('--boards', 'Include boards', true)\n    .option('--tasks', 'Include tasks', true)\n    .option('--tags', 'Include tags', true)\n    .option('--notes', 'Include notes', true)\n    .option('--board-ids <ids>', 'Specific board IDs to export')\n    .option('--anonymize', 'Anonymize sensitive data')\n    .option('--anonymize-user-data', 'Anonymize user data (assignees, etc.)')\n    .option('--anonymize-task-titles', 'Anonymize task titles')\n    .option('--anonymize-descriptions', 'Anonymize descriptions')\n    .option('--anonymize-notes', 'Anonymize note content')\n    .option('--preserve-structure', 'Preserve data structure while anonymizing')\n    .option('--hash-seed <seed>', 'Custom hash seed for deterministic anonymization')\n    .option('--pretty', 'Pretty print JSON output')\n    .action(\n      async (\n        file: string | undefined,\n        options: {\n          boards?: boolean;\n          tasks?: boolean;\n          tags?: boolean;\n          notes?: boolean;\n          boardIds?: string;\n          anonymize?: boolean;\n          anonymizeUserData?: boolean;\n          anonymizeTaskTitles?: boolean;\n          anonymizeDescriptions?: boolean;\n          anonymizeNotes?: boolean;\n          preserveStructure?: boolean;\n          hashSeed?: string;\n          pretty?: boolean;\n        }\n      ) => {\n        try {\n          const { apiClient, formatter } = getComponents();\n\n          formatter.info('Exporting data to JSON...');\n\n          const params: Record<string, string> = {\n            format: 'json',\n            includeBoards: String(options.boards),\n            includeTasks: String(options.tasks),\n            includeTags: String(options.tags),\n            includeNotes: String(options.notes),\n          };\n\n          if (options.boardIds) {\n            params.boardIds = options.boardIds;\n          }\n\n          // Add anonymization options\n          if (options.anonymize) {\n            params.anonymize = 'true';\n            params.anonymizationOptions = JSON.stringify({\n              anonymizeUserData: options.anonymizeUserData ?? true,\n              anonymizeTaskTitles: options.anonymizeTaskTitles ?? true,\n              anonymizeDescriptions: options.anonymizeDescriptions ?? true,\n              anonymizeNotes: options.anonymizeNotes ?? true,\n              preserveStructure: options.preserveStructure ?? false,\n              hashSeed: options.hashSeed,\n            });\n          }\n\n          const response = await apiClient.request('GET', '/export', undefined, params);\n\n          if (file) {\n            const outputPath = path.resolve(file);\n            const jsonData = options.pretty\n              ? JSON.stringify((response as any).data, null, 2)\n              : JSON.stringify((response as any).data);\n\n            await fs.writeFile(outputPath, jsonData);\n            formatter.success(`Data exported to ${String(outputPath)}`);\n          } else {\n            formatter.output(JSON.stringify((response as any).data, null, 2));\n          }\n        } catch (error) {\n          const { formatter } = getComponents();\n          formatter.error(\n            `Export failed: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  // Export to CSV\n  exportCmd\n    .command('csv <directory>')\n    .description('Export data to CSV files')\n    .option('--boards', 'Include boards', true)\n    .option('--tasks', 'Include tasks', true)\n    .option('--tags', 'Include tags', true)\n    .option('--notes', 'Include notes', true)\n    .option('--anonymize', 'Anonymize sensitive data')\n    .option('--anonymize-user-data', 'Anonymize user data (assignees, etc.)')\n    .option('--anonymize-task-titles', 'Anonymize task titles')\n    .option('--anonymize-descriptions', 'Anonymize descriptions')\n    .option('--anonymize-notes', 'Anonymize note content')\n    .option('--preserve-structure', 'Preserve data structure while anonymizing')\n    .option('--hash-seed <seed>', 'Custom hash seed for deterministic anonymization')\n    .action(\n      async (\n        _directory: string,\n        options: {\n          boards?: boolean;\n          tasks?: boolean;\n          tags?: boolean;\n          notes?: boolean;\n          anonymize?: boolean;\n          anonymizeUserData?: boolean;\n          anonymizeTaskTitles?: boolean;\n          anonymizeDescriptions?: boolean;\n          anonymizeNotes?: boolean;\n          preserveStructure?: boolean;\n          hashSeed?: string;\n        }\n      ) => {\n        try {\n          const { apiClient, formatter } = getComponents();\n\n          formatter.info('Exporting data to CSV...');\n\n          const params: Record<string, string> = {\n            format: 'csv',\n            includeBoards: String(options.boards),\n            includeTasks: String(options.tasks),\n            includeTags: String(options.tags),\n            includeNotes: String(options.notes),\n          };\n\n          // Add anonymization options\n          if (options.anonymize) {\n            params.anonymize = 'true';\n            params.anonymizationOptions = JSON.stringify({\n              anonymizeUserData: options.anonymizeUserData ?? true,\n              anonymizeTaskTitles: options.anonymizeTaskTitles ?? true,\n              anonymizeDescriptions: options.anonymizeDescriptions ?? true,\n              anonymizeNotes: options.anonymizeNotes ?? true,\n              preserveStructure: options.preserveStructure ?? false,\n              hashSeed: options.hashSeed,\n            });\n          }\n\n          const response = await apiClient.request('GET', '/export', undefined, params);\n\n          formatter.success('CSV export completed');\n          formatter.info(`Files: ${String((response as any).filePath)}`);\n          formatter.info(`Items: ${String((response as any).itemCount)}`);\n        } catch (error) {\n          const { formatter } = getComponents();\n          formatter.error(\n            `CSV export failed: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  // Anonymized export command (convenience command)\n  exportCmd\n    .command('anonymized [file]')\n    .description('Export anonymized data (convenience command)')\n    .option('--format <format>', 'Export format (json|csv)', 'json')\n    .option('--boards', 'Include boards', true)\n    .option('--tasks', 'Include tasks', true)\n    .option('--tags', 'Include tags', true)\n    .option('--notes', 'Include notes', true)\n    .option('--board-ids <ids...>', 'Filter by board IDs')\n    .option('--pretty', 'Pretty print JSON', true)\n    .option('--anonymize-user-data', 'Anonymize user data (assignees, etc.)', true)\n    .option('--anonymize-task-titles', 'Anonymize task titles', true)\n    .option('--anonymize-descriptions', 'Anonymize descriptions', true)\n    .option('--anonymize-notes', 'Anonymize note content', true)\n    .option('--preserve-structure', 'Preserve data structure while anonymizing')\n    .option('--hash-seed <seed>', 'Custom hash seed for deterministic anonymization')\n    .action(async (file: string | undefined, options: any) => {\n      try {\n        const { apiClient, formatter } = getComponents();\n\n        formatter.info(`Exporting anonymized data to ${String(options.format).toUpperCase()}...`);\n\n        const params: Record<string, string> = {\n          format: options.format,\n          includeBoards: String(options.boards),\n          includeTasks: String(options.tasks),\n          includeTags: String(options.tags),\n          includeNotes: String(options.notes),\n          anonymize: 'true',\n          anonymizationOptions: JSON.stringify({\n            anonymizeUserData: options.anonymizeUserData ?? true,\n            anonymizeTaskTitles: options.anonymizeTaskTitles ?? true,\n            anonymizeDescriptions: options.anonymizeDescriptions ?? true,\n            anonymizeNotes: options.anonymizeNotes ?? true,\n            preserveStructure: options.preserveStructure ?? false,\n            hashSeed: options.hashSeed,\n          }),\n        };\n\n        if (options.boardIds) {\n          params.boardIds = options.boardIds;\n        }\n\n        const response = await apiClient.request<AnyApiResponse>(\n          'GET',\n          '/export/anonymized',\n          undefined,\n          params\n        );\n\n        const exportResponse = response as ExportResponse;\n        if (file && options.format === 'json') {\n          const outputPath = path.resolve(file);\n          const jsonData = options.pretty\n            ? JSON.stringify(exportResponse.data, null, 2)\n            : JSON.stringify(exportResponse.data);\n\n          await fs.writeFile(outputPath, jsonData);\n          formatter.success(`Anonymized data exported to ${String(outputPath)}`);\n        } else if (options.format === 'json') {\n          formatter.output(JSON.stringify(exportResponse.data, null, 2));\n        } else {\n          formatter.success('Anonymized CSV export completed');\n          if (exportResponse.filePath) {\n            formatter.info(`Files: ${String(exportResponse.filePath)}`);\n          }\n          if (exportResponse.itemCount !== undefined) {\n            formatter.info(`Items: ${String(exportResponse.itemCount)}`);\n          }\n        }\n      } catch (error) {\n        const { formatter } = getComponents();\n        formatter.error(\n          `Anonymized export failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  // Format conversion command\n  exportCmd\n    .command('convert <input> <output>')\n    .description('Convert between export formats (json, csv, xml)')\n    .option('--from <format>', 'Input format (json|csv)', 'json')\n    .option('--to <format>', 'Output format (json|csv|xml)', 'csv')\n    .option('--delimiter <delimiter>', 'CSV delimiter', ',')\n    .option('--pretty', 'Pretty print JSON/XML output', false)\n    .action(async (input: string, output: string, options: any) => {\n      const { formatter } = getComponents();\n      try {\n        const fromFormat = options.from.toLowerCase();\n        const toFormat = options.to.toLowerCase();\n        const supported = getSupportedConversions();\n        if (!supported.from?.includes(fromFormat) || !supported.to?.includes(toFormat)) {\n          formatter.error(`Unsupported conversion: ${fromFormat} ‚Üí ${toFormat}`);\n          process.exit(1);\n        }\n\n        const inputPath = path.resolve(input);\n        const outputPath = path.resolve(output);\n        const inputData = await fs.readFile(inputPath, 'utf-8');\n        let result;\n\n        if (fromFormat === 'json' && toFormat === 'csv') {\n          const json = JSON.parse(inputData);\n          result = jsonToCsv(json, { delimiter: options.delimiter });\n        } else if (fromFormat === 'csv' && toFormat === 'json') {\n          result = csvToJson(inputData, { delimiter: options.delimiter });\n        } else if (fromFormat === 'json' && toFormat === 'xml') {\n          const json = JSON.parse(inputData);\n          result = jsonToXml(json);\n        } else {\n          formatter.error(`Conversion from ${fromFormat} to ${toFormat} is not supported.`);\n          process.exit(1);\n        }\n\n        if (!result.success) {\n          formatter.error(`Conversion failed: ${result.errors.join('; ')}`);\n          process.exit(1);\n        }\n\n        let outputData = result.data ?? '';\n        if ((toFormat === 'json' || toFormat === 'xml') && options.pretty) {\n          try {\n            outputData =\n              toFormat === 'json' ? JSON.stringify(JSON.parse(outputData), null, 2) : outputData;\n          } catch {\n            // ignore pretty print if parse fails\n          }\n        }\n        await fs.writeFile(outputPath, outputData);\n        formatter.success(`Converted ${input} (${fromFormat}) ‚Üí ${output} (${toFormat})`);\n      } catch (error) {\n        formatter.error(\n          `Format conversion failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n        process.exit(1);\n      }\n    });\n\n  // Import from JSON\n  importCmd\n    .command('json <file>')\n    .description('Import data from JSON file')\n    .option('--validate-only', 'Only validate without importing')\n    .option('--conflict <resolution>', 'Conflict resolution (skip/overwrite/rename)', 'skip')\n    .action(async (file, options) => {\n      try {\n        const { apiClient, formatter } = getComponents();\n\n        formatter.info('Reading JSON file...');\n\n        const filePath = path.resolve(file);\n        const fileContent = await fs.readFile(filePath, 'utf-8');\n\n        // Parse to validate JSON\n        JSON.parse(fileContent);\n\n        formatter.info('Uploading for import...');\n\n        const formData = new FormData();\n        formData.append('file', new Blob([fileContent]), path.basename(filePath));\n        formData.append('format', 'json');\n        formData.append('conflictResolution', options.conflict);\n\n        if (options.validateOnly) {\n          formData.append('validateOnly', 'true');\n        }\n\n        const endpoint = options.validateOnly ? '/import/validate' : '/import';\n        const response = await apiClient.request(endpoint, { method: 'POST', body: formData });\n\n        if (options.validateOnly) {\n          if (isSuccessResponse(response)) {\n            const validationData = response.data as ImportValidationResponse;\n            formatter.success('Validation completed');\n            formatter.info(`Valid: ${String(String(validationData.valid))}`);\n            formatter.info(`Would import: ${String(String(validationData.wouldImport))} items`);\n            formatter.info(`Would skip: ${String(String(validationData.wouldSkip))} items`);\n\n            if (validationData.errors.length > 0) {\n              formatter.error('Validation errors:');\n              validationData.errors.forEach((err: string) => {\n                formatter.error(`  ‚Ä¢ ${String(err)}`);\n              });\n            }\n          }\n        } else if (isSuccessResponse(response)) {\n          const importData = response.data as ImportResponse;\n          formatter.success('Import completed');\n          formatter.info(`Imported: ${String(String(importData.imported))} items`);\n          formatter.info(`Skipped: ${String(String(importData.skipped))} items`);\n\n          if (importData.errors.length > 0) {\n            formatter.error('Import errors:');\n            importData.errors.forEach((err: string) => {\n              formatter.error(`  ‚Ä¢ ${String(err)}`);\n            });\n          }\n        }\n      } catch (error) {\n        const { formatter } = getComponents();\n        formatter.error(\n          `Import failed: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/notes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 34,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 34,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1179, 1181], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 35,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 35,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1219, 1221], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 36,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 36,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1268, 1270], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 109,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 109,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3411, 3414], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3411, 3414], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .interactive on an `any` value.",
        "line": 109,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 109,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 163,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 163,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 164,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 164,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 175,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 175,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 175,
        "column": 66,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 175,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5477, 5480], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5477, 5480], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 176,
        "column": 78,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 176,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 202,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 202,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 202,
        "column": 62,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 202,
        "endColumn": 65,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6453, 6456], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6453, 6456], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 208,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 208,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6604, 6607], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6604, 6607], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .interactive on an `any` value.",
        "line": 210,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 210,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 211,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 237,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 216,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 216,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 216,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 216,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 222,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 222,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .content on an `any` value.",
        "line": 222,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 222,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 229,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 229,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 229,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 229,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 235,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 235,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned on an `any` value.",
        "line": 235,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 235,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 238,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 238,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 241,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 241,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 241,
        "column": 30,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 241,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 241,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 241,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 241,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 241,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .content on an `any` value.",
        "line": 242,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 242,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 242,
        "column": 32,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 242,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .content on an `any` value.",
        "line": 242,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 242,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .content on an `any` value.",
        "line": 242,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 242,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 243,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 243,
        "column": 33,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 243,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 243,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 243,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task on an `any` value.",
        "line": 244,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 244,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 244,
        "column": 29,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 244,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 244,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 244,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task on an `any` value.",
        "line": 244,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 244,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pin on an `any` value.",
        "line": 245,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 245,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned on an `any` value.",
        "line": 245,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 245,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .unpin on an `any` value.",
        "line": 246,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 246,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned on an `any` value.",
        "line": 246,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 246,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{}`.",
        "line": 249,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 249,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 254,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 254,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `UpdateNoteRequest`.",
        "line": 254,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 254,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 254,
        "column": 74,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 254,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8166, 8169], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8166, 8169], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .force on an `any` value.",
        "line": 274,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 274,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 275,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 275,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 275,
        "column": 57,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 275,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8816, 8819], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8816, 8819], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 281,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 288,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 285,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 285,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 317,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 317,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 317,
        "column": 31,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 317,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 317,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 317,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 318,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 318,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 318,
        "column": 28,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 318,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 318,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 318,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 320,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 320,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 320,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 320,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10245, 10248], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10245, 10248], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 322,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 322,
        "endColumn": 35
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 60,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport type { CliComponents } from '../types';\n\nexport function registerNoteCommands(program: Command): void {\n  const noteCmd = program.command('note').alias('n').description('Manage notes');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  noteCmd\n    .command('list')\n    .alias('ls')\n    .description('List all notes')\n    .option('-l, --limit <number>', 'limit number of results', '20')\n    .option('--sort <field>', 'sort by field', 'createdAt')\n    .option('--order <direction>', 'sort order (asc/desc)', 'desc')\n    .option('--category <category>', 'filter by category')\n    .option('--task <taskId>', 'filter by task ID')\n    .option('--pinned', 'show only pinned notes')\n    .action(\n      async (options: {\n        limit?: string;\n        sort?: string;\n        order?: string;\n        category?: string;\n        task?: string;\n        pinned?: boolean;\n      }) => {\n        const { apiClient, formatter } = getComponents();\n\n        try {\n          const params: Record<string, string> = {\n            limit: options.limit || '20',\n            sort: options.sort || 'createdAt',\n            order: options.order || 'desc',\n          };\n\n          if (options.category) params.category = options.category;\n          if (options.task) params.taskId = options.task;\n          if (options.pinned) params.pinned = 'true';\n\n          const notes = await apiClient.getNotes(params);\n\n          if (!notes || !Array.isArray(notes) || notes.length === 0) {\n            formatter.info('No notes found');\n            return;\n          }\n\n          formatter.output(notes, {\n            fields: ['id', 'title', 'category', 'pinned', 'taskId', 'createdAt'],\n            headers: ['ID', 'Title', 'Category', 'Pinned', 'Task ID', 'Created'],\n          });\n        } catch (error) {\n          formatter.error(\n            `Failed to list notes: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  noteCmd\n    .command('show <id>')\n    .description('Show note details')\n    .action(async (id: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const note = await apiClient.getNote(id);\n\n        if (!note) {\n          formatter.error(`Note ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        formatter.output(note);\n      } catch (error) {\n        formatter.error(\n          `Failed to get note: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  noteCmd\n    .command('add')\n    .alias('create')\n    .description('Add a new note')\n    .option('-t, --title <title>', 'note title')\n    .option('-c, --content <content>', 'note content')\n    .option('--category <category>', 'note category')\n    .option('--task <taskId>', 'link to task ID')\n    .option('--pin', 'pin the note')\n    .option('-i, --interactive', 'interactive mode')\n    .action(\n      async (options: {\n        title?: string;\n        content?: string;\n        category?: string;\n        task?: string;\n        pin?: boolean;\n        interactive?: boolean;\n      }) => {\n        const { apiClient, formatter } = getComponents();\n\n        let noteData: Record<string, unknown> = {};\n\n        if ((options as any).interactive ?? !options.title) {\n          const questions: Array<{\n            type: string;\n            name: string;\n            message: string;\n            validate?: (input: string) => boolean | string;\n            choices?: string[];\n            default?: string;\n          }> = [];\n\n          if (!options.title) {\n            questions.push({\n              type: 'input',\n              name: 'title',\n              message: 'Note title:',\n              validate: (input: string) => input.length > 0 || 'Title is required',\n            });\n          }\n\n          if (!options.content) {\n            questions.push({\n              type: 'editor',\n              name: 'content',\n              message: 'Note content:',\n            });\n          }\n\n          if (!options.category) {\n            questions.push({\n              type: 'list',\n              name: 'category',\n              message: 'Note category:',\n              choices: ['general', 'meeting', 'idea', 'bug', 'feature', 'docs'],\n              default: 'general',\n            });\n          }\n\n          if (!options.task) {\n            questions.push({\n              type: 'input',\n              name: 'taskId',\n              message: 'Link to task ID (optional):',\n            });\n          }\n\n          if (!options.pin) {\n            questions.push({\n              type: 'confirm',\n              name: 'pinned',\n              message: 'Pin this note?',\n              default: false,\n            });\n          }\n\n          const answers = await inquirer.prompt(questions);\n          noteData = { ...noteData, ...answers };\n        }\n\n        // Use command line options or answers\n        noteData.title = options.title ?? noteData.title;\n        noteData.content = options.content ?? noteData.content;\n        noteData.category = options.category ?? noteData.category ?? 'general';\n        noteData.taskId = options.task ?? noteData.taskId;\n        noteData.pinned = options.pin ?? noteData.pinned ?? false;\n\n        try {\n          const note = (await apiClient.createNote(noteData)) as any;\n          formatter.success(`Note created successfully: ${String(String(note.id))}`);\n          formatter.output(note);\n        } catch (error) {\n          formatter.error(\n            `Failed to create note: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  noteCmd\n    .command('update <id>')\n    .description('Update a note')\n    .option('-t, --title <title>', 'note title')\n    .option('-c, --content <content>', 'note content')\n    .option('--category <category>', 'note category')\n    .option('--task <taskId>', 'link to task ID')\n    .option('--pin', 'pin the note')\n    .option('--unpin', 'unpin the note')\n    .option('-i, --interactive', 'interactive mode')\n    .action(async (id: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        // Get current note data\n        const currentNote = (await apiClient.getNote(id)) as any;\n        if (!currentNote) {\n          formatter.error(`Note ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        let updates: any = {};\n\n        if (options.interactive) {\n          const answers = await inquirer.prompt([\n            {\n              type: 'input',\n              name: 'title',\n              message: 'Note title:',\n              default: currentNote.title,\n            },\n            {\n              type: 'editor',\n              name: 'content',\n              message: 'Note content:',\n              default: currentNote.content ?? '',\n            },\n            {\n              type: 'list',\n              name: 'category',\n              message: 'Note category:',\n              choices: ['general', 'meeting', 'idea', 'bug', 'feature', 'docs'],\n              default: currentNote.category ?? 'general',\n            },\n            {\n              type: 'confirm',\n              name: 'pinned',\n              message: 'Pin this note?',\n              default: currentNote.pinned ?? false,\n            },\n          ]);\n          updates = answers;\n        } else {\n          // Use command line options\n          if (options.title) updates.title = options.title;\n          if (options.content) updates.content = options.content;\n          if (options.category) updates.category = options.category;\n          if (options.task) updates.taskId = options.task;\n          if (options.pin) updates.pinned = true;\n          if (options.unpin) updates.pinned = false;\n        }\n\n        if (Object.keys(updates).length === 0) {\n          formatter.warn('No updates specified');\n          return;\n        }\n\n        const updatedNote = (await apiClient.updateNote(id, updates)) as any;\n        formatter.success('Note updated successfully');\n        formatter.output(updatedNote);\n      } catch (error) {\n        formatter.error(\n          `Failed to update note: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  noteCmd\n    .command('delete <id>')\n    .alias('rm')\n    .description('Delete a note')\n    .option('-f, --force', 'skip confirmation')\n    .action(async (id: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          const note = (await apiClient.getNote(id)) as any;\n          if (!note) {\n            formatter.error(`Note ${String(id)} not found`);\n            process.exit(1);\n          }\n\n          const { confirm } = await inquirer.prompt([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: `Delete note \"${String(String(note.title))}\"?`,\n              default: false,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Delete cancelled');\n            return;\n          }\n        }\n\n        await apiClient.deleteNote(id);\n        formatter.success(`Note ${String(id)} deleted successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to delete note: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  noteCmd\n    .command('search <query>')\n    .alias('find')\n    .description('Search notes')\n    .option('-c, --category <category>', 'filter by category')\n    .option('-l, --limit <number>', 'limit number of results', '10')\n    .action(async (query: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const searchParams: Record<string, string> = {};\n        if (options.category) searchParams.category = options.category;\n        if (options.limit) searchParams.limit = options.limit;\n\n        const notes = (await apiClient.searchNotes(query)) as any;\n\n        if (!notes || notes.length === 0) {\n          formatter.info(`No notes found matching \"${String(query)}\"`);\n          return;\n        }\n\n        formatter.output(notes, {\n          fields: ['id', 'title', 'category', 'content'],\n          headers: ['ID', 'Title', 'Category', 'Content'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to search notes: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  noteCmd\n    .command('pin <id>')\n    .description('Pin a note')\n    .action(async (id: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        await apiClient.updateNote(id, { pinned: true });\n        formatter.success(`Note ${String(id)} pinned successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to pin note: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  noteCmd\n    .command('unpin <id>')\n    .description('Unpin a note')\n    .action(async (id: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        await apiClient.updateNote(id, { pinned: false });\n        formatter.success(`Note ${String(id)} unpinned successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to unpin note: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/priority.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 20,
        "column": 53,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 20,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [782, 784], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 33,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 33,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1145, 1148], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1145, 1148], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priorityReasoning on an `any` value.",
        "line": 33,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 33,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 35,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 35,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1278, 1281], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1278, 1281], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priorityReasoning on an `any` value.",
        "line": 35,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 35,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 79,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 79,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2823, 2826], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2823, 2826], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 79,
        "column": 65,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 79,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 82,
        "column": 83,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 82,
        "endColumn": 85,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2957, 2959], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 108,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 108,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3825, 3828], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3825, 3828], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .message on an `any` value.",
        "line": 108,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 108,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 109,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 109,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3884, 3887], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3884, 3887], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .message on an `any` value.",
        "line": 109,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 109,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 112,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 112,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3934, 3937], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3934, 3937], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .updated on an `any` value.",
        "line": 112,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 112,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 113,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 113,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4004, 4007], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4004, 4007], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .updated on an `any` value.",
        "line": 113,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 113,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 138,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 138,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4802, 4805], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4802, 4805], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .reason on an `any` value.",
        "line": 139,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 139,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 140,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 140,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priorityReason on an `any` value.",
        "line": 140,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 140,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .reason on an `any` value.",
        "line": 140,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 140,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .reason on an `any` value.",
        "line": 146,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 146,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .reason on an `any` value.",
        "line": 147,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 147,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 164,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 164,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 164,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 164,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5675, 5678], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5675, 5678], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 170,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 170,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priority on an `any` value.",
        "line": 170,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 170,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
        "line": 171,
        "column": 38,
        "nodeType": "BinaryExpression",
        "messageId": "unsafeArgument",
        "endLine": 171,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 192,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 192,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 192,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 192,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6609, 6612], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6609, 6612], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 198,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 198,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priority on an `any` value.",
        "line": 198,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 198,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 31,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Command } from 'commander';\nimport type { CliComponents } from '../types';\n\nexport function registerPriorityCommands(program: Command): void {\n  const priorityCmd = program.command('priority').alias('p').description('Manage task priorities');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  priorityCmd\n    .command('next')\n    .alias('n')\n    .description('Get next prioritized task')\n    .option('-c, --count <number>', 'number of tasks to show', '1')\n    .option('--explain', 'show priority reasoning')\n    .action(async (options: { count?: string; explain?: boolean }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const count = parseInt(String(options.count || '1'), 10);\n\n        if (count === 1) {\n          const nextTask = await apiClient.getNextTask();\n\n          if (!nextTask) {\n            formatter.info('No prioritized tasks available');\n            return;\n          }\n\n          formatter.success('Next prioritized task:');\n          formatter.output(nextTask);\n\n          if (options.explain && (nextTask as any).priorityReasoning) {\n            formatter.info('\\n--- Priority Reasoning ---');\n            formatter.info(String((nextTask as any).priorityReasoning));\n          }\n        } else {\n          const priorities = await apiClient.getPriorities();\n\n          if (!priorities || !Array.isArray(priorities) || priorities.length === 0) {\n            formatter.info('No prioritized tasks available');\n            return;\n          }\n\n          const topTasks = priorities.slice(0, count);\n          formatter.success(`Top ${String(count)} prioritized tasks:`);\n          formatter.output(topTasks, {\n            fields: ['id', 'title', 'priority', 'status', 'dueDate'],\n            headers: ['ID', 'Title', 'Priority', 'Status', 'Due Date'],\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get next task: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  priorityCmd\n    .command('list')\n    .alias('ls')\n    .description('List all tasks by priority')\n    .option('-l, --limit <number>', 'limit number of results', '20')\n    .option('--status <status>', 'filter by status')\n    .action(async (options: { limit?: string; status?: string }) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const priorities = await apiClient.getPriorities();\n\n        if (!priorities || !Array.isArray(priorities) || priorities.length === 0) {\n          formatter.info('No prioritized tasks available');\n          return;\n        }\n\n        let filteredTasks = priorities;\n        if (options.status) {\n          filteredTasks = priorities.filter((task: any) => task.status === options.status);\n        }\n\n        const limitedTasks = filteredTasks.slice(0, parseInt(String(options.limit || '20'), 10));\n\n        formatter.output(limitedTasks, {\n          fields: ['id', 'title', 'priority', 'status', 'dueDate', 'dependencies'],\n          headers: ['ID', 'Title', 'Priority', 'Status', 'Due Date', 'Dependencies'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to list priorities: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  priorityCmd\n    .command('recalc')\n    .alias('calculate')\n    .description('Recalculate all task priorities')\n    .action(async () => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        formatter.info('Recalculating task priorities...');\n        const result = await apiClient.recalculatePriorities();\n\n        formatter.success('Priority recalculation completed');\n        if ((result as any).message) {\n          formatter.info(String((result as any).message));\n        }\n\n        if ((result as any).updated) {\n          formatter.info(`Updated ${String((result as any).updated)} task priorities`);\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to recalculate priorities: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  priorityCmd\n    .command('set <taskId> <priority>')\n    .description('Set task priority (1-10)')\n    .option('--reason <reason>', 'reason for priority change')\n    .action(async (taskId: string, priority: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const priorityNum = parseInt(priority, 10);\n\n        if (priorityNum < 1 || priorityNum > 10) {\n          formatter.error('Priority must be between 1 and 10');\n          process.exit(1);\n        }\n\n        const updateData: any = { priority: priorityNum };\n        if (options.reason) {\n          updateData.priorityReason = options.reason;\n        }\n\n        await apiClient.updateTaskPriority(taskId, priorityNum);\n        formatter.success(`Task ${String(taskId)} priority set to ${String(priorityNum)}`);\n\n        if (options.reason) {\n          formatter.info(`Reason: ${String(String(options.reason))}`);\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to set task priority: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  priorityCmd\n    .command('boost <taskId>')\n    .description('Boost task priority by 1')\n    .action(async (taskId: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const task = (await apiClient.getTask(taskId)) as any;\n        if (!task) {\n          formatter.error(`Task ${String(taskId)} not found`);\n          process.exit(1);\n        }\n\n        const currentPriority = task.priority ?? 5;\n        const newPriority = Math.min(currentPriority + 1, 10);\n\n        await apiClient.updateTaskPriority(taskId, newPriority);\n        formatter.success(\n          `Task ${String(taskId)} priority boosted from ${String(currentPriority)} to ${String(newPriority)}`\n        );\n      } catch (error) {\n        formatter.error(\n          `Failed to boost task priority: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  priorityCmd\n    .command('lower <taskId>')\n    .description('Lower task priority by 1')\n    .action(async (taskId: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const task = (await apiClient.getTask(taskId)) as any;\n        if (!task) {\n          formatter.error(`Task ${String(taskId)} not found`);\n          process.exit(1);\n        }\n\n        const currentPriority = task.priority ?? 5;\n        const newPriority = Math.max(currentPriority - 1, 1);\n\n        await apiClient.updateTaskPriority(taskId, newPriority);\n        formatter.success(\n          `Task ${String(taskId)} priority lowered from ${String(currentPriority)} to ${String(newPriority)}`\n        );\n      } catch (error) {\n        formatter.error(\n          `Failed to lower task priority: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/process-todos.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/realtime.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 69,
        "column": 19,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 69,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-base-to-string",
        "severity": 2,
        "message": "'data' may evaluate to '[object Object]' when stringified.",
        "line": 69,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "baseToString",
        "endLine": 69,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 71,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 71,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 72,
        "column": 21,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 72,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 72,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 72,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'getEventIcon' was used before it was defined.",
        "line": 81,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 81,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 81,
        "column": 43,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 81,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 81,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 81,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'getEventColor' was used before it was defined.",
        "line": 82,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 82,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 82,
        "column": 45,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 82,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 82,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 82,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 84,
        "column": 72,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 84,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 84,
        "column": 78,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 84,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .message on an `any` value.",
        "line": 84,
        "column": 102,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 84,
        "endColumn": 109
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'formatEventMessage' was used before it was defined.",
        "line": 84,
        "column": 113,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 84,
        "endColumn": 131
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 87,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 87,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 88,
        "column": 66,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 88,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 136,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 136,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .lines on an `any` value.",
        "line": 136,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 136,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 137,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 137,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .level on an `any` value.",
        "line": 137,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 137,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .component on an `any` value.",
        "line": 140,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 140,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 140,
        "column": 32,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 140,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .component on an `any` value.",
        "line": 140,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 140,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .since on an `any` value.",
        "line": 141,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 141,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 141,
        "column": 28,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 141,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .since on an `any` value.",
        "line": 141,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 141,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .follow on an `any` value.",
        "line": 143,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 143,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 147,
        "column": 39,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 147,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 149,
        "column": 21,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 154,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 154,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 154,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5425, 5428], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5425, 5428], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 156,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 156,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 157,
        "column": 17,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 157,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .forEach on an `any` value.",
        "line": 157,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 157,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 157,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 157,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5511, 5514], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5511, 5514], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 158,
        "column": 46,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 158,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .timestamp on an `any` value.",
        "line": 158,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 158,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 159,
        "column": 25,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 159,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 159,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 159,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 159,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 159,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .level on an `any` value.",
        "line": 159,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 159,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .padEnd on an `any` value.",
        "line": 159,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 159,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .component on an `any` value.",
        "line": 160,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 160,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .component on an `any` value.",
        "line": 160,
        "column": 75,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 160,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .message on an `any` value.",
        "line": 162,
        "column": 101,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 162,
        "endColumn": 108
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 173,
        "column": 13,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 173,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 187,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 187,
        "endColumn": 95
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 187,
        "column": 92,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 187,
        "endColumn": 95,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6637, 6640], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6637, 6640], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 189,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 189,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 222,
        "column": 47,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 222,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [7676, 7678], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 230,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 230,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7970, 7973], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7970, 7973], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 231,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 231,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 233,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 233,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 235,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 235,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 237,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 237,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 237,
        "column": 91,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 237,
        "endColumn": 95
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 239,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 239,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 241,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 241,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 243,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 243,
        "column": 96,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 100
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 245,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 245,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 247,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 247,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 247,
        "column": 102,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 247,
        "endColumn": 106
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 249,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 249,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 251,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 251,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 253,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 253,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .data on an `any` value.",
        "line": 253,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 253,
        "endColumn": 54
      }
    ],
    "suppressedMessages": [],
    "errorCount": 9,
    "fatalErrorCount": 0,
    "warningCount": 58,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger } from '@/utils/logger';\nimport type { Command } from 'commander';\nimport * as WebSocket from 'ws';\nimport type { CliComponents } from '../types';\n\nexport function registerRealtimeCommands(program: Command): void {\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  program\n    .command('watch')\n    .alias('w')\n    .description('Watch for real-time updates')\n    .option('-b, --board <id>', 'watch specific board')\n    .option('-t, --task <id>', 'watch specific task')\n    .option('--events <types>', 'event types to watch (comma-separated)')\n    .option('--format <format>', 'output format (json|table|compact)', 'compact')\n    .action((options: { board?: string; task?: string; events?: string; format?: string }) => {\n      const { config, formatter } = getComponents();\n\n      try {\n        const serverUrl = config.getServerUrl();\n        const apiKey = config.getApiKey();\n\n        if (!apiKey) {\n          formatter.error('API key required. Run \"kanban config set api.key <key>\"');\n          process.exit(1);\n        }\n\n        // Convert HTTP URL to WebSocket URL\n        const wsUrl = serverUrl.replace(/^https?:\\/\\//, 'ws://').replace(/^ws:\\/\\//, 'wss://');\n        const wsEndpoint = `${String(wsUrl)}/ws?apiKey=${String(apiKey)}`;\n\n        formatter.info('Connecting to real-time updates...');\n\n        const ws = new WebSocket.WebSocket(wsEndpoint);\n\n        ws.on('open', () => {\n          formatter.success('Connected to real-time updates');\n\n          // Subscribe to events based on options\n          const subscriptions: Record<string, unknown> = {};\n\n          if (options.board) {\n            subscriptions.board = options.board;\n          }\n\n          if (options.task) {\n            subscriptions.task = options.task;\n          }\n\n          if (options.events) {\n            subscriptions.events = options.events.split(',').map((e: string) => e.trim());\n          }\n\n          // Send subscription message\n          ws.send(\n            JSON.stringify({\n              type: 'subscribe',\n              data: subscriptions,\n            })\n          );\n\n          formatter.info('Watching for updates... (Press Ctrl+C to stop)');\n        });\n\n        ws.on('message', (data: WebSocket.Data) => {\n          try {\n            const message = JSON.parse(data.toString());\n\n            if (message.type === 'event') {\n              const event = message.data;\n              const timestamp = new Date().toLocaleTimeString();\n\n              if (options.format === 'json') {\n                logger.info(JSON.stringify({ timestamp, ...event }, null, 2));\n              } else if (options.format === 'table') {\n                formatter.output([{ timestamp, ...event }]);\n              } else {\n                // Compact format\n                const icon = getEventIcon(event.type);\n                const color = getEventColor(event.type);\n                logger.info(\n                  `${String(timestamp)} ${String(icon)} ${String(color(event.type))}: ${String(event.message ?? formatEventMessage(event))}`\n                );\n              }\n            } else if (message.type === 'error') {\n              formatter.error(`WebSocket error: ${String(message.data.message)}`);\n            }\n          } catch (error) {\n            formatter.warn(`Failed to parse message: ${String(data)}`);\n          }\n        });\n\n        ws.on('error', (error: Error) => {\n          formatter.error(`WebSocket error: ${String(error.message)}`);\n          process.exit(1);\n        });\n\n        ws.on('close', (code: number, reason: Buffer) => {\n          if (code === 1000) {\n            formatter.info('Connection closed normally');\n          } else {\n            formatter.error(`Connection closed: ${String(code)} ${String(reason)}`);\n            process.exit(1);\n          }\n        });\n\n        // Handle graceful shutdown\n        process.on('SIGINT', () => {\n          formatter.info('\\nClosing connection...');\n          ws.close();\n          process.exit(0);\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to start watching: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  program\n    .command('logs')\n    .description('View system logs')\n    .option('-f, --follow', 'follow log output')\n    .option('-n, --lines <number>', 'number of lines to show', '50')\n    .option('--level <level>', 'minimum log level (debug|info|warn|error)', 'info')\n    .option('--component <name>', 'filter by component')\n    .option('--since <time>', 'show logs since time (e.g., \"1h\", \"30m\", \"2024-01-01\")')\n    .action(async options => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const params: Record<string, string> = {\n          lines: options.lines,\n          level: options.level,\n        };\n\n        if (options.component) params.component = options.component;\n        if (options.since) params.since = options.since;\n\n        if (options.follow) {\n          // Stream logs in real-time\n          formatter.info('Following logs... (Press Ctrl+C to stop)');\n\n          const streamLogs = async () => {\n            try {\n              const logs = (await apiClient.request(\n                'GET',\n                '/api/logs/stream',\n                undefined,\n                params\n              )) as any;\n\n              if (logs && logs.length > 0) {\n                logs.forEach((log: any) => {\n                  const timestamp = new Date(log.timestamp).toLocaleTimeString();\n                  const level = log.level.toUpperCase().padEnd(5);\n                  const component = log.component ? `[${String(String(log.component))}]` : '';\n                  logger.info(\n                    `${String(timestamp)} ${String(level)} ${String(component)} ${String(String(log.message))}`\n                  );\n                });\n              }\n            } catch (error) {\n              // Ignore errors in streaming mode, will retry\n            }\n          };\n\n          // Poll for new logs every second\n          const interval = setInterval(() => {\n            void streamLogs();\n          }, 1000);\n\n          // Handle graceful shutdown\n          process.on('SIGINT', () => {\n            clearInterval(interval);\n            formatter.info('\\nStopped following logs');\n            process.exit(0);\n          });\n\n          // Initial load\n          await streamLogs();\n        } else {\n          // One-time log fetch\n          const logs = (await apiClient.request('GET', '/api/logs', undefined, params)) as any;\n\n          if (!logs || logs.length === 0) {\n            formatter.info('No logs found');\n            return;\n          }\n\n          formatter.output(logs, {\n            fields: ['timestamp', 'level', 'component', 'message'],\n            headers: ['Timestamp', 'Level', 'Component', 'Message'],\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get logs: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  // Utility functions for event formatting\n  function getEventIcon(eventType: string): string {\n    const icons: Record<string, string> = {\n      'task:created': '‚ú®',\n      'task:updated': 'üìù',\n      'task:moved': 'üîÑ',\n      'task:deleted': 'üóëÔ∏è',\n      'task:completed': '‚úÖ',\n      'note:added': 'üìÑ',\n      'note:updated': 'üìù',\n      'priority:changed': '‚ö°',\n      'dependency:blocked': 'üö´',\n      'subtask:completed': '‚úì',\n      default: 'üìã',\n    };\n    return icons[eventType] ?? (icons.default || 'üìã');\n  }\n\n  function getEventColor(_eventType: string): (text: string) => string {\n    // This would typically use chalk, but keeping it simple for now\n    return (text: string) => text; // In real implementation, apply colors based on event type\n  }\n\n  function formatEventMessage(event: any): string {\n    switch (event.type) {\n      case 'task:created':\n        return `Task \"${String(String(event.data.title))}\" created`;\n      case 'task:updated':\n        return `Task \"${String(String(event.data.title))}\" updated`;\n      case 'task:moved':\n        return `Task \"${String(String(event.data.title))}\" moved to ${String(String(event.data.columnName))}`;\n      case 'task:deleted':\n        return `Task \"${String(String(event.data.title))}\" deleted`;\n      case 'task:completed':\n        return `Task \"${String(String(event.data.title))}\" completed`;\n      case 'note:added':\n        return `Note \"${String(String(event.data.title))}\" added to task ${String(String(event.data.taskId))}`;\n      case 'note:updated':\n        return `Note \"${String(String(event.data.title))}\" updated`;\n      case 'priority:changed':\n        return `Task \"${String(String(event.data.title))}\" priority changed to ${String(String(event.data.newPriority))}`;\n      case 'dependency:blocked':\n        return `Task \"${String(String(event.data.title))}\" blocked by dependency`;\n      case 'subtask:completed':\n        return `Subtask \"${String(String(event.data.title))}\" completed`;\n      default:\n        return event.data ? JSON.stringify(event.data) : 'Unknown event';\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/search.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 37,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 37,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1305, 1307], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 38,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 38,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1345, 1347], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 39,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 39,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1394, 1396], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 89,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 89,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [3228, 3230], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 90,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 90,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [3268, 3270], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 91,
        "column": 34,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 91,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [3317, 3319], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 156,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 156,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5636, 5639], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5636, 5639], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .notesOnly on an `any` value.",
        "line": 159,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 159,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tagsOnly on an `any` value.",
        "line": 159,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 159,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 160,
        "column": 62,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 160,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 160,
        "column": 77,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 160,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tasksOnly on an `any` value.",
        "line": 164,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 164,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tagsOnly on an `any` value.",
        "line": 164,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 164,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tasksOnly on an `any` value.",
        "line": 169,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 169,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .notesOnly on an `any` value.",
        "line": 169,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 169,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 179,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 179,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 179,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 179,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 239,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 239,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 239,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 239,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 242,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 242,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 242,
        "column": 28,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 242,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 242,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 242,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 243,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 243,
        "column": 34,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 243,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 243,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 243,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tags on an `any` value.",
        "line": 244,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 244,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 244,
        "column": 27,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 244,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tags on an `any` value.",
        "line": 244,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 244,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 245,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 245,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 245,
        "column": 29,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 245,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 245,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 245,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priorityMin on an `any` value.",
        "line": 246,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 246,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 246,
        "column": 34,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 246,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priorityMin on an `any` value.",
        "line": 246,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 246,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priorityMax on an `any` value.",
        "line": 247,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 247,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 247,
        "column": 34,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 247,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priorityMax on an `any` value.",
        "line": 247,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 247,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .createdAfter on an `any` value.",
        "line": 248,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 248,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 248,
        "column": 35,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 248,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .createdAfter on an `any` value.",
        "line": 248,
        "column": 65,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 248,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .createdBefore on an `any` value.",
        "line": 249,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 249,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 249,
        "column": 36,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 249,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .createdBefore on an `any` value.",
        "line": 249,
        "column": 67,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 249,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dueAfter on an `any` value.",
        "line": 250,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 250,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 250,
        "column": 31,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 250,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dueAfter on an `any` value.",
        "line": 250,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 250,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dueBefore on an `any` value.",
        "line": 251,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 251,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 251,
        "column": 32,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 251,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dueBefore on an `any` value.",
        "line": 251,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 251,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 253,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 258,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 258,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 258,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9608, 9611], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9608, 9611], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 260,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 260,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 265,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 265,
        "endColumn": 64
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 53,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger } from '@/utils/logger';\nimport type { Command } from 'commander';\nimport type { CliComponents } from '../types';\n\nexport function registerSearchCommands(program: Command): void {\n  const searchCmd = program.command('search').alias('s').description('Search tasks and content');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  searchCmd\n    .command('tasks <query>')\n    .description('Search tasks')\n    .option('-b, --board <id>', 'search within specific board')\n    .option('-s, --status <status>', 'filter by status')\n    .option('-t, --tags <tags>', 'filter by tags (comma-separated)')\n    .option('-l, --limit <number>', 'limit number of results', '20')\n    .option('--sort <field>', 'sort by field', 'relevance')\n    .option('--order <direction>', 'sort order (asc/desc)', 'desc')\n    .action(\n      async (\n        query: string,\n        options: {\n          board?: string;\n          status?: string;\n          tags?: string;\n          limit?: string;\n          sort?: string;\n          order?: string;\n        }\n      ) => {\n        const { config, apiClient, formatter } = getComponents();\n\n        try {\n          const params: Record<string, string> = {\n            q: query,\n            limit: options.limit || '20',\n            sort: options.sort || 'relevance',\n            order: options.order || 'desc',\n          };\n\n          if (options.board) params.board = options.board;\n          if (options.status) params.status = options.status;\n          if (options.tags) params.tags = options.tags;\n\n          // Use default board if no board specified\n          if (!options.board && config.getDefaultBoard()) {\n            params.board = config.getDefaultBoard()!;\n          }\n\n          const results = await apiClient.searchTasks(query, params);\n\n          if (!results || !Array.isArray(results) || results.length === 0) {\n            formatter.info(`No tasks found for \"${String(query)}\"`);\n            return;\n          }\n\n          formatter.success(`Found ${String(results.length)} tasks matching \"${String(query)}\"`);\n          formatter.output(results, {\n            fields: ['id', 'title', 'status', 'priority', 'relevance', 'board'],\n            headers: ['ID', 'Title', 'Status', 'Priority', 'Relevance', 'Board'],\n          });\n        } catch (error) {\n          formatter.error(\n            `Failed to search tasks: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  searchCmd\n    .command('notes <query>')\n    .description('Search notes')\n    .option('-c, --category <category>', 'filter by category')\n    .option('-l, --limit <number>', 'limit number of results', '20')\n    .option('--sort <field>', 'sort by field', 'relevance')\n    .option('--order <direction>', 'sort order (asc/desc)', 'desc')\n    .action(\n      async (\n        query: string,\n        options: { category?: string; limit?: string; sort?: string; order?: string }\n      ) => {\n        const { apiClient, formatter } = getComponents();\n\n        try {\n          const params: Record<string, string> = {\n            q: query,\n            limit: options.limit || '20',\n            sort: options.sort || 'relevance',\n            order: options.order || 'desc',\n          };\n\n          if (options.category) params.category = options.category;\n\n          const results = await apiClient.searchNotes(query);\n\n          if (!results || !Array.isArray(results) || results.length === 0) {\n            formatter.info(`No notes found for \"${String(query)}\"`);\n            return;\n          }\n\n          formatter.success(`Found ${String(results.length)} notes matching \"${String(query)}\"`);\n          formatter.output(results, {\n            fields: ['id', 'title', 'category', 'relevance', 'createdAt'],\n            headers: ['ID', 'Title', 'Category', 'Relevance', 'Created'],\n          });\n        } catch (error) {\n          formatter.error(\n            `Failed to search notes: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  searchCmd\n    .command('tags <query>')\n    .description('Search tags')\n    .option('-l, --limit <number>', 'limit number of results', '20')\n    .action(async (query: string, _options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const results = await apiClient.searchTags(query);\n\n        if (!results || !Array.isArray(results) || results.length === 0) {\n          formatter.info(`No tags found for \"${String(query)}\"`);\n          return;\n        }\n\n        formatter.success(`Found ${String(results.length)} tags matching \"${String(query)}\"`);\n        formatter.output(results, {\n          fields: ['id', 'name', 'description', 'taskCount', 'parentId'],\n          headers: ['ID', 'Name', 'Description', 'Tasks', 'Parent'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to search tags: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  searchCmd\n    .command('all <query>')\n    .description('Search all content (tasks, notes, tags)')\n    .option('-l, --limit <number>', 'limit number of results per type', '10')\n    .option('--tasks-only', 'search only tasks')\n    .option('--notes-only', 'search only notes')\n    .option('--tags-only', 'search only tags')\n    .action(async (query: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const searchPromises: Promise<any>[] = [];\n        const searchTypes: string[] = [];\n\n        if (!options.notesOnly && !options.tagsOnly) {\n          searchPromises.push(apiClient.searchTasks(query, { limit: options.limit }));\n          searchTypes.push('tasks');\n        }\n\n        if (!options.tasksOnly && !options.tagsOnly) {\n          searchPromises.push(apiClient.searchNotes(query));\n          searchTypes.push('notes');\n        }\n\n        if (!options.tasksOnly && !options.notesOnly) {\n          searchPromises.push(apiClient.searchTags(query));\n          searchTypes.push('tags');\n        }\n\n        const results = await Promise.all(searchPromises);\n\n        let totalResults = 0;\n        results.forEach((result, index) => {\n          const type = searchTypes[index];\n          const count = result ? result.length : 0;\n          totalResults += count;\n\n          if (count > 0 && type) {\n            logger.info(\n              `\\n--- ${String(String(type.toUpperCase()))} (${String(count)} results) ---`\n            );\n\n            if (type === 'tasks') {\n              formatter.output(result, {\n                fields: ['id', 'title', 'status', 'priority'],\n                headers: ['ID', 'Title', 'Status', 'Priority'],\n              });\n            } else if (type === 'notes') {\n              formatter.output(result, {\n                fields: ['id', 'title', 'category'],\n                headers: ['ID', 'Title', 'Category'],\n              });\n            } else if (type === 'tags') {\n              formatter.output(result, {\n                fields: ['id', 'name', 'taskCount'],\n                headers: ['ID', 'Name', 'Tasks'],\n              });\n            }\n          }\n        });\n\n        if (totalResults === 0) {\n          formatter.info(`No results found for \"${String(query)}\"`);\n        } else {\n          formatter.success(`Found ${String(totalResults)} total results for \"${String(query)}\"`);\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to search: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n\n  // Advanced search with filters\n  searchCmd\n    .command('advanced')\n    .description('Advanced search with multiple filters')\n    .option('--title <query>', 'search in titles')\n    .option('--description <query>', 'search in descriptions')\n    .option('--tags <tags>', 'filter by tags (comma-separated)')\n    .option('--status <status>', 'filter by status')\n    .option('--priority-min <number>', 'minimum priority')\n    .option('--priority-max <number>', 'maximum priority')\n    .option('--created-after <date>', 'created after date (YYYY-MM-DD)')\n    .option('--created-before <date>', 'created before date (YYYY-MM-DD)')\n    .option('--due-after <date>', 'due after date (YYYY-MM-DD)')\n    .option('--due-before <date>', 'due before date (YYYY-MM-DD)')\n    .option('-l, --limit <number>', 'limit number of results', '20')\n    .action(async options => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const params: Record<string, string> = {\n          limit: options.limit,\n        };\n\n        if (options.title) params.title = options.title;\n        if (options.description) params.description = options.description;\n        if (options.tags) params.tags = options.tags;\n        if (options.status) params.status = options.status;\n        if (options.priorityMin) params.priorityMin = options.priorityMin;\n        if (options.priorityMax) params.priorityMax = options.priorityMax;\n        if (options.createdAfter) params.createdAfter = options.createdAfter;\n        if (options.createdBefore) params.createdBefore = options.createdBefore;\n        if (options.dueAfter) params.dueAfter = options.dueAfter;\n        if (options.dueBefore) params.dueBefore = options.dueBefore;\n\n        const results = (await apiClient.request(\n          'GET',\n          '/api/search/advanced',\n          undefined,\n          params\n        )) as any;\n\n        if (!results || results.length === 0) {\n          formatter.info('No results found with the specified filters');\n          return;\n        }\n\n        formatter.success(`Found ${String(String(results.length))} results with advanced filters`);\n        formatter.output(results, {\n          fields: ['id', 'title', 'status', 'priority', 'dueDate', 'createdAt'],\n          headers: ['ID', 'Title', 'Status', 'Priority', 'Due Date', 'Created'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to perform advanced search: ${String(error instanceof Error ? error.message : 'Unknown error')}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/subtasks.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 46,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 46,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1545, 1548], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1545, 1548], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .boardId on an `any` value.",
        "line": 46,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 46,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 47,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 47,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1596, 1599], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1596, 1599], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .columnId on an `any` value.",
        "line": 47,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 47,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 50,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 50,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1651, 1654], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1651, 1654], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .interactive on an `any` value.",
        "line": 50,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 50,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 109,
        "column": 19,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 109,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 110,
        "column": 13,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 110,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `CreateTaskRequest`.",
        "line": 122,
        "column": 54,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 122,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 122,
        "column": 69,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 122,
        "endColumn": 72,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4204, 4207], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4204, 4207], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 123,
        "column": 81,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 123,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4290, 4293], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4290, 4293], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 123,
        "column": 86,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 123,
        "endColumn": 88
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 145,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 145,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 145,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 145,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 148,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 148,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 149,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 149,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 149,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 149,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 152,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 152,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 152,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 152,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5181, 5184], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5181, 5184], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 154,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 154,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .blocked on an `any` value.",
        "line": 228,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 228,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 230,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 233,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 233,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 233,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7870, 7873], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7870, 7873], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 235,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 235,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 247,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 250,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 250,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 250,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8513, 8516], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8513, 8516], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 252,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 252,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 279,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 279,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .depth on an `any` value.",
        "line": 279,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 279,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 280,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 285,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 285,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 285,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9697, 9700], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9697, 9700], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 295,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 295,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9989, 9992], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9989, 9992], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 295,
        "column": 51,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 295,
        "endColumn": 53
      },
      {
        "ruleId": "no-nested-ternary",
        "severity": 2,
        "message": "Do not nest ternary expressions.",
        "line": 297,
        "column": 26,
        "nodeType": "ConditionalExpression",
        "messageId": "noNestedTernary",
        "endLine": 297,
        "endColumn": 99
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 297,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 297,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 297,
        "column": 67,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 297,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 299,
        "column": 70,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 299,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .title on an `any` value.",
        "line": 299,
        "column": 98,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 299,
        "endColumn": 103
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 299,
        "column": 129,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 299,
        "endColumn": 135
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dependencies on an `any` value.",
        "line": 302,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 302,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dependencies on an `any` value.",
        "line": 302,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 302,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 303,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 303,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dependencies on an `any` value.",
        "line": 303,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 303,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 303,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 303,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10473, 10476], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10473, 10476], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 41,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger } from '@/utils/logger';\nimport type { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport type { CliComponents, AnyApiResponse } from '../types';\n\nexport function registerSubtaskCommands(program: Command): void {\n  const subtaskCmd = program\n    .command('subtask')\n    .alias('sub')\n    .description('Manage subtasks and dependencies');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  subtaskCmd\n    .command('create <parentId>')\n    .description('Create a subtask for a parent task')\n    .option('-t, --title <title>', 'subtask title')\n    .option('-d, --description <desc>', 'subtask description')\n    .option('-p, --priority <number>', 'priority (1-10)', '5')\n    .option('--due <date>', 'due date (YYYY-MM-DD)')\n    .option('-i, --interactive', 'interactive mode')\n    .action(\n      async (\n        parentId: string,\n        options: {\n          title?: string;\n          description?: string;\n          priority?: string;\n          due?: string;\n          interactive?: boolean;\n        }\n      ) => {\n        const { apiClient, formatter } = getComponents();\n\n        try {\n          // Verify parent task exists\n          const parentTask = await apiClient.getTask(parentId);\n          if (!parentTask) {\n            formatter.error(`Parent task ${String(parentId)} not found`);\n            process.exit(1);\n          }\n\n          let subtaskData: Record<string, unknown> = {\n            parentId,\n            boardId: (parentTask as any).boardId,\n            columnId: (parentTask as any).columnId,\n          };\n\n          if ((options as any).interactive ?? !options.title) {\n            const questions: Array<\n              | {\n                  type: string;\n                  name: string;\n                  message: string;\n                  validate?: (input: string) => boolean | string;\n                  default?: number;\n                }\n              | {\n                  type: string;\n                  name: string;\n                  message: string;\n                  validate?: (input: number) => boolean | string;\n                  default?: number;\n                }\n            > = [];\n\n            if (!options.title) {\n              questions.push({\n                type: 'input',\n                name: 'title',\n                message: 'Subtask title:',\n                validate: (input: string) => input.length > 0 || 'Title is required',\n              });\n            }\n\n            if (!options.description) {\n              questions.push({\n                type: 'input',\n                name: 'description',\n                message: 'Subtask description (optional):',\n              });\n            }\n\n            if (!options.priority) {\n              questions.push({\n                type: 'number',\n                name: 'priority',\n                message: 'Priority (1-10):',\n                default: 5,\n                validate: (input: number) =>\n                  (input >= 1 && input <= 10) || 'Priority must be between 1 and 10',\n              });\n            }\n\n            if (!options.due) {\n              questions.push({\n                type: 'input',\n                name: 'dueDate',\n                message: 'Due date (YYYY-MM-DD, optional):',\n                validate: (input: string) => {\n                  if (!input) return true;\n                  const date = new Date(input);\n                  return !Number.isNaN(date.getTime()) || 'Invalid date format';\n                },\n              });\n            }\n\n            const answers = await inquirer.prompt(questions);\n            subtaskData = { ...subtaskData, ...answers };\n          }\n\n          // Use command line options or answers\n          subtaskData.title = options.title ?? subtaskData.title;\n          subtaskData.description = options.description ?? subtaskData.description;\n          subtaskData.priority = parseInt(options.priority ?? String(subtaskData.priority), 10);\n\n          if (options.due ?? subtaskData.dueDate) {\n            subtaskData.dueDate = options.due ?? subtaskData.dueDate;\n          }\n\n          const subtask = await apiClient.createTask(subtaskData as any);\n          formatter.success(`Subtask created successfully: ${String((subtask as any).id)}`);\n          formatter.output(subtask);\n        } catch (error) {\n          formatter.error(\n            `Failed to create subtask: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  subtaskCmd\n    .command('list <parentId>')\n    .description('List subtasks for a parent task')\n    .option('--status <status>', 'filter by status')\n    .option('-l, --limit <number>', 'limit number of results', '20')\n    .action(async (parentId: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const params: Record<string, string> = {\n          parent: parentId,\n          limit: options.limit,\n        };\n\n        if (options.status) {\n          params.status = options.status;\n        }\n\n        const subtasks = (await apiClient.getTasks(params)) as any;\n\n        if (!subtasks || subtasks.length === 0) {\n          formatter.info(`No subtasks found for task ${String(parentId)}`);\n          return;\n        }\n\n        formatter.output(subtasks, {\n          fields: ['id', 'title', 'status', 'priority', 'dueDate', 'createdAt'],\n          headers: ['ID', 'Title', 'Status', 'Priority', 'Due Date', 'Created'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to list subtasks: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  // Dependency commands\n  const dependCmd = subtaskCmd\n    .command('depend')\n    .alias('dep')\n    .description('Manage task dependencies');\n\n  dependCmd\n    .command('add <taskId> <dependsOnId>')\n    .description('Add a dependency (taskId depends on dependsOnId)')\n    .action(async (taskId: string, dependsOnId: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        await apiClient.request<AnyApiResponse>(\n          'POST',\n          `/api/tasks/${String(taskId)}/dependencies`,\n          { dependsOn: dependsOnId }\n        );\n        formatter.success(`Task ${String(taskId)} now depends on task ${String(dependsOnId)}`);\n      } catch (error) {\n        formatter.error(\n          `Failed to add dependency: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dependCmd\n    .command('remove <taskId> <dependsOnId>')\n    .description('Remove a dependency')\n    .action(async (taskId: string, dependsOnId: string) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        await apiClient.request<AnyApiResponse>(\n          'DELETE',\n          `/api/tasks/${String(taskId)}/dependencies/${String(dependsOnId)}`\n        );\n        formatter.success(\n          `Removed dependency: task ${String(taskId)} no longer depends on task ${String(dependsOnId)}`\n        );\n      } catch (error) {\n        formatter.error(\n          `Failed to remove dependency: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dependCmd\n    .command('list <taskId>')\n    .description('List task dependencies')\n    .option('--blocked', 'show tasks blocked by this task')\n    .action(async (taskId: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (options.blocked) {\n          // Show tasks that are blocked by this task\n          const blockedTasks = (await apiClient.request<AnyApiResponse>(\n            'GET',\n            `/api/tasks/${String(taskId)}/blocking`\n          )) as any;\n\n          if (!blockedTasks || blockedTasks.length === 0) {\n            formatter.info(`No tasks are blocked by task ${String(taskId)}`);\n            return;\n          }\n\n          formatter.info(`Tasks blocked by ${String(taskId)}:`);\n          formatter.output(blockedTasks, {\n            fields: ['id', 'title', 'status', 'priority'],\n            headers: ['ID', 'Title', 'Status', 'Priority'],\n          });\n        } else {\n          // Show dependencies of this task\n          const dependencies = (await apiClient.request<AnyApiResponse>(\n            'GET',\n            `/api/tasks/${String(taskId)}/dependencies`\n          )) as any;\n\n          if (!dependencies || dependencies.length === 0) {\n            formatter.info(`Task ${String(taskId)} has no dependencies`);\n            return;\n          }\n\n          formatter.info(`Dependencies for task ${String(taskId)}:`);\n          formatter.output(dependencies, {\n            fields: ['id', 'title', 'status', 'priority'],\n            headers: ['ID', 'Title', 'Status', 'Priority'],\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to list dependencies: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  dependCmd\n    .command('visualize <taskId>')\n    .description('Visualize dependency graph for a task')\n    .option('--depth <number>', 'depth of dependency tree', '3')\n    .action(async (taskId: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const depth = parseInt(options.depth, 10);\n        const graph = (await apiClient.request<AnyApiResponse>(\n          'GET',\n          `/api/tasks/${String(taskId)}/dependency-graph`,\n          undefined,\n          { depth: depth.toString() }\n        )) as any;\n\n        if (!graph) {\n          formatter.info(`No dependency graph available for task ${String(taskId)}`);\n          return;\n        }\n\n        formatter.info(`Dependency graph for task ${String(taskId)}:`);\n\n        // Simple text-based visualization\n        const printNode = (node: any, indent = 0) => {\n          const prefix = '  '.repeat(indent) + (indent > 0 ? '‚îî‚îÄ ' : '');\n          const status = node.status === 'completed' ? '‚úì' : node.status === 'blocked' ? '‚ö†' : '‚óã';\n          logger.info(\n            `${String(prefix)}${String(status)} ${String(String(node.id))}: ${String(String(node.title))} (${String(String(node.status))})`\n          );\n\n          if (node.dependencies && node.dependencies.length > 0) {\n            node.dependencies.forEach((dep: any) => printNode(dep, indent + 1));\n          }\n        };\n\n        printNode(graph);\n      } catch (error) {\n        formatter.error(\n          `Failed to visualize dependencies: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/tags.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'CreateTagPromptResult' is defined but never used.",
        "line": 50,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 50,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'UpdateTagOptions' is defined but never used.",
        "line": 56,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 56,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'UpdateTagPromptResult' is defined but never used.",
        "line": 64,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 64,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'DeleteTagOptions' is defined but never used.",
        "line": 71,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 71,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ConfirmPromptResult' is defined but never used.",
        "line": 75,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 75,
        "endColumn": 30
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Replace `await¬∑apiClient.getTags(` with `(await¬∑apiClient.getTags()`",
        "line": 95,
        "column": 30,
        "nodeType": null,
        "messageId": "replace",
        "endLine": 95,
        "endColumn": 54,
        "fix": { "range": [1953, 1977], "text": "(await apiClient.getTags()" }
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'displayTagTree' was used before it was defined.",
        "line": 106,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 106,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 112,
        "column": 55,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 112,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2562, 2564], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 116,
        "column": 72,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 116,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2688, 2690], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Replace `await¬∑apiClient.getTag(id` with `(await¬∑apiClient.getTag(id)`",
        "line": 142,
        "column": 29,
        "nodeType": null,
        "messageId": "replace",
        "endLine": 142,
        "endColumn": 54,
        "fix": { "range": [3570, 3595], "text": "(await apiClient.getTag(id)" }
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 182,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 182,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5008, 5011], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5008, 5011], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 184,
        "column": 31,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 184,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [5049, 5051], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 185,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 207,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 202,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 202,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 208,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 208,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 220,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 220,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `CreateTagRequest`.",
        "line": 220,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 220,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 220,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 220,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6132, 6135], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6132, 6135], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 221,
        "column": 67,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 221,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 244,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 244,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 244,
        "column": 60,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 244,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6985, 6988], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6985, 6988], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 250,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 250,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7134, 7137], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7134, 7137], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .interactive on an `any` value.",
        "line": 252,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 252,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 253,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 276,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 258,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 258,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 258,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 258,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 264,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 264,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 264,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 264,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 270,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 270,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 270,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 270,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 271,
        "column": 15,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 271,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 277,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 277,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 280,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 280,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 280,
        "column": 29,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 280,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 280,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 280,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 280,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 280,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 281,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 281,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 281,
        "column": 36,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 281,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 281,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 281,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 281,
        "column": 66,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 281,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 282,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 282,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 282,
        "column": 30,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 282,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 282,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 282,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 282,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 282,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .parent on an `any` value.",
        "line": 283,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 283,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 283,
        "column": 31,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 283,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .parentId on an `any` value.",
        "line": 283,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 283,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .parent on an `any` value.",
        "line": 283,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 283,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{}`.",
        "line": 286,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 286,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 291,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 291,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `UpdateTagRequest`.",
        "line": 291,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 291,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 291,
        "column": 72,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 291,
        "endColumn": 75,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8541, 8544], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8541, 8544], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .force on an `any` value.",
        "line": 311,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 311,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 312,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 312,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 312,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 312,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9168, 9171], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9168, 9171], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 318,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 325,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 322,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 322,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 352,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 352,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 352,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 352,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10313, 10316], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10313, 10316], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .length on an `any` value.",
        "line": 354,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 354,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 359,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 359,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .slice on an `any` value.",
        "line": 359,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 359,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 359,
        "column": 49,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 359,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 359,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 359,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .force on an `any` value.",
        "line": 379,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 379,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 380,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 380,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 380,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 380,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11224, 11227], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11224, 11227], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 381,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 381,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 381,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 381,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11287, 11290], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11287, 11290], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 388,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 395,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 392,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 392,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 392,
        "column": 82,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 392,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 392,
        "column": 126,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 392,
        "endColumn": 130
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 416,
        "column": 9,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 416,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12271, 12274], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12271, 12274], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 417,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 417,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12289, 12292], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12289, 12292], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 423,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 423,
        "endColumn": 85
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 423,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 423,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 423,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 423,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 423,
        "column": 65,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 423,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 423,
        "column": 81,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 423,
        "endColumn": 85
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 425,
        "column": 88,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 425,
        "endColumn": 90
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 429,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 429,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12693, 12696], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12693, 12696], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .parentId on an `any` value.",
        "line": 429,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 429,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 429,
        "column": 68,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 429,
        "endColumn": 70
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 77,
    "fixableErrorCount": 2,
    "fixableWarningCount": 0,
    "source": "import type { Command } from 'commander';\nimport inquirer from 'inquirer';\nimport type { CliComponents } from '../types';\nimport type { OutputFormatter } from '../formatter';\nimport { logger } from '../../utils/logger';\n\ninterface ListTagOptions {\n  usage?: boolean;\n  tree?: boolean;\n  limit?: string;\n}\n\ninterface ShowTagOptions {\n  tasks?: boolean;\n  usage?: boolean;\n}\n\ninterface CreateTagOptions {\n  name?: string;\n  color?: string;\n  description?: string;\n  parent?: string;\n  interactive?: boolean;\n}\n\ninterface TagData {\n  id: string;\n  name: string;\n  color?: string;\n  description?: string;\n  parentId?: string;\n  taskCount?: number;\n  children?: TagData[];\n  createdAt?: string;\n  updatedAt?: string;\n}\n\ninterface TagsApiResponse {\n  data: TagData[];\n  success: boolean;\n  error?: string;\n}\n\ninterface TagApiResponse {\n  data: TagData;\n  success: boolean;\n  error?: string;\n}\n\ninterface CreateTagPromptResult {\n  name: string;\n  description?: string;\n  color?: string;\n}\n\ninterface UpdateTagOptions {\n  name?: string;\n  description?: string;\n  color?: string;\n  parent?: string;\n  interactive?: boolean;\n}\n\ninterface UpdateTagPromptResult {\n  name?: string;\n  description?: string;\n  color?: string;\n  parent?: string;\n}\n\ninterface DeleteTagOptions {\n  force?: boolean;\n}\n\ninterface ConfirmPromptResult {\n  confirm: boolean;\n}\n\nexport function registerTagCommands(program: Command): void {\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  const tagCmd = program.command('tags').alias('tag').description('Manage tags');\n\n  tagCmd\n    .command('list')\n    .alias('ls')\n    .description('List all tags')\n    .option('-u, --usage', 'show usage statistics')\n    .option('-t, --tree', 'show as tree structure')\n    .option('-l, --limit <number>', 'limit number of results', '50')\n    .action(async (options: ListTagOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const tagsResponse = await apiClient.getTags() as TagsApiResponse;\n        const tags = tagsResponse.data;\n\n        if (!tags || tags.length === 0) {\n          formatter.info('No tags found');\n          return;\n        }\n\n        if (options.tree) {\n          // Display as tree structure\n          const rootTags = tags.filter((tag: TagData) => !tag.parentId);\n          displayTagTree(rootTags, tags, formatter, 0);\n        } else {\n          // Display as list\n          const displayTags = options.usage\n            ? tags.map((tag: TagData) => ({\n                ...tag,\n                usage: `${String(String(tag.taskCount || 0))} tasks`,\n              }))\n            : tags;\n\n          formatter.output(displayTags.slice(0, parseInt(options.limit || '50', 10)), {\n            fields: options.usage\n              ? ['id', 'name', 'color', 'usage', 'description']\n              : ['id', 'name', 'color', 'description'],\n            headers: options.usage\n              ? ['ID', 'Name', 'Color', 'Usage', 'Description']\n              : ['ID', 'Name', 'Color', 'Description'],\n          });\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to list tags: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  tagCmd\n    .command('show <id>')\n    .description('Show tag details')\n    .option('-t, --tasks', 'show tasks with this tag')\n    .option('-u, --usage', 'show usage statistics')\n    .action(async (id: string, options: ShowTagOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const tagResponse = await apiClient.getTag(id) as TagApiResponse;\n        const tag = tagResponse.data;\n        if (!tag) {\n          formatter.error(`Tag ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        formatter.output(tag, {\n          fields: options.usage\n            ? ['id', 'name', 'color', 'description', 'taskCount', 'createdAt']\n            : ['id', 'name', 'color', 'description', 'createdAt'],\n          headers: options.usage\n            ? ['ID', 'Name', 'Color', 'Description', 'Task Count', 'Created']\n            : ['ID', 'Name', 'Color', 'Description', 'Created'],\n        });\n\n        if (options.tasks) {\n          // TODO: Implement task listing for tag\n          formatter.info('Task listing for tags not yet implemented');\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get tag: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  tagCmd\n    .command('create')\n    .alias('add')\n    .description('Create a new tag')\n    .option('-n, --name <name>', 'tag name')\n    .option('-d, --description <desc>', 'tag description')\n    .option('-c, --color <color>', 'tag color (hex code)')\n    .option('-p, --parent <parentId>', 'parent tag ID')\n    .option('-i, --interactive', 'interactive mode')\n    .action(async (options: CreateTagOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      let tagData: any = {};\n\n      if (options.interactive || !options.name) {\n        const answers = await inquirer.prompt([\n          {\n            type: 'input',\n            name: 'name',\n            message: 'Tag name:',\n            validate: (input: string) => input.length > 0 || 'Name is required',\n          },\n          {\n            type: 'input',\n            name: 'description',\n            message: 'Tag description:',\n          },\n          {\n            type: 'input',\n            name: 'color',\n            message: 'Tag color (hex code):',\n            default: '#007acc',\n            validate: (input: string) => {\n              if (!input) return true;\n              return /^#[0-9A-Fa-f]{6}$/.test(input) || 'Invalid hex color format (use #RRGGBB)';\n            },\n          },\n        ]);\n        tagData = answers;\n      } else {\n        // Use command line options\n        tagData = {\n          name: options.name,\n          description: options.description,\n          color: options.color,\n          parentId: options.parent,\n        };\n      }\n\n      try {\n        const tag = (await apiClient.createTag(tagData)) as any;\n        formatter.success(`Tag created successfully: ${String(tag.id)}`);\n        formatter.output(tag);\n      } catch (error) {\n        formatter.error(\n          `Failed to create tag: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  tagCmd\n    .command('update <id>')\n    .description('Update a tag')\n    .option('-n, --name <name>', 'tag name')\n    .option('-d, --description <desc>', 'tag description')\n    .option('-c, --color <color>', 'tag color (hex code)')\n    .option('-p, --parent <parentId>', 'parent tag ID')\n    .option('-i, --interactive', 'interactive mode')\n    .action(async (id: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        // Get current tag data\n        const currentTag = (await apiClient.getTag(id)) as any;\n        if (!currentTag) {\n          formatter.error(`Tag ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        let updates: any = {};\n\n        if (options.interactive) {\n          const answers = await inquirer.prompt([\n            {\n              type: 'input',\n              name: 'name',\n              message: 'Tag name:',\n              default: currentTag.name,\n            },\n            {\n              type: 'input',\n              name: 'description',\n              message: 'Tag description:',\n              default: currentTag.description || '',\n            },\n            {\n              type: 'input',\n              name: 'color',\n              message: 'Tag color (hex code):',\n              default: currentTag.color || '#007acc',\n              validate: (input: string) => {\n                if (!input) return true;\n                return /^#[0-9A-Fa-f]{6}$/.test(input) || 'Invalid hex color format (use #RRGGBB)';\n              },\n            },\n          ]);\n          updates = answers;\n        } else {\n          // Use command line options\n          if (options.name) updates.name = options.name;\n          if (options.description) updates.description = options.description;\n          if (options.color) updates.color = options.color;\n          if (options.parent) updates.parentId = options.parent;\n        }\n\n        if (Object.keys(updates).length === 0) {\n          formatter.warn('No updates specified');\n          return;\n        }\n\n        const updatedTag = (await apiClient.updateTag(id, updates)) as any;\n        formatter.success('Tag updated successfully');\n        formatter.output(updatedTag);\n      } catch (error) {\n        formatter.error(\n          `Failed to update tag: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  tagCmd\n    .command('delete <id>')\n    .alias('rm')\n    .description('Delete a tag')\n    .option('-f, --force', 'skip confirmation')\n    .action(async (id: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          const tag = (await apiClient.getTag(id)) as any;\n          if (!tag) {\n            formatter.error(`Tag ${String(id)} not found`);\n            process.exit(1);\n          }\n\n          const { confirm } = await inquirer.prompt([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: `Delete tag \"${String(tag.name)}\"?`,\n              default: false,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Delete cancelled');\n            return;\n          }\n        }\n\n        await apiClient.deleteTag(id);\n        formatter.success(`Tag ${String(id)} deleted successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to delete tag: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  tagCmd\n    .command('search <query>')\n    .alias('find')\n    .description('Search tags by name')\n    .option('-l, --limit <number>', 'limit number of results', '10')\n    .action(async (query: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const tags = (await apiClient.searchTags(query)) as any;\n\n        if (!tags || tags.length === 0) {\n          formatter.info(`No tags found matching \"${String(query)}\"`);\n          return;\n        }\n\n        formatter.output(tags.slice(0, parseInt(options.limit, 10)), {\n          fields: ['id', 'name', 'color', 'description'],\n          headers: ['ID', 'Name', 'Color', 'Description'],\n        });\n      } catch (error) {\n        formatter.error(\n          `Failed to search tags: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  tagCmd\n    .command('merge <fromId> <toId>')\n    .description('Merge one tag into another')\n    .option('-f, --force', 'skip confirmation')\n    .action(async (fromId: string, toId: string, options) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          const fromTag = (await apiClient.getTag(fromId)) as any;\n          const toTag = (await apiClient.getTag(toId)) as any;\n\n          if (!fromTag || !toTag) {\n            formatter.error('One or both tags not found');\n            process.exit(1);\n          }\n\n          const { confirm } = await inquirer.prompt([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: `Merge tag \"${String(fromTag.name)}\" into \"${String(toTag.name)}\"? This will delete \"${String(fromTag.name)}\".`,\n              default: false,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Merge cancelled');\n            return;\n          }\n        }\n\n        await apiClient.mergeTags(fromId, toId);\n        formatter.success(`Merged tag ${String(fromId)} into ${String(toId)}`);\n      } catch (error) {\n        formatter.error(\n          `Failed to merge tags: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n}\n\n// Helper function to display tag tree\nfunction displayTagTree(\n  tags: any[],\n  allTags: any[],\n  formatter: OutputFormatter,\n  depth: number\n): void {\n  tags.forEach(tag => {\n    const indent = '  '.repeat(depth);\n    const name = tag.color ? `${String(tag.name)} (${String(tag.color)})` : tag.name;\n    logger.info(\n      `${String(indent)}${String(depth > 0 ? '‚îî‚îÄ ' : '')}${String(name)} (${String(tag.id)})`\n    );\n\n    // Find and display children\n    const children = allTags.filter((t: any) => t.parentId === tag.id);\n    if (children.length > 0) {\n      displayTagTree(children, allTags, formatter, depth + 1);\n    }\n  });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/commands/tasks.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-redeclare",
        "severity": 2,
        "message": "'Task' is already defined.",
        "line": 85,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "redeclared",
        "endLine": 85,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'MoveTaskPromptResult' is defined but never used.",
        "line": 113,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 113,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'formatter' is assigned a value but never used.",
        "line": 350,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 350,
        "endColumn": 43
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 450,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 450,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [13912, 13946], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 451,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 451,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [13957, 14005], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 452,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 452,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [14016, 14066], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 453,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 453,
        "endColumn": 50
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 454,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 454,
        "endColumn": 50
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 455,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 455,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 754,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 757,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 754,
        "column": 29,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 754,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .withSpinner on an `any` value.",
        "line": 754,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 754,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 783,
        "column": 44,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 783,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 789,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 789,
        "endColumn": 57
      },
      {
        "ruleId": "default-case",
        "severity": 2,
        "message": "Expected a default case.",
        "line": 818,
        "column": 13,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 873,
        "endColumn": 14
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 820,
        "column": 17,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 820,
        "endColumn": 70
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 831,
        "column": 17,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 838,
        "endColumn": 20
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 843,
        "column": 17,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 850,
        "endColumn": 20
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 855,
        "column": 17,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 862,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 880,
        "column": 82,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 880,
        "endColumn": 84
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 884,
        "column": 17,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 890,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 896,
        "column": 94,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 896,
        "endColumn": 96,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [30203, 30205], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 961,
        "column": 15,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 961,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"priority\"] is better written in dot notation.",
        "line": 388,
        "column": 24,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 388,
        "endColumn": 34,
        "fix": { "range": [11316, 11328], "text": ".priority" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"title\"] is better written in dot notation.",
        "line": 401,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 401,
        "endColumn": 25,
        "fix": { "range": [11722, 11731], "text": ".title" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"title\"] is better written in dot notation.",
        "line": 401,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 401,
        "endColumn": 62,
        "fix": { "range": [11759, 11768], "text": ".title" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"description\"] is better written in dot notation.",
        "line": 403,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 403,
        "endColumn": 31,
        "fix": { "range": [11835, 11850], "text": ".description" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"description\"] is better written in dot notation.",
        "line": 403,
        "column": 67,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 403,
        "endColumn": 80,
        "fix": { "range": [11884, 11899], "text": ".description" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"boardId\"] is better written in dot notation.",
        "line": 405,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 405,
        "endColumn": 27,
        "fix": { "range": [11966, 11977], "text": ".boardId" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"board\"] is better written in dot notation.",
        "line": 405,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 405,
        "endColumn": 64,
        "fix": { "range": [12005, 12014], "text": ".board" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"columnId\"] is better written in dot notation.",
        "line": 407,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 407,
        "endColumn": 28,
        "fix": { "range": [12109, 12121], "text": ".columnId" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"column\"] is better written in dot notation.",
        "line": 407,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 407,
        "endColumn": 67,
        "fix": { "range": [12150, 12160], "text": ".column" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"priority\"] is better written in dot notation.",
        "line": 409,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 409,
        "endColumn": 28,
        "fix": { "range": [12227, 12239], "text": ".priority" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"priority\"] is better written in dot notation.",
        "line": 409,
        "column": 77,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 409,
        "endColumn": 87,
        "fix": { "range": [12286, 12298], "text": ".priority" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"dueDate\"] is better written in dot notation.",
        "line": 412,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 412,
        "endColumn": 46,
        "fix": { "range": [12397, 12408], "text": ".dueDate" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"dueDate\"] is better written in dot notation.",
        "line": 414,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 414,
        "endColumn": 29,
        "fix": { "range": [12481, 12492], "text": ".dueDate" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"dueDate\"] is better written in dot notation.",
        "line": 414,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 414,
        "endColumn": 66,
        "fix": { "range": [12518, 12529], "text": ".dueDate" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"tags\"] is better written in dot notation.",
        "line": 418,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 418,
        "endColumn": 44,
        "fix": { "range": [12627, 12635], "text": ".tags" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"tags\"] is better written in dot notation.",
        "line": 420,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 420,
        "endColumn": 65,
        "fix": { "range": [12747, 12755], "text": ".tags" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"tags\"] is better written in dot notation.",
        "line": 422,
        "column": 20,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 422,
        "endColumn": 26,
        "fix": { "range": [12833, 12841], "text": ".tags" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"boardId\"] is better written in dot notation.",
        "line": 426,
        "column": 23,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 426,
        "endColumn": 32,
        "fix": { "range": [12978, 12989], "text": ".boardId" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"title\"] is better written in dot notation.",
        "line": 554,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 554,
        "endColumn": 45,
        "fix": { "range": [17706, 17715], "text": ".title" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"description\"] is better written in dot notation.",
        "line": 556,
        "column": 44,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 556,
        "endColumn": 57,
        "fix": { "range": [17826, 17841], "text": ".description" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"status\"] is better written in dot notation.",
        "line": 558,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 558,
        "endColumn": 47,
        "fix": { "range": [17953, 17963], "text": ".status" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"priority\"] is better written in dot notation.",
        "line": 560,
        "column": 41,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 560,
        "endColumn": 51,
        "fix": { "range": [18072, 18084], "text": ".priority" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"dueDate\"] is better written in dot notation.",
        "line": 562,
        "column": 36,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 562,
        "endColumn": 45,
        "fix": { "range": [18204, 18215], "text": ".dueDate" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"board\"] is better written in dot notation.",
        "line": 741,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 741,
        "endColumn": 28,
        "fix": { "range": [23760, 23769], "text": ".board" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"board\"] is better written in dot notation.",
        "line": 741,
        "column": 38,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 741,
        "endColumn": 45,
        "fix": { "range": [23777, 23786], "text": ".board" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"board\"] is better written in dot notation.",
        "line": 741,
        "column": 57,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 741,
        "endColumn": 64,
        "fix": { "range": [23796, 23805], "text": ".board" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"status\"] is better written in dot notation.",
        "line": 743,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 743,
        "endColumn": 29,
        "fix": { "range": [23875, 23885], "text": ".status" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"status\"] is better written in dot notation.",
        "line": 743,
        "column": 39,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 743,
        "endColumn": 47,
        "fix": { "range": [23893, 23903], "text": ".status" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"status\"] is better written in dot notation.",
        "line": 743,
        "column": 59,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 743,
        "endColumn": 67,
        "fix": { "range": [23913, 23923], "text": ".status" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"tags\"] is better written in dot notation.",
        "line": 745,
        "column": 21,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 745,
        "endColumn": 27,
        "fix": { "range": [23993, 24001], "text": ".tags" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"tags\"] is better written in dot notation.",
        "line": 745,
        "column": 37,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 745,
        "endColumn": 43,
        "fix": { "range": [24009, 24017], "text": ".tags" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"tags\"] is better written in dot notation.",
        "line": 745,
        "column": 55,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 745,
        "endColumn": 61,
        "fix": { "range": [24027, 24035], "text": ".tags" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"board\"] is better written in dot notation.",
        "line": 749,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 749,
        "endColumn": 29,
        "fix": { "range": [24158, 24167], "text": ".board" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "dot-notation",
        "severity": 2,
        "message": "[\"board\"] is better written in dot notation.",
        "line": 751,
        "column": 18,
        "nodeType": "Literal",
        "messageId": "useDot",
        "endLine": 751,
        "endColumn": 25,
        "fix": { "range": [24266, 24275], "text": ".board" },
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 8,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @module cli/commands/tasks\n * @description Task management commands for the CLI.\n *\n * Provides comprehensive task operations including creating, updating, listing,\n * moving, and deleting tasks. Supports both command-line options and interactive\n * mode for user-friendly task management.\n *\n * @example\n * ```bash\n * # List all tasks\n * kanban task list\n *\n * # List tasks with filters\n * kanban task list --board abc123 --status in_progress --limit 10\n *\n * # Create a task interactively\n * kanban task create --interactive\n *\n * # Create a task with options\n * kanban task create --title \"Fix bug\" --priority 8 --tags \"bug,urgent\"\n *\n * # Update task status\n * kanban task update task123 --status completed\n *\n * # Interactive task selection\n * kanban task select --status todo\n * ```\n */\n\nimport type { Command } from 'commander';\nimport inquirer from 'inquirer';\n\nimport type { CliComponents, CreateTaskRequest } from '../types';\nimport type { Task } from '../../types';\nimport { createTaskPrompt, PromptCancelledError } from '../prompts/task-prompts';\nimport { SpinnerManager } from '../utils/spinner';\nimport { isSuccessResponse } from '../api-client-wrapper';\n\ninterface ShowTaskOptions {\n  context?: boolean;\n}\n\ninterface CreateTaskOptions {\n  interactive?: boolean;\n  title?: string;\n  description?: string;\n  due?: string;\n  tags?: string;\n  priority?: string;\n  column?: string;\n  board?: string;\n}\n\ninterface UpdateTaskOptions {\n  title?: string;\n  description?: string;\n  status?: string;\n  priority?: string;\n  assignee?: string;\n  due?: string;\n  tags?: string;\n  interactive?: boolean;\n}\n\ninterface MoveTaskOptions {\n  column?: string;\n  position?: string;\n  interactive?: boolean;\n}\n\ninterface DeleteTaskOptions {\n  force?: boolean;\n}\n\ninterface SelectTaskOptions {\n  board?: string;\n  status?: string;\n  tags?: string;\n  limit?: string;\n  sort?: string;\n  order?: string;\n}\n\ninterface Task {\n  id: string;\n  title: string;\n  description?: string;\n  status: string;\n  priority?: string | number;\n  assignee?: string;\n  tags?: string[];\n  due_date?: string;\n  created_at?: string;\n  updated_at?: string;\n}\n\ninterface TaskListResponse {\n  data: Task[];\n  total?: number;\n}\n\ninterface UpdateTaskPromptResult {\n  title?: string;\n  description?: string;\n  status?: string;\n  priority?: string;\n  assignee?: string;\n  due_date?: string;\n  tags?: string;\n}\n\ninterface MoveTaskPromptResult {\n  column?: string;\n  position?: string;\n}\n\ninterface ConfirmPromptResult {\n  confirm: boolean;\n}\n\ninterface ActionPromptResult {\n  action: string;\n}\n\ninterface ColumnPromptResult {\n  columnId: string;\n}\n\ninterface StatusPromptResult {\n  newStatus: string;\n}\n\ninterface QueryPromptResult {\n  query: string;\n}\n\n/**\n * Register all task-related commands with the CLI program.\n *\n * @param program - The commander program instance\n *\n * Available commands:\n * - `list` (alias: `ls`) - List tasks with filtering and sorting\n * - `show <id>` - Display detailed task information\n * - `create` (alias: `new`) - Create a new task\n * - `update <id>` - Update task properties\n * - `delete <id>` (alias: `rm`) - Delete a task\n * - `move <id> <column>` - Move task to different column\n * - `select` (alias: `choose`) - Interactive task selection\n */\nexport function registerTaskCommands(program: Command): void {\n  const taskCmd = program.command('task').alias('t').description('Manage tasks');\n\n  // Get global components with proper typing\n  const getComponents = (): CliComponents => global.cliComponents;\n\n  /**\n   * List tasks with optional filters and sorting.\n   *\n   * @command list\n   * @alias ls\n   *\n   * @option -b, --board <id> - Filter by board ID\n   * @option -s, --status <status> - Filter by status (todo, in_progress, completed, blocked)\n   * @option -t, --tags <tags> - Filter by tags (comma-separated)\n   * @option -l, --limit <number> - Limit number of results (default: 20)\n   * @option --sort <field> - Sort by field: priority, created_at, updated_at, due_date (default: priority)\n   * @option --order <direction> - Sort order: asc or desc (default: desc)\n   *\n   * @example\n   * ```bash\n   * # List all tasks in default board\n   * kanban task list\n   *\n   * # List in-progress tasks with high priority\n   * kanban task list --status in_progress --sort priority --order desc\n   *\n   * # List tasks with specific tags\n   * kanban task list --tags \"bug,urgent\" --limit 50\n   * ```\n   */\n  taskCmd\n    .command('list')\n    .alias('ls')\n    .description('List tasks')\n    .option('-b, --board <board>', 'filter by board')\n    .option('-s, --status <status>', 'filter by status')\n    .option('-t, --tags <tags>', 'filter by tags (comma-separated)')\n    .option('-l, --limit <limit>', 'limit number of results')\n    .option('--sort <field>', 'sort by field')\n    .option('--order <order>', 'sort order (asc/desc)')\n    .action(\n      async (options: {\n        board?: string;\n        status?: string;\n        tags?: string;\n        limit?: string;\n        sort?: string;\n        order?: string;\n      }) => {\n        const { config, apiClient, formatter } = getComponents();\n\n        try {\n          const params: Record<string, string> = {\n            limit: options.limit ?? '20',\n            sort: options.sort ?? 'createdAt',\n            order: options.order ?? 'desc',\n          };\n\n          if (options.board) params.board = options.board;\n          if (options.status) params.status = options.status;\n          if (options.tags) params.tags = options.tags;\n\n          // Use default board if no board specified\n          if (!options.board && config.getDefaultBoard()) {\n            params.board = config.getDefaultBoard()!;\n          }\n\n          const tasks = await apiClient.getTasks(params);\n\n          if (\n            !tasks ||\n            !('data' in tasks) ||\n            !tasks.data ||\n            (Array.isArray(tasks.data) && tasks.data.length === 0)\n          ) {\n            formatter.info('No tasks found');\n            return;\n          }\n\n          formatter.output(tasks, {\n            fields: ['id', 'title', 'status', 'priority', 'dueDate', 'createdAt'],\n            headers: ['ID', 'Title', 'Status', 'Priority', 'Due Date', 'Created'],\n          });\n        } catch (error) {\n          formatter.error(\n            `Failed to list tasks: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n          process.exit(1);\n        }\n      }\n    );\n\n  /**\n   * Show detailed information about a specific task.\n   *\n   * @command show <id>\n   *\n   * @param id - The task ID to display\n   * @option --context - Include AI-generated context and insights\n   *\n   * @example\n   * ```bash\n   * # Show basic task details\n   * kanban task show task123\n   *\n   * # Show task with AI context\n   * kanban task show task123 --context\n   * ```\n   *\n   * Output includes:\n   * - Task title, description, and status\n   * - Priority, assignee, and tags\n   * - Creation and update timestamps\n   * - Due date and completion status\n   * - AI context (if requested): related tasks, insights, suggestions\n   */\n  taskCmd\n    .command('show <id>')\n    .description('Show task details')\n    .option('--context', 'include AI context')\n    .action(async (id: string, options: ShowTaskOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const task = await apiClient.getTask(id);\n\n        if (!task) {\n          formatter.error(`Task ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        formatter.output(task);\n\n        if (options.context) {\n          formatter.info('Getting AI context...');\n          try {\n            const context = await apiClient.getTaskContext(id);\n            formatter.info('\\n--- AI Context ---');\n            formatter.output(context);\n          } catch (error) {\n            formatter.warn('Could not retrieve AI context');\n          }\n        }\n      } catch (error) {\n        formatter.error(\n          `Failed to get task: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Create a new task with optional AI-powered size estimation.\n   *\n   * @command create\n   * @alias new\n   *\n   * @option -t, --title <title> - Task title (required in non-interactive mode)\n   * @option -d, --description <desc> - Detailed task description\n   * @option -b, --board <id> - Board ID (uses default if not specified)\n   * @option -c, --column <id> - Column ID to place task in\n   * @option -p, --priority <number> - Priority level 1-10 (default: 5)\n   * @option --due <date> - Due date in YYYY-MM-DD format\n   * @option --tags <tags> - Comma-separated list of tags\n   * @option -i, --interactive - Use interactive prompts with AI assistance\n   *\n   * @example\n   * ```bash\n   * # Create task with command line options\n   * kanban task create --title \"Implement login\" --priority 8 --due 2024-12-31\n   *\n   * # Create task interactively (recommended)\n   * kanban task create --interactive\n   *\n   * # Create task with tags\n   * kanban task create -t \"Fix memory leak\" --tags \"bug,performance,critical\"\n   * ```\n   *\n   * Interactive mode features:\n   * - AI-powered task size estimation\n   * - Smart priority suggestions\n   * - Guided prompts for all fields\n   * - Input validation and defaults\n   */\n  taskCmd\n    .command('create')\n    .alias('new')\n    .description('Create a new task')\n    .option('-t, --title <title>', 'task title')\n    .option('-d, --description <desc>', 'task description')\n    .option('-b, --board <id>', 'board ID')\n    .option('-c, --column <id>', 'column ID')\n    .option('-p, --priority <number>', 'priority (1-10)', '5')\n    .option('--due <date>', 'due date (YYYY-MM-DD)')\n    .option('--tags <tags>', 'tags (comma-separated)')\n    .option('-i, --interactive', 'interactive mode')\n    .action(async (options: CreateTaskOptions) => {\n      const { config, apiClient, formatter } = getComponents();\n      const spinner = new SpinnerManager();\n\n      try {\n        spinner.start('Initializing...');\n\n        let taskData: Record<string, unknown> = {};\n\n        if (options.interactive ?? !options.title) {\n          // Enhanced interactive mode with AI size estimation\n          spinner.info('Starting interactive task creation...');\n\n          try {\n            const defaults = {\n              title: options.title ?? '',\n              description: options.description ?? '',\n              due_date: options.due ?? '',\n              tags: options.tags ? options.tags.split(',').map((t: string) => t.trim()) : [],\n            };\n\n            const promptResult = await createTaskPrompt(defaults);\n\n            // Map prompt result to task data\n            taskData = {\n              title: promptResult.title,\n              description: promptResult.description,\n              priority: promptResult.priority,\n              size: promptResult.size,\n              assignee: promptResult.assignee,\n              dueDate: promptResult.due_date,\n              estimatedHours: promptResult.estimated_hours,\n              tags: promptResult.tags,\n            };\n\n            // Convert priority from P1-P5 to 1-10 scale\n            if (promptResult.priority) {\n              const priorityMap = { P1: 10, P2: 8, P3: 5, P4: 3, P5: 1 };\n              // eslint-disable-next-line dot-notation\n              taskData['priority'] = priorityMap[promptResult.priority] ?? 5;\n            }\n          } catch (error) {\n            if (error instanceof PromptCancelledError) {\n              spinner.info('Task creation cancelled');\n              return;\n            }\n            throw error;\n          }\n        }\n\n        // Use command line options or answers\n        // eslint-disable-next-line dot-notation\n        taskData['title'] = options.title ?? taskData['title'];\n        // eslint-disable-next-line dot-notation\n        taskData['description'] = options.description ?? taskData['description'];\n        // eslint-disable-next-line dot-notation\n        taskData['boardId'] = options.board ?? taskData['board'] ?? config.getDefaultBoard();\n        // eslint-disable-next-line dot-notation\n        taskData['columnId'] = options.column ?? taskData['column'];\n        // eslint-disable-next-line dot-notation\n        taskData['priority'] = parseInt(options.priority ?? String(taskData['priority'] ?? ''), 10);\n\n        // eslint-disable-next-line dot-notation\n        if (options.due ?? taskData['dueDate']) {\n          // eslint-disable-next-line dot-notation\n          taskData['dueDate'] = options.due ?? taskData['dueDate'];\n        }\n\n        // eslint-disable-next-line dot-notation\n        if (options.tags ?? taskData['tags']) {\n          // eslint-disable-next-line dot-notation\n          const tagsStr = options.tags ?? String(taskData['tags'] ?? '');\n          // eslint-disable-next-line dot-notation\n          taskData['tags'] = tagsStr.split(',').map((tag: string) => tag.trim());\n        }\n\n        // eslint-disable-next-line dot-notation\n        if (!taskData['boardId']) {\n          spinner.fail(\n            'Board ID is required. Set default board with \"kanban config set defaults.board <id>\"'\n          );\n          process.exit(1);\n        }\n\n        const createTaskRequest: CreateTaskRequest = {\n          title: String(taskData.title),\n          description: taskData.description as string,\n          board_id: String(taskData.boardId),\n          column_id: taskData.columnId as string,\n          priority: taskData.priority as number,\n          status: 'todo',\n          assignee: taskData.assignee as string,\n          due_date: taskData.dueDate as string,\n          tags: taskData.tags as string[],\n        };\n\n        spinner.start(`Creating task: ${createTaskRequest.title}`);\n        const response = await apiClient.createTask(createTaskRequest);\n\n        if (isSuccessResponse(response)) {\n          spinner.succeed(`Task created successfully: ${response.data.id}`);\n          console.log('\\nüìã Task Details:');\n          console.log(`   Title: ${response.data.title}`);\n          console.log(`   Status: ${response.data.status}`);\n          if (response.data.priority) console.log(`   Priority: ${response.data.priority}`);\n          if (response.data.assignee) console.log(`   Assignee: ${response.data.assignee}`);\n          if (response.data.due_date) console.log(`   Due: ${response.data.due_date}`);\n        } else {\n          spinner.fail(`Failed to create task: ${response.error?.message ?? 'Unknown error'}`);\n          process.exit(1);\n        }\n      } catch (error) {\n        spinner.fail(\n          `Failed to create task: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Update properties of an existing task.\n   *\n   * @command update <id>\n   *\n   * @param id - The task ID to update\n   * @option -t, --title <title> - New task title\n   * @option -d, --description <desc> - New task description\n   * @option -s, --status <status> - New status (todo, in_progress, completed, blocked)\n   * @option -p, --priority <number> - New priority (1-10)\n   * @option --due <date> - New due date (YYYY-MM-DD)\n   * @option -i, --interactive - Use interactive mode to update multiple fields\n   *\n   * @example\n   * ```bash\n   * # Update task status\n   * kanban task update task123 --status completed\n   *\n   * # Update multiple properties\n   * kanban task update task123 --title \"Updated title\" --priority 9\n   *\n   * # Interactive update (shows current values)\n   * kanban task update task123 --interactive\n   * ```\n   */\n  taskCmd\n    .command('update <id>')\n    .description('Update a task')\n    .option('-t, --title <title>', 'task title')\n    .option('-d, --description <desc>', 'task description')\n    .option('-s, --status <status>', 'task status')\n    .option('-p, --priority <number>', 'priority (1-10)')\n    .option('--due <date>', 'due date (YYYY-MM-DD)')\n    .option('-i, --interactive', 'interactive mode')\n    .action(async (id: string, options: UpdateTaskOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        // Get current task data\n        const currentTaskResponse = await apiClient.getTask(id);\n        if (\n          !currentTaskResponse ??\n          (!('data' in currentTaskResponse) || !currentTaskResponse.data)\n        ) {\n          formatter.error(`Task ${String(id)} not found`);\n          process.exit(1);\n        }\n\n        const currentTask = currentTaskResponse.data as Task;\n\n        let updates: Record<string, unknown> = {};\n\n        if (options.interactive) {\n          const answers = await inquirer.prompt<UpdateTaskPromptResult>([\n            {\n              type: 'input',\n              name: 'title',\n              message: 'Task title:',\n              default: currentTask.title,\n            },\n            {\n              type: 'input',\n              name: 'description',\n              message: 'Task description:',\n              default: currentTask.description ?? '',\n            },\n            {\n              type: 'list',\n              name: 'status',\n              message: 'Status:',\n              choices: ['todo', 'in_progress', 'completed', 'blocked'],\n              default: currentTask.status,\n            },\n            {\n              type: 'number',\n              name: 'priority',\n              message: 'Priority (1-10):',\n              default: currentTask.priority ?? 5,\n              validate: (input: number) =>\n                (input >= 1 && input <= 10) || 'Priority must be between 1 and 10',\n            },\n          ]);\n          updates = answers;\n        } else {\n          // Use command line options\n          // eslint-disable-next-line dot-notation\n          if (options.title) updates['title'] = options.title;\n          // eslint-disable-next-line dot-notation\n          if (options.description) updates['description'] = options.description;\n          // eslint-disable-next-line dot-notation\n          if (options.status) updates['status'] = options.status;\n          // eslint-disable-next-line dot-notation\n          if (options.priority) updates['priority'] = parseInt(options.priority, 10);\n          // eslint-disable-next-line dot-notation\n          if (options.due) updates['dueDate'] = options.due;\n        }\n\n        if (Object.keys(updates).length === 0) {\n          formatter.warn('No updates specified');\n          return;\n        }\n\n        const updatedTask = await apiClient.updateTask(id, updates);\n        formatter.success('Task updated successfully');\n        formatter.output(updatedTask);\n      } catch (error) {\n        formatter.error(\n          `Failed to update task: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Delete a task permanently.\n   *\n   * @command delete <id>\n   * @alias rm\n   *\n   * @param id - The task ID to delete\n   * @option -f, --force - Skip confirmation prompt\n   *\n   * @example\n   * ```bash\n   * # Delete with confirmation\n   * kanban task delete task123\n   *\n   * # Delete without confirmation\n   * kanban task delete task123 --force\n   * ```\n   *\n   * @warning This action cannot be undone. The task and all its associated\n   * data (notes, tags, dependencies) will be permanently removed.\n   */\n  taskCmd\n    .command('delete <id>')\n    .alias('rm')\n    .description('Delete a task')\n    .option('-f, --force', 'skip confirmation')\n    .action(async (id: string, options: DeleteTaskOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        if (!options.force) {\n          const response = await apiClient.getTask(id);\n          if (!isSuccessResponse(response) || !response.data) {\n            formatter.error(`Task ${String(id)} not found`);\n            process.exit(1);\n          }\n\n          const task = response.data as Task;\n          const { confirm } = await inquirer.prompt<ConfirmPromptResult>([\n            {\n              type: 'confirm',\n              name: 'confirm',\n              message: `Delete task \"${String(String(task.title))}\"?`,\n              default: false,\n            },\n          ]);\n\n          if (!confirm) {\n            formatter.info('Delete cancelled');\n            return;\n          }\n        }\n\n        await apiClient.deleteTask(id);\n        formatter.success(`Task ${String(id)} deleted successfully`);\n      } catch (error) {\n        formatter.error(\n          `Failed to delete task: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Move a task to a different column within the board.\n   *\n   * @command move <id> <column>\n   *\n   * @param id - The task ID to move\n   * @param column - The target column ID\n   * @option -p, --position <number> - Position within the column (0-based index)\n   *\n   * @example\n   * ```bash\n   * # Move task to \"In Progress\" column\n   * kanban task move task123 column456\n   *\n   * # Move task to specific position in column\n   * kanban task move task123 column456 --position 0\n   * ```\n   */\n  taskCmd\n    .command('move <id> <column>')\n    .description('Move task to different column')\n    .option('-p, --position <number>', 'position in column')\n    .action(async (id: string, columnId: string, options: MoveTaskOptions) => {\n      const { apiClient, formatter } = getComponents();\n\n      try {\n        const position = options.position ? parseInt(options.position, 10) : undefined;\n        await apiClient.moveTask(id, columnId, position);\n        formatter.success(`Task ${String(id)} moved to column ${String(columnId)}`);\n      } catch (error) {\n        formatter.error(\n          `Failed to move task: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n\n  /**\n   * Interactive task selection with keyboard navigation.\n   *\n   * @command select\n   * @alias choose\n   *\n   * @option -b, --board <id> - Filter by board ID\n   * @option -s, --status <status> - Filter by status\n   * @option -t, --tags <tags> - Filter by tags (comma-separated)\n   * @option --limit <number> - Maximum tasks to display (default: 50)\n   * @option --sort <field> - Sort field (default: priority)\n   * @option --order <direction> - Sort order: asc/desc (default: desc)\n   *\n   * @example\n   * ```bash\n   * # Select from all tasks\n   * kanban task select\n   *\n   * # Select from filtered tasks\n   * kanban task select --status todo --tags urgent\n   * ```\n   *\n   * Keyboard shortcuts:\n   * - ‚Üë/‚Üì or j/k: Navigate tasks\n   * - Enter: Select task for action\n   * - /: Search tasks\n   * - r: Refresh task list\n   * - h/l or ‚Üê/‚Üí: Filter by status\n   * - ?: Show help\n   * - q: Exit\n   *\n   * Available actions after selection:\n   * - View details\n   * - Edit task\n   * - Move to column\n   * - Update status\n   * - Delete task\n   */\n  taskCmd\n    .command('select')\n    .alias('choose')\n    .description('Interactive task selection and management')\n    .option('-b, --board <id>', 'filter by board ID')\n    .option('-s, --status <status>', 'filter by status')\n    .option('-t, --tags <tags>', 'filter by tags (comma-separated)')\n    .option('--limit <number>', 'limit number of results', '50')\n    .option('--sort <field>', 'sort by field', 'priority')\n    .option('--order <direction>', 'sort order (asc/desc)', 'desc')\n    .action(async (options: SelectTaskOptions) => {\n      const { config, apiClient, formatter } = getComponents();\n\n      try {\n        // Fetch tasks with spinner\n        const params: Record<string, string> = {\n          limit: options.limit ?? '50',\n          sort: options.sort ?? 'priority',\n          order: options.order ?? 'desc',\n        };\n\n        // eslint-disable-next-line dot-notation\n        if (options['board']) params['board'] = options['board'];\n        // eslint-disable-next-line dot-notation\n        if (options['status']) params['status'] = options['status'];\n        // eslint-disable-next-line dot-notation\n        if (options['tags']) params['tags'] = options['tags'];\n\n        // Use default board if no board specified\n        // eslint-disable-next-line dot-notation\n        if (!options['board'] && config.getDefaultBoard()) {\n          // eslint-disable-next-line dot-notation\n          params['board'] = config.getDefaultBoard()!;\n        }\n\n        const tasks = await spinner.withSpinner('Loading tasks...', apiClient.getTasks(params), {\n          successText: 'Tasks loaded successfully',\n          failText: 'Failed to load tasks',\n        });\n\n        const taskResponse = tasks as TaskListResponse;\n        if (!taskResponse.data ?? taskResponse.data.length === 0) {\n          formatter.info('No tasks found');\n          return;\n        }\n\n        // Start interactive task selection\n        const React = await import('react');\n        const { render } = await import('ink');\n        const TaskList = (await import('../ui/components/TaskList')).default;\n\n        // Transform API tasks to component format\n        const taskList: Task[] = taskResponse.data.map((task: Task) => ({\n          id: task.id,\n          title: task.title,\n          status: task.status,\n          priority: task.priority,\n          assignee: task.assignee,\n          tags: task.tags,\n          due_date: task.due_date,\n        }));\n\n        let shouldExit = false;\n\n        const InteractiveTaskSelector = () => {\n          const [currentTasks, setCurrentTasks] = React.useState(taskList);\n          const [statusFilter, setStatusFilter] = React.useState<string[]>([]);\n          const [, setSearchMode] = React.useState(false);\n          const [searchQuery, setSearchQuery] = React.useState('');\n\n          const handleTaskSelect = async (task: Task) => {\n            formatter.info(\n              `\\n‚úÖ Selected: ${String(String(task.title))} [${String(String(task.id))}]`\n            );\n            formatter.info(`   Status: ${String(String(task.status))}`);\n            formatter.info(`   Priority: ${String(String(task.priority ?? 'None'))}`);\n            if (task.assignee) formatter.info(`   Assignee: ${String(String(task.assignee))}`);\n            if (task.tags?.length)\n              formatter.info(`   Tags: ${String(String(task.tags.join(', ')))}`);\n            if (task.due_date) formatter.info(`   Due: ${String(String(task.due_date))}`);\n\n            // Ask what to do with selected task\n            const { action } = await inquirer.prompt<ActionPromptResult>([\n              {\n                type: 'list',\n                name: 'action',\n                message: 'What would you like to do?',\n                choices: [\n                  { name: 'View details', value: 'view' },\n                  { name: 'Edit task', value: 'edit' },\n                  { name: 'Move to column', value: 'move' },\n                  { name: 'Update status', value: 'status' },\n                  { name: 'Delete task', value: 'delete' },\n                  { name: 'Select another task', value: 'continue' },\n                  { name: 'Exit', value: 'exit' },\n                ],\n              },\n            ]);\n\n            switch (action) {\n              case 'view':\n                const taskDetails = await apiClient.getTask(task.id);\n                formatter.output(taskDetails);\n                break;\n              case 'edit':\n                // Launch edit command\n                formatter.info(\n                  `\\nüí° Run: kanban task update ${String(String(task.id))} --interactive`\n                );\n                break;\n              case 'move':\n                // Launch move command\n                const { columnId } = await inquirer.prompt<ColumnPromptResult>([\n                  {\n                    type: 'input',\n                    name: 'columnId',\n                    message: 'Enter column ID to move to:',\n                    validate: (input: string) => input.length > 0 || 'Column ID is required',\n                  },\n                ]);\n                await apiClient.moveTask(task.id, columnId);\n                formatter.success(`Task moved to column ${String(columnId)}`);\n                break;\n              case 'status':\n                const { newStatus } = await inquirer.prompt<StatusPromptResult>([\n                  {\n                    type: 'list',\n                    name: 'newStatus',\n                    message: 'Select new status:',\n                    choices: ['todo', 'in_progress', 'completed', 'blocked'],\n                  },\n                ]);\n                await apiClient.updateTask(task.id, { status: newStatus });\n                formatter.success(`Task status updated to ${String(newStatus)}`);\n                break;\n              case 'delete':\n                const { confirm } = await inquirer.prompt<ConfirmPromptResult>([\n                  {\n                    type: 'confirm',\n                    name: 'confirm',\n                    message: `Delete task \"${String(String(task.title))}\"?`,\n                    default: false,\n                  },\n                ]);\n                if (confirm) {\n                  await apiClient.deleteTask(task.id);\n                  formatter.success('Task deleted successfully');\n                }\n                break;\n              case 'continue':\n                return;\n              case 'exit':\n                shouldExit = true;\n                break;\n            }\n\n            if (action !== 'continue') {\n              shouldExit = true;\n            }\n          };\n\n          const handleKeyPress = async (key: string, _selectedTask: Task | null) => {\n            switch (key) {\n              case 'search':\n                setSearchMode(true);\n                const { query } = await inquirer.prompt<QueryPromptResult>([\n                  {\n                    type: 'input',\n                    name: 'query',\n                    message: 'Search tasks:',\n                  },\n                ]);\n                setSearchQuery(query);\n                if (query) {\n                  const filtered = taskList.filter(\n                    t =>\n                      t.title.toLowerCase().includes(query.toLowerCase()) ||\n                      (t.assignee && t.assignee.toLowerCase().includes(query.toLowerCase())) ||\n                      (t.tags &&\n                        t.tags.some((tag: string) =>\n                          tag.toLowerCase().includes(query.toLowerCase())\n                        ))\n                  );\n                  setCurrentTasks(filtered);\n                } else {\n                  setCurrentTasks(taskList);\n                }\n                setSearchMode(false);\n                break;\n              case 'refresh':\n                try {\n                  const refreshedTasks = await apiClient.getTasks(params);\n                  const refreshedResponse = refreshedTasks as TaskListResponse;\n                  const refreshedTaskList: Task[] = refreshedResponse.data.map((task: Task) => ({\n                    id: task.id,\n                    title: task.title,\n                    status: task.status,\n                    priority: task.priority,\n                    assignee: task.assignee,\n                    tags: task.tags,\n                    due_date: task.due_date,\n                  }));\n                  setCurrentTasks(refreshedTaskList);\n                  formatter.info('\\nüîÑ Tasks refreshed');\n                } catch (error) {\n                  formatter.error('\\n‚ùå Failed to refresh tasks');\n                }\n                break;\n              case 'help':\n                formatter.info('\\nüìñ Task Selection Help:');\n                formatter.info('  ‚Üë/‚Üì or j/k: Navigate tasks');\n                formatter.info('  Enter: Select task');\n                formatter.info('  /: Search tasks');\n                formatter.info('  r: Refresh task list');\n                formatter.info('  h/l or ‚Üê/‚Üí: Filter by status');\n                formatter.info('  ?: Show this help');\n                formatter.info('  q: Exit');\n                break;\n              default:\n                // Handle status filter changes\n                if (key.startsWith('filter:')) {\n                  const status = key.replace('filter:', '');\n                  const filtered = taskList.filter(t => t.status === status);\n                  setCurrentTasks(filtered);\n                  setStatusFilter([status]);\n                  formatter.info(`\\nüîç Filtered by status: ${String(status)}`);\n                }\n                break;\n            }\n          };\n\n          React.useEffect(() => {\n            if (shouldExit) {\n              process.exit(0);\n            }\n          }, [shouldExit]);\n\n          return React.createElement(TaskList, {\n            tasks: currentTasks,\n            title: `Task Selection ${statusFilter.length ? `(${statusFilter.join(', ')})` : ''}${searchQuery ? ` - Search: \"${searchQuery}\"` : ''}`,\n            onTaskSelect: handleTaskSelect,\n            onKeyPress: (key: string, selectedTask: Task | null) => {\n              void handleKeyPress(key, selectedTask);\n            },\n            showSelection: true,\n            maxHeight: 15,\n            showStats: true,\n          });\n        };\n\n        // Show instructions\n        formatter.info(\n          `Starting interactive task selection (${String(String(taskList.length))} tasks)`\n        );\n        formatter.info('Use ‚Üë/‚Üì to navigate, Enter to select, ? for help, q to quit');\n\n        // Render the interactive task selector\n        render(React.createElement(InteractiveTaskSelector));\n      } catch (error) {\n        formatter.error(\n          `Failed to start task selection: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n        );\n        process.exit(1);\n      }\n    });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/config.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "no-new",
        "severity": 2,
        "message": "Do not use 'new' for side effects.",
        "line": 222,
        "column": 7,
        "nodeType": "ExpressionStatement",
        "messageId": "noNewStatement",
        "endLine": 222,
        "endColumn": 36,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/estimation/__tests__/task-size-estimator.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/estimation/task-size-estimator.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'formatDuration' is defined but never used.",
        "line": 2,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'formatProgressBar' is defined but never used.",
        "line": 2,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'formatKeyValue' is defined but never used.",
        "line": 2,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 59
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'suggestTaskSize'.",
        "line": 185,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 185,
        "endColumn": 18
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'generateReasoning'.",
        "line": 431,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 431,
        "endColumn": 28
      },
      {
        "ruleId": "default-case",
        "severity": 2,
        "message": "Expected a default case.",
        "line": 508,
        "column": 5,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 524,
        "endColumn": 6
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 144,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 144,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4110, 4164], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 147,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 147,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4230, 4272], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 157,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 157,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4521, 4680], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 163,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 163,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4732, 4772], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 167,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 167,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4875, 4919], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 169,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 169,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4975, 5091], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 173,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 173,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [5147, 5267], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 177,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 177,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [5323, 5339], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import chalk from 'chalk';\nimport { formatDuration, formatProgressBar, formatKeyValue } from '../utils/formatter';\nimport type { TaskSize } from '../prompts/validators';\n\nexport interface TaskEstimate {\n  size: TaskSize;\n  suggestedSize: TaskSize;\n  minHours: number;\n  maxHours: number;\n  avgHours: number;\n  estimatedHours: number;\n  confidence: number;\n  reasoning: string[];\n}\n\nexport interface TaskForEstimation {\n  title: string;\n  description?: string;\n  tags?: string[];\n  subtaskCount?: number;\n  dependencyCount?: number;\n}\n\nexport interface EstimationConfig {\n  sizeHours: {\n    XS: { min: number; max: number; avg: number };\n    S: { min: number; max: number; avg: number };\n    M: { min: number; max: number; avg: number };\n    L: { min: number; max: number; avg: number };\n    XL: { min: number; max: number; avg: number };\n  };\n  complexityFactors: {\n    subtasks: number;\n    dependencies: number;\n    unknownTech: number;\n    testing: number;\n    documentation: number;\n  };\n  velocityMultiplier: number;\n}\n\n/**\n * Estimates task sizes and time requirements\n */\nexport class TaskSizeEstimator {\n  private readonly config: EstimationConfig;\n\n  private readonly historicalData: Map<string, { estimated: number; actual: number }>;\n\n  constructor(config?: Partial<EstimationConfig>) {\n    this.config = {\n      sizeHours: {\n        XS: { min: 0.5, max: 1, avg: 0.8 },\n        S: { min: 1, max: 3, avg: 2 },\n        M: { min: 3, max: 6, avg: 4.5 },\n        L: { min: 6, max: 12, avg: 9 },\n        XL: { min: 12, max: 24, avg: 18 },\n      },\n      complexityFactors: {\n        subtasks: 0.2, // 20% increase per subtask\n        dependencies: 0.15, // 15% increase per dependency\n        unknownTech: 0.5, // 50% increase for unknown technology\n        testing: 0.3, // 30% increase for testing requirements\n        documentation: 0.2, // 20% increase for documentation\n      },\n      velocityMultiplier: 1.0, // Adjusted based on team velocity\n      ...config,\n    };\n\n    this.historicalData = new Map();\n  }\n\n  /**\n   * Estimate time for a single task\n   */\n  estimateTime(task: TaskForEstimation): TaskEstimate {\n    const suggestedSize = this.suggestTaskSize(task);\n    const baseEstimate = this.config.sizeHours[suggestedSize];\n\n    // Calculate complexity multiplier\n    const complexityMultiplier = this.calculateComplexityMultiplier(task);\n\n    // Apply complexity and velocity\n    const minHours = baseEstimate.min * complexityMultiplier * this.config.velocityMultiplier;\n    const maxHours = baseEstimate.max * complexityMultiplier * this.config.velocityMultiplier;\n    const avgHours = baseEstimate.avg * complexityMultiplier * this.config.velocityMultiplier;\n\n    // Determine confidence based on various factors\n    const confidence = this.calculateConfidence(task, suggestedSize);\n\n    // Generate reasoning\n    const reasoning = this.generateReasoning(task, suggestedSize, complexityMultiplier);\n\n    return {\n      size: suggestedSize,\n      suggestedSize,\n      minHours: Math.round(minHours * 10) / 10,\n      maxHours: Math.round(maxHours * 10) / 10,\n      avgHours: Math.round(avgHours * 10) / 10,\n      estimatedHours: Math.round(avgHours * 10) / 10,\n      confidence,\n      reasoning,\n    };\n  }\n\n  /**\n   * Group tasks by size\n   */\n  groupTasksBySize(\n    tasks: TaskForEstimation[]\n  ): Record<TaskSize | 'Unknown', Array<{ task: TaskForEstimation; estimate: TaskEstimate }>> {\n    const groups: Record<\n      TaskSize | 'Unknown',\n      Array<{ task: TaskForEstimation; estimate: TaskEstimate }>\n    > = {\n      XS: [],\n      S: [],\n      M: [],\n      L: [],\n      XL: [],\n      Unknown: [],\n    };\n\n    tasks.forEach(task => {\n      const estimate = this.estimateTime(task);\n      const size = estimate.suggestedSize;\n      groups[size].push({ task, estimate });\n    });\n\n    return groups;\n  }\n\n  /**\n   * Display estimates in a formatted way\n   */\n  static displayEstimates(\n    taskGroups: Record<\n      TaskSize | 'Unknown',\n      Array<{ task: TaskForEstimation; estimate: TaskEstimate }>\n    >\n  ): void {\n    try {\n      // eslint-disable-next-line no-console\n      console.log(chalk.cyan('\\nüìä Task Size Estimates\\n'));\n    } catch {\n      // eslint-disable-next-line no-console\n      console.log('\\nüìä Task Size Estimates\\n');\n    }\n\n    const sizes: (TaskSize | 'Unknown')[] = ['XS', 'S', 'M', 'L', 'XL', 'Unknown'];\n\n    sizes.forEach(size => {\n      const tasks = taskGroups[size];\n      if (tasks.length === 0) return;\n\n      // eslint-disable-next-line no-console\n      console.log(\n        chalk.bold(\n          `${size === 'Unknown' ? 'Unknown' : TaskSizeEstimator.formatSize(size)} (${tasks.length} tasks):`\n        )\n      );\n      // eslint-disable-next-line no-console\n      console.log(chalk.gray('‚îÄ'.repeat(50)));\n\n      tasks.forEach(({ task, estimate }) => {\n        // eslint-disable-next-line no-console\n        console.log(chalk.white(`‚Ä¢ ${task.title}`));\n        // eslint-disable-next-line no-console\n        console.log(\n          chalk.gray(`  ${estimate.avgHours}h (${estimate.minHours}-${estimate.maxHours}h)`)\n        );\n        // eslint-disable-next-line no-console\n        console.log(\n          chalk.gray(`  Confidence: ${TaskSizeEstimator.formatConfidence(estimate.confidence)}`)\n        );\n        // eslint-disable-next-line no-console\n        console.log('');\n      });\n    });\n  }\n\n  /**\n   * Suggest task size based on heuristics\n   */\n  suggestTaskSize(task: TaskForEstimation | string): TaskSize {\n    // Handle string input (for backward compatibility with tests)\n    if (typeof task === 'string') {\n      return TaskSizeEstimator.suggestTaskSizeInternal({ title: task });\n    }\n    return TaskSizeEstimator.suggestTaskSizeInternal(task);\n  }\n\n  private static suggestTaskSizeInternal(task: TaskForEstimation): TaskSize {\n    let score = 0;\n\n    // Title length heuristic\n    if (task.title.length < 30) score += 1;\n    else if (task.title.length < 50) score += 2;\n    else score += 3;\n\n    // Description complexity\n    if (task.description) {\n      const wordCount = task.description.split(/\\s+/).length;\n      if (wordCount < 20) score += 1;\n      else if (wordCount < 50) score += 2;\n      else if (wordCount < 100) score += 3;\n      else score += 4;\n    }\n\n    // Subtasks\n    if (task.subtaskCount) {\n      if (task.subtaskCount <= 2) score += 1;\n      else if (task.subtaskCount <= 5) score += 2;\n      else score += 3;\n    }\n\n    // Dependencies\n    if (task.dependencyCount) {\n      if (task.dependencyCount === 1) score += 1;\n      else if (task.dependencyCount <= 3) score += 2;\n      else score += 3;\n    }\n\n    // Keywords in title/description\n    const text =\n      `${String(String(task.title))} ${String(String(task.description ?? ''))}`.toLowerCase();\n    const complexKeywords = [\n      'refactor',\n      'migrate',\n      'redesign',\n      'architecture',\n      'integration',\n      'optimize',\n      'implement',\n      'complete',\n      'system',\n    ];\n    const simpleKeywords = ['fix', 'update', 'add', 'remove', 'change', 'typo', 'small', 'css'];\n\n    if (complexKeywords.some(keyword => text.includes(keyword))) {\n      score += 3;\n      // Additional points for very complex keywords\n      if (text.includes('implement') && text.includes('system')) {\n        score += 2; // Extra points for system implementation\n      }\n      if (text.includes('complete') && text.includes('management')) {\n        score += 2; // Extra points for complete management systems\n      }\n    } else if (simpleKeywords.some(keyword => text.includes(keyword))) {\n      score -= 2; // Reduce score more for simple keywords\n    }\n\n    // Tags\n    if (task.tags) {\n      const complexTags = ['backend', 'database', 'api', 'performance', 'security'];\n      const hasComplexTag = task.tags.some(tag =>\n        complexTags.some(complex => tag.toLowerCase().includes(complex))\n      );\n      if (hasComplexTag) score += 2;\n    }\n\n    // Map score to size\n    if (score <= 2) return 'XS';\n    if (score <= 5) return 'S';\n    if (score <= 9) return 'M';\n    if (score <= 14) return 'L';\n    return 'XL';\n  }\n\n  /**\n   * Update velocity based on historical data\n   */\n  updateVelocity(taskId: string, estimatedHours: number, actualHours: number): void {\n    this.historicalData.set(taskId, { estimated: estimatedHours, actual: actualHours });\n\n    // Recalculate velocity multiplier based on historical data\n    if (this.historicalData.size >= 5) {\n      let totalEstimated = 0;\n      let totalActual = 0;\n\n      for (const { estimated, actual } of this.historicalData.values()) {\n        totalEstimated += estimated;\n        totalActual += actual;\n      }\n\n      // New velocity is the ratio of actual to estimated\n      this.config.velocityMultiplier = totalActual / totalEstimated;\n\n      // Clamp to reasonable values\n      this.config.velocityMultiplier = Math.max(0.5, Math.min(2.0, this.config.velocityMultiplier));\n    }\n  }\n\n  /**\n   * Get estimation accuracy report\n   */\n  getAccuracyReport(): {\n    accuracy: number;\n    overestimated: number;\n    underestimated: number;\n    samples: number;\n  } {\n    if (this.historicalData.size === 0) {\n      return { accuracy: 0, overestimated: 0, underestimated: 0, samples: 0 };\n    }\n\n    let correctEstimates = 0;\n    let overestimated = 0;\n    let underestimated = 0;\n\n    for (const { estimated, actual } of this.historicalData.values()) {\n      const variance = Math.abs(estimated - actual) / estimated;\n      if (variance <= 0.2) {\n        // Within 20% is considered accurate\n        correctEstimates += 1;\n      } else if (estimated > actual) {\n        overestimated += 1;\n      } else {\n        underestimated += 1;\n      }\n    }\n\n    return {\n      accuracy: (correctEstimates / this.historicalData.size) * 100,\n      overestimated: (overestimated / this.historicalData.size) * 100,\n      underestimated: (underestimated / this.historicalData.size) * 100,\n      samples: this.historicalData.size,\n    };\n  }\n\n  /**\n   * Calculate complexity multiplier\n   */\n  private calculateComplexityMultiplier(task: TaskForEstimation): number {\n    let multiplier = 1.0;\n\n    if (task.subtaskCount) {\n      multiplier += task.subtaskCount * this.config.complexityFactors.subtasks;\n    }\n\n    if (task.dependencyCount) {\n      multiplier += task.dependencyCount * this.config.complexityFactors.dependencies;\n    }\n\n    // Check for complexity indicators in text\n    const text =\n      `${String(String(task.title))} ${String(String(task.description ?? ''))}`.toLowerCase();\n\n    // API work is complex\n    if (text.includes('api') || text.includes('rest') || text.includes('endpoint')) {\n      multiplier += 0.8;\n    }\n\n    // Database work is complex\n    if (text.includes('database') || text.includes('sql') || text.includes('migration')) {\n      multiplier += 0.4;\n    }\n\n    // UI work is complex\n    if (\n      text.includes('ui') ||\n      text.includes('frontend') ||\n      text.includes('dashboard') ||\n      text.includes('responsive')\n    ) {\n      multiplier += 2.0;\n    }\n\n    if (text.includes('unknown') || text.includes('research') || text.includes('investigate')) {\n      multiplier += this.config.complexityFactors.unknownTech;\n    }\n\n    if (text.includes('test') || text.includes('testing') || text.includes('qa')) {\n      multiplier += this.config.complexityFactors.testing * 2; // Double the testing complexity\n    }\n\n    if (text.includes('document') || text.includes('docs') || text.includes('readme')) {\n      multiplier += this.config.complexityFactors.documentation;\n    }\n\n    return Math.max(1.0, multiplier);\n  }\n\n  /**\n   * Calculate confidence level\n   */\n  private calculateConfidence(task: TaskForEstimation, _size: TaskSize): number {\n    let confidenceScore = 5; // Start at medium\n\n    // More information increases confidence\n    if (task.description) confidenceScore += 1;\n    if (task.tags && task.tags.length > 0) confidenceScore += 1;\n\n    // Clear scope increases confidence\n    const text =\n      `${String(String(task.title))} ${String(String(task.description ?? ''))}`.toLowerCase();\n    if (text.includes('specifically') || text.includes('exactly') || text.includes('only')) {\n      confidenceScore += 1;\n    }\n\n    // Uncertainty decreases confidence\n    if (text.includes('maybe') || text.includes('possibly') || text.includes('unknown')) {\n      confidenceScore -= 2;\n    }\n\n    // Many dependencies decrease confidence\n    if (task.dependencyCount && task.dependencyCount > 3) {\n      confidenceScore -= 1;\n    }\n\n    // Historical accuracy affects confidence\n    const accuracy = this.getAccuracyReport();\n    if (accuracy.samples > 10) {\n      if (accuracy.accuracy > 80) confidenceScore += 1;\n      else if (accuracy.accuracy < 50) confidenceScore -= 1;\n    }\n\n    // Simple tasks get confidence bonus\n    const simpleKeywords = ['fix', 'typo', 'change', 'update', 'add', 'remove'];\n    if (simpleKeywords.some(keyword => text.includes(keyword))) {\n      confidenceScore += 2.5;\n    }\n\n    // Convert to 0-1 scale\n    return Math.max(0, Math.min(1, confidenceScore / 10));\n  }\n\n  /**\n   * Generate reasoning for estimate\n   */\n  private generateReasoning(\n    task: TaskForEstimation,\n    size: TaskSize,\n    complexityMultiplier: number\n  ): string[] {\n    const reasons: string[] = [];\n\n    // Title length reasoning\n    if (task.title.length < 30) {\n      reasons.push('Short, clear title suggests simple task');\n    } else if (task.title.length > 50) {\n      reasons.push('Long title indicates complex requirements');\n    }\n\n    // Description reasoning\n    if (task.description) {\n      const wordCount = task.description.split(/\\s+/).length;\n      if (wordCount < 20) {\n        reasons.push('Brief description suggests well-defined scope');\n      } else if (wordCount > 100) {\n        reasons.push('Detailed description indicates complex requirements');\n      }\n    } else {\n      reasons.push('No description provided - may need clarification');\n    }\n\n    // Subtask reasoning\n    if (task.subtaskCount) {\n      if (task.subtaskCount <= 2) {\n        reasons.push('Few subtasks suggest manageable scope');\n      } else if (task.subtaskCount > 5) {\n        reasons.push('Many subtasks indicate complex implementation');\n      }\n    }\n\n    // Dependency reasoning\n    if (task.dependencyCount) {\n      if (task.dependencyCount === 1) {\n        reasons.push('Single dependency manageable');\n      } else if (task.dependencyCount > 3) {\n        reasons.push('Multiple dependencies increase complexity');\n      }\n    }\n\n    // Check for specific technologies/patterns\n    const text =\n      `${String(String(task.title))} ${String(String(task.description ?? ''))}`.toLowerCase();\n\n    if (text.includes('api') || text.includes('rest') || text.includes('endpoint')) {\n      reasons.push('API');\n    }\n\n    if (text.includes('database') || text.includes('sql') || text.includes('migration')) {\n      reasons.push('Database');\n    }\n\n    if (\n      text.includes('ui') ||\n      text.includes('frontend') ||\n      text.includes('dashboard') ||\n      text.includes('responsive')\n    ) {\n      reasons.push('UI');\n    }\n\n    if (text.includes('test') || text.includes('testing')) {\n      reasons.push('Testing');\n    }\n\n    // Complexity multiplier reasoning\n    if (complexityMultiplier > 1.5) {\n      reasons.push('High complexity multiplier due to technical factors');\n    } else if (complexityMultiplier < 1.1) {\n      reasons.push('Low complexity suggests straightforward implementation');\n    }\n\n    // Size-specific reasoning\n    switch (size) {\n      case 'XS':\n        reasons.push('Very small task - likely quick fix or simple addition');\n        break;\n      case 'S':\n        reasons.push('Small task - well-defined scope with clear requirements');\n        break;\n      case 'M':\n        reasons.push('Medium task - moderate complexity with some unknowns');\n        break;\n      case 'L':\n        reasons.push('Large task - significant scope with multiple components');\n        break;\n      case 'XL':\n        reasons.push('Extra large task - major feature or complex refactoring');\n        break;\n    }\n\n    return reasons;\n  }\n\n  /**\n   * Format size for display\n   */\n  private static formatSize(size: TaskSize): string {\n    const sizeColors = {\n      XS: chalk.cyan,\n      S: chalk.green,\n      M: chalk.yellow,\n      L: chalk.magenta,\n      XL: chalk.red,\n    };\n\n    const sizeLabels = {\n      XS: 'Extra Small',\n      S: 'Small',\n      M: 'Medium',\n      L: 'Large',\n      XL: 'Extra Large',\n    };\n\n    try {\n      return sizeColors[size](`${String(size)} (${String(sizeLabels[size])})`);\n    } catch {\n      return `${String(size)} (${String(sizeLabels[size])})`;\n    }\n  }\n\n  /**\n   * Format confidence for display\n   */\n  private static formatConfidence(confidence: number): string {\n    let color;\n    let label;\n\n    if (confidence >= 0.7) {\n      color = chalk.green;\n      label = 'high';\n    } else if (confidence >= 0.4) {\n      color = chalk.yellow;\n      label = 'medium';\n    } else {\n      color = chalk.red;\n      label = 'low';\n    }\n\n    try {\n      return color(`${String(label)} (${String(String((confidence * 100).toFixed(0)))}%)`);\n    } catch {\n      return `${String(label)} (${String(String((confidence * 100).toFixed(0)))}%)`;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/formatter.ts",
    "messages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'error'.",
        "line": 72,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 72,
        "endColumn": 8
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'outputJson'.",
        "line": 106,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 106,
        "endColumn": 24
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'outputCsv'.",
        "line": 113,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 113,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Record<string, unknown>`.",
        "line": 161,
        "column": 70,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 161,
        "endColumn": 78
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'outputObjectTable'.",
        "line": 189,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 189,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 214,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 214,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5223, 5226], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5223, 5226], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 214,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 214,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5234, 5237], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5234, 5237], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [key] on an `any` value.",
        "line": 214,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 214,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [key] on an `any` value.",
        "line": 214,
        "column": 86,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 214,
        "endColumn": 89
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 248,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 248,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .color on an `any` value.",
        "line": 324,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 324,
        "endColumn": 28
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'formatSize'.",
        "line": 363,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 363,
        "endColumn": 13
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'formatDuration'.",
        "line": 379,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 379,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 394,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 394,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9732, 9735], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9732, 9735], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 398,
        "column": 16,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 398,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 398,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 398,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 398,
        "column": 70,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 398,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 402,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 402,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 403,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 403,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .backupType on an `any` value.",
        "line": 403,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 403,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .enabled on an `any` value.",
        "line": 405,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 405,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .cronExpression on an `any` value.",
        "line": 407,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 407,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .cron on an `any` value.",
        "line": 407,
        "column": 75,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 407,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 409,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 409,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 410,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 410,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 415,
        "column": 16,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 415,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 415,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 415,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 416,
        "column": 51,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 416,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .createdAt on an `any` value.",
        "line": 416,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 416,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 417,
        "column": 51,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 417,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .updatedAt on an `any` value.",
        "line": 417,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 417,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .lastRunAt on an `any` value.",
        "line": 419,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 419,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 420,
        "column": 54,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 420,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .lastRunAt on an `any` value.",
        "line": 420,
        "column": 63,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 420,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .nextRunAt on an `any` value.",
        "line": 423,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 423,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .next_run on an `any` value.",
        "line": 423,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 423,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 425,
        "column": 45,
        "nodeType": "LogicalExpression",
        "messageId": "unsafeArgument",
        "endLine": 425,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .nextRunAt on an `any` value.",
        "line": 425,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 425,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .next_run on an `any` value.",
        "line": 425,
        "column": 76,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 425,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 431,
        "column": 16,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 431,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 431,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 431,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .runCount on an `any` value.",
        "line": 432,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 432,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .failureCount on an `any` value.",
        "line": 433,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 433,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .runCount on an `any` value.",
        "line": 435,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 435,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .runCount on an `any` value.",
        "line": 437,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 437,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .failureCount on an `any` value.",
        "line": 437,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 437,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .runCount on an `any` value.",
        "line": 437,
        "column": 72,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 437,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 445,
        "column": 16,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 445,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 445,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 445,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .retentionDays on an `any` value.",
        "line": 446,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 446,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .compressionEnabled on an `any` value.",
        "line": 448,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 448,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .verificationEnabled on an `any` value.",
        "line": 451,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 451,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [],
    "errorCount": 15,
    "fatalErrorCount": 0,
    "warningCount": 37,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import Table from 'cli-table3';\nimport chalk from 'chalk';\nimport { logger } from '../utils/logger';\n\ntype OutputFormat = 'table' | 'json' | 'csv';\n\ninterface FormatterOptions {\n  format: OutputFormat;\n  verbose: boolean;\n  quiet: boolean;\n  color: boolean;\n}\n\nexport class OutputFormatter {\n  private readonly options: FormatterOptions = {\n    format: 'table',\n    verbose: false,\n    quiet: false,\n    color: true,\n  };\n\n  setFormat(format: OutputFormat): void {\n    this.options.format = format;\n  }\n\n  setVerbose(verbose: boolean): void {\n    this.options.verbose = verbose;\n  }\n\n  setQuiet(quiet: boolean): void {\n    this.options.quiet = quiet;\n  }\n\n  setColor(color: boolean): void {\n    this.options.color = color;\n  }\n\n  /**\n   * Format and output data in the specified format\n   */\n  output<T = unknown>(data: T, options?: { headers?: string[]; fields?: string[] }): void {\n    if (this.options.quiet && this.options.format !== 'json') {\n      return;\n    }\n\n    switch (this.options.format) {\n      case 'json':\n        this.outputJson(data);\n        break;\n      case 'csv':\n        this.outputCsv(data, options);\n        break;\n      case 'table':\n      default:\n        this.outputTable(data, options);\n        break;\n    }\n  }\n\n  /**\n   * Output success message\n   */\n  success(message: string): void {\n    if (!this.options.quiet) {\n      logger.info(OutputFormatter.colorize(message, 'green'));\n    }\n  }\n\n  /**\n   * Output error message\n   */\n  error(message: string): void {\n    logger.error(OutputFormatter.colorize(`Error: ${String(message)}`, 'red'));\n  }\n\n  /**\n   * Output warning message\n   */\n  warn(message: string): void {\n    if (!this.options.quiet) {\n      logger.warn(OutputFormatter.colorize(`Warning: ${String(message)}`, 'yellow'));\n    }\n  }\n\n  /**\n   * Output info message\n   */\n  info(message: string): void {\n    if (this.options.verbose && !this.options.quiet) {\n      logger.info(OutputFormatter.colorize(message, 'cyan'));\n    }\n  }\n\n  /**\n   * Output debug message\n   */\n  debug(message: string): void {\n    if (this.options.verbose && !this.options.quiet) {\n      logger.info(OutputFormatter.colorize(`Debug: ${String(message)}`, 'gray'));\n    }\n  }\n\n  /**\n   * Output JSON format\n   */\n  private outputJson<T>(data: T): void {\n    logger.log(JSON.stringify(data, null, 2));\n  }\n\n  /**\n   * Output CSV format\n   */\n  private outputCsv<T>(data: T, options?: { headers?: string[]; fields?: string[] }): void {\n    let items: T[];\n    if (!Array.isArray(data)) {\n      items = [data];\n    } else {\n      items = data;\n    }\n\n    const processedItems = Array.isArray(items) ? items : [items];\n\n    if (processedItems.length === 0) {\n      return;\n    }\n\n    const fields = options?.fields ?? Object.keys(processedItems[0]);\n    const headers = options?.headers ?? fields;\n\n    // Output headers\n    logger.info(headers.join(','));\n\n    // Output rows\n    processedItems.forEach((item): void => {\n      const values = fields.map((field): string => {\n        const value = OutputFormatter.getNestedValue(item, field);\n        const stringValue = OutputFormatter.formatValue(value);\n        // Escape commas and quotes in CSV\n        return `\"${String(stringValue.replace(/\"/g, '\"\"'))}\"`;\n      });\n      logger.info(values.join(','));\n    });\n  }\n\n  /**\n   * Output table format\n   */\n  private outputTable<T>(data: T, options?: { headers?: string[]; fields?: string[] }): void {\n    if (!Array.isArray(data)) {\n      // Single object - display as key-value pairs\n      this.outputObjectTable(data);\n      return;\n    }\n\n    const items = Array.isArray(data) ? data : [data];\n    if (items.length === 0) {\n      logger.info(OutputFormatter.colorize('No items found', 'gray'));\n      return;\n    }\n\n    const fields = options?.fields ?? OutputFormatter.getTableFields(items[0]);\n    const headers =\n      options?.headers ??\n      fields.map((field: string): string => OutputFormatter.formatHeader(field));\n\n    const table = new Table({\n      head: headers.map((h: string): string => OutputFormatter.colorize(h, 'cyan')),\n      style: {\n        'padding-left': 1,\n        'padding-right': 1,\n        head: this.options.color ? ['cyan'] : [],\n      },\n    });\n\n    items.forEach((item): void => {\n      const row = fields.map((field: string): string => {\n        const value = OutputFormatter.getNestedValue(item, field);\n        return OutputFormatter.formatTableValue(value, field);\n      });\n      table.push(row);\n    });\n\n    logger.info(table.toString());\n  }\n\n  /**\n   * Output single object as key-value table\n   */\n  private outputObjectTable<T>(obj: T): void {\n    const table = new Table({\n      style: {\n        'padding-left': 1,\n        'padding-right': 1,\n      },\n    });\n\n    Object.entries(obj as Record<string, unknown>).forEach(([key, value]): void => {\n      table.push([\n        OutputFormatter.colorize(OutputFormatter.formatHeader(key), 'cyan'),\n        OutputFormatter.formatTableValue(value, key),\n      ]);\n    });\n\n    logger.info(table.toString());\n  }\n\n  /**\n   * Get nested value from object using dot notation\n   */\n  private static getNestedValue(obj: unknown, path: string): unknown {\n    return path\n      .split('.')\n      .reduce(\n        (current: any, key): any => (current && current[key] !== undefined ? current[key] : ''),\n        obj\n      );\n  }\n\n  /**\n   * Format value for display\n   */\n  private static formatValue(value: unknown): string {\n    if (value === null ?? value === undefined) {\n      return '';\n    }\n\n    if (typeof value === 'boolean') {\n      return value ? 'Yes' : 'No';\n    }\n\n    if (value instanceof Date) {\n      return value.toLocaleString();\n    }\n\n    if (typeof value === 'object') {\n      return JSON.stringify(value);\n    }\n\n    return String(value);\n  }\n\n  /**\n   * Format value for table display with colors\n   */\n  private static formatTableValue(value: unknown, field: string): string {\n    const formatted = this.formatValue(value);\n\n    if (!this.options.color) {\n      return formatted;\n    }\n\n    // Apply field-specific coloring\n    if (field.includes('status')) {\n      if (formatted.toLowerCase().includes('completed')) {\n        return chalk.green(formatted);\n      }\n      if (formatted.toLowerCase().includes('in_progress')) {\n        return chalk.yellow(formatted);\n      }\n      if (formatted.toLowerCase().includes('todo')) {\n        return chalk.blue(formatted);\n      }\n    }\n\n    if (field.includes('priority')) {\n      const num = parseInt(formatted, 10);\n      if (num >= 8) return chalk.red(formatted);\n      if (num >= 5) return chalk.yellow(formatted);\n      if (num >= 1) return chalk.green(formatted);\n    }\n\n    if (field.includes('date') || field.includes('time')) {\n      return chalk.gray(formatted);\n    }\n\n    return formatted;\n  }\n\n  /**\n   * Format header text\n   */\n  private static formatHeader(field: string): string {\n    return field\n      .replace(/([A-Z])/g, ' $1')\n      .replace(/^./, (str): string => str.toUpperCase())\n      .trim();\n  }\n\n  /**\n   * Get appropriate fields for table display\n   */\n  private static getTableFields(obj: Record<string, unknown>): string[] {\n    const allFields = Object.keys(obj);\n\n    // Define field priority for common objects\n    const priorities = {\n      id: 1,\n      title: 2,\n      name: 2,\n      status: 3,\n      priority: 4,\n      description: 5,\n      createdAt: 8,\n      updatedAt: 9,\n    };\n\n    // Sort fields by priority, then alphabetically\n    return allFields.sort((a, b): number => {\n      const priorityA = priorities[a as keyof typeof priorities] ?? 6;\n      const priorityB = priorities[b as keyof typeof priorities] ?? 6;\n\n      if (priorityA !== priorityB) {\n        return priorityA - priorityB;\n      }\n\n      return a.localeCompare(b);\n    });\n  }\n\n  /**\n   * Apply color if color is enabled\n   */\n  private static colorize(text: string, color: string): string {\n    if (!this.options.color) {\n      return text;\n    }\n\n    switch (color) {\n      case 'red':\n        return chalk.red(text);\n      case 'green':\n        return chalk.green(text);\n      case 'yellow':\n        return chalk.yellow(text);\n      case 'blue':\n        return chalk.blue(text);\n      case 'cyan':\n        return chalk.cyan(text);\n      case 'gray':\n        return chalk.gray(text);\n      default:\n        return text;\n    }\n  }\n\n  /**\n   * Create a progress bar\n   */\n  progressBar(current: number, total: number, width: number = 20): string {\n    const percentage = Math.round((current / total) * 100);\n    const filled = Math.round((current / total) * width);\n    const empty = width - filled;\n\n    const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);\n    const text = `${String(bar)} ${String(percentage)}% (${String(current)}/${String(total)})`;\n\n    return this.options.color ? chalk.cyan(text) : text;\n  }\n\n  /**\n   * Format file size\n   */\n  formatSize(bytes: number): string {\n    const units = ['B', 'KB', 'MB', 'GB'];\n    let size = bytes;\n    let unitIndex = 0;\n\n    while (size >= 1024 && unitIndex < units.length - 1) {\n      size /= 1024;\n      unitIndex += 1;\n    }\n\n    return `${String(String(size.toFixed(1)))} ${String(units[unitIndex])}`;\n  }\n\n  /**\n   * Format duration\n   */\n  formatDuration(ms: number): string {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n    const days = Math.floor(hours / 24);\n\n    if (days > 0) return `${String(days)}d ${String(hours % 24)}h`;\n    if (hours > 0) return `${String(hours)}h ${String(minutes % 60)}m`;\n    if (minutes > 0) return `${String(minutes)}m ${String(seconds % 60)}s`;\n    return `${String(seconds)}s`;\n  }\n\n  /**\n   * Format backup schedule information\n   */\n  formatSchedule(schedule: any): string {\n    const lines: string[] = [];\n\n    // Header\n    lines.push(this.formatHeader(`Schedule: ${String(String(schedule.name))}`));\n    lines.push('');\n\n    // Basic info\n    lines.push(`ID: ${String(String(schedule.id))}`);\n    lines.push(`Type: ${String(String(schedule.backupType?.toUpperCase() ?? 'N/A'))}`);\n    lines.push(\n      `Status: ${String(String(schedule.enabled ? chalk.green('ENABLED') : chalk.red('DISABLED')))}`\n    );\n    lines.push(`Cron: ${String(String(schedule.cronExpression ?? schedule.cron ?? 'N/A'))}`);\n\n    if (schedule.description) {\n      lines.push(`Description: ${String(String(schedule.description))}`);\n    }\n\n    // Timing info\n    lines.push('');\n    lines.push(this.formatHeader('Timing:'));\n    lines.push(`Created: ${String(String(new Date(schedule.createdAt).toLocaleString()))}`);\n    lines.push(`Updated: ${String(String(new Date(schedule.updatedAt).toLocaleString()))}`);\n\n    if (schedule.lastRunAt) {\n      lines.push(`Last Run: ${String(String(new Date(schedule.lastRunAt).toLocaleString()))}`);\n    }\n\n    if (schedule.nextRunAt ?? schedule.next_run) {\n      lines.push(\n        `Next Run: ${String(String(new Date(schedule.nextRunAt ?? schedule.next_run).toLocaleString()))}`\n      );\n    }\n\n    // Statistics\n    lines.push('');\n    lines.push(this.formatHeader('Statistics:'));\n    lines.push(`Total Runs: ${String(String(schedule.runCount ?? 0))}`);\n    lines.push(`Failures: ${String(String(schedule.failureCount ?? 0))}`);\n\n    if (schedule.runCount > 0) {\n      const successRate = (\n        ((schedule.runCount - (schedule.failureCount ?? 0)) / schedule.runCount) *\n        100\n      ).toFixed(1);\n      lines.push(`Success Rate: ${String(successRate)}%`);\n    }\n\n    // Configuration\n    lines.push('');\n    lines.push(this.formatHeader('Configuration:'));\n    lines.push(`Retention: ${String(String(schedule.retentionDays ?? 30))} days`);\n    lines.push(\n      `Compression: ${String(String(schedule.compressionEnabled ? 'Enabled' : 'Disabled'))}`\n    );\n    lines.push(\n      `Verification: ${String(String(schedule.verificationEnabled ? 'Enabled' : 'Disabled'))}`\n    );\n\n    return lines.join('\\n');\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/index.ts",
    "messages": [
      {
        "ruleId": "vars-on-top",
        "severity": 2,
        "message": "All 'var' declarations must be at the top of the function scope.",
        "line": 29,
        "column": 3,
        "nodeType": "VariableDeclaration",
        "messageId": "top",
        "endLine": 29,
        "endColumn": 36
      },
      {
        "ruleId": "no-var",
        "severity": 2,
        "message": "Unexpected var, use let or const instead.",
        "line": 29,
        "column": 3,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpectedVar",
        "endLine": 29,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'spinner' is assigned a value but never used.",
        "line": 38,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 38,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'boardFormatter' is assigned a value but never used.",
        "line": 43,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 43,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'taskListFormatter' is assigned a value but never used.",
        "line": 44,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 44,
        "endColumn": 26
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 60,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 60,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [2232, 2280], "text": "" },
            "desc": "Remove the console.error()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 65,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 65,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [2371, 2444], "text": "" },
            "desc": "Remove the console.error()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 71,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 71,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [2549, 2599], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 76,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 76,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [2664, 2714], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 106,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 106,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [3485, 3537], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 107,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 107,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [3544, 3590], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 109,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 109,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [3598, 3637], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 111,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 111,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [3666, 3720], "text": "" },
            "desc": "Remove the console.error()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 141,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 141,
        "endColumn": 29
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 143,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 143,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [4618, 4671], "text": "" },
            "desc": "Remove the console.error()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 150,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 150,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "error" },
            "fix": { "range": [4742, 4790], "text": "" },
            "desc": "Remove the console.error()."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport { config } from '../config';\nimport { dbConnection } from '../database/connection';\nimport { registerTaskCommands } from './commands/tasks';\nimport { registerBoardCommands } from './commands/boards';\nimport { registerContextCommands } from './commands/context';\nimport { registerTagCommands } from './commands/tags';\nimport { registerNoteCommands } from './commands/notes';\nimport { registerExportCommands } from './commands/export';\nimport { registerBackupCommands } from './commands/backup';\nimport { registerRealtimeCommands } from './commands/realtime';\nimport { registerSearchCommands } from './commands/search';\nimport { registerPriorityCommands } from './commands/priority';\nimport { registerSubtaskCommands } from './commands/subtasks';\nimport { registerDatabaseCommands } from './commands/database';\nimport { registerConfigCommands } from './commands/config';\nimport { ApiClientWrapper } from './api-client-wrapper';\nimport { SpinnerManager } from './utils/spinner';\nimport { BoardFormatter } from './utils/board-formatter';\nimport { TaskListFormatter } from './utils/task-list-formatter';\nimport { OutputFormatter } from './formatter';\nimport { ConfigManager } from './config';\nimport type { CliComponents } from './types';\n\n// Global CLI components\ndeclare global {\n  var cliComponents: CliComponents;\n}\n\nconst program = new Command();\n\nprogram.name('kanban').description('MCP Kanban CLI').version('1.0.0');\n\n// Initialize CLI components\nconst initializeComponents = async (): Promise<CliComponents> => {\n  const spinner = new SpinnerManager();\n  const configManager = new ConfigManager();\n  const apiClient = new ApiClientWrapper(configManager, {\n    spinner: { defaultTimeout: 30000, showByDefault: true },\n  });\n  const boardFormatter = new BoardFormatter();\n  const taskListFormatter = new TaskListFormatter();\n  const formatter = new OutputFormatter();\n\n  // Initialize database connection\n  await dbConnection.initialize({ skipSchema: false });\n\n  return {\n    config: configManager,\n    apiClient,\n    formatter,\n  };\n};\n\n// Global error handler for CLI\nconst setupGlobalErrorHandler = (): void => {\n  process.on('uncaughtException', error => {\n    console.error('\\n‚ùå Uncaught Exception:', error);\n    process.exit(1);\n  });\n\n  process.on('unhandledRejection', (reason, promise) => {\n    console.error('\\n‚ùå Unhandled Rejection at:', promise, 'reason:', reason);\n    process.exit(1);\n  });\n\n  // Graceful shutdown handling (Ctrl+C)\n  process.on('SIGINT', () => {\n    console.log('\\n\\nüëã Shutting down gracefully...');\n    process.exit(0);\n  });\n\n  process.on('SIGTERM', () => {\n    console.log('\\n\\nüëã Shutting down gracefully...');\n    process.exit(0);\n  });\n};\n\n// Health check command\nprogram\n  .command('health')\n  .description('Check system health')\n  .action(async () => {\n    try {\n      const components = await initializeComponents();\n      const spinner = new SpinnerManager();\n\n      spinner.start('üîç Checking system health...');\n\n      // Check database connection\n      await dbConnection.initialize({ skipSchema: false });\n      spinner.succeed('Database connection: OK');\n\n      // Check API server\n      try {\n        await components.apiClient.getHealth();\n        spinner.succeed('API server: OK');\n      } catch (error) {\n        spinner.warn('API server: Not available (running in standalone mode)');\n      }\n\n      // Check config\n      spinner.succeed('Configuration: OK');\n      console.log(`   Database: ${config.database.path}`);\n      console.log(`   Port: ${config.server.port}`);\n\n      console.log('\\nüéâ System is healthy!');\n    } catch (error) {\n      console.error('‚ùå System health check failed:', error);\n      process.exit(1);\n    }\n  });\n\n// Initialize components and register commands\nconst main = async (): Promise<void> => {\n  try {\n    // Setup global error handling\n    setupGlobalErrorHandler();\n\n    // Initialize components\n    global.cliComponents = await initializeComponents();\n\n    // Register all command modules\n    registerTaskCommands(program);\n    registerBoardCommands(program);\n    registerContextCommands(program);\n    registerTagCommands(program);\n    registerNoteCommands(program);\n    registerExportCommands(program);\n    registerBackupCommands(program);\n    registerRealtimeCommands(program);\n    registerSearchCommands(program);\n    registerPriorityCommands(program);\n    registerSubtaskCommands(program);\n    registerDatabaseCommands(program);\n    registerConfigCommands(program);\n\n    // Parse command line arguments\n    await program.parseAsync();\n  } catch (error) {\n    console.error('‚ùå CLI initialization failed:', error);\n    process.exit(1);\n  }\n};\n\n// Run the CLI\nmain().catch(error => {\n  console.error('‚ùå CLI execution failed:', error);\n  process.exit(1);\n});\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/prompts/__tests__/validators.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/prompts/board-prompts.ts",
    "messages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 24,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 24,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [553, 605], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 27,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 44,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 27,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 27,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 33,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 33,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 34,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 34,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 46,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 46,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 51,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 60,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 51,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 51,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 65,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 92,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 65,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 65,
        "endColumn": 39
      },
      {
        "ruleId": "default-case",
        "severity": 2,
        "message": "Expected a default case.",
        "line": 95,
        "column": 5,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 130,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 139,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 148,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 139,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 139,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 145,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 145,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 153,
        "column": 24,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 153,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 164,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 171,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 164,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 164,
        "endColumn": 37
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 174,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 174,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4557, 4610], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 175,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 175,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4613, 4653], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 176,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 176,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4656, 4707], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 176,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 176,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 177,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 177,
        "endColumn": 28
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 178,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 178,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4743, 4796], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 178,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 178,
        "endColumn": 54
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 180,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 180,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4803, 4865], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 181,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 181,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4868, 4932], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 182,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 182,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [4935, 4975], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 185,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 185,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 185,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 185,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 186,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 186,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 186,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 186,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 188,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 188,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 196,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 201,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 196,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 196,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 203,
        "column": 3,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 203,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .confirmed on an `any` value.",
        "line": 203,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 203,
        "endColumn": 28
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 218,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 218,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [5698, 5756], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 229,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 235,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 229,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 229,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .selected on an `any` value.",
        "line": 237,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 237,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .selected on an `any` value.",
        "line": 237,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 237,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 241,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 241,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .selected on an `any` value.",
        "line": 241,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 241,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 243,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 248,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 243,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 243,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .selected on an `any` value.",
        "line": 250,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 250,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .selected on an `any` value.",
        "line": 254,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 254,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 254,
        "column": 60,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 254,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [6512, 6514], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 263,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 263,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [6715, 6763], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 265,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 286,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 265,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 265,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 270,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 270,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 271,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 271,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 288,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 288,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .position on an `any` value.",
        "line": 294,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 294,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 303,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 303,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 303,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 303,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 304,
        "column": 5,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 304,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .position on an `any` value.",
        "line": 304,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 304,
        "endColumn": 32
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 319,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 319,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [8030, 8080], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 321,
        "column": 9,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 360,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 321,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 321,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 327,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 327,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 328,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 328,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 365,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 365,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 366,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 366,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 366,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 366,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 368,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 368,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 369,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 369,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 369,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 369,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .isPublic on an `any` value.",
        "line": 371,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 371,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 372,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 372,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .isPublic on an `any` value.",
        "line": 372,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 372,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .defaultAssignee on an `any` value.",
        "line": 374,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 374,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 375,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 375,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .defaultAssignee on an `any` value.",
        "line": 375,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 375,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .autoArchiveDays on an `any` value.",
        "line": 377,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 377,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 378,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 378,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .autoArchiveDays on an `any` value.",
        "line": 378,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 378,
        "endColumn": 55
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 395,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 395,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [10005, 10058], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 398,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 398,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [10094, 10141], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 399,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 399,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [10146, 10160], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 402,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 402,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [10168, 10232], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 403,
        "column": 3,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 403,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [10235, 10294], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 406,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 411,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 406,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 406,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 81,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import prompts from 'prompts';\nimport chalk from 'chalk';\nimport { validateBoardName, validateColumnName } from './validators';\n\nexport interface BoardSetupInput {\n  name: string;\n  description?: string;\n  columns: Array<{ name: string; order: number }>;\n  isPublic?: boolean;\n}\n\nexport interface ColumnInput {\n  name: string;\n  position?: 'start' | 'end' | 'after';\n  afterColumn?: string;\n}\n\n/**\n * Quick board setup with prompts library\n */\nexport async function quickBoardSetup(\n  defaults?: Partial<BoardSetupInput>\n): Promise<BoardSetupInput> {\n  console.log(chalk.cyan('\\nüöÄ Quick Board Setup\\n'));\n\n  // Board name and description\n  const boardInfo = await prompts([\n    {\n      type: 'text',\n      name: 'name',\n      message: 'Board name:',\n      initial: defaults?.name,\n      validate: value => {\n        const result = validateBoardName(value);\n        return result === true ? true : result;\n      },\n    },\n    {\n      type: 'text',\n      name: 'description',\n      message: 'Description (optional):',\n      initial: defaults?.description,\n    },\n  ]);\n\n  if (!boardInfo.name) {\n    throw new Error('Board setup cancelled');\n  }\n\n  // Column setup\n  const { useTemplate } = await prompts({\n    type: 'select',\n    name: 'useTemplate',\n    message: 'Column setup:',\n    choices: [\n      { title: 'Use template', value: 'template' },\n      { title: 'Custom columns', value: 'custom' },\n    ],\n    initial: 0,\n  });\n\n  let columns: Array<{ name: string; order: number }> = [];\n\n  if (useTemplate === 'template') {\n    const { template } = await prompts({\n      type: 'select',\n      name: 'template',\n      message: 'Choose template:',\n      choices: [\n        {\n          title: 'Basic Kanban (To Do, In Progress, Done)',\n          value: 'basic',\n          description: 'Simple 3-column board',\n        },\n        {\n          title: 'Scrum Board (Backlog, To Do, In Progress, Review, Done)',\n          value: 'scrum',\n          description: 'Standard Scrum workflow',\n        },\n        {\n          title: 'Bug Tracking (New, Confirmed, In Progress, Testing, Resolved)',\n          value: 'bugs',\n          description: 'Bug tracking workflow',\n        },\n        {\n          title: 'Content Pipeline (Ideas, Writing, Editing, Review, Published)',\n          value: 'content',\n          description: 'Content creation workflow',\n        },\n      ],\n      initial: 0,\n    });\n\n    // Set columns based on template\n    switch (template) {\n      case 'basic':\n        columns = [\n          { name: 'To Do', order: 0 },\n          { name: 'In Progress', order: 1 },\n          { name: 'Done', order: 2 },\n        ];\n        break;\n      case 'scrum':\n        columns = [\n          { name: 'Backlog', order: 0 },\n          { name: 'To Do', order: 1 },\n          { name: 'In Progress', order: 2 },\n          { name: 'Review', order: 3 },\n          { name: 'Done', order: 4 },\n        ];\n        break;\n      case 'bugs':\n        columns = [\n          { name: 'New', order: 0 },\n          { name: 'Confirmed', order: 1 },\n          { name: 'In Progress', order: 2 },\n          { name: 'Testing', order: 3 },\n          { name: 'Resolved', order: 4 },\n        ];\n        break;\n      case 'content':\n        columns = [\n          { name: 'Ideas', order: 0 },\n          { name: 'Writing', order: 1 },\n          { name: 'Editing', order: 2 },\n          { name: 'Review', order: 3 },\n          { name: 'Published', order: 4 },\n        ];\n        break;\n    }\n  } else {\n    // Custom columns\n    let addingColumns = true;\n    let order = 0;\n\n    // eslint-disable-next-line no-await-in-loop\n    while (addingColumns) {\n      // eslint-disable-next-line no-await-in-loop\n      const { columnName } = await prompts({\n        type: 'text',\n        name: 'columnName',\n        message: `Column ${order + 1} name (leave empty to finish):`,\n        validate: value => {\n          if (!value) return true; // Allow empty to finish\n          const result = validateColumnName(value);\n          return result === true ? true : result;\n        },\n      });\n\n      if (!columnName) {\n        addingColumns = false;\n      } else {\n        columns.push({ name: columnName, order });\n        order++;\n      }\n    }\n\n    if (columns.length === 0) {\n      throw new Error('Board must have at least one column');\n    }\n  }\n\n  // Public/Private setting\n  const { isPublic } = await prompts({\n    type: 'toggle',\n    name: 'isPublic',\n    message: 'Make board public?',\n    initial: defaults?.isPublic ?? false,\n    active: 'yes',\n    inactive: 'no',\n  });\n\n  // Show summary\n  console.log(chalk.green('\\n‚úÖ Board Configuration:'));\n  console.log(chalk.gray('‚îÄ'.repeat(40)));\n  console.log(`Name: ${chalk.bold(boardInfo.name)}`);\n  if (boardInfo.description) {\n    console.log(`Description: ${boardInfo.description}`);\n  }\n  console.log(`Visibility: ${isPublic ? 'Public' : 'Private'}`);\n  console.log(`Columns: ${columns.map(c => c.name).join(' ‚Üí ')}`);\n  console.log(chalk.gray('‚îÄ'.repeat(40)));\n\n  return {\n    name: boardInfo.name,\n    description: boardInfo.description ?? undefined,\n    columns,\n    isPublic,\n  };\n}\n\n/**\n * Confirm action utility\n */\nexport async function confirmAction(message: string, defaultAnswer = false): Promise<boolean> {\n  const response = await prompts({\n    type: 'confirm',\n    name: 'confirmed',\n    message,\n    initial: defaultAnswer,\n  });\n\n  return response.confirmed ?? false;\n}\n\n/**\n * Select from list utility\n */\nexport async function selectFromList<T extends { id: string; name: string }>(\n  message: string,\n  items: T[],\n  options?: {\n    allowMultiple?: boolean;\n    showDescription?: (item: T) => string;\n  }\n): Promise<T | T[] | null> {\n  if (items.length === 0) {\n    console.log(chalk.yellow('No items available to select'));\n    return null;\n  }\n\n  const choices = items.map(item => ({\n    title: item.name,\n    value: item.id,\n    description: options?.showDescription?.(item),\n  }));\n\n  if (options?.allowMultiple) {\n    const response = await prompts({\n      type: 'multiselect',\n      name: 'selected',\n      message,\n      choices,\n      hint: '- Space to select. Return to submit',\n    });\n\n    if (!response.selected || response.selected.length === 0) {\n      return null;\n    }\n\n    return items.filter(item => response.selected.includes(item.id));\n  }\n  const response = await prompts({\n    type: 'select',\n    name: 'selected',\n    message,\n    choices,\n  });\n\n  if (!response.selected) {\n    return null;\n  }\n\n  return items.find(item => item.id === response.selected) || null;\n}\n\n/**\n * Add column to existing board prompt\n */\nexport async function addColumnPrompt(\n  existingColumns: Array<{ id: string; name: string; order: number }>\n): Promise<ColumnInput | null> {\n  console.log(chalk.cyan('\\n‚ûï Add New Column\\n'));\n\n  const response = await prompts([\n    {\n      type: 'text',\n      name: 'name',\n      message: 'Column name:',\n      validate: value => {\n        const result = validateColumnName(value);\n        return result === true ? true : result;\n      },\n    },\n    {\n      type: 'select',\n      name: 'position',\n      message: 'Position:',\n      choices: [\n        { title: 'At the beginning', value: 'start' },\n        { title: 'At the end', value: 'end' },\n        { title: 'After specific column', value: 'after' },\n      ],\n      initial: 1, // Default to 'end'\n    },\n  ]);\n\n  if (!response.name) {\n    return null;\n  }\n\n  let afterColumn: string | undefined;\n\n  if (response.position === 'after' && existingColumns.length > 0) {\n    const selected = await selectFromList('Insert after which column?', existingColumns);\n\n    if (selected && !Array.isArray(selected)) {\n      afterColumn = selected.id;\n    }\n  }\n\n  return {\n    name: response.name,\n    position: response.position,\n    afterColumn,\n  };\n}\n\n/**\n * Board settings prompt\n */\nexport async function boardSettingsPrompt(currentSettings: {\n  name: string;\n  description?: string;\n  isPublic: boolean;\n  defaultAssignee?: string;\n  autoArchiveDays?: number;\n}): Promise<Partial<typeof currentSettings>> {\n  console.log(chalk.cyan('\\n‚öôÔ∏è  Board Settings\\n'));\n\n  const response = await prompts([\n    {\n      type: 'text',\n      name: 'name',\n      message: 'Board name:',\n      initial: currentSettings.name,\n      validate: value => {\n        const result = validateBoardName(value);\n        return result === true ? true : result;\n      },\n    },\n    {\n      type: 'text',\n      name: 'description',\n      message: 'Description:',\n      initial: currentSettings.description,\n    },\n    {\n      type: 'toggle',\n      name: 'isPublic',\n      message: 'Public board?',\n      initial: currentSettings.isPublic,\n      active: 'yes',\n      inactive: 'no',\n    },\n    {\n      type: 'text',\n      name: 'defaultAssignee',\n      message: 'Default assignee (optional):',\n      initial: currentSettings.defaultAssignee,\n    },\n    {\n      type: 'number',\n      name: 'autoArchiveDays',\n      message: 'Auto-archive completed tasks after (days, 0 to disable):',\n      initial: currentSettings.autoArchiveDays ?? 0,\n      min: 0,\n      max: 365,\n    },\n  ]);\n\n  // Filter out unchanged values\n  const changes: Partial<typeof currentSettings> = {};\n\n  if (response.name !== currentSettings.name) {\n    changes.name = response.name;\n  }\n  if (response.description !== currentSettings.description) {\n    changes.description = response.description ?? undefined;\n  }\n  if (response.isPublic !== currentSettings.isPublic) {\n    changes.isPublic = response.isPublic;\n  }\n  if (response.defaultAssignee !== currentSettings.defaultAssignee) {\n    changes.defaultAssignee = response.defaultAssignee ?? undefined;\n  }\n  if (response.autoArchiveDays !== currentSettings.autoArchiveDays) {\n    changes.autoArchiveDays = response.autoArchiveDays ?? undefined;\n  }\n\n  return changes;\n}\n\n/**\n * Delete confirmation with safety check\n */\nexport async function confirmDelete(\n  itemType: string,\n  itemName: string,\n  options?: {\n    showWarning?: string;\n    requireTyping?: boolean;\n  }\n): Promise<boolean> {\n  console.log(chalk.red(`\\n‚ö†Ô∏è  Delete ${itemType}\\n`));\n\n  if (options?.showWarning) {\n    console.log(chalk.yellow(options.showWarning));\n    console.log();\n  }\n\n  console.log(`You are about to delete: ${chalk.bold(itemName)}`);\n  console.log(chalk.gray('This action cannot be undone.\\n'));\n\n  if (options?.requireTyping) {\n    const { confirmText } = await prompts({\n      type: 'text',\n      name: 'confirmText',\n      message: `Type \"${itemName}\" to confirm:`,\n      validate: value => (value === itemName ? true : `Please type exactly: ${itemName}`),\n    });\n\n    if (confirmText !== itemName) {\n      return false;\n    }\n  }\n\n  return confirmAction(`Are you sure you want to delete this ${itemType}?`, false);\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/prompts/task-prompts.ts",
    "messages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 31,
        "column": 36,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 31,
        "endColumn": 47
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 32,
        "column": 39,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 32,
        "endColumn": 50
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 33,
        "column": 36,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 33,
        "endColumn": 47
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 34,
        "column": 37,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 34,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 50,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 50,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1418, 1421], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1418, 1421], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 52,
        "column": 5,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 52,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PromptOptions | PromptOptions[]`.",
        "line": 52,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 52,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { prompt } from 'enquirer';\nimport chalk from 'chalk';\nimport type { Priority, TaskSize } from './validators';\nimport {\n  validateTaskTitle,\n  validateDate,\n  validateTimeEstimate,\n  PRIORITIES,\n  TASK_SIZES,\n} from './validators';\nimport { TaskSizeEstimator } from '../estimation/task-size-estimator';\n\n// Define the prompt options type based on enquirer's internal types\n\ninterface TaskEstimation {\n  size: TaskSize;\n  avgHours: number;\n  confidence: string;\n  reasoning: string[];\n}\n\ninterface FormatterInterface {\n  info: (message: string) => void;\n  success: (message: string) => void;\n  warn: (message: string) => void;\n  error: (message: string) => void;\n}\n\n// Simple formatter for prompts - falls back to console if no proper formatter available\nconst simpleFormatter: FormatterInterface = {\n  info: (message: string): void => console.log(chalk.cyan(message)),\n  success: (message: string): void => console.log(chalk.green(message)),\n  warn: (message: string): void => console.log(chalk.yellow(message)),\n  error: (message: string): void => console.log(chalk.red(message)),\n};\n\n/**\n * Error thrown when a prompt is cancelled\n */\nexport class PromptCancelledError extends Error {\n  constructor(message = 'Prompt was cancelled by user') {\n    super(message);\n    this.name = 'PromptCancelledError';\n  }\n}\n\n/**\n * Wrapper for prompt that handles cancellation\n */\nasync function safePrompt<T>(promptConfig: any): Promise<T> {\n  try {\n    return await prompt<T>(promptConfig);\n  } catch (error) {\n    // Check if it's a cancellation (Ctrl+C, ESC, etc.)\n    if (error instanceof Error) {\n      const errorMessage = error.message.toLowerCase();\n      if (\n        errorMessage.includes('cancel') ||\n        errorMessage.includes('abort') ||\n        errorMessage.includes('interrupt') ||\n        error.name === 'SIGINT'\n      ) {\n        throw new PromptCancelledError(`Operation cancelled: ${error.message}`);\n      }\n    }\n    // Re-throw other errors\n    throw error;\n  }\n}\n\nexport interface TaskInput {\n  title: string;\n  description?: string;\n  priority?: Priority;\n  size?: TaskSize;\n  assignee?: string;\n  due_date?: string;\n  estimated_hours?: number;\n  tags?: string[];\n}\n\nexport interface MoveTaskInput {\n  taskId: string;\n  targetColumn: string;\n  position?: number;\n}\n\nexport interface BulkActionInput {\n  taskIds: string[];\n  action: 'move' | 'delete' | 'archive' | 'assign' | 'tag';\n  params?: Record<string, unknown>;\n}\n\n/**\n * Create task interactive prompt\n */\nexport async function createTaskPrompt(defaults?: Partial<TaskInput>): Promise<TaskInput> {\n  try {\n    simpleFormatter.info('\\nüìù Create New Task\\n');\n    simpleFormatter.info(chalk.gray('Press Ctrl+C to cancel at any time\\n'));\n\n    // Create estimator instance\n    const estimator = new TaskSizeEstimator();\n\n    // Get basic info first for estimation\n    const basicInfo = await safePrompt<{ title: string; description?: string }>([\n      {\n        type: 'input',\n        name: 'title',\n        message: 'Task title:',\n        initial: defaults?.title,\n        validate: validateTaskTitle,\n      },\n      {\n        type: 'text',\n        name: 'description',\n        message: 'Description (optional):',\n        initial: defaults?.description,\n        multiline: true,\n        hint: 'Press Ctrl+D when done',\n      },\n    ]);\n\n    // Generate size estimation\n    let suggestedSize: TaskSize | undefined;\n    let estimation: TaskEstimation | undefined;\n\n    if (basicInfo.title) {\n      try {\n        estimation = estimator.estimateTime({\n          title: basicInfo.title,\n          description: basicInfo.description,\n        }) as TaskEstimation;\n        suggestedSize = estimation.size;\n\n        // Show estimation\n        simpleFormatter.info(chalk.cyan('\\nü§ñ AI Size Estimation:'));\n        simpleFormatter.info(\n          chalk.yellow(`  Suggested Size: ${suggestedSize} (${estimation.avgHours} hours)`)\n        );\n        simpleFormatter.info(chalk.gray(`  Confidence: ${estimation.confidence}`));\n        if (estimation.reasoning?.length > 0) {\n          simpleFormatter.info(chalk.gray('  Reasoning:'));\n          estimation.reasoning.forEach((reason: string) => {\n            simpleFormatter.info(chalk.gray(`    ‚Ä¢ ${reason}`));\n          });\n        }\n        simpleFormatter.info('');\n      } catch (error) {\n        simpleFormatter.warn('‚ö†Ô∏è  Size estimation unavailable\\n');\n      }\n    }\n\n    const additionalInfo = await safePrompt<Omit<TaskInput, 'title' | 'description'>>([\n      {\n        type: 'select',\n        name: 'priority',\n        message: 'Priority:',\n        choices: [\n          { name: 'P1', value: 'P1', hint: 'Critical - Must be done ASAP' },\n          { name: 'P2', value: 'P2', hint: 'High - Important and urgent' },\n          { name: 'P3', value: 'P3', hint: 'Medium - Important but not urgent' },\n          { name: 'P4', value: 'P4', hint: 'Low - Nice to have' },\n          { name: 'P5', value: 'P5', hint: 'Very Low - Backlog' },\n          { name: 'Skip', value: undefined, hint: 'No priority' },\n        ],\n        initial: defaults?.priority ? PRIORITIES.indexOf(defaults.priority) : 2,\n      },\n      {\n        type: 'select',\n        name: 'size',\n        message: suggestedSize ? `Task size (AI suggests: ${suggestedSize}):` : 'Task size:',\n        choices: [\n          {\n            name:\n              suggestedSize === 'S' ? `S ‚≠ê (AI suggested - ${estimation?.avgHours ?? 1}h)` : 'S',\n            value: 'S',\n            hint: 'Small - Less than 2 hours',\n          },\n          {\n            name:\n              suggestedSize === 'M' ? `M ‚≠ê (AI suggested - ${estimation?.avgHours ?? 3}h)` : 'M',\n            value: 'M',\n            hint: 'Medium - 2-4 hours',\n          },\n          {\n            name:\n              suggestedSize === 'L' ? `L ‚≠ê (AI suggested - ${estimation?.avgHours ?? 6}h)` : 'L',\n            value: 'L',\n            hint: 'Large - 4-8 hours',\n          },\n          {\n            name:\n              suggestedSize === 'XL'\n                ? `XL ‚≠ê (AI suggested - ${estimation?.avgHours ?? 12}h)`\n                : 'XL',\n            value: 'XL',\n            hint: 'Extra Large - More than 8 hours',\n          },\n          { name: 'Skip', value: undefined, hint: 'No size estimate' },\n        ],\n        initial: ((): number => {\n          if (suggestedSize) {\n            return TASK_SIZES.indexOf(suggestedSize);\n          }\n          if (defaults?.size) {\n            return TASK_SIZES.indexOf(defaults.size);\n          }\n          return 1;\n        })(),\n      },\n      {\n        type: 'input',\n        name: 'assignee',\n        message: 'Assignee (optional):',\n        initial: defaults?.assignee,\n        hint: 'Username or email',\n      },\n      {\n        type: 'input',\n        name: 'due_date',\n        message: 'Due date (optional):',\n        initial: defaults?.due_date,\n        hint: 'Format: YYYY-MM-DD',\n        validate: validateDate,\n      },\n      {\n        type: 'numeral',\n        name: 'estimated_hours',\n        message: 'Estimated hours (optional):',\n        initial: defaults?.estimated_hours,\n        float: true,\n        validate: (value: string): string | boolean => {\n          if (!value) return true;\n          return validateTimeEstimate(value);\n        },\n      },\n      {\n        type: 'list',\n        name: 'tags',\n        message: 'Tags (comma-separated, optional):',\n        initial: defaults?.tags?.join(', '),\n        separator: ',',\n        hint: 'e.g., frontend, bug, urgent',\n      },\n    ]);\n\n    // Merge basicInfo and additionalInfo\n    const response = {\n      title: basicInfo.title,\n      description: basicInfo.description,\n      ...additionalInfo,\n    };\n\n    // Clean up the response\n    const cleanedResponse: TaskInput = {\n      title: response.title,\n    };\n\n    if (response.description?.trim()) {\n      cleanedResponse.description = response.description.trim();\n    }\n    if (response.priority && response.priority !== 'undefined') {\n      cleanedResponse.priority = response.priority as Priority;\n    }\n    if (response.size && response.size !== 'undefined') {\n      cleanedResponse.size = response.size as TaskSize;\n    }\n    if (response.assignee?.trim()) {\n      cleanedResponse.assignee = response.assignee.trim();\n    }\n    if (response.due_date?.trim()) {\n      cleanedResponse.due_date = response.due_date.trim();\n    }\n    if (response.estimated_hours) {\n      cleanedResponse.estimated_hours = response.estimated_hours;\n    }\n    if (response.tags && response.tags.length > 0) {\n      cleanedResponse.tags = response.tags\n        .map((tag: string) => tag.trim())\n        .filter((tag: string) => tag.length > 0);\n    }\n\n    return cleanedResponse;\n  } catch (error) {\n    if (error instanceof PromptCancelledError) {\n      simpleFormatter.warn('\\n‚ö†Ô∏è  Task creation cancelled\\n');\n      throw error;\n    }\n    simpleFormatter.error(\n      `\\n‚ùå Failed to create task: ${error instanceof Error ? error.message : String(error)}`\n    );\n    throw error;\n  }\n}\n\n/**\n * Move task interactive prompt\n */\nexport async function moveTaskPrompt(\n  taskId: string,\n  availableColumns: Array<{ id: string; name: string; taskCount: number }>\n): Promise<MoveTaskInput> {\n  try {\n    simpleFormatter.info(chalk.cyan(`\\nüîÑ Move Task ${taskId}\\n`));\n    simpleFormatter.info(chalk.gray('Press Ctrl+C to cancel at any time\\n'));\n\n    const response = await safePrompt<{\n      targetColumn: string;\n      position: string;\n    }>([\n      {\n        type: 'select',\n        name: 'targetColumn',\n        message: 'Move to column:',\n        choices: availableColumns.map(col => ({\n          name: `${col.name} (${col.taskCount} tasks)`,\n          value: col.id,\n        })),\n      },\n      {\n        type: 'select',\n        name: 'position',\n        message: 'Position in column:',\n        choices: [\n          { name: 'Top', value: 'top' },\n          { name: 'Bottom', value: 'bottom' },\n          { name: 'Specific position', value: 'specific' },\n        ],\n      },\n    ]);\n\n    let position: number | undefined;\n\n    if (response.position === 'specific') {\n      const targetCol = availableColumns.find(c => c.id === response.targetColumn);\n      const maxPosition = targetCol?.taskCount ?? 0;\n\n      const posResponse = await safePrompt<{ position: number }>({\n        type: 'numeral',\n        name: 'position',\n        message: `Position (1-${maxPosition + 1}):`,\n        min: 1,\n        max: maxPosition + 1,\n        initial: 1,\n      });\n\n      position = posResponse.position - 1; // Convert to 0-based index\n    } else if (response.position === 'top') {\n      position = 0;\n    }\n    // 'bottom' leaves position undefined, which means append\n\n    return {\n      taskId,\n      targetColumn: response.targetColumn,\n      position,\n    };\n  } catch (error) {\n    if (error instanceof PromptCancelledError) {\n      simpleFormatter.warn('\\n‚ö†Ô∏è  Move operation cancelled\\n');\n      throw error;\n    }\n    simpleFormatter.error(\n      `\\n‚ùå Failed to move task: ${error instanceof Error ? error.message : String(error)}`\n    );\n    throw error;\n  }\n}\n\n/**\n * Bulk task action prompt\n */\nexport async function bulkTaskActionPrompt(\n  tasks: Array<{ id: string; title: string; status: string }>\n): Promise<BulkActionInput | null> {\n  try {\n    simpleFormatter.info(chalk.cyan(`\\nüì¶ Bulk Action for ${tasks.length} tasks\\n`));\n    simpleFormatter.info(chalk.gray('Press Ctrl+C to cancel at any time\\n'));\n\n    // Show selected tasks\n    simpleFormatter.info(chalk.gray('Selected tasks:'));\n    tasks.forEach((task, index) => {\n      if (index < 5) {\n        simpleFormatter.info(chalk.gray(`  - [${task.id}] ${task.title}`));\n      }\n    });\n    if (tasks.length > 5) {\n      simpleFormatter.info(chalk.gray(`  ... and ${tasks.length - 5} more`));\n    }\n    simpleFormatter.info('');\n\n    const { action } = await safePrompt<{ action: string }>({\n      type: 'select',\n      name: 'action',\n      message: 'Choose bulk action:',\n      choices: [\n        { name: 'Move to column', value: 'move' },\n        { name: 'Assign to user', value: 'assign' },\n        { name: 'Add tags', value: 'tag' },\n        { name: 'Archive tasks', value: 'archive' },\n        { name: 'Delete tasks', value: 'delete' },\n        { name: 'Cancel', value: 'cancel' },\n      ],\n    });\n\n    if (action === 'cancel') {\n      return null;\n    }\n\n    const taskIds = tasks.map(t => t.id);\n    const params: Record<string, unknown> = {};\n\n    switch (action) {\n      case 'move': {\n        const { column } = await safePrompt<{ column: string }>({\n          type: 'input',\n          name: 'column',\n          message: 'Target column name:',\n          validate: (value: string) => (value.trim() ? true : 'Column name required'),\n        });\n        params.column = column;\n        break;\n      }\n\n      case 'assign': {\n        const { assignee } = await safePrompt<{ assignee: string }>({\n          type: 'input',\n          name: 'assignee',\n          message: 'Assign to (username or email):',\n          validate: (value: string) => (value.trim() ? true : 'Assignee required'),\n        });\n        params.assignee = assignee;\n        break;\n      }\n\n      case 'tag': {\n        const { tags } = await safePrompt<{ tags: string[] }>({\n          type: 'list',\n          name: 'tags',\n          message: 'Add tags (comma-separated):',\n          separator: ',',\n          validate: (value: string[]) => (value.length > 0 ? true : 'At least one tag required'),\n        });\n        params.tags = tags.map(t => t.trim()).filter(t => t.length > 0);\n        break;\n      }\n\n      case 'delete': {\n        const { confirm } = await safePrompt<{ confirm: boolean }>({\n          type: 'confirm',\n          name: 'confirm',\n          message: chalk.red(`Are you sure you want to delete ${tasks.length} tasks?`),\n          initial: false,\n        });\n        if (!confirm) {\n          return null;\n        }\n        break;\n      }\n\n      case 'archive': {\n        const { confirm } = await safePrompt<{ confirm: boolean }>({\n          type: 'confirm',\n          name: 'confirm',\n          message: `Archive ${tasks.length} tasks?`,\n          initial: true,\n        });\n        if (!confirm) {\n          return null;\n        }\n        break;\n      }\n\n      default:\n        // Should never reach here due to action validation, but required for ESLint\n        throw new Error(`Unknown action: ${action}`);\n    }\n\n    return {\n      taskIds,\n      action: action as BulkActionInput['action'],\n      params: Object.keys(params).length > 0 ? params : undefined,\n    };\n  } catch (error) {\n    if (error instanceof PromptCancelledError) {\n      simpleFormatter.warn('\\n‚ö†Ô∏è  Bulk action cancelled\\n');\n      return null;\n    }\n    simpleFormatter.error(\n      `\\n‚ùå Failed to execute bulk action: ${error instanceof Error ? error.message : String(error)}`\n    );\n    throw error;\n  }\n}\n\n/**\n * Task filter prompt\n */\nexport async function taskFilterPrompt(): Promise<{\n  status?: string[];\n  priority?: Priority[];\n  assignee?: string;\n  tags?: string[];\n  dateRange?: { start: string; end: string };\n}> {\n  try {\n    simpleFormatter.info(chalk.cyan('\\nüîç Filter Tasks\\n'));\n    simpleFormatter.info(chalk.gray('Press Ctrl+C to cancel at any time\\n'));\n\n    const response = await safePrompt<{\n      filterBy: string[];\n    }>({\n      type: 'multiselect',\n      name: 'filterBy',\n      message: 'Filter by:',\n      choices: [\n        { name: 'Status', value: 'status' },\n        { name: 'Priority', value: 'priority' },\n        { name: 'Assignee', value: 'assignee' },\n        { name: 'Tags', value: 'tags' },\n        { name: 'Date range', value: 'dateRange' },\n      ],\n      hint: 'Space to select, Enter to continue',\n    });\n\n    const filters: Record<string, unknown> = {};\n\n    if (response.filterBy.includes('status')) {\n      const { status } = await safePrompt<{ status: string[] }>({\n        type: 'multiselect',\n        name: 'status',\n        message: 'Select statuses:',\n        choices: ['todo', 'in_progress', 'done', 'blocked', 'cancelled'],\n      });\n      if (status.length > 0) filters.status = status;\n    }\n\n    if (response.filterBy.includes('priority')) {\n      const { priority } = await safePrompt<{ priority: Priority[] }>({\n        type: 'multiselect',\n        name: 'priority',\n        message: 'Select priorities:',\n        choices: PRIORITIES.map(p => ({ name: p, value: p })),\n      });\n      if (priority.length > 0) filters.priority = priority;\n    }\n\n    if (response.filterBy.includes('assignee')) {\n      const { assignee } = await safePrompt<{ assignee: string }>({\n        type: 'input',\n        name: 'assignee',\n        message: 'Assignee (username or email):',\n      });\n      if (assignee.trim()) filters.assignee = assignee.trim();\n    }\n\n    if (response.filterBy.includes('tags')) {\n      const { tags } = await safePrompt<{ tags: string[] }>({\n        type: 'list',\n        name: 'tags',\n        message: 'Tags (comma-separated):',\n        separator: ',',\n      });\n      if (tags.length > 0) {\n        filters.tags = tags.map(t => t.trim()).filter(t => t.length > 0);\n      }\n    }\n\n    if (response.filterBy.includes('dateRange')) {\n      const dateRange = await safePrompt<{ start: string; end: string }>([\n        {\n          type: 'input',\n          name: 'start',\n          message: 'Start date (YYYY-MM-DD):',\n          validate: validateDate,\n        },\n        {\n          type: 'input',\n          name: 'end',\n          message: 'End date (YYYY-MM-DD):',\n          validate: validateDate,\n        },\n      ]);\n      if (dateRange.start && dateRange.end) {\n        filters.dateRange = dateRange;\n      }\n    }\n\n    return filters;\n  } catch (error) {\n    if (error instanceof PromptCancelledError) {\n      simpleFormatter.warn('\\n‚ö†Ô∏è  Filter cancelled\\n');\n      return {};\n    }\n    simpleFormatter.error(\n      `\\n‚ùå Failed to apply filters: ${error instanceof Error ? error.message : String(error)}`\n    );\n    throw error;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/prompts/validators.ts",
    "messages": [
      {
        "ruleId": "eqeqeq",
        "severity": 2,
        "message": "Expected '===' and instead saw '=='.",
        "line": 124,
        "column": 22,
        "nodeType": "BinaryExpression",
        "messageId": "unexpected",
        "endLine": 124,
        "endColumn": 24
      },
      {
        "ruleId": "no-script-url",
        "severity": 2,
        "message": "Script URL is a form of eval.",
        "line": 124,
        "column": 25,
        "nodeType": "Literal",
        "messageId": "unexpectedScriptURL",
        "endLine": 124,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'result' is already declared in the upper scope on line 506 column 11.",
        "line": 536,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 536,
        "endColumn": 79
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { z } from 'zod';\nimport {\n  sanitizeTaskTitle,\n  sanitizeDescription,\n  sanitizeName,\n  sanitizeTag,\n  sanitizeEmail,\n  sanitizeUrl,\n  createSafePromptValidator,\n  detectSuspicious,\n} from '../utils/input-sanitizer';\n\n/**\n * Input validation functions for CLI prompts with comprehensive sanitization\n * Enhanced for TASK-119: Input sanitization for all prompts\n */\n\n// Task size options\nexport const TASK_SIZES = ['XS', 'S', 'M', 'L', 'XL'] as const;\nexport type TaskSize = (typeof TASK_SIZES)[number];\n\n// Priority options\nexport const PRIORITIES = ['P1', 'P2', 'P3', 'P4', 'P5'] as const;\nexport type Priority = (typeof PRIORITIES)[number];\n\n// Status options\nexport const STATUSES = ['todo', 'in_progress', 'done', 'blocked', 'cancelled'] as const;\nexport type Status = (typeof STATUSES)[number];\n\n/**\n * Validate task title with comprehensive sanitization\n */\nexport const validateTaskTitle = createSafePromptValidator(\n  sanitizeTaskTitle,\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (!trimmed) {\n      return 'Task title cannot be empty';\n    }\n\n    if (trimmed.length < 3) {\n      return 'Task title must be at least 3 characters long';\n    }\n\n    if (trimmed.length > 200) {\n      return 'Task title must be less than 200 characters';\n    }\n\n    // Additional security checks\n    const suspiciousCheck = detectSuspicious(input);\n    if (suspiciousCheck.suspicious) {\n      return `Security issue: ${suspiciousCheck.patterns.join(', ')} detected in title`;\n    }\n\n    return true;\n  }\n);\n\n/**\n * Validate priority\n */\nexport function validatePriority(input: string): true | string {\n  const upperInput = input.toUpperCase();\n\n  if (!PRIORITIES.includes(upperInput as Priority)) {\n    return `Priority must be one of: ${PRIORITIES.join(', ')}`;\n  }\n\n  return true;\n}\n\n/**\n * Validate task size\n */\nexport function validateTaskSize(input: string): true | string {\n  const upperInput = input.toUpperCase();\n\n  if (!TASK_SIZES.includes(upperInput as TaskSize)) {\n    return `Task size must be one of: ${TASK_SIZES.join(', ')}`;\n  }\n\n  return true;\n}\n\n/**\n * Validate email address with sanitization\n */\nexport const validateEmail = createSafePromptValidator(\n  sanitizeEmail,\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (!trimmed) {\n      return 'Email address cannot be empty';\n    }\n\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(trimmed)) {\n      return 'Please enter a valid email address';\n    }\n\n    return true;\n  }\n);\n\n/**\n * Validate URL with sanitization\n */\nexport const validateUrl = createSafePromptValidator(\n  sanitizeUrl,\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (!trimmed) {\n      return 'URL cannot be empty';\n    }\n\n    try {\n      const url = new URL(trimmed);\n\n      // Additional security checks for URLs\n      if (\n        url.protocol == 'javascript:' ||\n        url.protocol === 'data:' ||\n        url.protocol === 'vbscript:'\n      ) {\n        return 'Unsafe URL protocol detected';\n      }\n\n      return true;\n    } catch {\n      return 'Please enter a valid URL';\n    }\n  }\n);\n\n/**\n * Validate git repository URL\n */\nexport function validateGitRepoUrl(input: string): true | string {\n  const urlValidation = validateUrl(input);\n  if (urlValidation !== true) {\n    return urlValidation;\n  }\n\n  const gitUrlRegex =\n    /^(https?:\\/\\/(github\\.com|gitlab\\.com|bitbucket\\.org)\\/[\\w-]+\\/[\\w-]+|git@(github\\.com|gitlab\\.com|bitbucket\\.org):[\\w-]+\\/[\\w-]+\\.git)$/;\n\n  if (!gitUrlRegex.test(input)) {\n    return 'Please enter a valid Git repository URL (GitHub, GitLab, or Bitbucket)';\n  }\n\n  return true;\n}\n\n/**\n * Validate board name with sanitization\n */\nexport const validateBoardName = createSafePromptValidator(\n  (input: string) => sanitizeName(input, 50),\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (!trimmed) {\n      return 'Board name cannot be empty';\n    }\n\n    if (trimmed.length < 2) {\n      return 'Board name must be at least 2 characters long';\n    }\n\n    if (trimmed.length > 50) {\n      return 'Board name must be less than 50 characters';\n    }\n\n    return true;\n  }\n);\n\n/**\n * Validate column name with sanitization\n */\nexport const validateColumnName = createSafePromptValidator(\n  (input: string) => sanitizeName(input, 30),\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (!trimmed) {\n      return 'Column name cannot be empty';\n    }\n\n    if (trimmed.length > 30) {\n      return 'Column name must be less than 30 characters';\n    }\n\n    return true;\n  }\n);\n\n/**\n * Validate tag name with sanitization\n */\nexport const validateTagName = createSafePromptValidator(\n  sanitizeTag,\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (!trimmed) {\n      return 'Tag name cannot be empty';\n    }\n\n    if (trimmed.length > 20) {\n      return 'Tag name must be less than 20 characters';\n    }\n\n    return true;\n  }\n);\n\n/**\n * Validate date input\n */\nexport function validateDate(input: string): true | string {\n  const trimmed = input.trim();\n\n  if (!trimmed) {\n    return true; // Date is optional\n  }\n\n  // Accept various date formats\n  const dateFormats = [\n    /^\\d{4}-\\d{2}-\\d{2}$/, // YYYY-MM-DD\n    /^\\d{2}\\/\\d{2}\\/\\d{4}$/, // MM/DD/YYYY\n    /^\\d{2}-\\d{2}-\\d{4}$/, // DD-MM-YYYY\n  ];\n\n  const matchesFormat = dateFormats.some(format => format.test(trimmed));\n  if (!matchesFormat) {\n    return 'Please enter a date in format YYYY-MM-DD, MM/DD/YYYY, or DD-MM-YYYY';\n  }\n\n  const date = new Date(trimmed);\n  if (Number.isNaN(date.getTime())) {\n    return 'Please enter a valid date';\n  }\n\n  return true;\n}\n\n/**\n * Validate time estimate (hours)\n */\nexport function validateTimeEstimate(input: string): true | string {\n  const trimmed = input.trim();\n\n  if (!trimmed) {\n    return true; // Time estimate is optional\n  }\n\n  const num = parseFloat(trimmed);\n  if (Number.isNaN(num)) {\n    return 'Please enter a valid number';\n  }\n\n  if (num <= 0) {\n    return 'Time estimate must be greater than 0';\n  }\n\n  if (num > 999) {\n    return 'Time estimate seems too high. Please enter a value less than 1000 hours';\n  }\n\n  return true;\n}\n\n/**\n * Validate percentage\n */\nexport function validatePercentage(input: string): true | string {\n  const trimmed = input.trim();\n\n  if (!trimmed) {\n    return 'Percentage cannot be empty';\n  }\n\n  const num = parseInt(trimmed, 10);\n  if (Number.isNaN(num)) {\n    return 'Please enter a valid number';\n  }\n\n  if (num < 0 || num > 100) {\n    return 'Percentage must be between 0 and 100';\n  }\n\n  return true;\n}\n\n/**\n * Create a custom validator with min/max length\n */\nexport function createLengthValidator(\n  fieldName: string,\n  minLength: number,\n  maxLength: number\n): (input: string) => true | string {\n  return (input: string) => {\n    const trimmed = input.trim();\n\n    if (!trimmed && minLength > 0) {\n      return `${String(fieldName)} cannot be empty`;\n    }\n\n    if (trimmed.length < minLength) {\n      return `${String(fieldName)} must be at least ${String(minLength)} characters long`;\n    }\n\n    if (trimmed.length > maxLength) {\n      return `${String(fieldName)} must be less than ${String(maxLength)} characters`;\n    }\n\n    return true;\n  };\n}\n\n/**\n * Create a custom enum validator\n */\nexport function createEnumValidator<T extends readonly string[]>(\n  fieldName: string,\n  validOptions: T\n): (input: string) => true | string {\n  return (input: string) => {\n    if (!validOptions.includes(input)) {\n      return `${fieldName} must be one of: ${validOptions.join(', ')}`;\n    }\n    return true;\n  };\n}\n\n/**\n * Zod schemas for more complex validation\n */\n\nexport const TaskSchema = z.object({\n  title: z.string().min(3).max(200),\n  description: z.string().optional(),\n  priority: z.enum(PRIORITIES).optional(),\n  size: z.enum(TASK_SIZES).optional(),\n  assignee: z.string().optional(),\n  due_date: z.string().datetime().optional(),\n  tags: z.array(z.string()).optional(),\n});\n\nexport const BoardSchema = z.object({\n  name: z\n    .string()\n    .min(2)\n    .max(50)\n    .regex(/^[\\w\\s-]+$/),\n  description: z.string().optional(),\n  columns: z.array(\n    z.object({\n      name: z.string().min(1).max(30),\n      order: z.number().int().min(0),\n    })\n  ),\n});\n\nexport type TaskInput = z.infer<typeof TaskSchema>;\nexport type BoardInput = z.infer<typeof BoardSchema>;\n\n/**\n * Additional sanitized validators for descriptions and other text inputs\n */\n\n/**\n * Validate task description with sanitization\n */\nexport const validateTaskDescription = createSafePromptValidator(\n  sanitizeDescription,\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (trimmed.length > 2000) {\n      return 'Description must be less than 2000 characters';\n    }\n\n    return true;\n  }\n);\n\n/**\n * Validate board description with sanitization\n */\nexport const validateBoardDescription = createSafePromptValidator(\n  sanitizeDescription,\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (trimmed.length > 500) {\n      return 'Board description must be less than 500 characters';\n    }\n\n    return true;\n  }\n);\n\n/**\n * Validate assignee name with sanitization\n */\nexport const validateAssignee = createSafePromptValidator(\n  (input: string) => sanitizeName(input, 100),\n  (input: string): true | string => {\n    const trimmed = input.trim();\n\n    if (trimmed.length > 100) {\n      return 'Assignee name must be less than 100 characters';\n    }\n\n    return true;\n  }\n);\n\n/**\n * Create safe versions of existing Zod schemas with sanitization\n */\nexport const SafeTaskSchema = z.object({\n  title: z\n    .string()\n    .transform(val => sanitizeTaskTitle(val).sanitized)\n    .pipe(z.string().min(3).max(200)),\n  description: z\n    .string()\n    .optional()\n    .transform(val => (val ? sanitizeDescription(val).sanitized : val)),\n  priority: z.enum(PRIORITIES).optional(),\n  size: z.enum(TASK_SIZES).optional(),\n  assignee: z\n    .string()\n    .optional()\n    .transform(val => (val ? sanitizeName(val, 100).sanitized : val)),\n  due_date: z.string().optional(),\n  tags: z.array(z.string().transform(val => sanitizeTag(val).sanitized)).optional(),\n});\n\nexport const SafeBoardSchema = z.object({\n  name: z\n    .string()\n    .transform(val => sanitizeName(val, 50).sanitized)\n    .pipe(z.string().min(2).max(50)),\n  description: z\n    .string()\n    .optional()\n    .transform(val => (val ? sanitizeDescription(val).sanitized : val)),\n  columns: z.array(\n    z.object({\n      name: z\n        .string()\n        .transform(val => sanitizeName(val, 30).sanitized)\n        .pipe(z.string().min(1).max(30)),\n      order: z.number().int().min(0),\n    })\n  ),\n});\n\nexport type SafeTaskInput = z.infer<typeof SafeTaskSchema>;\nexport type SafeBoardInput = z.infer<typeof SafeBoardSchema>;\n\n/**\n * Utility function to validate and sanitize any input\n */\nexport function validateAndSanitizeInput(\n  input: string,\n  type: 'title' | 'description' | 'name' | 'tag' | 'email' | 'url' | 'assignee'\n): { valid: boolean; sanitized: string; error?: string; warnings?: string[] } {\n  try {\n    let validator: (input: string) => true | string;\n\n    switch (type) {\n      case 'title':\n        validator = validateTaskTitle;\n        break;\n      case 'description':\n        validator = validateTaskDescription;\n        break;\n      case 'name':\n        validator = validateBoardName;\n        break;\n      case 'tag':\n        validator = validateTagName;\n        break;\n      case 'email':\n        validator = validateEmail;\n        break;\n      case 'url':\n        validator = validateUrl;\n        break;\n      case 'assignee':\n        validator = validateAssignee;\n        break;\n      default:\n        return { valid: false, sanitized: input, error: 'Unknown validation type' };\n    }\n\n    const result = validator(input);\n    if (result === true) {\n      // Get the sanitized version\n      let sanitized: string;\n      switch (type) {\n        case 'title':\n          sanitized = sanitizeTaskTitle(input).sanitized;\n          break;\n        case 'description':\n          sanitized = sanitizeDescription(input).sanitized;\n          break;\n        case 'name':\n          sanitized = sanitizeName(input).sanitized;\n          break;\n        case 'tag':\n          sanitized = sanitizeTag(input).sanitized;\n          break;\n        case 'email':\n          sanitized = sanitizeEmail(input).sanitized;\n          break;\n        case 'url':\n          sanitized = sanitizeUrl(input).sanitized;\n          break;\n        case 'assignee':\n          sanitized = sanitizeName(input, 100).sanitized;\n          break;\n        default:\n          sanitized = input;\n      }\n\n      const result: { valid: boolean; sanitized: string; warnings?: string[] } = {\n        valid: true,\n        sanitized,\n      };\n\n      if (sanitized !== input) {\n        result.warnings = ['Input was sanitized'];\n      }\n\n      return result;\n    }\n    return { valid: false, sanitized: input, error: result };\n  } catch (error) {\n    return {\n      valid: false,\n      sanitized: input,\n      error: `Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/services/dashboard-data.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 9,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 9,
        "endColumn": 56
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 9,
        "column": 54,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 9,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 37,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 37,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1166, 1169], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1166, 1169], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any[]` typed value.",
        "line": 43,
        "column": 7,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 43,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 68,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 68,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2133, 2136], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2133, 2136], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any[]` typed value.",
        "line": 74,
        "column": 7,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 74,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 85,
        "column": 43,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 85,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2717, 2720], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2717, 2720], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 96,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 96,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 96,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 96,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [status] resolves to an any value.",
        "line": 97,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 97,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [status] resolves to an any value.",
        "line": 97,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 97,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 100,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 100,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .priority on an `any` value.",
        "line": 100,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 100,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [priority] resolves to an any value.",
        "line": 101,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 101,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [priority] resolves to an any value.",
        "line": 101,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 101,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .due_date on an `any` value.",
        "line": 109,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 109,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 109,
        "column": 37,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 109,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .due_date on an `any` value.",
        "line": 109,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 109,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 140,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 140,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4342, 4345], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4342, 4345], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 142,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 142,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .completed_count on an `any` value.",
        "line": 142,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 142,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 160,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 160,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4963, 4966], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4963, 4966], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 161,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 161,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 161,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 161,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .username on an `any` value.",
        "line": 161,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 161,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 162,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 162,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .active_tasks on an `any` value.",
        "line": 162,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 162,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 163,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 163,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .workload_percentage on an `any` value.",
        "line": 163,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 163,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 181,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 181,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5628, 5631], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5628, 5631], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 182,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 182,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .day on an `any` value.",
        "line": 182,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 182,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 183,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 183,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .remaining_tasks on an `any` value.",
        "line": 183,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 183,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 184,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 184,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .ideal_remaining on an `any` value.",
        "line": 184,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 184,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 196,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 196,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6040, 6043], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6040, 6043], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 198,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 198,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .created_at on an `any` value.",
        "line": 198,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 198,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 203,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 203,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .user on an `any` value.",
        "line": 203,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 203,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .user on an `any` value.",
        "line": 203,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 203,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 210,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 210,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6502, 6505], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6502, 6505], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 211,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 211,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 211,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 211,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 212,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 212,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .entity_type on an `any` value.",
        "line": 212,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 212,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 213,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 214,
        "endColumn": 93
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .entity_name on an `any` value.",
        "line": 214,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 214,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .entity_id on an `any` value.",
        "line": 214,
        "column": 80,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 214,
        "endColumn": 89
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .details on an `any` value.",
        "line": 224,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 224,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .details on an `any` value.",
        "line": 226,
        "column": 76,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 226,
        "endColumn": 83
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 48,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { ApiClient } from '../client';\nimport type { DashboardData } from '../utils/dashboard-manager';\nimport { logger } from '../../utils/logger';\n\n/**\n * Service to fetch and transform data for dashboard components\n */\nexport class DashboardDataService {\n  constructor(private readonly apiClient: ApiClient) {}\n\n  /**\n   * Fetch complete dashboard data from API\n   */\n  async fetchDashboardData(): Promise<DashboardData> {\n    try {\n      const [tasks, activity] = await Promise.all([this.fetchTasks(), this.fetchActivity()]);\n\n      return {\n        tasks: DashboardDataService.transformTaskData(tasks),\n        velocity: await this.calculateVelocity(),\n        teamMembers: await this.fetchTeamMembers(),\n        burndown: await this.calculateBurndown(),\n        activity: DashboardDataService.transformActivityData(activity),\n      };\n    } catch (error) {\n      logger.warn(\n        'Failed to fetch dashboard data, using sample data:',\n        error instanceof Error ? error.message : 'Unknown error'\n      );\n      return DashboardDataService.generateSampleData();\n    }\n  }\n\n  /**\n   * Fetch tasks from API\n   */\n  private async fetchTasks(): Promise<any[]> {\n    try {\n      const response = await this.apiClient.get('/tasks', {\n        // include_archived: false, // Not supported in RequestOptions type\n        // limit: 1000, // Not supported in RequestOptions type\n      });\n      return 'data' in response && Array.isArray(response.data) ? response.data : [];\n    } catch (error) {\n      throw new Error(\n        `Failed to fetch tasks: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n      );\n    }\n  }\n\n  /**\n   * Fetch boards from API\n   */\n  // private async fetchBoards(): Promise<any[]> {\n  //   try {\n  //     const response = await this.apiClient.get('/boards');\n  //     return response.data ?? [];\n  //   } catch (error) {\n  //     throw new Error(\n  //       `Failed to fetch boards: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n  //     );\n  //   }\n  // }\n\n  /**\n   * Fetch activity from API\n   */\n  private async fetchActivity(): Promise<any[]> {\n    try {\n      const response = await this.apiClient.get('/activity', {\n        // limit: 20, // Not supported in RequestOptions type\n        // order: 'desc', // Not supported in RequestOptions type\n      });\n      return 'data' in response && Array.isArray(response.data) ? response.data : [];\n    } catch (error) {\n      throw new Error(\n        `Failed to fetch activity: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n      );\n    }\n  }\n\n  /**\n   * Transform task data for dashboard display\n   */\n  private static transformTaskData(tasks: any[]): DashboardData['tasks'] {\n    const total = tasks.length;\n    const byStatus: Record<string, number> = {};\n    const byPriority: Record<string, number> = {};\n    let completed = 0;\n    let overdue = 0;\n\n    const now = new Date();\n\n    tasks.forEach(task => {\n      // Count by status\n      const status = task.status ?? 'todo';\n      byStatus[status] = (byStatus[status] ?? 0) + 1;\n\n      // Count by priority\n      const priority = task.priority ?? 'P3';\n      byPriority[priority] = (byPriority[priority] ?? 0) + 1;\n\n      // Count completed\n      if (status === 'done' || status === 'completed') {\n        completed += 1;\n      }\n\n      // Count overdue\n      if (task.due_date && new Date(task.due_date) < now && status !== 'done') {\n        overdue += 1;\n      }\n    });\n\n    return {\n      total,\n      byStatus,\n      byPriority,\n      completed,\n      overdue,\n    };\n  }\n\n  /**\n   * Calculate velocity data (tasks completed per week)\n   */\n  private async calculateVelocity(): Promise<DashboardData['velocity']> {\n    try {\n      const endDate = new Date();\n      const startDate = new Date();\n      startDate.setDate(endDate.getDate() - 8 * 7); // 8 weeks back\n\n      const response = await this.apiClient.get('/analytics/velocity', {\n        // start_date: startDate.toISOString(), // Not supported in RequestOptions type\n        // end_date: endDate.toISOString(), // Not supported in RequestOptions type\n        // group_by: 'week', // Not supported in RequestOptions type\n      });\n\n      return (\n        ('data' in response && Array.isArray(response.data) ? response.data : [])?.map(\n          (item: any, index: number) => ({\n            period: `W${String(index + 1)}`,\n            completed: item.completed_count ?? 0,\n          })\n        ) || DashboardDataService.generateSampleVelocity()\n      );\n    } catch (error) {\n      return DashboardDataService.generateSampleVelocity();\n    }\n  }\n\n  /**\n   * Fetch team member data\n   */\n  private async fetchTeamMembers(): Promise<DashboardData['teamMembers']> {\n    try {\n      const response = await this.apiClient.get('/analytics/team-workload');\n\n      return (\n        ('data' in response && Array.isArray(response.data) ? response.data : [])?.map(\n          (member: any) => ({\n            name: member.name ?? member.username,\n            taskCount: member.active_tasks ?? 0,\n            load: member.workload_percentage ?? 0,\n          })\n        ) || DashboardDataService.generateSampleTeamMembers()\n      );\n    } catch (error) {\n      return DashboardDataService.generateSampleTeamMembers();\n    }\n  }\n\n  /**\n   * Calculate burndown chart data\n   */\n  private async calculateBurndown(): Promise<DashboardData['burndown']> {\n    try {\n      const response = await this.apiClient.get('/analytics/burndown');\n\n      return (\n        ('data' in response && Array.isArray(response.data) ? response.data : [])?.map(\n          (item: any) => ({\n            day: item.day,\n            remaining: item.remaining_tasks ?? 0,\n            ideal: item.ideal_remaining ?? 0,\n          })\n        ) || DashboardDataService.generateSampleBurndown()\n      );\n    } catch (error) {\n      return DashboardDataService.generateSampleBurndown();\n    }\n  }\n\n  /**\n   * Transform activity data for display\n   */\n  private static transformActivityData(activities: any[]): DashboardData['activity'] {\n    return activities.slice(0, 10).map(activity => ({\n      timestamp: new Date(activity.created_at).toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit',\n      }),\n      event: this.formatActivityEvent(activity),\n      user: activity.user?.name ?? activity.user?.username ?? 'System',\n    }));\n  }\n\n  /**\n   * Format activity event for display\n   */\n  private static formatActivityEvent(activity: any): string {\n    const action = activity.action ?? 'updated';\n    const entityType = activity.entity_type ?? 'task';\n    const entityName =\n      activity.entity_name ?? `${String(entityType)} #${String(String(activity.entity_id))}`;\n\n    switch (action) {\n      case 'create':\n        return `Created ${String(entityType)}: ${String(entityName)}`;\n      case 'update':\n        return `Updated ${String(entityType)}: ${String(entityName)}`;\n      case 'delete':\n        return `Deleted ${String(entityType)}: ${String(entityName)}`;\n      case 'move':\n        return `Moved ${String(entityName)} to ${String(String(activity.details?.new_status))}`;\n      case 'assign':\n        return `Assigned ${String(entityName)} to ${String(String(activity.details?.assignee))}`;\n      case 'comment':\n        return `Commented on ${String(entityName)}`;\n      default:\n        return `${String(action)} ${String(entityName)}`;\n    }\n  }\n\n  /**\n   * Generate sample velocity data as fallback\n   */\n  private static generateSampleVelocity(): DashboardData['velocity'] {\n    return [\n      { period: 'W1', completed: 12 },\n      { period: 'W2', completed: 15 },\n      { period: 'W3', completed: 18 },\n      { period: 'W4', completed: 14 },\n      { period: 'W5', completed: 20 },\n      { period: 'W6', completed: 16 },\n      { period: 'W7', completed: 22 },\n      { period: 'W8', completed: 19 },\n    ];\n  }\n\n  /**\n   * Generate sample team data as fallback\n   */\n  private static generateSampleTeamMembers(): DashboardData['teamMembers'] {\n    return [\n      { name: 'Alice', taskCount: 8, load: 85 },\n      { name: 'Bob', taskCount: 6, load: 70 },\n      { name: 'Charlie', taskCount: 10, load: 95 },\n      { name: 'Diana', taskCount: 7, load: 75 },\n    ];\n  }\n\n  /**\n   * Generate sample burndown data as fallback\n   */\n  private static generateSampleBurndown(): DashboardData['burndown'] {\n    return [\n      { day: 'Day 1', remaining: 45, ideal: 45 },\n      { day: 'Day 2', remaining: 42, ideal: 40 },\n      { day: 'Day 3', remaining: 38, ideal: 35 },\n      { day: 'Day 4', remaining: 35, ideal: 30 },\n      { day: 'Day 5', remaining: 30, ideal: 25 },\n      { day: 'Day 6', remaining: 28, ideal: 20 },\n      { day: 'Day 7', remaining: 25, ideal: 15 },\n      { day: 'Day 8', remaining: 20, ideal: 10 },\n      { day: 'Day 9', remaining: 15, ideal: 5 },\n      { day: 'Day 10', remaining: 12, ideal: 0 },\n    ];\n  }\n\n  /**\n   * Generate complete sample data as fallback\n   */\n  private static generateSampleData(): DashboardData {\n    return {\n      tasks: {\n        total: 45,\n        byStatus: {\n          todo: 18,\n          in_progress: 12,\n          done: 13,\n          blocked: 2,\n        },\n        byPriority: {\n          P1: 8,\n          P2: 15,\n          P3: 18,\n          P4: 4,\n        },\n        completed: 13,\n        overdue: 3,\n      },\n      velocity: this.generateSampleVelocity(),\n      teamMembers: this.generateSampleTeamMembers(),\n      burndown: this.generateSampleBurndown(),\n      activity: [\n        { timestamp: '14:32', event: 'Task completed: User Auth', user: 'Alice' },\n        { timestamp: '14:15', event: 'New task created: Fix login bug', user: 'Bob' },\n        { timestamp: '13:45', event: 'Task moved to In Progress', user: 'Charlie' },\n        { timestamp: '13:20', event: 'Comment added to TASK-123', user: 'Diana' },\n        { timestamp: '12:55', event: 'Task assigned to Alice', user: 'Bob' },\n      ],\n    };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/types.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "vars-on-top",
        "severity": 2,
        "message": "All 'var' declarations must be at the top of the function scope.",
        "line": 20,
        "column": 3,
        "nodeType": "VariableDeclaration",
        "messageId": "top",
        "endLine": 20,
        "endColumn": 36,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-var",
        "severity": 2,
        "message": "Unexpected var, use let or const instead.",
        "line": 20,
        "column": 3,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpectedVar",
        "endLine": 20,
        "endColumn": 36,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/ui/themes/dashboard-themes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 340,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 340,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 350,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 350,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 360,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 360,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 373,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 373,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 385,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 385,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 395,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 395,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 405,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 405,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 414,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 414,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 427,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 427,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 440,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 440,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Dashboard theme configurations for blessed-contrib\n */\n\nexport interface DashboardTheme {\n  name: string;\n  colors: {\n    primary: string;\n    secondary: string;\n    success: string;\n    warning: string;\n    error: string;\n    info: string;\n    background: string;\n    foreground: string;\n    border: string;\n    accent: string;\n  };\n  widgets: {\n    donut: {\n      remainColor: string;\n      colors: string[];\n    };\n    bar: {\n      barColor: string;\n      textColor: string;\n    };\n    line: {\n      lineColor: string;\n      textColor: string;\n      baseline: string;\n    };\n    table: {\n      fg: string;\n      selectedFg: string;\n      selectedBg: string;\n      border: string;\n    };\n    log: {\n      fg: string;\n      selectedFg: string;\n    };\n    gauge: {\n      stroke: string;\n      fill: string;\n    };\n    sparkline: {\n      fg: string;\n    };\n    box: {\n      fg: string;\n      bg: string;\n      border: string;\n    };\n  };\n}\n\n/**\n * Dark theme (default)\n */\nexport const darkTheme: DashboardTheme = {\n  name: 'dark',\n  colors: {\n    primary: 'cyan',\n    secondary: 'blue',\n    success: 'green',\n    warning: 'yellow',\n    error: 'red',\n    info: 'magenta',\n    background: 'black',\n    foreground: 'white',\n    border: 'cyan',\n    accent: 'yellow',\n  },\n  widgets: {\n    donut: {\n      remainColor: 'black',\n      colors: ['green', 'yellow', 'red', 'blue', 'magenta', 'cyan'],\n    },\n    bar: {\n      barColor: 'cyan',\n      textColor: 'white',\n    },\n    line: {\n      lineColor: 'yellow',\n      textColor: 'green',\n      baseline: 'black',\n    },\n    table: {\n      fg: 'white',\n      selectedFg: 'white',\n      selectedBg: 'blue',\n      border: 'cyan',\n    },\n    log: {\n      fg: 'green',\n      selectedFg: 'green',\n    },\n    gauge: {\n      stroke: 'green',\n      fill: 'white',\n    },\n    sparkline: {\n      fg: 'blue',\n    },\n    box: {\n      fg: 'white',\n      bg: 'black',\n      border: 'cyan',\n    },\n  },\n};\n\n/**\n * Light theme\n */\nexport const lightTheme: DashboardTheme = {\n  name: 'light',\n  colors: {\n    primary: 'blue',\n    secondary: 'gray',\n    success: 'green',\n    warning: 'orange',\n    error: 'red',\n    info: 'purple',\n    background: 'white',\n    foreground: 'black',\n    border: 'gray',\n    accent: 'blue',\n  },\n  widgets: {\n    donut: {\n      remainColor: 'white',\n      colors: ['green', 'orange', 'red', 'blue', 'purple', 'gray'],\n    },\n    bar: {\n      barColor: 'blue',\n      textColor: 'black',\n    },\n    line: {\n      lineColor: 'blue',\n      textColor: 'black',\n      baseline: 'gray',\n    },\n    table: {\n      fg: 'black',\n      selectedFg: 'white',\n      selectedBg: 'blue',\n      border: 'gray',\n    },\n    log: {\n      fg: 'black',\n      selectedFg: 'black',\n    },\n    gauge: {\n      stroke: 'blue',\n      fill: 'black',\n    },\n    sparkline: {\n      fg: 'blue',\n    },\n    box: {\n      fg: 'black',\n      bg: 'white',\n      border: 'gray',\n    },\n  },\n};\n\n/**\n * High contrast theme for accessibility\n */\nexport const highContrastTheme: DashboardTheme = {\n  name: 'high-contrast',\n  colors: {\n    primary: 'white',\n    secondary: 'yellow',\n    success: 'green',\n    warning: 'yellow',\n    error: 'red',\n    info: 'cyan',\n    background: 'black',\n    foreground: 'white',\n    border: 'white',\n    accent: 'yellow',\n  },\n  widgets: {\n    donut: {\n      remainColor: 'black',\n      colors: ['white', 'yellow', 'red', 'green', 'cyan', 'magenta'],\n    },\n    bar: {\n      barColor: 'white',\n      textColor: 'white',\n    },\n    line: {\n      lineColor: 'white',\n      textColor: 'white',\n      baseline: 'black',\n    },\n    table: {\n      fg: 'white',\n      selectedFg: 'black',\n      selectedBg: 'white',\n      border: 'white',\n    },\n    log: {\n      fg: 'white',\n      selectedFg: 'white',\n    },\n    gauge: {\n      stroke: 'white',\n      fill: 'white',\n    },\n    sparkline: {\n      fg: 'white',\n    },\n    box: {\n      fg: 'white',\n      bg: 'black',\n      border: 'white',\n    },\n  },\n};\n\n/**\n * Solarized dark theme\n */\nexport const solarizedDarkTheme: DashboardTheme = {\n  name: 'solarized-dark',\n  colors: {\n    primary: 'cyan',\n    secondary: 'blue',\n    success: 'green',\n    warning: 'yellow',\n    error: 'red',\n    info: 'magenta',\n    background: 'black',\n    foreground: 'gray',\n    border: 'cyan',\n    accent: 'blue',\n  },\n  widgets: {\n    donut: {\n      remainColor: 'black',\n      colors: ['cyan', 'green', 'yellow', 'blue', 'magenta', 'red'],\n    },\n    bar: {\n      barColor: 'cyan',\n      textColor: 'gray',\n    },\n    line: {\n      lineColor: 'cyan',\n      textColor: 'gray',\n      baseline: 'black',\n    },\n    table: {\n      fg: 'gray',\n      selectedFg: 'white',\n      selectedBg: 'blue',\n      border: 'cyan',\n    },\n    log: {\n      fg: 'cyan',\n      selectedFg: 'cyan',\n    },\n    gauge: {\n      stroke: 'cyan',\n      fill: 'gray',\n    },\n    sparkline: {\n      fg: 'cyan',\n    },\n    box: {\n      fg: 'gray',\n      bg: 'black',\n      border: 'cyan',\n    },\n  },\n};\n\n/**\n * Available themes registry\n */\nexport const themes: Record<string, DashboardTheme> = {\n  dark: darkTheme,\n  light: lightTheme,\n  'high-contrast': highContrastTheme,\n  'solarized-dark': solarizedDarkTheme,\n};\n\n/**\n * Get theme by name with fallback to dark theme\n */\nexport function getTheme(name: string): DashboardTheme {\n  return themes[name] ?? darkTheme;\n}\n\n/**\n * Get all available theme names\n */\nexport function getThemeNames(): string[] {\n  return Object.keys(themes);\n}\n\n/**\n * Theme helper functions\n */\nexport class ThemeHelper {\n  private readonly theme: DashboardTheme;\n\n  constructor(themeName: string = 'dark') {\n    this.theme = getTheme(themeName);\n  }\n\n  /**\n   * Update theme\n   */\n  setTheme(themeName: string): void {\n    this.theme = getTheme(themeName);\n  }\n\n  /**\n   * Get current theme\n   */\n  getTheme(): DashboardTheme {\n    return this.theme;\n  }\n\n  /**\n   * Get color by name\n   */\n  getColor(colorName: keyof DashboardTheme['colors']): string {\n    return this.theme.colors[colorName];\n  }\n\n  /**\n   * Get widget styles for donut charts\n   */\n  getDonutStyles() {\n    return {\n      remainColor: this.theme.widgets.donut.remainColor,\n      colors: this.theme.widgets.donut.colors,\n    };\n  }\n\n  /**\n   * Get widget styles for bar charts\n   */\n  getBarStyles() {\n    return {\n      barColor: this.theme.widgets.bar.barColor,\n      textColor: this.theme.widgets.bar.textColor,\n    };\n  }\n\n  /**\n   * Get widget styles for line charts\n   */\n  getLineStyles() {\n    return {\n      style: {\n        line: this.theme.widgets.line.lineColor,\n        text: this.theme.widgets.line.textColor,\n        baseline: this.theme.widgets.line.baseline,\n      },\n    };\n  }\n\n  /**\n   * Get widget styles for tables\n   */\n  getTableStyles() {\n    return {\n      fg: this.theme.widgets.table.fg,\n      selectedFg: this.theme.widgets.table.selectedFg,\n      selectedBg: this.theme.widgets.table.selectedBg,\n      border: { type: 'line', fg: this.theme.widgets.table.border },\n    };\n  }\n\n  /**\n   * Get widget styles for log widgets\n   */\n  getLogStyles() {\n    return {\n      fg: this.theme.widgets.log.fg,\n      selectedFg: this.theme.widgets.log.selectedFg,\n    };\n  }\n\n  /**\n   * Get widget styles for gauge widgets\n   */\n  getGaugeStyles() {\n    return {\n      stroke: this.theme.widgets.gauge.stroke,\n      fill: this.theme.widgets.gauge.fill,\n    };\n  }\n\n  /**\n   * Get widget styles for sparkline widgets\n   */\n  getSparklineStyles() {\n    return {\n      style: { fg: this.theme.widgets.sparkline.fg },\n    };\n  }\n\n  /**\n   * Get widget styles for box widgets\n   */\n  getBoxStyles() {\n    return {\n      style: {\n        fg: this.theme.widgets.box.fg,\n        bg: this.theme.widgets.box.bg,\n      },\n      border: { type: 'line', fg: this.theme.widgets.box.border },\n    };\n  }\n\n  /**\n   * Get header styles\n   */\n  getHeaderStyles() {\n    return {\n      border: { type: 'line', fg: this.theme.colors.border },\n      style: {\n        fg: this.theme.colors.foreground,\n        bg: this.theme.colors.secondary,\n      },\n    };\n  }\n\n  /**\n   * Get footer styles\n   */\n  getFooterStyles() {\n    return {\n      border: { type: 'line', fg: this.theme.colors.border },\n      style: { fg: this.theme.colors.foreground },\n    };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/ui/themes/default.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/__tests__/date-formatter.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/__tests__/formatter.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/__tests__/spinner.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/board-formatter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 58,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 58,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 58,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 58,
        "endColumn": 45
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'formatBoardList'.",
        "line": 128,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 128,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 175,
        "column": 66,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 175,
        "endColumn": 68,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [4456, 4458], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .totalTasks on an `any` value.",
        "line": 202,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 202,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .overdueTasks on an `any` value.",
        "line": 204,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 204,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .overdueTasks on an `any` value.",
        "line": 205,
        "column": 68,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 205,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tasksByPriority on an `any` value.",
        "line": 208,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 208,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tasksByPriority on an `any` value.",
        "line": 210,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 210,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
        "line": 211,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 211,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
        "line": 211,
        "column": 52,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 211,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .totalTasks on an `any` value.",
        "line": 211,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 211,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any[]` typed value.",
        "line": 229,
        "column": 5,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 229,
        "endColumn": 63
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'exportBoard'.",
        "line": 235,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 235,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 10,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import chalk from 'chalk';\nimport Table from 'cli-table3';\nimport { formatTaskListItem, formatBoardColumn, formatPercentage, truncate } from './formatter';\n\nexport interface Task {\n  id: string;\n  title: string;\n  description?: string;\n  status: string;\n  priority?: string;\n  assignee?: string;\n  due_date?: string;\n  tags?: string[];\n}\n\nexport interface Column {\n  id: string;\n  name: string;\n  tasks: Task[];\n  order: number;\n}\n\nexport interface Board {\n  id: string;\n  name: string;\n  description?: string;\n  columns: Column[];\n}\n\n/**\n * Format board output for CLI display\n */\nexport class BoardFormatter {\n  /**\n   * Format a complete board view\n   */\n  formatBoard(\n    board: Board,\n    options?: {\n      maxWidth?: number;\n      showDescription?: boolean;\n      showStats?: boolean;\n    }\n  ): string {\n    const { maxWidth = 120, showDescription = true, showStats = true } = options ?? {};\n    const output: string[] = [];\n\n    // Board header\n    output.push(chalk.bold.cyan(`\\nüìã ${String(String(board.name))}\\n`));\n\n    if (showDescription && board.description) {\n      output.push(chalk.gray(board.description));\n      output.push('');\n    }\n\n    // Board stats\n    if (showStats) {\n      const stats = this.calculateBoardStats(board);\n      output.push(BoardFormatter.formatBoardStats(stats));\n      output.push('');\n    }\n\n    // Create table for columns\n    const table = new Table({\n      head: board.columns.map(col => formatBoardColumn(col.name, col.tasks.length)),\n      style: { head: ['cyan'] },\n      colWidths: BoardFormatter.calculateColumnWidths(board.columns.length, maxWidth),\n      wordWrap: true,\n    });\n\n    // Find max tasks in any column\n    const maxTasks = Math.max(...board.columns.map(col => col.tasks.length));\n\n    // Add rows\n    for (let i = 0; i < maxTasks; i += 1) {\n      const row = board.columns.map(col => {\n        const task = col.tasks[i];\n        return task ? BoardFormatter.formatTaskCard(task) : '';\n      });\n      table.push(row);\n    }\n\n    output.push(table.toString());\n    return output.join('\\n');\n  }\n\n  /**\n   * Format a single task card for board view\n   */\n  private static formatTaskCard(task: Task): string {\n    const lines: string[] = [];\n\n    // Task ID and title\n    lines.push(chalk.bold(`[${String(String(task.id))}]`));\n    lines.push(truncate(task.title, 30));\n\n    // Priority and status\n    if (task.priority) {\n      lines.push(`Priority: ${String(String(task.priority))}`);\n    }\n\n    // Assignee\n    if (task.assignee) {\n      lines.push(chalk.cyan(`@${String(String(task.assignee))}`));\n    }\n\n    // Due date\n    if (task.due_date) {\n      const dueDate = new Date(task.due_date);\n      const isOverdue = dueDate < new Date();\n      const dateStr = dueDate.toLocaleDateString();\n      lines.push(\n        isOverdue ? chalk.red(`‚è∞ ${String(dateStr)}`) : chalk.gray(`üìÖ ${String(dateStr)}`)\n      );\n    }\n\n    // Tags\n    if (task.tags && task.tags.length > 0) {\n      lines.push(task.tags.map(tag => chalk.magenta(`#${String(tag)}`)).join(' '));\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Format board as a simple list view\n   */\n  formatBoardList(board: Board): string {\n    const output: string[] = [];\n\n    output.push(chalk.bold.cyan(`\\nüìã ${String(String(board.name))}\\n`));\n\n    for (const column of board.columns) {\n      output.push(\n        chalk.bold.underline(\n          `\\n${String(String(column.name))} (${String(String(column.tasks.length))})`\n        )\n      );\n\n      if (column.tasks.length === 0) {\n        output.push(chalk.gray('  No tasks'));\n      } else {\n        for (const task of column.tasks) {\n          output.push(`  ${formatTaskListItem(task)}`);\n        }\n      }\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate board statistics\n   */\n  private static calculateBoardStats(board: Board): {\n    totalTasks: number;\n    tasksByColumn: Map<string, number>;\n    tasksByPriority: Map<string, number>;\n    overdueTasks: number;\n  } {\n    const stats = {\n      totalTasks: 0,\n      tasksByColumn: new Map<string, number>(),\n      tasksByPriority: new Map<string, number>(),\n      overdueTasks: 0,\n    };\n\n    for (const column of board.columns) {\n      stats.tasksByColumn.set(column.name, column.tasks.length);\n      stats.totalTasks += column.tasks.length;\n\n      for (const task of column.tasks) {\n        // Count by priority\n        if (task.priority) {\n          const count = stats.tasksByPriority.get(task.priority) || 0;\n          stats.tasksByPriority.set(task.priority, count + 1);\n        }\n\n        // Count overdue\n        if (task.due_date) {\n          const dueDate = new Date(task.due_date);\n          if (dueDate < new Date()) {\n            stats.overdueTasks += 1;\n          }\n        }\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Format board statistics\n   */\n  private static formatBoardStats(\n    stats: ReturnType<BoardFormatter['calculateBoardStats']>\n  ): string {\n    const lines: string[] = [];\n\n    lines.push(chalk.gray('‚îÄ'.repeat(40)));\n    lines.push(chalk.bold('Board Statistics:'));\n    lines.push(`  Total Tasks: ${String(String(stats.totalTasks))}`);\n\n    if (stats.overdueTasks > 0) {\n      lines.push(chalk.red(`  Overdue Tasks: ${String(String(stats.overdueTasks))}`));\n    }\n\n    if (stats.tasksByPriority.size > 0) {\n      lines.push('  By Priority:');\n      for (const [priority, count] of stats.tasksByPriority) {\n        const percentage = formatPercentage(count, stats.totalTasks);\n        lines.push(`    ${String(priority)}: ${String(count)} (${String(percentage)})`);\n      }\n    }\n\n    lines.push(chalk.gray('‚îÄ'.repeat(40)));\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Calculate column widths for table display\n   */\n  private static calculateColumnWidths(columnCount: number, maxWidth: number): number[] {\n    const borderWidth = (columnCount + 1) * 3; // Account for table borders\n    const availableWidth = maxWidth - borderWidth;\n    const columnWidth = Math.floor(availableWidth / columnCount);\n\n    return Array(columnCount).fill(Math.max(columnWidth, 20));\n  }\n\n  /**\n   * Format board for export (CSV, JSON, etc.)\n   */\n  exportBoard(board: Board, format: 'csv' | 'json' = 'json'): string {\n    if (format === 'json') {\n      return JSON.stringify(board, null, 2);\n    }\n\n    // CSV format\n    const lines: string[] = [];\n    lines.push('Column,Task ID,Title,Status,Priority,Assignee,Due Date,Tags');\n\n    for (const column of board.columns) {\n      for (const task of column.tasks) {\n        const row = [\n          column.name,\n          task.id,\n          `\"${String(String(task.title.replace(/\"/g, '\"\"')))}\"`,\n          task.status,\n          task.priority ?? '',\n          task.assignee ?? '',\n          task.due_date ?? '',\n          (task.tags ?? []).join(';'),\n        ];\n        lines.push(row.join(','));\n      }\n    }\n\n    return lines.join('\\n');\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/command-injection-prevention.ts",
    "messages": [
      {
        "ruleId": "max-classes-per-file",
        "severity": 2,
        "message": "File has too many classes (2). Maximum allowed is 1.",
        "line": 10,
        "column": 1,
        "nodeType": "Program",
        "messageId": "maximumExceeded",
        "endLine": 971,
        "endColumn": 1
      },
      {
        "ruleId": "no-control-regex",
        "severity": 2,
        "message": "Unexpected control character(s) in regular expression: \\x00.",
        "line": 175,
        "column": 7,
        "nodeType": "Literal",
        "messageId": "unexpected",
        "endLine": 175,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 473,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 473,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .toString on an `any` value.",
        "line": 473,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 473,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 477,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 477,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .toString on an `any` value.",
        "line": 477,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 477,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 529,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 529,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 531,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 531,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 543,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 543,
        "endColumn": 16
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'validateFilePath'.",
        "line": 648,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 648,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 726,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 726,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 746,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 746,
        "endColumn": 5
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 761,
        "column": 85,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 761,
        "endColumn": 87
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 777,
        "column": 87,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 777,
        "endColumn": 89
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Command Injection Prevention Module\n * Addresses TASK-120: Add command injection prevention\n *\n * This module provides comprehensive protection against command injection attacks\n * in CLI applications by sanitizing inputs and preventing execution of malicious commands.\n */\n\n// import type { SpawnOptions } from 'child_process';\nimport { spawn } from 'child_process';\nimport path from 'path';\nimport { logger } from '@/utils/logger';\nimport { inputSanitizer } from './input-sanitizer';\n\n/**\n * Options for command execution with security controls\n *\n * @interface CommandExecutionOptions\n * @property {string[]} [allowedCommands] - Whitelist of allowed commands\n * @property {string[]} [allowedFlags] - Whitelist of allowed command flags\n * @property {boolean} [restrictToWorkingDir] - Restrict file paths to current working directory\n * @property {number} [timeout] - Command execution timeout in milliseconds\n * @property {Record<string, string>} [env] - Additional environment variables\n * @property {boolean} [validateArgs] - Whether to validate arguments\n * @property {boolean} [logExecution] - Whether to log command execution\n */\nexport interface CommandExecutionOptions {\n  allowedCommands?: string[];\n  allowedFlags?: string[];\n  restrictToWorkingDir?: boolean;\n  timeout?: number;\n  env?: Record<string, string>;\n  validateArgs?: boolean;\n  logExecution?: boolean;\n}\n\n/**\n * Result of command validation with security analysis\n *\n * @interface CommandValidationResult\n * @property {boolean} safe - Whether the command is safe to execute\n * @property {string} sanitizedCommand - Sanitized command name\n * @property {string[]} sanitizedArgs - Sanitized command arguments\n * @property {string[]} warnings - Non-critical security warnings\n * @property {string[]} blockedPatterns - Critical patterns that blocked execution\n */\nexport interface CommandValidationResult {\n  safe: boolean;\n  sanitizedCommand: string;\n  sanitizedArgs: string[];\n  warnings: string[];\n  blockedPatterns: string[];\n}\n\n/**\n * Result of safe command execution\n *\n * @interface ExecutionResult\n * @property {boolean} success - Whether the command executed successfully\n * @property {string} stdout - Standard output from the command\n * @property {string} stderr - Standard error output from the command\n * @property {number} exitCode - Process exit code\n * @property {number} duration - Execution duration in milliseconds\n * @property {string} command - The command that was executed\n * @property {string[]} args - The arguments that were passed\n */\nexport interface ExecutionResult {\n  success: boolean;\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n  duration: number;\n  command: string;\n  args: string[];\n}\n\n/**\n * Command injection prevention class with comprehensive security measures\n *\n * @class CommandInjectionPrevention\n * @description Provides robust protection against command injection attacks by\n * validating, sanitizing, and safely executing CLI commands. Uses multiple\n * layers of security including whitelisting, pattern detection, and path validation.\n *\n * @example\n * ```typescript\n * const cip = CommandInjectionPrevention.getInstance();\n *\n * // Validate a command before execution\n * const validation = cip.validateCommand('git', ['status']);\n * if (validation.safe) {\n *   const result = await cip.safeExecute('git', ['status']);\n * }\n * ```\n */\nexport class CommandInjectionPrevention {\n  private static readonly instance: CommandInjectionPrevention;\n\n  private readonly dangerousCommands: Set<string>;\n\n  private readonly dangerousPatterns: RegExp[];\n\n  private readonly allowedCommands: Set<string>;\n\n  private readonly maxArgLength: number;\n\n  private readonly maxTotalArgsLength: number;\n\n  constructor() {\n    // Commands that should never be executed\n    this.dangerousCommands = new Set([\n      'rm',\n      'rmdir',\n      'del',\n      'format',\n      'fdisk',\n      'wget',\n      'curl',\n      'nc',\n      'netcat',\n      'telnet',\n      'ssh',\n      'scp',\n      'ftp',\n      'tftp',\n      'python',\n      'python3',\n      'node',\n      'ruby',\n      'perl',\n      'php',\n      'sh',\n      'bash',\n      'zsh',\n      'fish',\n      'csh',\n      'tcsh',\n      'cmd',\n      'powershell',\n      'pwsh',\n      'eval',\n      'exec',\n      'source',\n      'sudo',\n      'su',\n      'chmod',\n      'chown',\n      'mount',\n      'umount',\n      'iptables',\n      'ufw',\n      'firewalld',\n      'systemctl',\n      'service',\n      'launchctl',\n      'reboot',\n      'shutdown',\n      'halt',\n      'poweroff',\n    ]);\n\n    // Dangerous patterns that indicate injection attempts\n    this.dangerousPatterns = [\n      // Command chaining\n      /[;&|`]/,\n      // Process substitution\n      /<\\(|>\\(/,\n      // Command substitution\n      /\\$\\(/,\n      // Backticks\n      /`/,\n      // Redirection attempts\n      /[<>]+/,\n      // Null bytes\n      /\\x00/,\n      // Path traversal\n      /\\.\\.[/\\\\]/,\n      // Variable expansion\n      /\\$\\{[^}]*\\}/,\n      // Globbing attempts\n      /\\*|\\?|\\[.*\\]/,\n      // Script execution\n      /\\.(sh|bat|cmd|ps1|py|rb|pl|php)(\\s|$)/i,\n      // Network operations\n      /(wget|curl|nc|netcat)\\s+/i,\n      // Remote execution\n      /(ssh|scp|ftp|telnet)\\s+/i,\n    ];\n\n    // Safe commands that are allowed by default\n    this.allowedCommands = new Set([\n      'echo',\n      'printf',\n      'cat',\n      'head',\n      'tail',\n      'ls',\n      'dir',\n      'pwd',\n      'whoami',\n      'id',\n      'date',\n      'uptime',\n      'uname',\n      'git',\n      'npm',\n      'yarn',\n      'pnpm',\n      'node',\n      'tsc',\n      'eslint',\n      'prettier',\n      'grep',\n      'find',\n      'sort',\n      'uniq',\n      'wc',\n    ]);\n\n    this.maxArgLength = 1000;\n    this.maxTotalArgsLength = 10000;\n  }\n\n  /**\n   * Gets the singleton instance of CommandInjectionPrevention\n   *\n   * @static\n   * @returns {CommandInjectionPrevention} The singleton instance\n   *\n   * @example\n   * ```typescript\n   * const cip = CommandInjectionPrevention.getInstance();\n   * ```\n   */\n  static getInstance(): CommandInjectionPrevention {\n    if (!CommandInjectionPrevention.instance) {\n      CommandInjectionPrevention.instance = new CommandInjectionPrevention();\n    }\n    return CommandInjectionPrevention.instance;\n  }\n\n  /**\n   * Validates and sanitizes a command before execution\n   *\n   * @param {string} command - The command to validate\n   * @param {string[]} [args=[]] - Command arguments to validate\n   * @param {CommandExecutionOptions} [options={}] - Execution options with security controls\n   * @returns {CommandValidationResult} Validation result with sanitized values\n   *\n   * @description Performs comprehensive security validation including:\n   * - Command name sanitization and whitelisting\n   * - Argument length and content validation\n   * - Dangerous pattern detection (command chaining, injection attempts)\n   * - Path traversal prevention\n   * - Working directory restriction\n   *\n   * @example\n   * ```typescript\n   * const result = cip.validateCommand('ls', ['-la', '/etc/passwd']);\n   * if (!result.safe) {\n   *   console.error('Blocked:', result.blockedPatterns);\n   * }\n   * ```\n   */\n  validateCommand(\n    command: string,\n    args: string[] = [],\n    options: CommandExecutionOptions = {}\n  ): CommandValidationResult {\n    const warnings: string[] = [];\n    const blockedPatterns: string[] = [];\n    let safe = true;\n\n    // Sanitize command name\n    const commandSanitized = inputSanitizer.sanitizeText(command, {\n      allowHtml: false,\n      maxLength: 100,\n      stripControlChars: true,\n      preventInjection: true,\n      escapeSpecialChars: false,\n      allowedCharacters: /[\\w\\-_.]/,\n    });\n\n    if (commandSanitized.modified) {\n      warnings.push('Command was sanitized');\n      if (commandSanitized.warnings.length > 0) {\n        warnings.push(...commandSanitized.warnings);\n      }\n    }\n\n    const sanitizedCommand = commandSanitized.sanitized;\n\n    // Check if command is in dangerous list\n    if (this.dangerousCommands.has(sanitizedCommand.toLowerCase())) {\n      safe = false;\n      blockedPatterns.push(`Dangerous command: ${String(sanitizedCommand)}`);\n    }\n\n    // Check if command is allowed (if allowlist is specified)\n    if (options.allowedCommands && !options.allowedCommands.includes(sanitizedCommand)) {\n      safe = false;\n      blockedPatterns.push(`Command not in allowlist: ${String(sanitizedCommand)}`);\n    } else if (\n      !options.allowedCommands &&\n      !this.allowedCommands.has(sanitizedCommand.toLowerCase())\n    ) {\n      // Default allowlist check\n      warnings.push(`Command not in default safe list: ${String(sanitizedCommand)}`);\n    }\n\n    // Sanitize arguments\n    const sanitizedArgs: string[] = [];\n    let totalArgsLength = 0;\n\n    args.forEach((arg, index) => {\n      // Check individual arg length\n      if (arg.length > this.maxArgLength) {\n        safe = false;\n        blockedPatterns.push(\n          `Argument ${String(index)} exceeds maximum length (${String(String(this.maxArgLength))})`\n        );\n        return;\n      }\n\n      totalArgsLength += arg.length;\n\n      // Sanitize the argument\n      const argSanitized = inputSanitizer.sanitizeText(arg, {\n        allowHtml: false,\n        maxLength: this.maxArgLength,\n        stripControlChars: true,\n        preventInjection: true,\n        escapeSpecialChars: true,\n      });\n\n      if (argSanitized.modified) {\n        warnings.push(`Argument ${String(index)} was sanitized`);\n      }\n\n      // Check for dangerous patterns in arguments\n      this.dangerousPatterns.forEach(pattern => {\n        if (pattern.test(arg)) {\n          safe = false;\n          blockedPatterns.push(\n            `Dangerous pattern in argument ${String(index)}: ${String(String(pattern.source))}`\n          );\n        }\n      });\n\n      // Validate flags if specified\n      if (options.allowedFlags && arg.startsWith('-')) {\n        const flag = arg.replace(/^-+/, '');\n        if (!options.allowedFlags.includes(flag)) {\n          safe = false;\n          blockedPatterns.push(`Flag not allowed: ${String(arg)}`);\n        }\n      }\n\n      // Path traversal protection\n      if (arg.includes('../') || arg.includes('..\\\\')) {\n        safe = false;\n        blockedPatterns.push(`Path traversal attempt in argument ${String(index)}`);\n      }\n\n      // Working directory restriction\n      if (options.restrictToWorkingDir && path.isAbsolute(arg)) {\n        const resolved = path.resolve(arg);\n        const cwd = process.cwd();\n        if (!resolved.startsWith(cwd)) {\n          safe = false;\n          blockedPatterns.push(`Argument ${String(index)} points outside working directory`);\n        }\n      }\n\n      sanitizedArgs.push(argSanitized.sanitized);\n    });\n\n    // Check total arguments length\n    if (totalArgsLength > this.maxTotalArgsLength) {\n      safe = false;\n      blockedPatterns.push(\n        `Total arguments length exceeds maximum (${String(String(this.maxTotalArgsLength))})`\n      );\n    }\n\n    // Additional security checks for the complete command\n    const fullCommand = `${String(sanitizedCommand)} ${String(String(sanitizedArgs.join(' ')))}`;\n    const suspiciousCheck = inputSanitizer.detectSuspiciousPatterns(fullCommand);\n    if (suspiciousCheck.suspicious) {\n      warnings.push(\n        `Suspicious patterns detected: ${String(String(suspiciousCheck.patterns.join(', ')))}`\n      );\n      // Mark as unsafe if critical patterns are detected\n      const criticalPatterns = ['Script tag', 'JavaScript protocol', 'Remote script execution'];\n      if (suspiciousCheck.patterns.some(p => criticalPatterns.includes(p))) {\n        safe = false;\n        blockedPatterns.push(...suspiciousCheck.patterns);\n      }\n    }\n\n    return {\n      safe,\n      sanitizedCommand,\n      sanitizedArgs,\n      warnings,\n      blockedPatterns,\n    };\n  }\n\n  /**\n   * Safely executes a command with comprehensive protection\n   *\n   * @param {string} command - The command to execute\n   * @param {string[]} [args=[]] - Command arguments\n   * @param {CommandExecutionOptions} [options={}] - Execution options\n   * @returns {Promise<ExecutionResult>} Execution result with output and status\n   *\n   * @throws {Error} If command validation fails or is deemed unsafe\n   *\n   * @description Validates the command and arguments, then executes in a\n   * controlled environment with timeout, environment isolation, and output capture.\n   *\n   * @example\n   * ```typescript\n   * try {\n   *   const result = await cip.safeExecute('git', ['log', '--oneline', '-5']);\n   *   console.log(result.stdout);\n   * } catch (error) {\n   *   console.error('Command blocked:', error.message);\n   * }\n   * ```\n   */\n  async safeExecute(\n    command: string,\n    args: string[] = [],\n    options: CommandExecutionOptions = {}\n  ): Promise<ExecutionResult> {\n    const startTime = Date.now();\n\n    // Validate the command first\n    const validation = this.validateCommand(command, args, options);\n\n    if (!validation.safe) {\n      throw new Error(\n        `Command execution blocked: ${String(String(validation.blockedPatterns.join(', ')))}`\n      );\n    }\n\n    // Log execution if requested\n    if (options.logExecution) {\n      logger.info('Command execution started', {\n        command: validation.sanitizedCommand,\n        args: validation.sanitizedArgs,\n      });\n      if (validation.warnings.length > 0) {\n        logger.warn('Command execution warnings', {\n          warnings: validation.warnings,\n        });\n      }\n    }\n\n    return new Promise<ExecutionResult>((resolve, _reject) => {\n      const child = spawn(validation.sanitizedCommand, validation.sanitizedArgs, {\n        stdio: ['pipe', 'pipe', 'pipe'],\n        env: { ...process.env, ...options.env },\n        timeout: options.timeout ?? 30000,\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      child.stdout?.on('data', data => {\n        stdout += data.toString();\n      });\n\n      child.stderr?.on('data', data => {\n        stderr += data.toString();\n      });\n\n      child.on('close', code => {\n        const duration = Date.now() - startTime;\n        resolve({\n          success: code === 0,\n          stdout,\n          stderr,\n          exitCode: code ?? 0,\n          duration,\n          command: validation.sanitizedCommand,\n          args: validation.sanitizedArgs,\n        });\n      });\n\n      child.on('error', error => {\n        const duration = Date.now() - startTime;\n        resolve({\n          success: false,\n          stdout: '',\n          stderr: error.message,\n          exitCode: -1,\n          duration,\n          command: validation.sanitizedCommand,\n          args: validation.sanitizedArgs,\n        });\n      });\n    });\n  }\n\n  /**\n   * Creates a safe command wrapper with predefined flags\n   *\n   * @param {string} baseCommand - The base command to wrap\n   * @param {string[]} [allowedFlags=[]] - Allowed flags for this command\n   * @returns {Object} Command wrapper with validate and execute methods\n   *\n   * @description Creates a reusable command wrapper that enforces consistent\n   * security policies for a specific command.\n   *\n   * @example\n   * ```typescript\n   * const gitCommand = cip.createSafeCommand('git', ['status', 'log', 'diff']);\n   *\n   * // Validate arguments\n   * const validatedArgs = gitCommand.validate(['status', '-s']);\n   *\n   * // Execute safely\n   * const result = await gitCommand.execute(['status']);\n   * ```\n   */\n  createSafeCommand(baseCommand: string, allowedFlags: string[] = []) {\n    return {\n      validate: (args: string[], options: CommandExecutionOptions = {}) => {\n        const validation = this.validateCommand(baseCommand, args, {\n          ...options,\n          allowedFlags,\n        });\n\n        if (!validation.safe) {\n          throw new Error(`Invalid argument: ${validation.blockedPatterns.join(', ')}`);\n        }\n        return validation.sanitizedArgs[0];\n      },\n\n      execute: (args: string[], options: CommandExecutionOptions = {}) =>\n        this.safeExecute(baseCommand, args, {\n          ...options,\n          allowedFlags,\n          logExecution: true,\n        }),\n    };\n  }\n\n  /**\n   * Adds a custom command to the allowed list\n   *\n   * @param {string} command - Command name to allow\n   *\n   * @example\n   * ```typescript\n   * cip.addAllowedCommand('docker');\n   * ```\n   */\n  addAllowedCommand(command: string): void {\n    this.allowedCommands.add(command.toLowerCase());\n  }\n\n  /**\n   * Removes a command from the allowed list\n   *\n   * @param {string} command - Command name to remove\n   *\n   * @example\n   * ```typescript\n   * cip.removeAllowedCommand('rm');\n   * ```\n   */\n  removeAllowedCommand(command: string): void {\n    this.allowedCommands.delete(command.toLowerCase());\n  }\n\n  /**\n   * Checks if a command is in the dangerous list\n   *\n   * @param {string} command - Command name to check\n   * @returns {boolean} True if the command is considered dangerous\n   *\n   * @example\n   * ```typescript\n   * if (cip.isDangerousCommand('rm')) {\n   *   console.error('This command is dangerous!');\n   * }\n   * ```\n   */\n  isDangerousCommand(command: string): boolean {\n    return this.dangerousCommands.has(command.toLowerCase());\n  }\n\n  /**\n   * Gets the list of allowed commands\n   *\n   * @returns {string[]} Array of allowed command names\n   *\n   * @example\n   * ```typescript\n   * const allowed = cip.getAllowedCommands();\n   * console.log('Allowed commands:', allowed);\n   * ```\n   */\n  getAllowedCommands(): string[] {\n    return Array.from(this.allowedCommands);\n  }\n\n  /**\n   * Gets the list of dangerous commands\n   *\n   * @returns {string[]} Array of dangerous command names\n   *\n   * @example\n   * ```typescript\n   * const dangerous = cip.getDangerousCommands();\n   * console.log('Dangerous commands:', dangerous);\n   * ```\n   */\n  getDangerousCommands(): string[] {\n    return Array.from(this.dangerousCommands);\n  }\n\n  /**\n   * Validates a file path for safe access\n   *\n   * @param {string} filePath - The file path to validate\n   * @param {string[]} [allowedDirectories=[]] - List of allowed base directories\n   * @returns {Object} Validation result\n   * @returns {boolean} result.safe - Whether the path is safe\n   * @returns {string} result.normalizedPath - Normalized version of the path\n   * @returns {string[]} result.warnings - Any security warnings\n   *\n   * @description Validates file paths to prevent directory traversal attacks\n   * and restrict access to allowed directories.\n   *\n   * @example\n   * ```typescript\n   * const result = cip.validateFilePath('../../../etc/passwd', ['/home/user']);\n   * if (!result.safe) {\n   *   console.error('Unsafe path:', result.warnings);\n   * }\n   * ```\n   */\n  validateFilePath(\n    filePath: string,\n    allowedDirectories: string[] = []\n  ): {\n    safe: boolean;\n    normalizedPath: string;\n    warnings: string[];\n  } {\n    const warnings: string[] = [];\n    let safe = true;\n\n    // Sanitize the file path\n    const sanitized = inputSanitizer.sanitizeFilePath(filePath);\n    if (sanitized.modified) {\n      warnings.push('File path was sanitized');\n    }\n\n    const normalizedPath = path.normalize(sanitized.sanitized);\n\n    // Check for path traversal\n    if (normalizedPath.includes('../') || normalizedPath.includes('..\\\\')) {\n      safe = false;\n      warnings.push('Path traversal detected');\n    }\n\n    // Check if path is within allowed directories\n    if (allowedDirectories.length > 0) {\n      const resolved = path.resolve(normalizedPath);\n      const isInAllowedDir = allowedDirectories.some(dir => {\n        const allowedDir = path.resolve(dir);\n        return resolved.startsWith(allowedDir);\n      });\n\n      if (!isInAllowedDir) {\n        safe = false;\n        warnings.push('Path outside allowed directories');\n      }\n    }\n\n    // Check for dangerous file extensions\n    const dangerousExtensions = ['.sh', '.bat', '.cmd', '.ps1', '.py', '.rb', '.pl', '.php'];\n    const ext = path.extname(normalizedPath).toLowerCase();\n    if (dangerousExtensions.includes(ext)) {\n      warnings.push(`Potentially dangerous file extension: ${String(ext)}`);\n    }\n\n    return {\n      safe,\n      normalizedPath,\n      warnings,\n    };\n  }\n}\n\n/**\n * Singleton instance of CommandInjectionPrevention\n * @constant {CommandInjectionPrevention}\n */\nexport const commandInjectionPrevention = CommandInjectionPrevention.getInstance();\n\n/**\n * Convenience function for safe command execution\n *\n * @function safeExecute\n * @param {string} command - Command to execute\n * @param {string[]} [args=[]] - Command arguments\n * @param {CommandExecutionOptions} [options={}] - Execution options\n * @returns {Promise<ExecutionResult>} Execution result\n *\n * @example\n * ```typescript\n * const result = await safeExecute('ls', ['-la']);\n * ```\n */\nexport const safeExecute = (\n  command: string,\n  args: string[] = [],\n  options: CommandExecutionOptions = {}\n) => commandInjectionPrevention.safeExecute(command, args, options);\n\n/**\n * Convenience function for command validation\n *\n * @function validateCommand\n * @param {string} command - Command to validate\n * @param {string[]} [args=[]] - Command arguments\n * @param {CommandExecutionOptions} [options={}] - Validation options\n * @returns {CommandValidationResult} Validation result\n *\n * @example\n * ```typescript\n * const validation = validateCommand('rm', ['-rf', '/']);\n * ```\n */\nexport const validateCommand = (\n  command: string,\n  args: string[] = [],\n  options: CommandExecutionOptions = {}\n) => commandInjectionPrevention.validateCommand(command, args, options);\n\n/**\n * Convenience function for creating safe command wrappers\n *\n * @function createSafeCommand\n * @param {string} baseCommand - Base command name\n * @param {string[]} [allowedFlags=[]] - Allowed flags\n * @returns {Object} Command wrapper\n *\n * @example\n * ```typescript\n * const git = createSafeCommand('git', ['status', 'log']);\n * ```\n */\nexport const createSafeCommand = (baseCommand: string, allowedFlags: string[] = []) =>\n  commandInjectionPrevention.createSafeCommand(baseCommand, allowedFlags);\n\n/**\n * Convenience function for file path validation\n *\n * @function validateFilePath\n * @param {string} filePath - Path to validate\n * @param {string[]} [allowedDirectories=[]] - Allowed directories\n * @returns {Object} Validation result\n *\n * @example\n * ```typescript\n * const validation = validateFilePath('/etc/passwd');\n * ```\n */\nexport const validateFilePath = (filePath: string, allowedDirectories: string[] = []) =>\n  commandInjectionPrevention.validateFilePath(filePath, allowedDirectories);\n\n/**\n * Safe wrapper for common CLI operations\n *\n * @class SafeCliOperations\n * @description Provides pre-configured safe wrappers for common CLI operations\n * like file reading, directory listing, and version control commands.\n *\n * @example\n * ```typescript\n * // Read a file safely\n * const content = await SafeCliOperations.safeFileRead('./config.json');\n *\n * // List directory contents\n * const files = await SafeCliOperations.safeDirectoryList('./src');\n *\n * // Execute git command\n * const result = await SafeCliOperations.safeGitCommand(['status']);\n * ```\n */\nexport class SafeCliOperations {\n  /**\n   * Safely reads a file with path validation\n   *\n   * @static\n   * @param {string} filePath - Path to the file to read\n   * @param {string[]} [allowedDirectories=[]] - Allowed base directories\n   * @returns {Promise<string>} File contents\n   *\n   * @throws {Error} If the file path is unsafe or reading fails\n   *\n   * @example\n   * ```typescript\n   * try {\n   *   const content = await SafeCliOperations.safeFileRead('./data.json', ['./']);\n   *   const data = JSON.parse(content);\n   * } catch (error) {\n   *   console.error('Failed to read file:', error.message);\n   * }\n   * ```\n   */\n  static async safeFileRead(filePath: string, allowedDirectories: string[] = []): Promise<string> {\n    const pathValidation = validateFilePath(filePath, allowedDirectories);\n    if (!pathValidation.safe) {\n      throw new Error(`Unsafe file path: ${String(String(pathValidation.warnings.join(', ')))}`);\n    }\n\n    const result = await safeExecute('cat', [pathValidation.normalizedPath], {\n      timeout: 5000,\n      restrictToWorkingDir: allowedDirectories.length === 0,\n    });\n\n    if (!result.success) {\n      throw new Error(`Failed to read file: ${String(String(result.stderr))}`);\n    }\n\n    return result.stdout;\n  }\n\n  /**\n   * Safely lists directory contents\n   *\n   * @static\n   * @param {string} [dirPath='.'] - Directory path to list\n   * @param {string[]} [allowedDirectories=[]] - Allowed base directories\n   * @returns {Promise<string[]>} Array of directory entries\n   *\n   * @throws {Error} If the directory path is unsafe or listing fails\n   *\n   * @example\n   * ```typescript\n   * const files = await SafeCliOperations.safeDirectoryList('./src');\n   * files.forEach(file => console.log(file));\n   * ```\n   */\n  static async safeDirectoryList(\n    dirPath: string = '.',\n    allowedDirectories: string[] = []\n  ): Promise<string[]> {\n    const pathValidation = validateFilePath(dirPath, allowedDirectories);\n    if (!pathValidation.safe) {\n      throw new Error(\n        `Unsafe directory path: ${String(String(pathValidation.warnings.join(', ')))}`\n      );\n    }\n\n    const result = await safeExecute('ls', ['-la', pathValidation.normalizedPath], {\n      timeout: 10000,\n      restrictToWorkingDir: allowedDirectories.length === 0,\n    });\n\n    if (!result.success) {\n      throw new Error(`Failed to list directory: ${String(String(result.stderr))}`);\n    }\n\n    return result.stdout.split('\\n').filter(line => line.trim().length > 0);\n  }\n\n  /**\n   * Safely executes Git commands\n   *\n   * @static\n   * @param {string[]} args - Git command arguments\n   * @returns {Promise<ExecutionResult>} Command execution result\n   *\n   * @description Executes Git commands with a whitelist of safe operations\n   * including status, log, diff, branch, and other read/write operations.\n   *\n   * @example\n   * ```typescript\n   * // Get git status\n   * const status = await SafeCliOperations.safeGitCommand(['status', '--short']);\n   *\n   * // View recent commits\n   * const log = await SafeCliOperations.safeGitCommand(['log', '--oneline', '-10']);\n   * ```\n   */\n  static async safeGitCommand(args: string[]): Promise<ExecutionResult> {\n    const allowedGitArgs = [\n      'status',\n      'log',\n      'diff',\n      'branch',\n      'remote',\n      'config',\n      'add',\n      'commit',\n      'push',\n      'pull',\n      'fetch',\n      'checkout',\n      'merge',\n      'rebase',\n      'stash',\n      'tag',\n      'show',\n      'blame',\n    ];\n\n    return safeExecute('git', args, {\n      allowedFlags: allowedGitArgs,\n      timeout: 30000,\n      restrictToWorkingDir: true,\n      logExecution: true,\n    });\n  }\n\n  /**\n   * Safely executes NPM commands\n   *\n   * @static\n   * @param {string[]} args - NPM command arguments\n   * @returns {Promise<ExecutionResult>} Command execution result\n   *\n   * @description Executes NPM commands with a whitelist of safe operations\n   * including install, update, list, audit, and script execution.\n   *\n   * @example\n   * ```typescript\n   * // Install dependencies\n   * await SafeCliOperations.safeNpmCommand(['install']);\n   *\n   * // Run a script\n   * const result = await SafeCliOperations.safeNpmCommand(['run', 'test']);\n   * ```\n   */\n  static async safeNpmCommand(args: string[]): Promise<ExecutionResult> {\n    const allowedNpmArgs = [\n      'install',\n      'update',\n      'list',\n      'outdated',\n      'audit',\n      'run',\n      'start',\n      'test',\n      'build',\n      'version',\n      'info',\n      'search',\n      'view',\n      'help',\n    ];\n\n    return safeExecute('npm', args, {\n      allowedFlags: allowedNpmArgs,\n      timeout: 120000, // NPM operations can take longer\n      restrictToWorkingDir: true,\n      logExecution: true,\n    });\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/dashboard-manager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 35,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 35,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1021, 1024], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1021, 1024], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 37,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 37,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1067, 1070], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1067, 1070], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "default-param-last",
        "severity": 2,
        "message": "Default parameters should be last.",
        "line": 55,
        "column": 15,
        "nodeType": "AssignmentPattern",
        "messageId": "shouldBeLast",
        "endLine": 55,
        "endColumn": 52
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 101,
        "column": 7,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 101,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 172,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 183,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 172,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 172,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 172,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 172,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 187,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 198,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 187,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 187,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 187,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 187,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 202,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 212,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 202,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 202,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 202,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 202,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 216,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 219,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 216,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 216,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 216,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 216,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 223,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 223,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .log on an `any` value.",
        "line": 223,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 223,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 244,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 258,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 244,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 244,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 244,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 244,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 261,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 284,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 261,
        "column": 26,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 261,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 261,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 261,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 287,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 299,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 287,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 287,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 287,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 287,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 301,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 301,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setData on an `any` value.",
        "line": 301,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 301,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 325,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 329,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 325,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 325,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 325,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 325,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 332,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 332,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setPercent on an `any` value.",
        "line": 332,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 332,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 335,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 347,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 335,
        "column": 23,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 335,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 335,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 335,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 349,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 349,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setData on an `any` value.",
        "line": 349,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 349,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 360,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 364,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 360,
        "column": 27,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 360,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 360,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 360,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 366,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 366,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setData on an `any` value.",
        "line": 366,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 366,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 369,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 374,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 369,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 369,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 369,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 369,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 376,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 376,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setContent on an `any` value.",
        "line": 376,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 376,
        "endColumn": 24
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 407,
        "column": 5,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 407,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 415,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 419,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 415,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 415,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 415,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 415,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 422,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 422,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setContent on an `any` value.",
        "line": 422,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 422,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 431,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 434,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 431,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 431,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .set on an `any` value.",
        "line": 431,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 431,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 437,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 437,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setContent on an `any` value.",
        "line": 437,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 437,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 450,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 450,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11843, 11846], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11843, 11846], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .width on an `any` value.",
        "line": 450,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 450,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 459,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 459,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .append on an `any` value.",
        "line": 459,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 459,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 460,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 460,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 460,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 460,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 464,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 464,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .remove on an `any` value.",
        "line": 464,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 464,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 465,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 465,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 465,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 465,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 476,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 476,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12478, 12481], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12478, 12481], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .width on an `any` value.",
        "line": 476,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 476,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 478,
        "column": 31,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 478,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 478,
        "column": 35,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 478,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 478,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 478,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 480,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 480,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 480,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 480,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 480,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 480,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 481,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 481,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 481,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 481,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 481,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 481,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 488,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 488,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .append on an `any` value.",
        "line": 488,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 488,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 489,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 489,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 489,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 489,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 493,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 493,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .remove on an `any` value.",
        "line": 493,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 493,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 494,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 494,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 494,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 494,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 556,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 556,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .append on an `any` value.",
        "line": 556,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 556,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 560,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 560,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .remove on an `any` value.",
        "line": 560,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 560,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 561,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 561,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 561,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 561,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 564,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 564,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 564,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 564,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 572,
        "column": 41,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 572,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .theme on an `any` value.",
        "line": 572,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 572,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .theme on an `any` value.",
        "line": 575,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 575,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 576,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 576,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .setTheme on an `any` value.",
        "line": 576,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 576,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .theme on an `any` value.",
        "line": 576,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 576,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .theme on an `any` value.",
        "line": 579,
        "column": 79,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 579,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 582,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 582,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .autoRefresh on an `any` value.",
        "line": 589,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 589,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .autoRefresh on an `any` value.",
        "line": 589,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 589,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .autoRefresh on an `any` value.",
        "line": 591,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 591,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 592,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 592,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 594,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 594,
        "endColumn": 27
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 606,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 606,
        "endColumn": 32
      },
      {
        "ruleId": "default-case",
        "severity": 2,
        "message": "Expected a default case.",
        "line": 629,
        "column": 7,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 639,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 644,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 644,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 645,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 645,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 645,
        "column": 28,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 645,
        "endColumn": 51
      },
      {
        "ruleId": "default-case",
        "severity": 2,
        "message": "Expected a default case.",
        "line": 647,
        "column": 7,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 657,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `DashboardData`.",
        "line": 649,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 649,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `DashboardData`.",
        "line": 652,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 652,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `DashboardData`.",
        "line": 655,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 655,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 668,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 668,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .destroy on an `any` value.",
        "line": 668,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 668,
        "endColumn": 21
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 750,
        "column": 5,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 750,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Iterable<unknown> | ArrayLike<unknown>`.",
        "line": 759,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 759,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 759,
        "column": 35,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 759,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .keys on an `any` value.",
        "line": 759,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 759,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 766,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 766,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 766,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 766,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .get on an `any` value.",
        "line": 766,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 766,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .focus on an `any` value.",
        "line": 768,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 768,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 769,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 769,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .focus on an `any` value.",
        "line": 769,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 769,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 770,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 770,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 770,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 770,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Iterable<unknown> | ArrayLike<unknown>`.",
        "line": 778,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "unsafeArgument",
        "endLine": 778,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 778,
        "column": 35,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 778,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .keys on an `any` value.",
        "line": 778,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 778,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 785,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 785,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 785,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 785,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .get on an `any` value.",
        "line": 785,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 785,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .focus on an `any` value.",
        "line": 787,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 787,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 788,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 788,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .focus on an `any` value.",
        "line": 788,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 788,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 789,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 789,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 789,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 789,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 811,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 811,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 824,
        "column": 31,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 824,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 824,
        "column": 35,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 824,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 824,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 824,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 826,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 826,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 826,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 826,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 826,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 826,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 827,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 827,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 827,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 827,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 827,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 827,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .refreshInterval on an `any` value.",
        "line": 832,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 832,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .size on an `any` value.",
        "line": 833,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 833,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 834,
        "column": 36,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 834,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getTheme on an `any` value.",
        "line": 834,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 834,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 834,
        "column": 64,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 834,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .autoRefresh on an `any` value.",
        "line": 835,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 835,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 851,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 851,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .append on an `any` value.",
        "line": 851,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 851,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 855,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 855,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .remove on an `any` value.",
        "line": 855,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 855,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 856,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 856,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 856,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 856,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 859,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 859,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 859,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 859,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 877,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 877,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 880,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 880,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .constructor on an `any` value.",
        "line": 889,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 889,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 922,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 922,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Node`.",
        "line": 924,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 924,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 937,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 937,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 938,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 938,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 951,
        "column": 31,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 951,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 951,
        "column": 35,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 951,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 951,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 951,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 953,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 953,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 953,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 953,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 953,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 953,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 954,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 954,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 954,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 954,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .getColor on an `any` value.",
        "line": 954,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 954,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 961,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 961,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .append on an `any` value.",
        "line": 961,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 961,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 962,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 962,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 962,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 962,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 966,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 966,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .remove on an `any` value.",
        "line": 966,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 966,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 967,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 967,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .render on an `any` value.",
        "line": 967,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 967,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 14,
    "fatalErrorCount": 0,
    "warningCount": 178,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import blessed from 'blessed';\nimport contrib from 'blessed-contrib';\n\nimport { DashboardDataService } from '../services/dashboard-data';\nimport type { ApiClient } from '../client';\nimport { ThemeHelper, getThemeNames } from '../ui/themes/dashboard-themes';\n\nexport interface DashboardData {\n  tasks: {\n    total: number;\n    byStatus: Record<string, number>;\n    byPriority: Record<string, number>;\n    completed: number;\n    overdue: number;\n  };\n  velocity: Array<{ period: string; completed: number }>;\n  teamMembers: Array<{ name: string; taskCount: number; load: number }>;\n  burndown: Array<{ day: string; remaining: number; ideal: number }>;\n  activity: Array<{ timestamp: string; event: string; user: string }>;\n}\n\nexport interface DashboardConfig {\n  refreshInterval: number;\n  theme: string;\n  showHelp: boolean;\n  autoRefresh: boolean;\n}\n\n/**\n * Manages terminal dashboards using blessed-contrib\n */\nexport class DashboardManager {\n  private readonly screen: blessed.Widgets.Screen;\n\n  private readonly grid: any;\n\n  private readonly widgets: Map<string, any> = new Map();\n\n  private readonly config: DashboardConfig;\n\n  private readonly dataService: DashboardDataService;\n\n  private readonly themeHelper: ThemeHelper;\n\n  private readonly refreshTimer?: NodeJS.Timeout;\n\n  private currentLayout: 'overview' | 'velocity' | 'personal' = 'overview';\n\n  private readonly focusedWidget: string | null = null;\n\n  private readonly isFullscreen = false;\n\n  private readonly debugMode = false;\n\n  constructor(config: Partial<DashboardConfig> = {}, apiClient?: ApiClient) {\n    this.config = {\n      refreshInterval: 30000, // 30 seconds\n      theme: 'dark',\n      showHelp: true,\n      autoRefresh: true,\n      ...config,\n    };\n\n    // Initialize data service\n    this.dataService = apiClient\n      ? new DashboardDataService(apiClient)\n      : new DashboardDataService({} as ApiClient);\n\n    // Initialize theme helper\n    this.themeHelper = new ThemeHelper(this.config.theme);\n\n    // Create screen\n    this.screen = blessed.screen({\n      smartCSR: true,\n      title: 'Kanban Dashboard',\n      dockBorders: true,\n    });\n\n    // Create grid\n    this.grid = contrib.grid({\n      rows: 12,\n      cols: 12,\n      screen: this.screen,\n    });\n\n    this.setupKeyBindings();\n  }\n\n  /**\n   * Setup keyboard navigation\n   */\n  private setupKeyBindings(): void {\n    // Exit commands\n    this.screen.key(['q', 'C-c'], () => {\n      this.destroy();\n      process.exit(0);\n    });\n\n    // Dashboard controls\n    this.screen.key(['r', 'F5'], () => {\n      void this.refreshData();\n    });\n\n    // Layout switching\n    this.screen.key(['1', 'F1'], () => {\n      this.switchLayout('overview');\n    });\n\n    this.screen.key(['2', 'F2'], () => {\n      this.switchLayout('velocity');\n    });\n\n    this.screen.key(['3', 'F3'], () => {\n      this.switchLayout('personal');\n    });\n\n    // Help and settings\n    this.screen.key(['h', '?', 'F12'], () => {\n      DashboardManager.showHelp();\n    });\n\n    this.screen.key(['t', 'F9'], () => {\n      DashboardManager.toggleTheme();\n    });\n\n    this.screen.key(['a', 'F10'], () => {\n      DashboardManager.toggleAutoRefresh();\n    });\n\n    // Navigation within widgets\n    this.screen.key(['tab'], () => {\n      DashboardManager.focusNextWidget();\n    });\n\n    this.screen.key(['S-tab'], () => {\n      DashboardManager.focusPreviousWidget();\n    });\n\n    // Zoom/fullscreen toggle\n    this.screen.key(['f', 'F11'], () => {\n      DashboardManager.toggleFullscreen();\n    });\n\n    // Quick actions\n    this.screen.key(['s'], () => {\n      DashboardManager.showQuickStats();\n    });\n\n    this.screen.key(['e'], () => {\n      DashboardManager.exportDashboard();\n    });\n\n    // Debug mode toggle\n    this.screen.key(['d'], () => {\n      DashboardManager.toggleDebugMode();\n    });\n\n    // Reset view\n    this.screen.key(['escape'], () => {\n      DashboardManager.resetView();\n    });\n  }\n\n  /**\n   * Create overview dashboard layout\n   */\n  createOverviewDashboard(data: DashboardData): void {\n    this.clearWidgets();\n\n    // Task status donut chart\n    const donutStyles = this.themeHelper.getDonutStyles();\n    const statusDonut = this.grid.set(0, 0, 6, 6, contrib.donut, {\n      label: 'Tasks by Status',\n      radius: 8,\n      arcWidth: 4,\n      remainColor: donutStyles.remainColor,\n      yPadding: 2,\n      data: Object.entries(data.tasks.byStatus).map(([status, count], index) => ({\n        label: status,\n        percent: (count / data.tasks.total) * 100,\n        color: donutStyles.colors[index % donutStyles.colors.length],\n      })),\n    });\n\n    // Priority bar chart\n    const barStyles = this.themeHelper.getBarStyles();\n    const priorityBar = this.grid.set(0, 6, 6, 6, contrib.bar, {\n      label: 'Tasks by Priority',\n      barWidth: 4,\n      barSpacing: 6,\n      xOffset: 0,\n      maxHeight: 9,\n      style: { fg: barStyles.textColor },\n      data: {\n        titles: Object.keys(data.tasks.byPriority),\n        data: Object.values(data.tasks.byPriority),\n      },\n    });\n\n    // Velocity line chart\n    const lineStyles = this.themeHelper.getLineStyles();\n    const velocityLine = this.grid.set(6, 0, 6, 8, contrib.line, {\n      ...lineStyles,\n      xLabelPadding: 3,\n      xPadding: 5,\n      label: 'Team Velocity (Last 8 Weeks)',\n      data: {\n        title: 'Completed Tasks',\n        x: data.velocity.map(v => v.period),\n        y: data.velocity.map(v => v.completed),\n      },\n    });\n\n    // Activity log\n    const logStyles = this.themeHelper.getLogStyles();\n    const activityLog = this.grid.set(6, 8, 6, 4, contrib.log, {\n      ...logStyles,\n      label: 'Recent Activity',\n    });\n\n    // Populate activity log\n    data.activity.forEach(activity => {\n      activityLog.log(\n        `${String(String(activity.timestamp))}: ${String(String(activity.event))} (${String(String(activity.user))})`\n      );\n    });\n\n    this.widgets.set('statusDonut', statusDonut);\n    this.widgets.set('priorityBar', priorityBar);\n    this.widgets.set('velocityLine', velocityLine);\n    this.widgets.set('activityLog', activityLog);\n\n    this.addHeader('üìä Kanban Dashboard - Overview');\n    this.addFooter();\n  }\n\n  /**\n   * Create velocity-focused dashboard\n   */\n  createVelocityDashboard(data: DashboardData): void {\n    this.clearWidgets();\n\n    // Large velocity chart\n    const velocityLine = this.grid.set(0, 0, 8, 12, contrib.line, {\n      style: {\n        line: 'cyan',\n        text: 'white',\n        baseline: 'black',\n      },\n      xLabelPadding: 3,\n      xPadding: 5,\n      label: 'Team Velocity Trend',\n      data: {\n        title: 'Completed Tasks',\n        x: data.velocity.map(v => v.period),\n        y: data.velocity.map(v => v.completed),\n      },\n    });\n\n    // Burndown chart\n    const burndownLine = this.grid.set(8, 0, 4, 8, contrib.line, {\n      style: {\n        line: 'red',\n        text: 'white',\n        baseline: 'black',\n      },\n      xLabelPadding: 3,\n      xPadding: 5,\n      label: 'Sprint Burndown',\n      data: [\n        {\n          title: 'Actual',\n          x: data.burndown.map(b => b.day),\n          y: data.burndown.map(b => b.remaining),\n          style: { line: 'red' },\n        },\n        {\n          title: 'Ideal',\n          x: data.burndown.map(b => b.day),\n          y: data.burndown.map(b => b.ideal),\n          style: { line: 'green' },\n        },\n      ],\n    });\n\n    // Team capacity table\n    const teamTable = this.grid.set(8, 8, 4, 4, contrib.table, {\n      keys: true,\n      fg: 'white',\n      selectedFg: 'white',\n      selectedBg: 'blue',\n      interactive: false,\n      label: 'Team Capacity',\n      width: '30%',\n      height: '30%',\n      border: { type: 'line', fg: 'cyan' },\n      columnSpacing: 10,\n      columnWidth: [16, 12, 12],\n    });\n\n    teamTable.setData({\n      headers: ['Member', 'Tasks', 'Load %'],\n      data: data.teamMembers.map(member => [\n        member.name,\n        member.taskCount.toString(),\n        `${String(String(member.load))}%`,\n      ]),\n    });\n\n    this.widgets.set('velocityLine', velocityLine);\n    this.widgets.set('burndownLine', burndownLine);\n    this.widgets.set('teamTable', teamTable);\n\n    this.addHeader('üìà Velocity Dashboard');\n    this.addFooter();\n  }\n\n  /**\n   * Create personal productivity dashboard\n   */\n  createPersonalDashboard(data: DashboardData): void {\n    this.clearWidgets();\n\n    // Personal task progress\n    const progressGauge = this.grid.set(0, 0, 6, 6, contrib.gauge, {\n      label: 'Personal Progress',\n      stroke: 'green',\n      fill: 'white',\n    });\n\n    const completionRate = (data.tasks.completed / data.tasks.total) * 100;\n    progressGauge.setPercent(completionRate);\n\n    // Task breakdown\n    const taskTable = this.grid.set(0, 6, 6, 6, contrib.table, {\n      keys: true,\n      fg: 'white',\n      selectedFg: 'white',\n      selectedBg: 'blue',\n      interactive: true,\n      label: 'My Tasks',\n      width: '30%',\n      height: '30%',\n      border: { type: 'line', fg: 'cyan' },\n      columnSpacing: 10,\n      columnWidth: [20, 12, 12],\n    });\n\n    taskTable.setData({\n      headers: ['Task', 'Priority', 'Status'],\n      data: [\n        ['Complete user auth', 'P1', 'In Progress'],\n        ['Fix login bug', 'P1', 'Todo'],\n        ['Update docs', 'P3', 'Done'],\n        ['Code review', 'P2', 'Todo'],\n      ],\n    });\n\n    // Time tracking sparkline\n    const timeSparkline = this.grid.set(6, 0, 3, 12, contrib.sparkline, {\n      label: 'Hours This Week',\n      tags: true,\n      style: { fg: 'blue' },\n    });\n\n    timeSparkline.setData(['Mon', 'Tue', 'Wed', 'Thu', 'Fri'], [8, 7, 9, 6, 8]);\n\n    // Today's focus box\n    const focusBox = this.grid.set(9, 0, 3, 12, blessed.box, {\n      label: \"Today's Focus\",\n      border: { type: 'line', fg: 'yellow' },\n      style: { fg: 'white' },\n      padding: { left: 2, right: 2 },\n    });\n\n    focusBox.setContent(`\nüéØ Current Sprint Goals:\n‚Ä¢ Complete user authentication system\n‚Ä¢ Fix critical login bug \n‚Ä¢ Prepare demo for stakeholders\n\nüìù Today's Tasks:\n‚Ä¢ [In Progress] Implement OAuth integration\n‚Ä¢ [Todo] Write unit tests for auth module\n‚Ä¢ [Todo] Review PR #123\n\n‚ö° Quick Stats:\n‚Ä¢ 12 tasks completed this week\n‚Ä¢ 3 hours average daily focus time\n‚Ä¢ 85% sprint completion rate\n    `);\n\n    this.widgets.set('progressGauge', progressGauge);\n    this.widgets.set('taskTable', taskTable);\n    this.widgets.set('timeSparkline', timeSparkline);\n    this.widgets.set('focusBox', focusBox);\n\n    this.addHeader('üë§ Personal Dashboard');\n    this.addFooter();\n  }\n\n  /**\n   * Switch between dashboard layouts\n   */\n  switchLayout(layout: 'overview' | 'velocity' | 'personal'): void {\n    this.currentLayout = layout;\n    void this.refreshData();\n  }\n\n  /**\n   * Add header with current info\n   */\n  private addHeader(title: string): void {\n    const headerStyles = this.themeHelper.getHeaderStyles();\n    const header = this.grid.set(-1, 0, 1, 12, blessed.box, {\n      label: title,\n      ...headerStyles,\n      align: 'center',\n    });\n\n    const now = new Date().toLocaleString();\n    header.setContent(`${String(title)} | ${String(now)} | Press 'h' for help`);\n    this.widgets.set('header', header);\n  }\n\n  /**\n   * Add footer with controls\n   */\n  private addFooter(): void {\n    const footerStyles = this.themeHelper.getFooterStyles();\n    const footer = this.grid.set(12, 0, 1, 12, blessed.box, {\n      ...footerStyles,\n      align: 'center',\n    });\n\n    const currentTheme = this.themeHelper.getTheme().name;\n    footer.setContent(\n      `1-3:Layouts | Tab:Navigate | r:Refresh | t:Theme(${String(currentTheme)}) | s:Stats | d:Debug | h:Help | q:Quit`\n    );\n    this.widgets.set('footer', footer);\n  }\n\n  /**\n   * Show error notification\n   */\n  private static showErrorNotification(message: string): void {\n    const errorBox = blessed.box({\n      top: 1,\n      right: 1,\n      width: Math.floor((this.screen as any).width * 0.4),\n      height: 3,\n      border: { type: 'line', fg: 'red' },\n      style: { fg: 'white', bg: 'red' },\n      label: '‚ö†Ô∏è  Error',\n      content: message,\n      padding: { left: 1, right: 1 },\n    });\n\n    this.screen.append(errorBox);\n    this.screen.render();\n\n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      this.screen.remove(errorBox);\n      this.screen.render();\n    }, 5000);\n  }\n\n  /**\n   * Show theme change notification\n   */\n  private static showThemeNotification(message: string): void {\n    const themeBox = blessed.box({\n      top: 1,\n      left: 1,\n      width: Math.floor((this.screen as any).width * 0.3),\n      height: 3,\n      border: { type: 'line', fg: this.themeHelper.getColor('primary') },\n      style: {\n        fg: this.themeHelper.getColor('foreground'),\n        bg: this.themeHelper.getColor('secondary'),\n      },\n      label: 'üé® Theme',\n      content: message,\n      padding: { left: 1, right: 1 },\n    });\n\n    this.screen.append(themeBox);\n    this.screen.render();\n\n    // Auto-remove after 3 seconds\n    setTimeout(() => {\n      this.screen.remove(themeBox);\n      this.screen.render();\n    }, 3000);\n  }\n\n  /**\n   * Show help overlay\n   */\n  private static showHelp(): void {\n    const helpBox = blessed.box({\n      top: 'center',\n      left: 'center',\n      width: '50%',\n      height: '60%',\n      border: { type: 'line', fg: 'yellow' },\n      style: { fg: 'white', bg: 'black' },\n      label: 'üìñ Dashboard Help',\n      content: `\nüéÆ Navigation & Controls:\n  Layout Switching:\n    1, F1      - Overview dashboard\n    2, F2      - Velocity dashboard  \n    3, F3      - Personal dashboard\n\n  Widget Navigation:\n    Tab        - Focus next widget\n    Shift+Tab  - Focus previous widget\n    F, F11     - Toggle fullscreen for focused widget\n    \n  Dashboard Controls:\n    r, F5      - Refresh data manually\n    a, F10     - Toggle auto-refresh\n    t, F9      - Cycle through themes\n    s          - Show quick statistics\n    d          - Toggle debug mode\n    e          - Export dashboard (coming soon)\n    \n  Help & Exit:\n    h, ?, F12  - Show this help\n    Escape     - Reset view to default\n    q, Ctrl+C  - Quit dashboard\n\nüìä Dashboard Layouts:\n  1 - Overview: Task status, priority breakdown, activity\n  2 - Velocity: Team performance, burndown charts, capacity\n  3 - Personal: Individual progress, focus areas, time tracking\n\nüé® Themes:\n  Available: dark, light, high-contrast, solarized-dark\n  Use 't' to cycle through themes or --theme flag on startup\n\n‚öôÔ∏è  Features:\n  ‚Ä¢ Real-time data updates with configurable intervals\n  ‚Ä¢ Interactive charts and tables with focus navigation\n  ‚Ä¢ Multiple color themes for accessibility\n  ‚Ä¢ Debug mode for troubleshooting\n  ‚Ä¢ Export functionality (coming soon)\n\nPress any key to close this help...\n      `,\n      padding: { left: 2, right: 2 },\n    });\n\n    this.screen.append(helpBox);\n    helpBox.focus();\n\n    helpBox.key(['escape', 'enter', 'space'], () => {\n      this.screen.remove(helpBox);\n      this.screen.render();\n    });\n\n    this.screen.render();\n  }\n\n  /**\n   * Toggle between available themes\n   */\n  private static toggleTheme(): void {\n    const themes = getThemeNames();\n    const currentIndex = themes.indexOf(this.config.theme);\n    const nextIndex = (currentIndex + 1) % themes.length;\n\n    this.config.theme = themes[nextIndex];\n    this.themeHelper.setTheme(this.config.theme);\n\n    // Show theme change notification\n    this.showThemeNotification(`Theme changed to: ${String(String(this.config.theme))}`);\n\n    // Refresh dashboard with new theme\n    this.refreshData();\n  }\n\n  /**\n   * Toggle auto-refresh\n   */\n  private static toggleAutoRefresh(): void {\n    this.config.autoRefresh = !this.config.autoRefresh;\n\n    if (this.config.autoRefresh) {\n      this.startAutoRefresh();\n    } else {\n      this.stopAutoRefresh();\n    }\n  }\n\n  /**\n   * Start auto-refresh timer\n   */\n  startAutoRefresh(): void {\n    this.stopAutoRefresh(); // Clear existing timer\n\n    if (this.config.autoRefresh) {\n      this.refreshTimer = setInterval(() => {\n        void this.refreshData();\n      }, this.config.refreshInterval);\n    }\n  }\n\n  /**\n   * Stop auto-refresh timer\n   */\n  stopAutoRefresh(): void {\n    if (this.refreshTimer) {\n      clearInterval(this.refreshTimer);\n      this.refreshTimer = undefined;\n    }\n  }\n\n  /**\n   * Refresh dashboard data\n   */\n  async refreshData(): Promise<void> {\n    try {\n      // Fetch real data from API or fallback to sample data\n      const data = await this.dataService.fetchDashboardData();\n\n      switch (this.currentLayout) {\n        case 'overview':\n          this.createOverviewDashboard(data);\n          break;\n        case 'velocity':\n          this.createVelocityDashboard(data);\n          break;\n        case 'personal':\n          this.createPersonalDashboard(data);\n          break;\n      }\n\n      this.screen.render();\n    } catch (error) {\n      // Show error notification and use sample data\n      this.showErrorNotification(`Data refresh failed: ${String(String(error.message))}`);\n      const fallbackData = this.generateSampleData();\n\n      switch (this.currentLayout) {\n        case 'overview':\n          this.createOverviewDashboard(fallbackData);\n          break;\n        case 'velocity':\n          this.createVelocityDashboard(fallbackData);\n          break;\n        case 'personal':\n          this.createPersonalDashboard(fallbackData);\n          break;\n      }\n\n      this.screen.render();\n    }\n  }\n\n  /**\n   * Clear all widgets\n   */\n  private clearWidgets(): void {\n    for (const widget of this.widgets.values()) {\n      widget.destroy();\n    }\n    this.widgets.clear();\n  }\n\n  /**\n   * Get color for task status\n   */\n  // private static getStatusColor(status: string): string {\n  //   const colors = {\n  //     todo: 'gray',\n  //     in_progress: 'yellow',\n  //     done: 'green',\n  //     blocked: 'red',\n  //   };\n  //   return colors[status as keyof typeof colors] ?? 'white';\n  // }\n\n  /**\n   * Generate sample data for demo\n   */\n  private static generateSampleData(): DashboardData {\n    return {\n      tasks: {\n        total: 45,\n        byStatus: {\n          todo: 18,\n          in_progress: 12,\n          done: 13,\n          blocked: 2,\n        },\n        byPriority: {\n          P1: 8,\n          P2: 15,\n          P3: 18,\n          P4: 4,\n        },\n        completed: 13,\n        overdue: 3,\n      },\n      velocity: [\n        { period: 'W1', completed: 12 },\n        { period: 'W2', completed: 15 },\n        { period: 'W3', completed: 18 },\n        { period: 'W4', completed: 14 },\n        { period: 'W5', completed: 20 },\n        { period: 'W6', completed: 16 },\n        { period: 'W7', completed: 22 },\n        { period: 'W8', completed: 19 },\n      ],\n      teamMembers: [\n        { name: 'Alice', taskCount: 8, load: 85 },\n        { name: 'Bob', taskCount: 6, load: 70 },\n        { name: 'Charlie', taskCount: 10, load: 95 },\n        { name: 'Diana', taskCount: 7, load: 75 },\n      ],\n      burndown: [\n        { day: 'Day 1', remaining: 45, ideal: 45 },\n        { day: 'Day 2', remaining: 42, ideal: 40 },\n        { day: 'Day 3', remaining: 38, ideal: 35 },\n        { day: 'Day 4', remaining: 35, ideal: 30 },\n        { day: 'Day 5', remaining: 30, ideal: 25 },\n        { day: 'Day 6', remaining: 28, ideal: 20 },\n        { day: 'Day 7', remaining: 25, ideal: 15 },\n        { day: 'Day 8', remaining: 20, ideal: 10 },\n        { day: 'Day 9', remaining: 15, ideal: 5 },\n        { day: 'Day 10', remaining: 12, ideal: 0 },\n      ],\n      activity: [\n        { timestamp: '14:32', event: 'Task completed: User Auth', user: 'Alice' },\n        { timestamp: '14:15', event: 'New task created: Fix login bug', user: 'Bob' },\n        { timestamp: '13:45', event: 'Task moved to In Progress', user: 'Charlie' },\n        { timestamp: '13:20', event: 'Comment added to TASK-123', user: 'Diana' },\n        { timestamp: '12:55', event: 'Task assigned to Alice', user: 'Bob' },\n      ],\n    };\n  }\n\n  /**\n   * Start the dashboard\n   */\n  start(): void {\n    void this.refreshData();\n    this.startAutoRefresh();\n    this.screen.render();\n  }\n\n  /**\n   * Focus next widget for navigation\n   */\n  private static focusNextWidget(): void {\n    const widgetKeys = Array.from(this.widgets.keys());\n    if (widgetKeys.length === 0) return;\n\n    const currentIndex = this.focusedWidget ? widgetKeys.indexOf(this.focusedWidget) : -1;\n    const nextIndex = (currentIndex + 1) % widgetKeys.length;\n\n    this.focusedWidget = widgetKeys[nextIndex];\n    const widget = this.widgets.get(this.focusedWidget);\n\n    if (widget?.focus) {\n      widget.focus();\n      this.screen.render();\n    }\n  }\n\n  /**\n   * Focus previous widget for navigation\n   */\n  private static focusPreviousWidget(): void {\n    const widgetKeys = Array.from(this.widgets.keys());\n    if (widgetKeys.length === 0) return;\n\n    const currentIndex = this.focusedWidget ? widgetKeys.indexOf(this.focusedWidget) : -1;\n    const prevIndex = currentIndex <= 0 ? widgetKeys.length - 1 : currentIndex - 1;\n\n    this.focusedWidget = widgetKeys[prevIndex];\n    const widget = this.widgets.get(this.focusedWidget);\n\n    if (widget?.focus) {\n      widget.focus();\n      this.screen.render();\n    }\n  }\n\n  /**\n   * Toggle fullscreen mode for focused widget\n   */\n  private static toggleFullscreen(): void {\n    if (!this.focusedWidget) {\n      this.showNotification('No widget focused. Use Tab to focus a widget first.');\n      return;\n    }\n\n    this.isFullscreen = !this.isFullscreen;\n\n    if (this.isFullscreen) {\n      this.showNotification(\n        `Fullscreen mode: ${String(String(this.focusedWidget))} (press F or F11 to exit)`\n      );\n      // In a real implementation, this would resize the focused widget to full screen\n    } else {\n      this.showNotification('Exited fullscreen mode');\n      this.refreshData(); // Restore normal layout\n    }\n  }\n\n  /**\n   * Show quick statistics overlay\n   */\n  private static showQuickStats(): void {\n    const statsBox = blessed.box({\n      top: 'center',\n      left: 'center',\n      width: '60%',\n      height: '50%',\n      border: { type: 'line', fg: this.themeHelper.getColor('primary') },\n      style: {\n        fg: this.themeHelper.getColor('foreground'),\n        bg: this.themeHelper.getColor('background'),\n      },\n      label: 'üìä Quick Statistics',\n      content: `\nüìà Performance Metrics:\n  ‚Ä¢ Dashboard Refresh Rate: ${String(String(this.config.refreshInterval / 1000))}s\n  ‚Ä¢ Active Widgets: ${String(String(this.widgets.size))}\n  ‚Ä¢ Current Theme: ${String(String(this.themeHelper.getTheme().name))}\n  ‚Ä¢ Auto-refresh: ${String(String(this.config.autoRefresh ? 'Enabled' : 'Disabled'))}\n\nüéÆ Navigation Tips:\n  ‚Ä¢ Tab/Shift+Tab: Navigate between widgets\n  ‚Ä¢ F/F11: Toggle fullscreen for focused widget\n  ‚Ä¢ 1-3/F1-F3: Switch dashboard layouts\n  ‚Ä¢ t/F9: Cycle through themes\n  ‚Ä¢ r/F5: Manual refresh\n  ‚Ä¢ s: Show this quick stats\n  ‚Ä¢ h/?: Full help\n\nPress any key to close...\n      `,\n      padding: { left: 2, right: 2 },\n    });\n\n    this.screen.append(statsBox);\n    statsBox.focus();\n\n    statsBox.key(['escape', 'enter', 'space', 's'], () => {\n      this.screen.remove(statsBox);\n      this.screen.render();\n    });\n\n    this.screen.render();\n  }\n\n  /**\n   * Export dashboard (placeholder)\n   */\n  private static exportDashboard(): void {\n    this.showNotification('Export functionality coming soon! (PNG/SVG export)');\n  }\n\n  /**\n   * Toggle debug mode\n   */\n  private static toggleDebugMode(): void {\n    this.debugMode = !this.debugMode;\n\n    if (this.debugMode) {\n      this.showNotification('Debug mode enabled - showing widget info');\n      this.showDebugOverlay();\n    } else {\n      this.showNotification('Debug mode disabled');\n      this.hideDebugOverlay();\n    }\n  }\n\n  /**\n   * Show debug overlay with widget information\n   */\n  private showDebugOverlay(): void {\n    const debugInfo = Array.from(this.widgets.entries())\n      .map(([name, widget]) => `${String(name)}: ${String(String(widget.constructor.name))}`)\n      .join('\\n');\n\n    const debugBox = blessed.box({\n      top: 0,\n      right: 0,\n      width: '25%',\n      height: '30%',\n      border: { type: 'line', fg: 'yellow' },\n      style: { fg: 'yellow', bg: 'black' },\n      label: 'üêõ Debug Info',\n      content: `\nWidgets: ${String(String(this.widgets.size))}\nFocused: ${String(String(this.focusedWidget ?? 'none'))}\nLayout: ${String(String(this.currentLayout))}\nFullscreen: ${String(String(this.isFullscreen))}\nTheme: ${String(String(this.themeHelper.getTheme().name))}\n\nActive Widgets:\n${String(debugInfo)}\n      `,\n      padding: { left: 1, right: 1 },\n    });\n\n    this.widgets.set('debug', debugBox);\n    this.screen.append(debugBox);\n    this.screen.render();\n  }\n\n  /**\n   * Hide debug overlay\n   */\n  private hideDebugOverlay(): void {\n    const debugWidget = this.widgets.get('debug');\n    if (debugWidget) {\n      this.screen.remove(debugWidget);\n      this.widgets.delete('debug');\n      this.screen.render();\n    }\n  }\n\n  /**\n   * Reset view to default state\n   */\n  private static resetView(): void {\n    this.isFullscreen = false;\n    this.focusedWidget = null;\n    this.debugMode = false;\n    this.hideDebugOverlay();\n    this.refreshData();\n    this.showNotification('View reset to default state');\n  }\n\n  /**\n   * Show general notification\n   */\n  private static showNotification(message: string): void {\n    const notificationBox = blessed.box({\n      top: 1,\n      left: 'center',\n      width: '50%',\n      height: 3,\n      border: { type: 'line', fg: this.themeHelper.getColor('info') },\n      style: {\n        fg: this.themeHelper.getColor('foreground'),\n        bg: this.themeHelper.getColor('secondary'),\n      },\n      label: '‚ÑπÔ∏è  Info',\n      content: message,\n      padding: { left: 1, right: 1 },\n    });\n\n    this.screen.append(notificationBox);\n    this.screen.render();\n\n    // Auto-remove after 3 seconds\n    setTimeout(() => {\n      this.screen.remove(notificationBox);\n      this.screen.render();\n    }, 3000);\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    this.stopAutoRefresh();\n    this.clearWidgets();\n    this.screen.destroy();\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/formatter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/input-sanitizer.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 33,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 33,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [784, 787], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [784, 787], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `WindowLike | undefined`.",
        "line": 38,
        "column": 29,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 38,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 38,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 38,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [952, 955], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [952, 955], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 41,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 41,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .addHook on an `any` value.",
        "line": 41,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 41,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 41,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 41,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1067, 1070], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1067, 1070], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .nodeName on an `any` value.",
        "line": 43,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 43,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .nodeName on an `any` value.",
        "line": 43,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 43,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 44,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 44,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .remove on an `any` value.",
        "line": 44,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 44,
        "endColumn": 20
      },
      {
        "ruleId": "no-control-regex",
        "severity": 2,
        "message": "Unexpected control character(s) in regular expression: \\x00, \\x08, \\x0b, \\x0c, \\x0e, \\x1f.",
        "line": 87,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "unexpected",
        "endLine": 87,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 102,
        "column": 7,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 102,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 102,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 102,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .sanitize on an `any` value.",
        "line": 102,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 102,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 104,
        "column": 7,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 104,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 104,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 104,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .sanitize on an `any` value.",
        "line": 104,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 104,
        "endColumn": 39
      },
      {
        "ruleId": "no-control-regex",
        "severity": 2,
        "message": "Unexpected control character(s) in regular expression: \\x00.",
        "line": 155,
        "column": 7,
        "nodeType": "Literal",
        "messageId": "unexpected",
        "endLine": 155,
        "endColumn": 14
      },
      {
        "ruleId": "no-new",
        "severity": 2,
        "message": "Do not use 'new' for side effects.",
        "line": 238,
        "column": 7,
        "nodeType": "ExpressionStatement",
        "messageId": "noNewStatement",
        "endLine": 238,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 346,
        "column": 41,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 346,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [9232, 9234], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'detectSuspiciousPatterns'.",
        "line": 356,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 356,
        "endColumn": 27
      },
      {
        "ruleId": "no-control-regex",
        "severity": 2,
        "message": "Unexpected control character(s) in regular expression: \\x00, \\x08, \\x0b, \\x0c, \\x0e, \\x1f.",
        "line": 416,
        "column": 9,
        "nodeType": "Literal",
        "messageId": "unexpected",
        "endLine": 416,
        "endColumn": 48
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\[.",
        "line": 423,
        "column": 60,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 423,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [11703, 11704], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [11703, 11703], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 423,
        "column": 84,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 423,
        "endColumn": 86,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [11727, 11729], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import DOMPurify from 'dompurify';\nimport { JSDOM } from 'jsdom';\n\n/**\n * Comprehensive input sanitization utility for CLI prompts\n * Addresses TASK-119: Implement input sanitization for all prompts\n */\n\nexport interface SanitizationOptions {\n  allowHtml?: boolean;\n  maxLength?: number;\n  allowedCharacters?: RegExp;\n  stripControlChars?: boolean;\n  normalizeWhitespace?: boolean;\n  preventInjection?: boolean;\n  escapeSpecialChars?: boolean;\n}\n\nexport interface SanitizationResult {\n  sanitized: string;\n  modified: boolean;\n  warnings: string[];\n  originalLength: number;\n  sanitizedLength: number;\n}\n\n/**\n * Main input sanitizer class with security-focused features\n */\nexport class InputSanitizer {\n  private static readonly instance: InputSanitizer;\n\n  private readonly purify: any;\n\n  constructor() {\n    // Initialize DOMPurify with JSDOM for server-side sanitization\n    const { window } = new JSDOM('');\n    this.purify = DOMPurify(window as any);\n\n    // Configure DOMPurify for strict sanitization\n    this.purify.addHook('beforeSanitizeElements', (node: any) => {\n      // Remove all script tags and event handlers\n      if (node.nodeName === 'SCRIPT' || node.nodeName === 'IFRAME') {\n        node.remove();\n      }\n    });\n  }\n\n  static getInstance(): InputSanitizer {\n    if (!InputSanitizer.instance) {\n      InputSanitizer.instance = new InputSanitizer();\n    }\n    return InputSanitizer.instance;\n  }\n\n  /**\n   * Sanitize text input with comprehensive security checks\n   */\n  sanitizeText(input: string, options: SanitizationOptions = {}): SanitizationResult {\n    const {\n      allowHtml = false,\n      maxLength = 1000,\n      stripControlChars = true,\n      normalizeWhitespace = true,\n      preventInjection = true,\n      escapeSpecialChars = true,\n    } = options;\n\n    let sanitized = input;\n    const warnings: string[] = [];\n    const originalLength = input.length;\n\n    // 1. Basic safety checks\n    if (typeof sanitized !== 'string') {\n      sanitized = String(sanitized);\n      warnings.push('Input was converted to string');\n    }\n\n    // 2. Length validation\n    if (sanitized.length > maxLength) {\n      sanitized = sanitized.substring(0, maxLength);\n      warnings.push(`Input truncated to ${String(maxLength)} characters`);\n    }\n\n    // 3. Strip control characters (except common whitespace)\n    if (stripControlChars) {\n      const controlCharRegex = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F]/g;\n      const beforeStrip = sanitized;\n      sanitized = sanitized.replace(controlCharRegex, '');\n      if (beforeStrip !== sanitized) {\n        warnings.push('Control characters removed');\n      }\n    }\n\n    // 4. Command injection prevention\n    if (preventInjection) {\n      sanitized = InputSanitizer.preventCommandInjection(sanitized, warnings);\n    }\n\n    // 5. HTML sanitization\n    if (!allowHtml) {\n      sanitized = this.purify.sanitize(sanitized, { ALLOWED_TAGS: [] });\n    } else {\n      sanitized = this.purify.sanitize(sanitized);\n    }\n\n    // 6. Escape special characters for CLI safety\n    if (escapeSpecialChars) {\n      sanitized = InputSanitizer.escapeCliSpecialChars(sanitized, warnings);\n    }\n\n    // 7. Normalize whitespace\n    if (normalizeWhitespace) {\n      const beforeNormalize = sanitized;\n      sanitized = sanitized\n        .replace(/\\s+/g, ' ') // Multiple spaces to single\n        .replace(/^\\s+|\\s+$/g, '') // Trim\n        .replace(/\\t/g, '    '); // Tabs to spaces\n      if (beforeNormalize !== sanitized) {\n        warnings.push('Whitespace normalized');\n      }\n    }\n\n    // 8. Additional character restrictions\n    if (options.allowedCharacters) {\n      const beforeFilter = sanitized;\n      sanitized = sanitized.replace(\n        new RegExp(`[^${String(String(options.allowedCharacters.source))}]`, 'g'),\n        ''\n      );\n      if (beforeFilter !== sanitized) {\n        warnings.push('Invalid characters removed');\n      }\n    }\n\n    return {\n      sanitized,\n      modified: sanitized !== input,\n      warnings,\n      originalLength,\n      sanitizedLength: sanitized.length,\n    };\n  }\n\n  /**\n   * Prevent command injection attacks\n   */\n  private static preventCommandInjection(input: string, warnings: string[]): string {\n    const dangerousPatterns = [\n      // Shell injection patterns\n      /[;&|`$(){}[\\]\\\\]/g,\n      // Path traversal\n      /\\.\\.[/\\\\]/g,\n      // Null bytes\n      /\\x00/g,\n      // Process substitution\n      /<\\(/g,\n      />\\(/g,\n      // Command substitution\n      /\\$\\(/g,\n      // Backticks\n      /`/g,\n    ];\n\n    let sanitized = input;\n    let hasInjectionAttempt = false;\n\n    dangerousPatterns.forEach(pattern => {\n      if (pattern.test(sanitized)) {\n        sanitized = sanitized.replace(pattern, '');\n        hasInjectionAttempt = true;\n      }\n    });\n\n    if (hasInjectionAttempt) {\n      warnings.push('Potential command injection patterns removed');\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Escape CLI special characters\n   */\n  private static escapeCliSpecialChars(input: string, warnings: string[]): string {\n    const beforeEscape = input;\n\n    // Escape common shell metacharacters that are safe to keep but should be escaped\n    const escapeMap: Record<string, string> = {\n      '\"': '\\\\\"',\n      \"'\": \"\\\\'\",\n      '\\\\': '\\\\\\\\',\n    };\n\n    let escaped = input;\n    Object.entries(escapeMap).forEach(([char, replacement]) => {\n      escaped = escaped.replace(new RegExp(`\\\\${String(char)}`, 'g'), replacement);\n    });\n\n    if (beforeEscape !== escaped) {\n      warnings.push('Special characters escaped');\n    }\n\n    return escaped;\n  }\n\n  /**\n   * Sanitize file path inputs\n   */\n  sanitizeFilePath(input: string): SanitizationResult {\n    return this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength: 255,\n      stripControlChars: true,\n      normalizeWhitespace: true,\n      preventInjection: true,\n      escapeSpecialChars: false, // File paths may need some special chars\n      allowedCharacters: /[\\w\\-.\\s/\\\\:]/,\n    });\n  }\n\n  /**\n   * Sanitize URL inputs\n   */\n  sanitizeUrl(input: string): SanitizationResult {\n    const result = this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength: 2048,\n      stripControlChars: true,\n      normalizeWhitespace: true,\n      preventInjection: true,\n      escapeSpecialChars: false,\n      allowedCharacters: /[\\w\\-._~:/?#[\\]@!$&'()*+,;=%]/,\n    });\n\n    // Additional URL validation\n    try {\n      new URL(result.sanitized);\n    } catch {\n      result.warnings.push('Invalid URL format detected');\n      result.sanitized = '';\n    }\n\n    return result;\n  }\n\n  /**\n   * Sanitize email inputs\n   */\n  sanitizeEmail(input: string): SanitizationResult {\n    return this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength: 254, // RFC 5321 limit\n      stripControlChars: true,\n      normalizeWhitespace: true,\n      preventInjection: true,\n      escapeSpecialChars: false,\n      allowedCharacters: /[\\w\\-_.@+]/,\n    });\n  }\n\n  /**\n   * Sanitize task title with specific rules\n   */\n  sanitizeTaskTitle(input: string): SanitizationResult {\n    return this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength: 200,\n      stripControlChars: true,\n      normalizeWhitespace: true,\n      preventInjection: true,\n      escapeSpecialChars: true,\n      allowedCharacters: /[\\w\\s\\-_.()[\\]!?@#%&+=]/,\n    });\n  }\n\n  /**\n   * Sanitize description/long text inputs\n   */\n  sanitizeDescription(input: string): SanitizationResult {\n    return this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength: 2000,\n      stripControlChars: true,\n      normalizeWhitespace: true,\n      preventInjection: true,\n      escapeSpecialChars: false, // Descriptions can have more varied content\n      allowedCharacters: /[\\w\\s\\-_.()[\\]!?@#%&+=:;,.\"']/,\n    });\n  }\n\n  /**\n   * Sanitize board/column names\n   */\n  sanitizeName(input: string, maxLength: number = 50): SanitizationResult {\n    return this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength,\n      stripControlChars: true,\n      normalizeWhitespace: true,\n      preventInjection: true,\n      escapeSpecialChars: true,\n      allowedCharacters: /[\\w\\s\\-_]/,\n    });\n  }\n\n  /**\n   * Sanitize tag names (more restrictive)\n   */\n  sanitizeTag(input: string): SanitizationResult {\n    return this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength: 20,\n      stripControlChars: true,\n      normalizeWhitespace: true,\n      preventInjection: true,\n      escapeSpecialChars: true,\n      allowedCharacters: /[\\w\\-_]/,\n    });\n  }\n\n  /**\n   * Sanitize command-line arguments\n   */\n  sanitizeCliArgument(input: string): SanitizationResult {\n    return this.sanitizeText(input, {\n      allowHtml: false,\n      maxLength: 500,\n      stripControlChars: true,\n      normalizeWhitespace: false, // Preserve exact spacing in CLI args\n      preventInjection: true,\n      escapeSpecialChars: true,\n    });\n  }\n\n  /**\n   * Batch sanitize multiple inputs\n   */\n  sanitizeBatch(\n    inputs: Record<string, string>,\n    sanitizers: Record<string, (input: string) => SanitizationResult>\n  ): Record<string, SanitizationResult> {\n    const results: Record<string, SanitizationResult> = {};\n\n    Object.entries(inputs).forEach(([key, value]) => {\n      const sanitizer = sanitizers[key] || this.sanitizeText.bind(this);\n      results[key] = sanitizer(value);\n    });\n\n    return results;\n  }\n\n  /**\n   * Check if input contains suspicious patterns\n   */\n  detectSuspiciousPatterns(input: string): { suspicious: boolean; patterns: string[] } {\n    const suspiciousPatterns = [\n      { pattern: /javascript:/i, name: 'JavaScript protocol' },\n      { pattern: /data:/i, name: 'Data protocol' },\n      { pattern: /vbscript:/i, name: 'VBScript protocol' },\n      { pattern: /<script/i, name: 'Script tag' },\n      { pattern: /on\\w+\\s*=/i, name: 'Event handler' },\n      { pattern: /eval\\s*\\(/i, name: 'Eval function' },\n      { pattern: /expression\\s*\\(/i, name: 'CSS expression' },\n      { pattern: /\\$\\{.*\\}/g, name: 'Template literal injection' },\n      { pattern: /\\{\\{.*\\}\\}/g, name: 'Template engine injection' },\n      { pattern: /rm\\s+-rf/i, name: 'Destructive command' },\n      { pattern: /curl\\s+.*\\|\\s*sh/i, name: 'Remote script execution' },\n    ];\n\n    const detectedPatterns: string[] = [];\n\n    suspiciousPatterns.forEach(({ pattern, name }) => {\n      if (pattern.test(input)) {\n        detectedPatterns.push(name);\n      }\n    });\n\n    return {\n      suspicious: detectedPatterns.length > 0,\n      patterns: detectedPatterns,\n    };\n  }\n\n  /**\n   * Generate security report for input\n   */\n  generateSecurityReport(input: string): {\n    safe: boolean;\n    score: number; // 0-100, higher is safer\n    issues: string[];\n    recommendations: string[];\n  } {\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    let score = 100;\n\n    // Check length\n    if (input.length > 1000) {\n      issues.push('Input exceeds recommended length');\n      recommendations.push('Consider shortening the input');\n      score -= 10;\n    }\n\n    // Check for suspicious patterns\n    const suspiciousCheck = this.detectSuspiciousPatterns(input);\n    if (suspiciousCheck.suspicious) {\n      issues.push(\n        `Suspicious patterns detected: ${String(String(suspiciousCheck.patterns.join(', ')))}`\n      );\n      recommendations.push('Remove or escape suspicious content');\n      score -= 30;\n    }\n\n    // Check for control characters\n    if (/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F]/.test(input)) {\n      issues.push('Contains control characters');\n      recommendations.push('Remove non-printable characters');\n      score -= 15;\n    }\n\n    // Check for excessive special characters\n    const specialCharCount = (input.match(/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?]/g) || []).length;\n    const specialCharRatio = specialCharCount / input.length;\n    if (specialCharRatio > 0.3) {\n      issues.push('High ratio of special characters');\n      recommendations.push('Review special character usage');\n      score -= 10;\n    }\n\n    return {\n      safe: score >= 70,\n      score: Math.max(0, score),\n      issues,\n      recommendations,\n    };\n  }\n}\n\n// Export singleton instance\nexport const inputSanitizer = InputSanitizer.getInstance();\n\n// Utility functions for quick access\nexport const sanitizeTaskTitle = (input: string): SanitizationResult =>\n  inputSanitizer.sanitizeTaskTitle(input);\nexport const sanitizeDescription = (input: string): SanitizationResult =>\n  inputSanitizer.sanitizeDescription(input);\nexport const sanitizeName = (input: string, maxLength?: number): SanitizationResult =>\n  inputSanitizer.sanitizeName(input, maxLength);\nexport const sanitizeTag = (input: string): SanitizationResult => inputSanitizer.sanitizeTag(input);\nexport const sanitizeEmail = (input: string): SanitizationResult =>\n  inputSanitizer.sanitizeEmail(input);\nexport const sanitizeUrl = (input: string): SanitizationResult => inputSanitizer.sanitizeUrl(input);\nexport const sanitizeFilePath = (input: string): SanitizationResult =>\n  inputSanitizer.sanitizeFilePath(input);\nexport const detectSuspicious = (input: string): { suspicious: boolean; patterns: string[] } =>\n  inputSanitizer.detectSuspiciousPatterns(input);\n\n/**\n * Safe prompt wrapper that automatically sanitizes input\n */\nexport function createSafePromptValidator(\n  sanitizeFunction: (input: string) => SanitizationResult,\n  additionalValidation?: (input: string) => true | string\n) {\n  return (input: string): true | string => {\n    // First, sanitize the input\n    const sanitized = sanitizeFunction(input);\n\n    // Check if input was modified significantly\n    if (sanitized.modified && sanitized.warnings.length > 0) {\n      return `Input modified during sanitization: ${String(String(sanitized.warnings.join(', ')))}. Please try again.`;\n    }\n\n    // Check security score\n    const securityReport = inputSanitizer.generateSecurityReport(input);\n    if (!securityReport.safe) {\n      return `Security issues detected: ${String(String(securityReport.issues.join(', ')))}`;\n    }\n\n    // Run additional validation if provided\n    if (additionalValidation) {\n      return additionalValidation(sanitized.sanitized);\n    }\n\n    return true;\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/keyboard-handler.ts",
    "messages": [
      {
        "ruleId": "max-classes-per-file",
        "severity": 2,
        "message": "File has too many classes (2). Maximum allowed is 1.",
        "line": 1,
        "column": 1,
        "nodeType": "Program",
        "messageId": "maximumExceeded",
        "endLine": 342,
        "endColumn": 1
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 24,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 24,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 54,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "voidReturnArgument",
        "endLine": 54,
        "endColumn": 62
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 106,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 106,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "clear" },
            "fix": { "range": [2294, 2310], "text": "" },
            "desc": "Remove the console.clear()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 122,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 122,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 122,
        "column": 28,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 122,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 130,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 130,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 130,
        "column": 28,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 130,
        "endColumn": 49
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 146,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 146,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "clear" },
            "fix": { "range": [3585, 3601], "text": "" },
            "desc": "Remove the console.clear()."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 173,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 173,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 176,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 176,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 176,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 176,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 181,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 181,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 185,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 185,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 191,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 191,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async method 'action' has no 'await' expression.",
        "line": 194,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 194,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 201,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 201,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async method 'action' has no 'await' expression.",
        "line": 204,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 204,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 211,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 211,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'ScopedKeyboardHandler' was used before it was defined.",
        "line": 267,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 267,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import chalk from 'chalk';\nimport { logger } from '../../utils/logger';\n\nexport interface KeyboardShortcut {\n  key: string;\n  description: string;\n  action: () => Promise<void> | void;\n  global?: boolean;\n}\n\n/**\n * Global keyboard shortcut handler for CLI applications\n */\nexport class KeyboardHandler {\n  private readonly shortcuts: Map<string, KeyboardShortcut> = new Map();\n\n  private readonly isActive = false;\n\n  private readonly helpVisible = false;\n\n  private readonly refreshCallback?: () => Promise<void> | void;\n\n  constructor() {\n    this.setupDefaultShortcuts();\n  }\n\n  /**\n   * Register a new keyboard shortcut\n   */\n  register(shortcut: KeyboardShortcut): void {\n    this.shortcuts.set(shortcut.key, shortcut);\n  }\n\n  /**\n   * Remove a keyboard shortcut\n   */\n  unregister(key: string): void {\n    this.shortcuts.delete(key);\n  }\n\n  /**\n   * Activate global keyboard listening\n   */\n  activate(): void {\n    if (this.isActive) return;\n\n    this.isActive = true;\n\n    // Set up raw mode for real-time key capture\n    if (process.stdin.isTTY) {\n      process.stdin.setRawMode(true);\n      process.stdin.resume();\n      process.stdin.setEncoding('utf8');\n      process.stdin.on('data', this.handleKeyPress.bind(this));\n    }\n  }\n\n  /**\n   * Deactivate global keyboard listening\n   */\n  deactivate(): void {\n    if (!this.isActive) return;\n\n    this.isActive = false;\n\n    if (process.stdin.isTTY) {\n      process.stdin.setRawMode(false);\n      process.stdin.pause();\n      process.stdin.removeAllListeners('data');\n    }\n  }\n\n  /**\n   * Handle key press events\n   */\n  private async handleKeyPress(key: string): Promise<void> {\n    const keyCode = key.charCodeAt(0);\n\n    // Handle Ctrl+C (exit)\n    if (keyCode === 3) {\n      logger.info(chalk.yellow('\\n‚ö†Ô∏è  Interrupted by user'));\n      process.exit(130);\n    }\n\n    // Handle specific key combinations\n    const shortcut = this.shortcuts.get(key);\n    if (shortcut) {\n      try {\n        await shortcut.action();\n      } catch (error) {\n        logger.error(chalk.red(`Error executing shortcut ${String(key)}:`), error);\n      }\n    }\n  }\n\n  /**\n   * Show help overlay with all available shortcuts\n   */\n  showHelp(): void {\n    if (this.helpVisible) {\n      this.hideHelp();\n      return;\n    }\n\n    this.helpVisible = true;\n    console.clear();\n\n    logger.log(chalk.cyan.bold('\\nüìã Keyboard Shortcuts\\n'));\n    logger.log(chalk.gray('‚îÄ'.repeat(50)));\n\n    const globalShortcuts = Array.from(this.shortcuts.values())\n      .filter(s => s.global)\n      .sort((a, b) => a.key.localeCompare(b.key));\n\n    const localShortcuts = Array.from(this.shortcuts.values())\n      .filter(s => !s.global)\n      .sort((a, b) => a.key.localeCompare(b.key));\n\n    if (globalShortcuts.length > 0) {\n      logger.log(chalk.yellow.bold('\\nGlobal Shortcuts:'));\n      globalShortcuts.forEach(shortcut => {\n        const keyDisplay = this.formatKeyDisplay(shortcut.key);\n        logger.log(`  ${String(keyDisplay)} - ${String(String(shortcut.description))}`);\n      });\n    }\n\n    if (localShortcuts.length > 0) {\n      logger.log(chalk.yellow.bold('\\nContext Shortcuts:'));\n      localShortcuts.forEach(shortcut => {\n        const keyDisplay = this.formatKeyDisplay(shortcut.key);\n        logger.log(`  ${String(keyDisplay)} - ${String(String(shortcut.description))}`);\n      });\n    }\n\n    logger.log(chalk.gray('\\n‚îÄ'.repeat(50)));\n    logger.log(chalk.gray('Press ? again to hide help, Ctrl+C to exit\\n'));\n  }\n\n  /**\n   * Hide help overlay\n   */\n  hideHelp(): void {\n    if (!this.helpVisible) return;\n\n    this.helpVisible = false;\n    console.clear();\n    logger.log(chalk.gray('Help hidden. Press ? to show again.\\n'));\n  }\n\n  /**\n   * Format key display for help\n   */\n  private static formatKeyDisplay(key: string): string {\n    const keyCode = key.charCodeAt(0);\n\n    if (keyCode === 3) return chalk.cyan('Ctrl+C');\n    if (keyCode === 18) return chalk.cyan('Ctrl+R');\n    if (keyCode === 6) return chalk.cyan('Ctrl+F');\n    if (keyCode === 14) return chalk.cyan('Ctrl+N');\n    if (key === '?') return chalk.cyan('?');\n    if (key === 'q') return chalk.cyan('q');\n    if (key === 'r') return chalk.cyan('r');\n    if (key === '/') return chalk.cyan('/');\n\n    return chalk.cyan(key);\n  }\n\n  /**\n   * Set up default global shortcuts\n   */\n  private static setupDefaultShortcuts(): void {\n    // Help shortcut\n    this.register({\n      key: '?',\n      description: 'Show/hide keyboard shortcuts help',\n      action: () => this.showHelp(),\n      global: true,\n    });\n\n    // Refresh shortcut (Ctrl+R)\n    this.register({\n      key: String.fromCharCode(18), // Ctrl+R\n      description: 'Refresh current view',\n      action: async () => {\n        await this.executeRefresh();\n      },\n      global: true,\n    });\n\n    // Search shortcut (Ctrl+F or /)\n    this.register({\n      key: '/',\n      description: 'Search/filter',\n      action: async () => {\n        logger.log(chalk.cyan('üîç Search mode (not implemented)'));\n      },\n      global: true,\n    });\n\n    // New item shortcut (Ctrl+N)\n    this.register({\n      key: String.fromCharCode(14), // Ctrl+N\n      description: 'Create new item',\n      action: async () => {\n        logger.log(chalk.cyan('üìù Create new item (not implemented)'));\n      },\n      global: true,\n    });\n\n    // Quit shortcut\n    this.register({\n      key: 'q',\n      description: 'Quit application',\n      action: () => {\n        logger.log(chalk.yellow('üëã Goodbye!'));\n        process.exit(0);\n      },\n      global: true,\n    });\n  }\n\n  /**\n   * Get all registered shortcuts\n   */\n  getShortcuts(): KeyboardShortcut[] {\n    return Array.from(this.shortcuts.values());\n  }\n\n  /**\n   * Check if handler is currently active\n   */\n  isActivated(): boolean {\n    return this.isActive;\n  }\n\n  /**\n   * Set refresh callback for Ctrl+R functionality\n   */\n  setRefreshCallback(callback: () => Promise<void> | void): void {\n    this.refreshCallback = callback;\n  }\n\n  /**\n   * Execute refresh action\n   */\n  private async executeRefresh(): Promise<void> {\n    if (this.refreshCallback) {\n      try {\n        logger.log(chalk.cyan('üîÑ Refreshing...'));\n        await this.refreshCallback();\n        logger.log(chalk.green('‚úÖ Refreshed'));\n      } catch (error) {\n        logger.error(\n          chalk.red('‚ùå Refresh failed:'),\n          error instanceof Error ? error.message : String(error)\n        );\n      }\n    } else {\n      logger.log(chalk.yellow('‚ö†Ô∏è  No refresh action available in current context'));\n    }\n  }\n\n  /**\n   * Create a scoped keyboard handler for specific contexts\n   */\n  createScope(contextName: string): ScopedKeyboardHandler {\n    return new ScopedKeyboardHandler(this, contextName);\n  }\n}\n\n/**\n * Scoped keyboard handler for specific UI contexts\n */\nexport class ScopedKeyboardHandler {\n  private readonly parent: KeyboardHandler;\n\n  // private readonly contextName: string;\n\n  private readonly scopedShortcuts: Map<string, KeyboardShortcut> = new Map();\n\n  constructor(parent: KeyboardHandler, _contextName: string) {\n    this.parent = parent;\n    // this['contextName'] = contextName;\n  }\n\n  /**\n   * Register a context-specific shortcut\n   */\n  register(shortcut: Omit<KeyboardShortcut, 'global'>): void {\n    const scopedShortcut: KeyboardShortcut = {\n      ...shortcut,\n      global: false,\n    };\n\n    this.scopedShortcuts.set(shortcut.key, scopedShortcut);\n    this.parent.register(scopedShortcut);\n  }\n\n  /**\n   * Activate this scope (removes other scope shortcuts)\n   */\n  activate(): void {\n    // Clean up previous scope shortcuts\n    this.parent\n      .getShortcuts()\n      .filter(s => !s.global)\n      .forEach(s => this.parent.unregister(s.key));\n\n    // Add this scope's shortcuts\n    this.scopedShortcuts.forEach(shortcut => {\n      this.parent.register(shortcut);\n    });\n  }\n\n  /**\n   * Deactivate this scope\n   */\n  deactivate(): void {\n    this.scopedShortcuts.forEach((_, key) => {\n      this.parent.unregister(key);\n    });\n  }\n}\n\n// Export singleton instance\nexport const keyboardHandler = new KeyboardHandler();\n\n// Cleanup on process exit\nprocess.on('exit', () => {\n  keyboardHandler.deactivate();\n});\n\nprocess.on('SIGINT', () => {\n  keyboardHandler.deactivate();\n  process.exit(130);\n});\n\nprocess.on('SIGTERM', () => {\n  keyboardHandler.deactivate();\n  process.exit(143);\n});\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/secure-cli-wrapper.ts",
    "messages": [
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to function parameter 'arg'.",
        "line": 172,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParam",
        "endLine": 172,
        "endColumn": 12
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to function parameter 'arg'.",
        "line": 190,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParam",
        "endLine": 190,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 240,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 240,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8131, 8134], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8131, 8134], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 240,
        "column": 69,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 240,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 241,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 241,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8203, 8206], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8203, 8206], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 244,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 244,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ArrayLike<unknown> | { [s: string]: unknown; }`.",
        "line": 283,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 283,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe spread of an `any` array type.",
        "line": 302,
        "column": 27,
        "nodeType": "SpreadElement",
        "messageId": "unsafeArraySpread",
        "endLine": 302,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 332,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 332,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 332,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 332,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11667, 11670], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11667, 11670], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access ._actionHandler on an `any` value.",
        "line": 332,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 332,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 335,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 335,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11752, 11755], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11752, 11755], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 347,
        "column": 11,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 347,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 347,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeCall",
        "endLine": 347,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 445,
        "column": 60,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 445,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [15268, 15270], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 446,
        "column": 60,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 446,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [15338, 15340], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'program'.",
        "line": 726,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 726,
        "endColumn": 10
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 726,
        "column": 19,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 726,
        "endColumn": 28
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 726,
        "column": 19,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 726,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 726,
        "column": 65,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 726,
        "endColumn": 68,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [23055, 23058], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [23055, 23058], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 727,
        "column": 23,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 727,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [23084, 23086], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string[] | undefined`.",
        "line": 742,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 742,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Secure CLI Wrapper\n * Integrates command injection prevention and input sanitization for the entire CLI\n * Addresses TASK-120: Command injection prevention\n */\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport { commandInjectionPrevention, validateCommand } from './command-injection-prevention';\nimport { inputSanitizer } from './input-sanitizer';\nimport { logger } from '../../utils/logger';\n\n/**\n * Configuration options for CLI security features\n *\n * @interface SecurityConfig\n * @property {boolean} enableInputSanitization - Enable automatic input sanitization\n * @property {boolean} enableCommandValidation - Enable command validation checks\n * @property {boolean} logSecurityEvents - Log security events for monitoring\n * @property {boolean} strictMode - Fail on security warnings instead of just logging\n * @property {number} maxArgumentLength - Maximum allowed length for CLI arguments\n * @property {string[]} allowedCommands - Whitelist of allowed commands\n * @property {RegExp[]} blockedPatterns - Patterns that trigger security blocks\n */\nexport interface SecurityConfig {\n  enableInputSanitization: boolean;\n  enableCommandValidation: boolean;\n  logSecurityEvents: boolean;\n  strictMode: boolean;\n  maxArgumentLength: number;\n  allowedCommands: string[];\n  blockedPatterns: RegExp[];\n}\n\n/**\n * Security event for audit logging\n *\n * @interface SecurityEvent\n * @property {Date} timestamp - When the event occurred\n * @property {'input_sanitized' | 'command_blocked' | 'suspicious_pattern' | 'validation_failed'} type - Event type\n * @property {string} details - Detailed description of the event\n * @property {string} input - The input that triggered the event\n * @property {'low' | 'medium' | 'high' | 'critical'} risk - Risk level assessment\n */\nexport interface SecurityEvent {\n  timestamp: Date;\n  type: 'input_sanitized' | 'command_blocked' | 'suspicious_pattern' | 'validation_failed';\n  details: string;\n  input: string;\n  risk: 'low' | 'medium' | 'high' | 'critical';\n}\n\n/**\n * Secure CLI wrapper with comprehensive protection\n *\n * @class SecureCliWrapper\n * @description Provides a security layer for CLI applications by integrating\n * command injection prevention, input sanitization, and security event monitoring.\n * Wraps Commander.js commands with automatic security validation.\n *\n * @example\n * ```typescript\n * const wrapper = SecureCliWrapper.getInstance();\n * const command = wrapper.createSecureCommand('process', 'Process data safely');\n *\n * // Add security middleware to entire program\n * addSecurityMiddleware(program);\n * ```\n */\nexport class SecureCliWrapper {\n  private static readonly instance: SecureCliWrapper;\n\n  private readonly securityEvents: SecurityEvent[] = [];\n\n  private readonly config: SecurityConfig;\n\n  constructor(config: Partial<SecurityConfig> = {}) {\n    this.config = {\n      enableInputSanitization: true,\n      enableCommandValidation: true,\n      logSecurityEvents: true,\n      strictMode: false,\n      maxArgumentLength: 1000,\n      allowedCommands: [],\n      blockedPatterns: [\n        /rm\\s+-rf/i,\n        /curl.*\\|.*sh/i,\n        /wget.*\\|.*sh/i,\n        /eval\\s*\\(/i,\n        /exec\\s*\\(/i,\n        /system\\s*\\(/i,\n        /passthru\\s*\\(/i,\n        /shell_exec\\s*\\(/i,\n        /`[^`]*`/,\n        /\\$\\([^)]*\\)/,\n        /<\\([^)]*\\)/,\n      ],\n      ...config,\n    };\n\n    // Configure command injection prevention with CLI-specific settings\n    if (this.config.allowedCommands.length > 0) {\n      this.config.allowedCommands.forEach(cmd => {\n        commandInjectionPrevention.addAllowedCommand(cmd);\n      });\n    }\n  }\n\n  /**\n   * Gets the singleton instance of SecureCliWrapper\n   *\n   * @static\n   * @param {Partial<SecurityConfig>} [config] - Security configuration\n   * @returns {SecureCliWrapper} The singleton instance\n   *\n   * @example\n   * ```typescript\n   * const wrapper = SecureCliWrapper.getInstance({\n   *   strictMode: true,\n   *   maxArgumentLength: 500\n   * });\n   * ```\n   */\n  static getInstance(config?: Partial<SecurityConfig>): SecureCliWrapper {\n    if (!SecureCliWrapper.instance) {\n      SecureCliWrapper.instance = new SecureCliWrapper(config);\n    }\n    return SecureCliWrapper.instance;\n  }\n\n  /**\n   * Sanitizes and validates CLI arguments\n   *\n   * @param {string[]} args - Raw CLI arguments\n   * @returns {Object} Sanitization result\n   * @returns {string[]} result.sanitized - Sanitized arguments\n   * @returns {string[]} result.warnings - Security warnings generated\n   *\n   * @description Performs comprehensive security checks including:\n   * - Length validation\n   * - Blocked pattern detection\n   * - Input sanitization\n   * - Suspicious pattern detection\n   *\n   * @example\n   * ```typescript\n   * const result = wrapper.sanitizeArguments(['--file', '../../../etc/passwd']);\n   * if (result.warnings.length > 0) {\n   *   console.warn('Security warnings:', result.warnings);\n   * }\n   * ```\n   */\n  sanitizeArguments(args: string[]): { sanitized: string[]; warnings: string[] } {\n    const sanitized: string[] = [];\n    const warnings: string[] = [];\n\n    args.forEach((arg, index) => {\n      // Check length\n      if (arg.length > this.config.maxArgumentLength) {\n        this.logSecurityEvent({\n          type: 'validation_failed',\n          details: `Argument ${String(index)} exceeds maximum length`,\n          input: `${String(String(arg.substring(0, 100)))}...`,\n          risk: 'medium',\n        });\n        if (this.config.strictMode) {\n          throw new Error(\n            `Argument ${String(index)} exceeds maximum length (${String(String(this.config.maxArgumentLength))})`\n          );\n        }\n        warnings.push(`Argument ${String(index)} truncated`);\n        arg = arg.substring(0, this.config.maxArgumentLength);\n      }\n\n      // Check for blocked patterns\n      const blockedPattern = this.config.blockedPatterns.find(pattern => pattern.test(arg));\n      if (blockedPattern) {\n        this.logSecurityEvent({\n          type: 'command_blocked',\n          details: `Blocked pattern detected: ${String(String(blockedPattern.source))}`,\n          input: arg,\n          risk: 'high',\n        });\n        if (this.config.strictMode) {\n          throw new Error(\n            `Blocked pattern detected in argument ${String(index)}: ${String(String(blockedPattern.source))}`\n          );\n        }\n        warnings.push(`Blocked pattern removed from argument ${String(index)}`);\n        arg = arg.replace(blockedPattern, '');\n      }\n\n      // Sanitize input if enabled\n      if (this.config.enableInputSanitization) {\n        const sanitizationResult = inputSanitizer.sanitizeCliArgument(arg);\n        if (sanitizationResult.modified) {\n          this.logSecurityEvent({\n            type: 'input_sanitized',\n            details: `Argument ${String(index)} sanitized: ${String(String(sanitizationResult.warnings.join(', ')))}`,\n            input: arg,\n            risk: 'low',\n          });\n          warnings.push(`Argument ${String(index)} sanitized`);\n        }\n        sanitized.push(sanitizationResult.sanitized);\n      } else {\n        sanitized.push(arg);\n      }\n    });\n\n    return { sanitized, warnings };\n  }\n\n  /**\n   * Creates a secure command wrapper with built-in protection\n   *\n   * @param {string} name - Command name\n   * @param {string} description - Command description\n   * @returns {Command} Secured Commander.js command\n   *\n   * @description Creates a new command with automatic security validation\n   * that runs before the command action is executed.\n   *\n   * @example\n   * ```typescript\n   * const processCmd = wrapper.createSecureCommand('process', 'Process files safely');\n   * processCmd\n   *   .argument('<file>', 'File to process')\n   *   .action(async (file) => {\n   *     // Command logic here - file is already validated\n   *   });\n   * ```\n   */\n  createSecureCommand(name: string, description: string): Command {\n    const command = new Command(name);\n    command.description(description);\n\n    // Override the action method to add security checks\n    const originalAction = command.action.bind(command);\n    command.action = (fn: (...args: any[]) => void | Promise<void>) =>\n      originalAction(async (...args: any[]) => {\n        try {\n          // Extract options and command arguments\n          const options = args[args.length - 1];\n          const commandArgs = args.slice(0, -1);\n\n          // Validate command arguments\n          if (this.config.enableCommandValidation && commandArgs.length > 0) {\n            const stringArgs = commandArgs.map(arg => String(arg));\n            const validation = validateCommand(name, stringArgs);\n\n            if (!validation.safe) {\n              this.logSecurityEvent({\n                type: 'command_blocked',\n                details: `Command validation failed: ${String(String(validation.blockedPatterns.join(', ')))}`,\n                input: `${String(name)} ${String(String(stringArgs.join(' ')))}`,\n                risk: 'critical',\n              });\n              throw new Error(\n                `Command blocked: ${String(String(validation.blockedPatterns.join(', ')))}`\n              );\n            }\n\n            if (validation.warnings.length > 0) {\n              this.logSecurityEvent({\n                type: 'suspicious_pattern',\n                details: `Command warnings: ${String(String(validation.warnings.join(', ')))}`,\n                input: `${String(name)} ${String(String(stringArgs.join(' ')))}`,\n                risk: 'medium',\n              });\n              if (this.config.logSecurityEvents) {\n                logger.warn(\n                  chalk.yellow(\n                    `‚ö†Ô∏è  Security warnings: ${String(String(validation.warnings.join(', ')))}`\n                  )\n                );\n              }\n            }\n          }\n\n          // Check for suspicious patterns in options\n          if (options && typeof options === 'object') {\n            for (const [key, value] of Object.entries(options)) {\n              if (typeof value === 'string') {\n                const suspicious = inputSanitizer.detectSuspiciousPatterns(value);\n                if (suspicious.suspicious) {\n                  this.logSecurityEvent({\n                    type: 'suspicious_pattern',\n                    details: `Suspicious pattern in option ${String(key)}: ${String(String(suspicious.patterns.join(', ')))}`,\n                    input: value,\n                    risk: 'medium',\n                  });\n                  if (this.config.strictMode) {\n                    throw new Error(`Suspicious pattern detected in option ${String(key)}`);\n                  }\n                }\n              }\n            }\n          }\n\n          // Execute the original function\n          return await fn(...args);\n        } catch (error) {\n          if (error instanceof Error && error.message.includes('blocked')) {\n            logger.error(chalk.red(`üö´ Security: ${String(String(error.message))}`));\n            process.exit(1);\n          }\n          throw error;\n        }\n      });\n\n    return command;\n  }\n\n  /**\n   * Wraps an existing command with security features\n   *\n   * @param {Command} command - Commander.js command to secure\n   * @returns {Command} The secured command\n   *\n   * @description Adds security validation to an existing command without\n   * modifying its core functionality.\n   *\n   * @example\n   * ```typescript\n   * const existingCommand = program.command('deploy');\n   * const securedCommand = wrapper.secureCommand(existingCommand);\n   * ```\n   */\n  secureCommand(command: Command): Command {\n    // Store original action handler using the public API\n    const originalAction = (command as any)._actionHandler;\n\n    if (originalAction) {\n      command.action(async (...args: any[]) => {\n        try {\n          // Apply security checks\n          const sanitizedArgs = this.sanitizeArguments(args.filter(arg => typeof arg === 'string'));\n\n          if (sanitizedArgs.warnings.length > 0 && this.config.logSecurityEvents) {\n            logger.warn(\n              chalk.yellow(`‚ö†Ô∏è  Security: ${String(String(sanitizedArgs.warnings.join(', ')))}`)\n            );\n          }\n\n          // Execute original action with sanitized args\n          return await originalAction(...args);\n        } catch (error) {\n          if (error instanceof Error && error.message.includes('blocked')) {\n            logger.error(chalk.red(`üö´ Security: ${String(String(error.message))}`));\n            process.exit(1);\n          }\n          throw error;\n        }\n      });\n    }\n\n    return command;\n  }\n\n  /**\n   * Logs a security event for monitoring and auditing\n   *\n   * @private\n   * @static\n   * @param {Omit<SecurityEvent, 'timestamp'>} event - Event to log (timestamp added automatically)\n   *\n   * @description Logs security events with appropriate risk levels and\n   * maintains a rolling buffer of the last 1000 events.\n   */\n  private logSecurityEvent(event: Omit<SecurityEvent, 'timestamp'>): void {\n    const fullEvent: SecurityEvent = {\n      ...event,\n      timestamp: new Date(),\n    };\n\n    this.securityEvents.push(fullEvent);\n\n    // Keep only last 1000 events\n    if (this.securityEvents.length > 1000) {\n      this.securityEvents = this.securityEvents.slice(-1000);\n    }\n\n    if (this.config.logSecurityEvents) {\n      const color = {\n        low: chalk.blue,\n        medium: chalk.yellow,\n        high: chalk.magenta,\n        critical: chalk.red,\n      }[event.risk];\n\n      logger.log(\n        color(\n          `üîí Security [${String(String(event.risk.toUpperCase()))}]: ${String(String(event.type))} - ${String(String(event.details))}`\n        )\n      );\n    }\n  }\n\n  /**\n   * Retrieves security events for analysis\n   *\n   * @param {number} [limit] - Maximum number of events to return\n   * @returns {SecurityEvent[]} Array of security events (most recent first)\n   *\n   * @example\n   * ```typescript\n   * const recentEvents = wrapper.getSecurityEvents(10);\n   * recentEvents.forEach(event => {\n   *   console.log(`${event.timestamp}: ${event.type} - ${event.details}`);\n   * });\n   * ```\n   */\n  getSecurityEvents(limit?: number): SecurityEvent[] {\n    const events = this.securityEvents.slice().reverse();\n    return limit ? events.slice(0, limit) : events;\n  }\n\n  /**\n   * Gets security statistics for monitoring\n   *\n   * @returns {Object} Security statistics\n   * @returns {number} stats.totalEvents - Total number of events\n   * @returns {Record<string, number>} stats.eventsByType - Event counts by type\n   * @returns {Record<string, number>} stats.eventsByRisk - Event counts by risk level\n   * @returns {SecurityEvent} [stats.lastEvent] - Most recent event if any\n   *\n   * @example\n   * ```typescript\n   * const stats = wrapper.getSecurityStats();\n   * console.log(`Total security events: ${stats.totalEvents}`);\n   * console.log('High risk events:', stats.eventsByRisk.high || 0);\n   * ```\n   */\n  getSecurityStats(): {\n    totalEvents: number;\n    eventsByType: Record<string, number>;\n    eventsByRisk: Record<string, number>;\n    lastEvent?: SecurityEvent;\n  } {\n    const eventsByType: Record<string, number> = {};\n    const eventsByRisk: Record<string, number> = {};\n\n    this.securityEvents.forEach(event => {\n      eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;\n      eventsByRisk[event.risk] = (eventsByRisk[event.risk] || 0) + 1;\n    });\n\n    const lastEvent = this.securityEvents[this.securityEvents.length - 1];\n    return {\n      totalEvents: this.securityEvents.length,\n      eventsByType,\n      eventsByRisk,\n      ...(lastEvent && { lastEvent }),\n    };\n  }\n\n  /**\n   * Clears all security events from the log\n   *\n   * @example\n   * ```typescript\n   * wrapper.clearSecurityEvents();\n   * console.log('Security event log cleared');\n   * ```\n   */\n  clearSecurityEvents(): void {\n    this.securityEvents = [];\n  }\n\n  /**\n   * Updates security configuration at runtime\n   *\n   * @param {Partial<SecurityConfig>} newConfig - Configuration updates\n   *\n   * @example\n   * ```typescript\n   * wrapper.updateConfig({\n   *   strictMode: true,\n   *   maxArgumentLength: 200\n   * });\n   * ```\n   */\n  updateConfig(newConfig: Partial<SecurityConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Gets the current security configuration\n   *\n   * @returns {SecurityConfig} Current configuration (defensive copy)\n   *\n   * @example\n   * ```typescript\n   * const config = wrapper.getConfig();\n   * console.log('Strict mode:', config.strictMode);\n   * ```\n   */\n  getConfig(): SecurityConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Validates program arguments before execution\n   *\n   * @param {string[]} argv - Command line arguments\n   * @returns {Object} Validation result\n   * @returns {boolean} result.safe - Whether arguments are safe to execute\n   * @returns {string[]} result.sanitized - Sanitized arguments\n   * @returns {string[]} result.warnings - Security warnings\n   *\n   * @description Performs full validation of command line arguments including\n   * sanitization and pattern detection across the entire command.\n   *\n   * @example\n   * ```typescript\n   * const validation = wrapper.validateProgramArgs(process.argv.slice(2));\n   * if (!validation.safe) {\n   *   console.error('Unsafe command detected');\n   *   process.exit(1);\n   * }\n   * ```\n   */\n  validateProgramArgs(argv: string[]): { safe: boolean; sanitized: string[]; warnings: string[] } {\n    const sanitizedResult = this.sanitizeArguments(argv);\n\n    // Additional validation for the entire command line\n    const fullCommand = sanitizedResult.sanitized.join(' ');\n    const suspicious = inputSanitizer.detectSuspiciousPatterns(fullCommand);\n\n    if (suspicious.suspicious) {\n      this.logSecurityEvent({\n        type: 'suspicious_pattern',\n        details: `Command line contains suspicious patterns: ${String(String(suspicious.patterns.join(', ')))}`,\n        input: fullCommand,\n        risk: 'high',\n      });\n\n      if (this.config.strictMode) {\n        return {\n          safe: false,\n          sanitized: sanitizedResult.sanitized,\n          warnings: [...sanitizedResult.warnings, 'Suspicious patterns detected'],\n        };\n      }\n    }\n\n    return {\n      safe: true,\n      sanitized: sanitizedResult.sanitized,\n      warnings: sanitizedResult.warnings,\n    };\n  }\n\n  /**\n   * Generates a comprehensive security report\n   *\n   * @returns {string} Formatted security report\n   *\n   * @description Creates a human-readable report of security events,\n   * statistics, and current configuration.\n   *\n   * @example\n   * ```typescript\n   * const report = wrapper.generateSecurityReport();\n   * console.log(report);\n   * // Save to file or display in CLI\n   * ```\n   */\n  generateSecurityReport(): string {\n    const stats = this.getSecurityStats();\n    const recentEvents = this.getSecurityEvents(10);\n\n    const report = `\nüîí CLI Security Report\n===================\n\nTotal Security Events: ${String(String(stats.totalEvents))}\n\nEvents by Type:\n${Object.entries(stats.eventsByType)\n  .map(([type, count]) => `  ${type}: ${count}`)\n  .join('\\n')}\n\nEvents by Risk Level:\n${Object.entries(stats.eventsByRisk)\n  .map(([risk, count]) => `  ${risk}: ${count}`)\n  .join('\\n')}\n\nRecent Events (last 10):\n${recentEvents\n  .map(\n    event =>\n      `  ${event.timestamp.toISOString()} [${event.risk.toUpperCase()}] ${event.type}: ${event.details}`\n  )\n  .join('\\n')}\n\nSecurity Configuration:\n  Input Sanitization: ${String(String(this.config.enableInputSanitization ? 'Enabled' : 'Disabled'))}\n  Command Validation: ${String(String(this.config.enableCommandValidation ? 'Enabled' : 'Disabled'))}\n  Strict Mode: ${String(String(this.config.strictMode ? 'Enabled' : 'Disabled'))}\n  Max Argument Length: ${String(String(this.config.maxArgumentLength))}\n  Allowed Commands: ${String(String(this.config.allowedCommands.length))}\n  Blocked Patterns: ${String(String(this.config.blockedPatterns.length))}\n`;\n\n    return report;\n  }\n}\n\n/**\n * Default singleton instance of SecureCliWrapper\n * @constant {SecureCliWrapper}\n */\nexport const secureCliWrapper = SecureCliWrapper.getInstance({\n  enableInputSanitization: true,\n  enableCommandValidation: true,\n  logSecurityEvents: process.env.NODE_ENV !== 'production',\n  strictMode: false,\n  maxArgumentLength: 1000,\n  allowedCommands: [\n    'git',\n    'npm',\n    'yarn',\n    'pnpm',\n    'node',\n    'tsc',\n    'eslint',\n    'prettier',\n    'cat',\n    'ls',\n    'grep',\n    'find',\n    'head',\n    'tail',\n    'wc',\n    'sort',\n    'uniq',\n  ],\n});\n\n/**\n * Convenience function to create a secure command\n *\n * @function createSecureCommand\n * @param {string} name - Command name\n * @param {string} description - Command description\n * @returns {Command} Secured command\n *\n * @example\n * ```typescript\n * const cmd = createSecureCommand('deploy', 'Deploy application');\n * ```\n */\nexport const createSecureCommand = (name: string, description: string): Command =>\n  secureCliWrapper.createSecureCommand(name, description);\n\n/**\n * Convenience function to secure an existing command\n *\n * @function secureCommand\n * @param {Command} command - Command to secure\n * @returns {Command} Secured command\n *\n * @example\n * ```typescript\n * const secured = secureCommand(existingCommand);\n * ```\n */\nexport const secureCommand = (command: Command): Command => secureCliWrapper.secureCommand(command);\n\n/**\n * Convenience function to validate program arguments\n *\n * @function validateProgramArgs\n * @param {string[]} argv - Arguments to validate\n * @returns {Object} Validation result\n *\n * @example\n * ```typescript\n * const validation = validateProgramArgs(['--file', 'data.json']);\n * ```\n */\nexport const validateProgramArgs = (\n  argv: string[]\n): { safe: boolean; sanitized: string[]; warnings: string[] } =>\n  secureCliWrapper.validateProgramArgs(argv);\n\n/**\n * Adds comprehensive security middleware to a Commander.js program\n *\n * @function addSecurityMiddleware\n * @param {Command} program - Commander.js program\n * @returns {Command} Enhanced program with security features\n *\n * @description Adds security validation, monitoring, and management commands\n * to a Commander.js program. Includes:\n * - Automatic argument validation\n * - Security event logging\n * - Security management commands\n * - Security report generation\n *\n * @example\n * ```typescript\n * import { program } from 'commander';\n * import { addSecurityMiddleware } from './secure-cli-wrapper';\n *\n * addSecurityMiddleware(program);\n *\n * program\n *   .command('process')\n *   .action(() => {\n *     // Command is automatically secured\n *   });\n * ```\n */\nexport function addSecurityMiddleware(program: Command): Command {\n  // Add global security options\n  program\n    .option('--security-report', 'show security report')\n    .option('--security-strict', 'enable strict security mode')\n    .option('--security-events [limit]', 'show recent security events');\n\n  // Hook into the program's action handling\n  const originalParse = program.parse.bind(program);\n  program.parse = function (argv?: readonly string[], options?: any) {\n    const args = argv || process.argv;\n\n    // Validate arguments before parsing\n    const validation = validateProgramArgs(args.slice(2));\n\n    if (!validation.safe) {\n      logger.error(chalk.red('üö´ Security: Command blocked due to security concerns'));\n      logger.error(chalk.yellow('Warnings:', validation.warnings.join(', ')));\n      process.exit(1);\n    }\n\n    if (validation.warnings.length > 0) {\n      logger.warn(chalk.yellow('‚ö†Ô∏è  Security warnings:', validation.warnings.join(', ')));\n    }\n\n    return originalParse.call(this, argv, options);\n  };\n\n  // Add security command\n  const securityCmd = program.command('security').description('Security management commands');\n\n  securityCmd\n    .command('report')\n    .description('Show security report')\n    .action(() => {\n      logger.log(secureCliWrapper.generateSecurityReport());\n    });\n\n  securityCmd\n    .command('events [limit]')\n    .description('Show recent security events')\n    .action((limit?: string) => {\n      const events = secureCliWrapper.getSecurityEvents(limit ? parseInt(limit, 10) : 20);\n      if (events.length === 0) {\n        logger.log(chalk.green('‚úÖ No security events recorded'));\n        return;\n      }\n\n      logger.log(chalk.blue('üîí Recent Security Events:'));\n      events.forEach(event => {\n        const color = {\n          low: chalk.blue,\n          medium: chalk.yellow,\n          high: chalk.magenta,\n          critical: chalk.red,\n        }[event.risk];\n\n        logger.log(\n          `${event.timestamp.toISOString()} ${color(`[${event.risk.toUpperCase()}]`)} ${event.type}: ${event.details}`\n        );\n      });\n    });\n\n  securityCmd\n    .command('clear')\n    .description('Clear security event log')\n    .action(() => {\n      secureCliWrapper.clearSecurityEvents();\n      logger.log(chalk.green('‚úÖ Security events cleared'));\n    });\n\n  securityCmd\n    .command('config')\n    .description('Show security configuration')\n    .action(() => {\n      const config = secureCliWrapper.getConfig();\n      logger.log(chalk.blue('üîß Security Configuration:'));\n      logger.log(JSON.stringify(config, null, 2));\n    });\n\n  return program;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/spinner.ts",
    "messages": [
      {
        "ruleId": "max-classes-per-file",
        "severity": 2,
        "message": "File has too many classes (2). Maximum allowed is 1.",
        "line": 1,
        "column": 1,
        "nodeType": "Program",
        "messageId": "maximumExceeded",
        "endLine": 379,
        "endColumn": 1
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'safeOperation'.",
        "line": 56,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 56,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 153,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 153,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 153,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 153,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .text on an `any` value.",
        "line": 153,
        "column": 71,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 153,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 155,
        "column": 7,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 155,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 157,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 157,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .stop on an `any` value.",
        "line": 157,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 157,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 159,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 159,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [method] on an `any` value.",
        "line": 159,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 159,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 187,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 187,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .stop on an `any` value.",
        "line": 187,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 187,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 199,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 199,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 206,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 206,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 213,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 213,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 220,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 220,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 227,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 227,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 241,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 241,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Expected non-Promise value in a boolean conditional.",
        "line": 257,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "conditional",
        "endLine": 257,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 302,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 302,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6895, 6898], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6895, 6898], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 312,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 312,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7120, 7123], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7120, 7123], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 318,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 318,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7382, 7385], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7382, 7385], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 343,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 347,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 20,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Ora } from 'ora';\nimport ora from 'ora';\nimport { logger } from '../../utils/logger';\n\n/**\n * Error thrown by SpinnerManager\n */\nexport class SpinnerError extends Error {\n  constructor(\n    message: string,\n    public code: string\n  ) {\n    super(message);\n    this.name = 'SpinnerError';\n  }\n}\n\n/**\n * Manages loading spinners for CLI operations with comprehensive error handling\n */\nexport class SpinnerManager {\n  private readonly spinner: Ora | null = null;\n\n  private readonly isSpinning = false;\n\n  private readonly destroyed = false;\n\n  private readonly maxTextLength = 200;\n\n  /**\n   * Validate text input\n   */\n  private validateText(text: string): string {\n    if (this.destroyed) {\n      throw new SpinnerError('SpinnerManager has been destroyed', 'DESTROYED');\n    }\n\n    if (typeof text !== 'string') {\n      throw new SpinnerError('Text must be a string', 'INVALID_TYPE');\n    }\n\n    if (text.length === 0) {\n      throw new SpinnerError('Text cannot be empty', 'EMPTY_TEXT');\n    }\n\n    if (text.length > this.maxTextLength) {\n      return `${String(String(text.substring(0, this.maxTextLength - 3)))}...`;\n    }\n\n    return text.trim();\n  }\n\n  /**\n   * Safe spinner operation wrapper\n   */\n  private safeOperation<T>(operation: () => T, fallback: T): T {\n    try {\n      return operation();\n    } catch (error) {\n      logger.warn(\n        `Spinner operation failed: ${String(String(error instanceof Error ? error.message : String(error)))}`\n      );\n      return fallback;\n    }\n  }\n\n  /**\n   * Start a new spinner with the given text\n   */\n  start(text: string): void {\n    try {\n      const validatedText = this.validateText(text);\n\n      if (this.isSpinning) {\n        this.stop();\n      }\n\n      this.spinner = this.safeOperation(\n        () =>\n          ora({\n            text: validatedText,\n            color: 'cyan',\n            spinner: 'dots',\n            hideCursor: true,\n          }).start(),\n        null\n      );\n\n      if (this.spinner) {\n        this.isSpinning = true;\n      } else {\n        throw new SpinnerError('Failed to create spinner instance', 'CREATION_FAILED');\n      }\n    } catch (error) {\n      if (error instanceof SpinnerError) {\n        throw error;\n      }\n      throw new SpinnerError(\n        `Failed to start spinner: ${String(String(error instanceof Error ? error.message : String(error)))}`,\n        'START_FAILED'\n      );\n    }\n  }\n\n  /**\n   * Update the spinner text\n   */\n  update(text: string): void {\n    try {\n      const validatedText = this.validateText(text);\n\n      if (!this.spinner) {\n        throw new SpinnerError('No active spinner to update', 'NO_SPINNER');\n      }\n\n      if (!this.isSpinning) {\n        throw new SpinnerError('Spinner is not currently running', 'NOT_RUNNING');\n      }\n\n      this.safeOperation(() => {\n        this.spinner!.text = validatedText;\n        return true;\n      }, false);\n    } catch (error) {\n      if (error instanceof SpinnerError) {\n        throw error;\n      }\n      throw new SpinnerError(\n        `Failed to update spinner: ${String(String(error instanceof Error ? error.message : String(error)))}`,\n        'UPDATE_FAILED'\n      );\n    }\n  }\n\n  /**\n   * Common stop logic with error handling\n   */\n  private static stopSpinner(\n    method: 'succeed' | 'fail' | 'warn' | 'info' | 'stop',\n    text?: string\n  ): void {\n    try {\n      if (this.destroyed) {\n        logger.warn('Attempted to stop destroyed spinner');\n        return;\n      }\n\n      if (!this.spinner ?? !this.isSpinning) {\n        // Silently ignore - not an error condition\n        return;\n      }\n\n      const finalText = text ? this.validateText(text) : this.spinner.text;\n\n      this.safeOperation(() => {\n        if (method === 'stop') {\n          this.spinner!.stop();\n        } else {\n          this.spinner![method](finalText);\n        }\n        return true;\n      }, false);\n\n      this.cleanup();\n    } catch (error) {\n      logger.warn(\n        `Failed to stop spinner: ${String(String(error instanceof Error ? error.message : String(error)))}`\n      );\n      this.forceCleanup();\n    }\n  }\n\n  /**\n   * Clean up spinner state\n   */\n  private static cleanup(): void {\n    this.isSpinning = false;\n    this.spinner = null;\n  }\n\n  /**\n   * Force cleanup in case of errors\n   */\n  private static forceCleanup(): void {\n    try {\n      if (this.spinner) {\n        this.spinner.stop();\n      }\n    } catch {\n      // Ignore errors during force cleanup\n    }\n    this.cleanup();\n  }\n\n  /**\n   * Stop the spinner with success\n   */\n  succeed(text?: string): void {\n    this.stopSpinner('succeed', text);\n  }\n\n  /**\n   * Stop the spinner with failure\n   */\n  fail(text?: string): void {\n    this.stopSpinner('fail', text);\n  }\n\n  /**\n   * Stop the spinner with warning\n   */\n  warn(text?: string): void {\n    this.stopSpinner('warn', text);\n  }\n\n  /**\n   * Stop the spinner with info\n   */\n  info(text?: string): void {\n    this.stopSpinner('info', text);\n  }\n\n  /**\n   * Stop the spinner without any status\n   */\n  stop(): void {\n    this.stopSpinner('stop');\n  }\n\n  /**\n   * Check if spinner is currently active\n   */\n  isActive(): boolean {\n    return this.isSpinning && !this.destroyed;\n  }\n\n  /**\n   * Destroy the spinner manager (cleanup)\n   */\n  destroy(): void {\n    this.forceCleanup();\n    this.destroyed = true;\n  }\n\n  /**\n   * Create a promise that shows a spinner while executing\n   */\n  async withSpinner<T>(\n    text: string,\n    promise: Promise<T>,\n    options?: {\n      successText?: string;\n      failText?: string;\n      timeout?: number;\n    }\n  ): Promise<T> {\n    if (!promise ?? typeof promise.then !== 'function') {\n      throw new SpinnerError('Promise is required and must be a valid Promise', 'INVALID_PROMISE');\n    }\n\n    this.start(text);\n\n    const timeout = options?.timeout;\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    try {\n      let racePromise: Promise<T>;\n\n      if (timeout && timeout > 0) {\n        const timeoutPromise = new Promise<never>((_, reject) => {\n          timeoutId = setTimeout(() => {\n            reject(new SpinnerError(`Operation timed out after ${String(timeout)}ms`, 'TIMEOUT'));\n          }, timeout);\n        });\n\n        racePromise = Promise.race([promise, timeoutPromise]);\n      } else {\n        racePromise = promise;\n      }\n\n      const result = await racePromise;\n      if (timeoutId) clearTimeout(timeoutId);\n      this.succeed(options?.successText);\n      return result;\n    } catch (error) {\n      if (timeoutId) clearTimeout(timeoutId);\n\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const failText = options?.failText ?? `Failed: ${String(text)} - ${String(errorMessage)}`;\n\n      this.fail(failText);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a spinner for a multi-step process\n   */\n  async withSteps(\n    steps: Array<{\n      text: string;\n      action: () => Promise<any>;\n      successText?: string;\n      failText?: string;\n      timeout?: number;\n      skipOnError?: boolean;\n    }>,\n    options?: {\n      stopOnError?: boolean;\n      showProgress?: boolean;\n    }\n  ): Promise<{ results: any[]; errors: Error[] }> {\n    if (!Array.isArray(steps) || steps.length === 0) {\n      throw new SpinnerError('Steps must be a non-empty array', 'INVALID_STEPS');\n    }\n\n    const { stopOnError = true, showProgress = true } = options ?? {};\n    const results: any[] = [];\n    const errors: Error[] = [];\n\n    for (let i = 0; i < steps.length; i += 1) {\n      const step = steps[i];\n\n      if (!step ?? typeof step.action !== 'function') {\n        const error = new SpinnerError(\n          `Invalid step at index ${String(i)}: action must be a function`,\n          'INVALID_STEP'\n        );\n        errors.push(error);\n\n        if (stopOnError && !step?.skipOnError) {\n          throw error;\n        }\n        continue;\n      }\n\n      try {\n        const progressText = showProgress\n          ? `[${String(i + 1)}/${String(String(steps.length))}] ${String(String(step.text))}`\n          : step.text;\n\n        // eslint-disable-next-line no-await-in-loop\n        const result = await this.withSpinner(progressText, step.action(), {\n          ...(step.successText && { successText: step.successText }),\n          ...(step.failText && { failText: step.failText }),\n          ...(step.timeout && { timeout: step.timeout }),\n        });\n\n        results.push(result);\n      } catch (error) {\n        const stepError = error instanceof Error ? error : new Error(String(error));\n        errors.push(stepError);\n\n        if (stopOnError && !step?.skipOnError) {\n          throw stepError;\n        }\n      }\n    }\n\n    return { results, errors };\n  }\n}\n\n// Export singleton instance\nexport const spinner = new SpinnerManager();\n\n// Cleanup on process termination\nconst cleanup = (): void => {\n  spinner.destroy();\n};\n\nprocess.on('exit', cleanup);\nprocess.on('SIGINT', cleanup);\nprocess.on('SIGTERM', cleanup);\nprocess.on('SIGUSR1', cleanup);\nprocess.on('SIGUSR2', cleanup);\nprocess.on('uncaughtException', cleanup);\nprocess.on('unhandledRejection', cleanup);\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/task-list-formatter.ts",
    "messages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'formatTaskTable'.",
        "line": 54,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 54,
        "endColumn": 18
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'formatTaskList'.",
        "line": 128,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 128,
        "endColumn": 17
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'formatTaskDetail'.",
        "line": 212,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 212,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 227,
        "column": 58,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 227,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [6291, 6293], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 228,
        "column": 58,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 228,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [6367, 6369], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 240,
        "column": 30,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 240,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [6908, 6910], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 313,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 313,
        "endColumn": 71
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 314,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 314,
        "endColumn": 91
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 315,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 315,
        "endColumn": 91
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 353,
        "column": 31,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 353,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [10441, 10443], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 356,
        "column": 31,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 356,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [10531, 10533], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import chalk from 'chalk';\nimport Table from 'cli-table3';\nimport {\n  formatStatus,\n  formatPriority,\n  formatRelativeTime,\n  formatDateTime,\n  truncate,\n  formatProgressBar,\n  formatKeyValue,\n  formatDivider,\n  formatHeader,\n} from './formatter';\n\nexport interface TaskDetails {\n  id: string;\n  title: string;\n  description?: string;\n  status: string;\n  priority?: string;\n  assignee?: string;\n  reporter?: string;\n  created_at: string;\n  updated_at: string;\n  due_date?: string;\n  estimated_hours?: number;\n  actual_hours?: number;\n  tags?: string[];\n  subtasks?: TaskDetails[];\n  dependencies?: string[];\n  comments_count?: number;\n  attachments_count?: number;\n  completion_percentage?: number;\n}\n\nexport interface TaskListOptions {\n  showDescription?: boolean;\n  showDates?: boolean;\n  showAssignee?: boolean;\n  showTags?: boolean;\n  sortBy?: 'priority' | 'due_date' | 'created' | 'updated' | 'status';\n  groupBy?: 'status' | 'priority' | 'assignee' | 'none';\n  maxItems?: number;\n  format?: 'table' | 'list' | 'compact';\n}\n\n/**\n * Format task lists for CLI display\n */\nexport class TaskListFormatter {\n  /**\n   * Format a list of tasks as a table\n   */\n  formatTaskTable(tasks: TaskDetails[], options: TaskListOptions = {}): string {\n    const {\n      showDescription = false,\n      showDates = true,\n      showAssignee = true,\n      showTags = false,\n      sortBy = 'priority',\n    } = options;\n\n    // Sort tasks\n    const sortedTasks = TaskListFormatter.sortTasks(tasks, sortBy);\n\n    // Build table headers\n    const headers = ['ID', 'Title', 'Status', 'Priority'];\n    if (showAssignee) headers.push('Assignee');\n    if (showDates) headers.push('Due Date');\n    if (showTags) headers.push('Tags');\n\n    // Create table\n    const table = new Table({\n      head: headers,\n      style: { head: ['cyan'] },\n      colWidths: TaskListFormatter.calculateTableWidths(headers, showDescription),\n    });\n\n    // Add rows\n    for (const task of sortedTasks) {\n      const row: string[] = [\n        task.id,\n        truncate(task.title, 40),\n        formatStatus(task.status),\n        task.priority ? formatPriority(task.priority) : '-',\n      ];\n\n      if (showAssignee) {\n        row.push(task.assignee ? chalk.cyan(`@${String(String(task.assignee))}`) : '-');\n      }\n\n      if (showDates) {\n        if (task.due_date) {\n          const dueDate = new Date(task.due_date);\n          const isOverdue = dueDate < new Date() && task.status !== 'done';\n          const dateStr = formatDateTime(dueDate, 'MMM dd');\n          row.push(isOverdue ? chalk.red(dateStr) : dateStr);\n        } else {\n          row.push('-');\n        }\n      }\n\n      if (showTags) {\n        row.push(\n          task.tags ? task.tags.map((t: string) => chalk.magenta(`#${String(t)}`)).join(' ') : '-'\n        );\n      }\n\n      table.push(row);\n\n      // Add description row if enabled\n      if (showDescription && task.description) {\n        const descRow = [chalk.gray(`  ${String(String(truncate(task.description, 100)))}`)];\n        // Add empty cells to match header count\n        for (let i = 1; i < headers.length; i += 1) {\n          descRow.push('');\n        }\n        table.push(descRow);\n      }\n    }\n\n    return table.toString();\n  }\n\n  /**\n   * Format tasks as a detailed list\n   */\n  formatTaskList(tasks: TaskDetails[], options: TaskListOptions = {}): string {\n    const { groupBy = 'none', maxItems } = options;\n    const output: string[] = [];\n\n    if (groupBy !== 'none') {\n      const grouped = TaskListFormatter.groupTasks(tasks, groupBy);\n\n      for (const [group, groupTasks] of grouped) {\n        output.push(\n          chalk.bold.underline(`\\n${String(group)} (${String(String(groupTasks.length))})`)\n        );\n\n        const tasksToShow = maxItems ? groupTasks.slice(0, maxItems) : groupTasks;\n        for (const task of tasksToShow) {\n          output.push(TaskListFormatter.formatTaskListItem(task));\n        }\n\n        if (maxItems && groupTasks.length > maxItems) {\n          output.push(chalk.gray(`  ... and ${String(String(groupTasks.length - maxItems))} more`));\n        }\n      }\n    } else {\n      const tasksToShow = maxItems ? tasks.slice(0, maxItems) : tasks;\n      for (const task of tasksToShow) {\n        output.push(TaskListFormatter.formatTaskListItem(task));\n      }\n\n      if (maxItems && tasks.length > maxItems) {\n        output.push(chalk.gray(`\\n... and ${String(String(tasks.length - maxItems))} more tasks`));\n      }\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Format a single task list item\n   */\n  private static formatTaskListItem(task: TaskDetails): string {\n    const lines: string[] = [];\n\n    // Main task line\n    const mainLine = [\n      chalk.dim(`[${String(String(task.id))}]`),\n      task.title,\n      task.priority ? formatPriority(task.priority) : '',\n      formatStatus(task.status),\n    ]\n      .filter(Boolean)\n      .join(' ');\n\n    lines.push(`  ${String(mainLine)}`);\n\n    // Additional details\n    const details: string[] = [];\n\n    if (task.assignee) {\n      details.push(chalk.cyan(`@${String(String(task.assignee))}`));\n    }\n\n    if (task.due_date) {\n      const dueDate = new Date(task.due_date);\n      const isOverdue = dueDate < new Date() && task.status !== 'done';\n      details.push(\n        isOverdue\n          ? chalk.red(`Due: ${String(formatDateTime(dueDate, 'MMM dd'))}`)\n          : chalk.gray(`Due: ${String(formatDateTime(dueDate, 'MMM dd'))}`)\n      );\n    }\n\n    if (task.tags && task.tags.length > 0) {\n      details.push(task.tags.map(tag => chalk.magenta(`#${String(tag)}`)).join(' '));\n    }\n\n    if (details.length > 0) {\n      lines.push(`    ${String(String(details.join(' | ')))}`);\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Format detailed task view\n   */\n  formatTaskDetail(task: TaskDetails): string {\n    const output: string[] = [];\n\n    // Header\n    output.push(formatHeader(`Task ${String(String(task.id))}`, 60));\n    output.push('');\n\n    // Title and status\n    output.push(chalk.bold(task.title));\n    output.push(formatStatus(task.status));\n    output.push('');\n\n    // Details section\n    output.push(chalk.bold('Details:'));\n    output.push(formatKeyValue('Priority', task.priority ? formatPriority(task.priority) : 'None'));\n    output.push(formatKeyValue('Assignee', task.assignee || 'Unassigned'));\n    output.push(formatKeyValue('Reporter', task.reporter || 'Unknown'));\n    output.push(formatKeyValue('Created', formatRelativeTime(task.created_at)));\n    output.push(formatKeyValue('Updated', formatRelativeTime(task.updated_at)));\n\n    if (task.due_date) {\n      const dueDate = new Date(task.due_date);\n      const isOverdue = dueDate < new Date() && task.status !== 'done';\n      const dueDateStr = formatDateTime(dueDate, 'MMM dd, yyyy');\n      output.push(formatKeyValue('Due Date', isOverdue ? chalk.red(dueDateStr) : dueDateStr));\n    }\n\n    // Time tracking\n    if (task.estimated_hours || task.actual_hours) {\n      output.push('');\n      output.push(chalk.bold('Time Tracking:'));\n      if (task.estimated_hours) {\n        output.push(formatKeyValue('Estimated', `${String(String(task.estimated_hours))}h`));\n      }\n      if (task.actual_hours) {\n        output.push(formatKeyValue('Actual', `${String(String(task.actual_hours))}h`));\n      }\n    }\n\n    // Description\n    if (task.description) {\n      output.push('');\n      output.push(chalk.bold('Description:'));\n      output.push(task.description);\n    }\n\n    // Progress\n    if (task.completion_percentage !== undefined) {\n      output.push('');\n      output.push(chalk.bold('Progress:'));\n      output.push(formatProgressBar(task.completion_percentage, 100, 30));\n    }\n\n    // Subtasks\n    if (task.subtasks && task.subtasks.length > 0) {\n      output.push('');\n      output.push(chalk.bold(`Subtasks (${String(String(task.subtasks.length))}):`));\n      for (const subtask of task.subtasks) {\n        const icon = subtask.status === 'done' ? '‚úì' : '‚óã';\n        output.push(\n          `  ${String(String(chalk.green(icon)))} [${String(String(subtask.id))}] ${String(String(subtask.title))}`\n        );\n      }\n    }\n\n    // Dependencies\n    if (task.dependencies && task.dependencies.length > 0) {\n      output.push('');\n      output.push(chalk.bold('Dependencies:'));\n      output.push(`  ${String(String(task.dependencies.join(', ')))}`);\n    }\n\n    // Tags\n    if (task.tags && task.tags.length > 0) {\n      output.push('');\n      output.push(chalk.bold('Tags:'));\n      output.push(`  ${task.tags.map(tag => chalk.magenta(`#${tag}`)).join(' ')}`);\n    }\n\n    // Metadata\n    output.push('');\n    output.push(formatDivider());\n    if (task.comments_count) {\n      output.push(`üí¨ ${task.comments_count} comment${task.comments_count > 1 ? 's' : ''}`);\n    }\n    if (task.attachments_count) {\n      output.push(\n        `üìé ${task.attachments_count} attachment${task.attachments_count > 1 ? 's' : ''}`\n      );\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Sort tasks by specified field\n   */\n  private static sortTasks(tasks: TaskDetails[], sortBy: string): TaskDetails[] {\n    return [...tasks].sort((a, b) => {\n      switch (sortBy) {\n        case 'priority':\n          const priorityOrder = { P1: 1, P2: 2, P3: 3, P4: 4, P5: 5 };\n          const aPriority = priorityOrder[a.priority as keyof typeof priorityOrder] || 99;\n          const bPriority = priorityOrder[b.priority as keyof typeof priorityOrder] || 99;\n          return aPriority - bPriority;\n\n        case 'due_date':\n          if (!a.due_date && !b.due_date) return 0;\n          if (!a.due_date) return 1;\n          if (!b.due_date) return -1;\n          return new Date(a.due_date).getTime() - new Date(b.due_date).getTime();\n\n        case 'created':\n          return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();\n\n        case 'updated':\n          return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();\n\n        case 'status':\n          return a.status.localeCompare(b.status);\n\n        default:\n          return 0;\n      }\n    });\n  }\n\n  /**\n   * Group tasks by specified field\n   */\n  private static groupTasks(tasks: TaskDetails[], groupBy: string): Map<string, TaskDetails[]> {\n    const grouped = new Map<string, TaskDetails[]>();\n\n    for (const task of tasks) {\n      let key: string;\n\n      switch (groupBy) {\n        case 'status':\n          key = task.status;\n          break;\n        case 'priority':\n          key = task.priority || 'No Priority';\n          break;\n        case 'assignee':\n          key = task.assignee || 'Unassigned';\n          break;\n        default:\n          key = 'All Tasks';\n      }\n\n      if (!grouped.has(key)) {\n        grouped.set(key, []);\n      }\n      grouped.get(key)!.push(task);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Calculate column widths for table\n   */\n  private static calculateTableWidths(headers: string[], showDescription: boolean): number[] {\n    const baseWidths = {\n      ID: 10,\n      Title: showDescription ? 40 : 50,\n      Status: 15,\n      Priority: 10,\n      Assignee: 15,\n      'Due Date': 12,\n      Tags: 20,\n    };\n\n    return headers.map(h => baseWidths[h as keyof typeof baseWidths] || 15);\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/task-runner.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 8,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 8,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [188, 191], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [188, 191], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 52,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 55,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 55,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 55,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1320, 1323], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1320, 1323], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 77,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 77,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1741, 1744], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1741, 1744], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 77,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 77,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1752, 1755], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1752, 1755], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 77,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 77,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1758, 1761], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1758, 1761], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 85,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 85,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .newListr on an `any` value.",
        "line": 85,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 85,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 96,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 99,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 99,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 99,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2390, 2393], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2390, 2393], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 116,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 116,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2705, 2708], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2705, 2708], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 128,
        "column": 11,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 128,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 158,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 161,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 161,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 161,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3947, 3950], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3947, 3950], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'createRetryTask'.",
        "line": 171,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 171,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 173,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 173,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4108, 4111], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4108, 4111], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 185,
        "column": 7,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 185,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 186,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 186,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4428, 4431], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4428, 4431], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 192,
        "column": 13,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 192,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .message on an `any` value.",
        "line": 205,
        "column": 84,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 205,
        "endColumn": 91
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 19,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Listr } from 'listr2';\nimport chalk from 'chalk';\nimport { logger } from '../../utils/logger';\n\nexport interface TaskItem {\n  id: string;\n  title: string;\n  action: () => Promise<any>;\n  skip?: () => boolean | string;\n  enabled?: boolean;\n  concurrent?: boolean;\n}\n\nexport interface TaskGroup {\n  title: string;\n  tasks: TaskItem[];\n  concurrent?: boolean;\n}\n\n/**\n * Manages concurrent task execution with visual feedback using Listr\n */\nexport class TaskRunner {\n  private readonly renderer: 'default' | 'simple' | 'verbose';\n\n  constructor(options?: { renderer?: 'default' | 'simple' | 'verbose' }) {\n    this.renderer = options?.renderer ?? 'default';\n  }\n\n  /**\n   * Run a single group of tasks\n   */\n  async runTasks(\n    _title: string,\n    tasks: TaskItem[],\n    options?: {\n      concurrent?: boolean;\n      exitOnError?: boolean;\n    }\n  ): Promise<void> {\n    const listrTasks = tasks.map(task => ({\n      title: task.title,\n      task: task.action,\n      ...(task.skip && { skip: task.skip }),\n      enabled: task.enabled ?? true,\n    }));\n\n    const listr = new Listr(listrTasks, {\n      concurrent: options?.concurrent ?? false,\n      exitOnError: options?.exitOnError ?? true,\n      renderer: this.renderer,\n      rendererOptions: {\n        showSubtasks: true,\n        showTimer: true,\n      } as any,\n    });\n\n    try {\n      await listr.run();\n    } catch (error) {\n      logger.error(chalk.red('Task execution failed:'), error);\n      throw error;\n    }\n  }\n\n  /**\n   * Run multiple groups of tasks\n   */\n  async runTaskGroups(\n    groups: TaskGroup[],\n    options?: {\n      exitOnError?: boolean;\n    }\n  ): Promise<void> {\n    const mainTasks = groups.map(group => ({\n      title: group.title,\n      task: (_ctx: any, task: any): any => {\n        const subtasks = group.tasks.map(item => ({\n          title: item.title,\n          task: item.action,\n          ...(item.skip && { skip: item.skip }),\n          enabled: item.enabled ?? true,\n        }));\n\n        return task.newListr(subtasks, {\n          concurrent: group.concurrent ?? false,\n          exitOnError: options?.exitOnError ?? true,\n        });\n      },\n    }));\n\n    const listr = new Listr(mainTasks, {\n      concurrent: false,\n      exitOnError: options?.exitOnError ?? true,\n      renderer: this.renderer,\n      rendererOptions: {\n        showSubtasks: true,\n        showTimer: true,\n      } as any,\n    });\n\n    try {\n      await listr.run();\n    } catch (error) {\n      logger.error(chalk.red('Task group execution failed:'), error);\n      throw error;\n    }\n  }\n\n  /**\n   * Run tasks with progress tracking\n   */\n  async runWithProgress<T>(\n    title: string,\n    items: T[],\n    processor: (item: T, task: any) => Promise<void>,\n    options?: {\n      concurrent?: boolean;\n      concurrency?: number;\n    }\n  ): Promise<void> {\n    const total = items.length;\n\n    const listr = new Listr(\n      [\n        {\n          title: `${String(title)} (0/${String(total)})`,\n          task: async (_ctx, task) => {\n            if (options?.concurrent) {\n              const concurrency = options.concurrency ?? 5;\n              const chunks: T[][] = [];\n\n              for (let i = 0; i < items.length; i += concurrency) {\n                chunks.push(items.slice(i, i + concurrency));\n              }\n\n              await Promise.all(\n                chunks.map(async chunk => {\n                  await Promise.all(\n                    chunk.map(async item => {\n                      await processor(item, task);\n                    })\n                  );\n                })\n              );\n            } else {\n              await Promise.all(\n                items.map(async item => {\n                  await processor(item, task);\n                })\n              );\n            }\n          },\n        },\n      ],\n      {\n        renderer: this.renderer,\n        rendererOptions: {\n          showSubtasks: true,\n          showTimer: true,\n        } as any,\n      }\n    );\n\n    await listr.run();\n  }\n\n  /**\n   * Create a task with retry logic\n   */\n  createRetryTask(\n    title: string,\n    action: () => Promise<any>,\n    options?: {\n      retries?: number;\n      retryDelay?: number;\n    }\n  ): TaskItem {\n    const maxRetries = options?.retries ?? 3;\n    const retryDelay = options?.retryDelay ?? 1000;\n\n    return {\n      id: `retry-${String(String(Date.now()))}`,\n      title,\n      action: async () => {\n        let lastError: any;\n\n        // eslint-disable-next-line no-await-in-loop\n        for (let attempt = 1; attempt <= maxRetries; attempt += 1) {\n          try {\n            // eslint-disable-next-line no-await-in-loop\n            return await action();\n          } catch (error) {\n            lastError = error;\n            if (attempt < maxRetries) {\n              // eslint-disable-next-line no-await-in-loop\n              await new Promise<void>(resolve => {\n                setTimeout(resolve, retryDelay);\n              });\n            }\n          }\n        }\n\n        throw new Error(\n          `Failed after ${String(maxRetries)} attempts: ${String(String(lastError?.message ?? 'Unknown error'))}`\n        );\n      },\n    };\n  }\n\n  /**\n   * Run tasks with dependency resolution\n   */\n  async runWithDependencies(tasks: Array<TaskItem & { dependencies?: string[] }>): Promise<void> {\n    const completed = new Set<string>();\n    const running = new Set<string>();\n\n    const canRun = (task: (typeof tasks)[0]): boolean => {\n      if (!task.dependencies || task.dependencies.length === 0) {\n        return true;\n      }\n      return task.dependencies.every(dep => completed.has(dep));\n    };\n\n    const runTask = async (task: (typeof tasks)[0]): Promise<void> => {\n      running.add(task.id);\n      try {\n        await task.action();\n        completed.add(task.id);\n      } finally {\n        running.delete(task.id);\n      }\n    };\n\n    // Group tasks by whether they can run\n    const groups: TaskGroup[] = [];\n    const remaining = [...tasks];\n\n    while (remaining.length > 0) {\n      const ready = remaining.filter(t => canRun(t) && !completed.has(t.id));\n\n      if (ready.length === 0 && remaining.length > 0) {\n        throw new Error('Circular dependency detected or unresolvable dependencies');\n      }\n\n      if (ready.length > 0) {\n        groups.push({\n          title: `Running ${String(String(ready.length))} task(s)`,\n          tasks: ready.map(t => ({\n            ...t,\n            action: () => runTask(t),\n          })),\n          concurrent: true,\n        });\n\n        // Remove ready tasks from remaining\n        remaining.splice(0, remaining.length, ...remaining.filter(t => !ready.includes(t)));\n      }\n    }\n\n    await this.runTaskGroups(groups);\n  }\n}\n\n// Export singleton instance\nexport const taskRunner = new TaskRunner();\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/cli/utils/todo-processor.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'chalk' is defined but never used.",
        "line": 3,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 3,
        "endColumn": 13
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class async method 'parseTodoFile'.",
        "line": 60,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 60,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 89,
        "column": 26,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 89,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2332, 2334], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'groupByPhase'.",
        "line": 102,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 102,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 106,
        "column": 32,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 106,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2736, 2738], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'createExecutionGroups'.",
        "line": 119,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 119,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 175,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 175,
        "endColumn": 27
      },
      {
        "ruleId": "no-promise-executor-return",
        "severity": 2,
        "message": "Return values from promise executor functions cannot be read.",
        "line": 178,
        "column": 46,
        "nodeType": "CallExpression",
        "messageId": "returnsValue",
        "endLine": 178,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "wrapBraces",
            "fix": { "range": [4703, 4727], "text": "{setTimeout(resolve, 100)}" },
            "desc": "Wrap the expression in `{}`."
          }
        ]
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'todo'.",
        "line": 179,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 179,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 182,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 182,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 213,
        "column": 9,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 213,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'task' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 213,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 213,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async method 'task' has no 'await' expression.",
        "line": 213,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 213,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 216,
        "column": 13,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 216,
        "endColumn": 25
      },
      {
        "ruleId": "no-promise-executor-return",
        "severity": 2,
        "message": "Return values from promise executor functions cannot be read.",
        "line": 218,
        "column": 46,
        "nodeType": "CallExpression",
        "messageId": "returnsValue",
        "endLine": 218,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "wrapBraces",
            "fix": { "range": [5947, 5971], "text": "{setTimeout(resolve, 100)}" },
            "desc": "Wrap the expression in `{}`."
          }
        ]
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'todo'.",
        "line": 219,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 219,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 226,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 228,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 228,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 228,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6233, 6236], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6233, 6236], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 234,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 237,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 237,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 237,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6406, 6409], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6406, 6409], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class async method 'generateReport'.",
        "line": 247,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 247,
        "endColumn": 31
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { readFile, writeFile } from 'fs/promises';\nimport { Listr } from 'listr2';\nimport chalk from 'chalk';\nimport type { TaskGroup } from './task-runner';\nimport { TaskRunner } from './task-runner';\nimport { logger } from '../../utils/logger';\n\nexport interface TodoItem {\n  id: string;\n  text: string;\n  completed: boolean;\n  priority: 'P1' | 'P2' | 'P3' | 'P4' | 'P5';\n  size: 'S' | 'M' | 'L' | 'XL';\n  value: 'S' | 'M' | 'L';\n  dependencies: string[];\n  owner?: string;\n  notes?: string;\n  phase?: string;\n}\n\nexport interface TodoProcessorOptions {\n  concurrent?: boolean;\n  maxConcurrent?: number;\n  groupByPhase?: boolean;\n  showDependencies?: boolean;\n  generateReport?: boolean;\n  dryRun?: boolean;\n}\n\n/**\n * Processes TODO items from markdown files with visual feedback\n */\nexport class TodoProcessor {\n  private readonly taskRunner: TaskRunner;\n\n  constructor() {\n    this.taskRunner = new TaskRunner({ renderer: 'default' });\n  }\n\n  /**\n   * Process TODO.md file with the given options\n   */\n  async process(filePath: string, options: TodoProcessorOptions): Promise<void> {\n    const todos = await this.parseTodoFile(filePath);\n\n    if (options.groupByPhase) {\n      await this.processGroupedByPhase(todos, options);\n    } else {\n      await this.processWithDependencies(todos, options);\n    }\n\n    if (options.generateReport) {\n      await this.generateReport(todos, filePath);\n    }\n  }\n\n  /**\n   * Parse TODO.md file and extract tasks\n   */\n  async parseTodoFile(filePath: string): Promise<Map<string, TodoItem>> {\n    const content = await readFile(filePath, 'utf-8');\n    const lines = content.split('\\n');\n    const todos = new Map<string, TodoItem>();\n    const currentPhase = '';\n\n    for (const line of lines) {\n      const todo = TodoProcessor.parseTodoLine(line, currentPhase);\n      if (todo) {\n        todos.set(todo.id, todo);\n      }\n    }\n\n    return todos;\n  }\n\n  /**\n   * Parse a single TODO line\n   */\n  private static parseTodoLine(line: string, currentPhase: string): TodoItem | null {\n    // Simple TODO line parser - can be enhanced\n    const todoMatch = line.match(/^- \\[([ x])\\] (.+)$/);\n    if (!todoMatch) return null;\n\n    const [, completed, text] = todoMatch;\n    const id = `todo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    return {\n      id,\n      text: text?.trim() || '',\n      completed: completed === 'x',\n      priority: 'P3',\n      size: 'M',\n      value: 'M',\n      dependencies: [],\n      phase: currentPhase,\n    };\n  }\n\n  /**\n   * Group todos by phase\n   */\n  private groupByPhase(todos: Map<string, TodoItem>): Map<string, TodoItem[]> {\n    const phases = new Map<string, TodoItem[]>();\n\n    for (const todo of todos.values()) {\n      const phase = todo.phase || 'Unknown';\n      if (!phases.has(phase)) {\n        phases.set(phase, []);\n      }\n      phases.get(phase)!.push(todo);\n    }\n\n    return phases;\n  }\n\n  /**\n   * Create execution groups based on dependencies\n   */\n  private createExecutionGroups(todos: Map<string, TodoItem>): TodoItem[][] {\n    const groups: TodoItem[][] = [];\n    const visited = new Set<string>();\n    const inProgress = new Set<string>();\n\n    const visit = (todo: TodoItem): void => {\n      if (visited.has(todo.id)) return;\n      if (inProgress.has(todo.id)) return; // Circular dependency\n\n      inProgress.add(todo.id);\n\n      // Visit dependencies first\n      for (const depId of todo.dependencies) {\n        const dep = todos.get(depId);\n        if (dep) visit(dep);\n      }\n\n      inProgress.delete(todo.id);\n      visited.add(todo.id);\n\n      // Add to appropriate group\n      if (groups.length === 0) groups.push([]);\n      groups[groups.length - 1].push(todo);\n    };\n\n    for (const todo of todos.values()) {\n      if (!visited.has(todo.id)) {\n        visit(todo);\n      }\n    }\n\n    return groups;\n  }\n\n  /**\n   * Process todos grouped by phase\n   */\n  private async processGroupedByPhase(\n    todos: Map<string, TodoItem>,\n    options: TodoProcessorOptions\n  ): Promise<void> {\n    const phases = this.groupByPhase(todos);\n    const taskGroups: TaskGroup[] = [];\n\n    for (const [phaseName, phaseTodos] of phases) {\n      if (!phaseTodos) continue;\n      const completedCount = phaseTodos.filter(t => t.completed).length;\n      const totalCount = phaseTodos.length;\n\n      taskGroups.push({\n        title: `${phaseName} [${completedCount}/${totalCount}]`,\n        tasks: phaseTodos\n          .filter(t => !t.completed)\n          .map(todo => ({\n            id: todo.id,\n            title: `${todo.id}: ${todo.text}`,\n            action: async () => {\n              if (!options.dryRun) {\n                // Simulate task implementation\n                await new Promise(resolve => setTimeout(resolve, 100));\n                todo.completed = true;\n              }\n            },\n            skip: () => {\n              if (todo.dependencies.length > 0) {\n                const unmet = todo.dependencies.filter(dep => !todos.get(dep)?.completed);\n                if (unmet.length > 0) {\n                  return `Waiting for: ${unmet.join(', ')}`;\n                }\n              }\n              return false;\n            },\n          })),\n        concurrent: options.concurrent ?? false,\n      });\n    }\n\n    await this.taskRunner.runTaskGroups(taskGroups, {\n      exitOnError: false,\n    });\n  }\n\n  /**\n   * Process todos with dependency resolution\n   */\n  private async processWithDependencies(\n    todos: Map<string, TodoItem>,\n    options: TodoProcessorOptions\n  ): Promise<void> {\n    const groups = this.createExecutionGroups(todos);\n\n    const listr = new Listr(\n      groups.map((group, index) => ({\n        title: `Execution Group ${index + 1} (${group.length} tasks)`,\n        task: async (_ctx, task) => {\n          const subtasks = group.map(todo => ({\n            title: `${todo.id}: ${todo.text}`,\n            task: async () => {\n              if (!options.dryRun) {\n                await new Promise(resolve => setTimeout(resolve, 100));\n                todo.completed = true;\n              }\n            },\n          }));\n\n          return new Listr(subtasks, {\n            concurrent: options.concurrent ?? true,\n            rendererOptions: {\n              showSubtasks: true,\n            } as any,\n          });\n        },\n      })),\n      {\n        concurrent: false,\n        rendererOptions: {\n          showSubtasks: true,\n          showTimer: true,\n        } as any,\n      }\n    );\n\n    await listr.run();\n  }\n\n  /**\n   * Generate implementation report\n   */\n  private async generateReport(todos: Map<string, TodoItem>, todoFile: string): Promise<void> {\n    const reportPath = todoFile.replace('.md', '-report.md');\n    const completed = Array.from(todos.values()).filter(t => t.completed);\n    const pending = Array.from(todos.values()).filter(t => !t.completed);\n\n    const report = `# TODO Implementation Report\n\nGenerated: ${new Date().toISOString()}\n\n## Summary\n- Total Tasks: ${todos.size}\n- Completed: ${completed.length}\n- Pending: ${pending.length}\n- Completion Rate: ${((completed.length / todos.size) * 100).toFixed(1)}%\n\n## Completed Tasks\n${completed.map(t => `- [x] ${t.id}: ${t.text}`).join('\\n')}\n\n## Pending Tasks\n${pending.map(t => `- [ ] ${t.id}: ${t.text}`).join('\\n')}\n\n## Time Estimates\n- Completed: ${TodoProcessor.calculateTimeEstimate(completed)} minutes\n- Remaining: ${TodoProcessor.calculateTimeEstimate(pending)} minutes\n`;\n\n    await writeFile(reportPath, report);\n    logger.info(`Report generated: ${reportPath}`);\n  }\n\n  /**\n   * Calculate time estimate based on task sizes\n   */\n  private static calculateTimeEstimate(todos: TodoItem[]): number {\n    const sizeMultipliers = { S: 1, M: 1.4, L: 4, XL: 8 };\n    return todos.reduce((total, todo) => total + sizeMultipliers[todo.size], 0);\n  }\n}\n\n// Export singleton instance\nexport const todoProcessor = new TodoProcessor();\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/config/index.ts",
    "messages": [
      {
        "ruleId": "no-restricted-globals",
        "severity": 2,
        "message": "Unexpected use of 'isNaN'. Use Number.isNaN instead https://github.com/airbnb/javascript#standard-library--isnan",
        "line": 178,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "customMessage",
        "endLine": 178,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Configuration management module\n * Loads and validates environment variables and application settings\n *\n * @module config\n * @description This module provides centralized configuration management for the MCP Kanban server.\n * It loads environment variables using dotenv, validates them using Zod schemas, and provides\n * type-safe access to all configuration values throughout the application.\n *\n * @example\n * ```typescript\n * import { config } from '@/config';\n *\n * // Access configuration values\n * const port = config.server.port;\n * const dbPath = config.database.path;\n * ```\n */\n\nimport * as dotenv from 'dotenv';\nimport { z } from 'zod';\n\n// Load environment variables\ndotenv.config();\n\n// Configuration schema validation\nconst configSchema = z.object({\n  // Server configuration\n  server: z.object({\n    port: z.number().int().min(1).max(65535).default(3000),\n    host: z.string().default('localhost'),\n    nodeEnv: z.enum(['development', 'production', 'test']).default('development'),\n  }),\n\n  // Database configuration\n  database: z.object({\n    path: z.string().default('./data/kanban.db'),\n    backupPath: z.string().default('./data/backups'),\n    walMode: z.boolean().default(true),\n    memoryLimit: z.number().int().positive().default(268435456), // 256MB\n    timeout: z.number().int().positive().default(30000), // 30 seconds\n    verbose: z.boolean().default(false),\n  }),\n\n  // API Security\n  api: z.object({\n    keySecret: z.string().min(16).default('dev-secret-key-change-in-production'),\n    keys: z.array(z.string()).default(['dev-key-1']),\n    corsOrigin: z.union([z.string(), z.array(z.string())]).default('*'),\n    corsCredentials: z.boolean().default(true),\n  }),\n\n  // Rate limiting\n  rateLimit: z.object({\n    windowMs: z.number().int().positive().default(60000), // 1 minute\n    maxRequests: z.number().int().positive().default(1000),\n    skipSuccessfulRequests: z.boolean().default(false),\n  }),\n\n  // WebSocket configuration\n  websocket: z.object({\n    port: z.number().int().min(1).max(65535).default(3001),\n    host: z.string().default('localhost'),\n    path: z.string().default('/socket.io'),\n    corsOrigin: z.string().default('*'),\n    heartbeatInterval: z.number().int().positive().default(25000),\n    heartbeatTimeout: z.number().int().positive().default(60000),\n    authRequired: z.boolean().default(false),\n    authTimeout: z.number().int().positive().default(30000),\n    maxConnections: z.number().int().positive().default(1000),\n    maxMessagesPerMinute: z.number().int().positive().default(100),\n    maxSubscriptionsPerClient: z.number().int().positive().default(50),\n    compression: z.boolean().default(true),\n    maxPayload: z.number().int().positive().default(1048576), // 1MB\n  }),\n\n  // Git integration\n  git: z.object({\n    autoDetect: z.boolean().default(true),\n    branchPatterns: z.array(z.string()).default(['feature/{taskId}-*', '{taskId}-*']),\n    commitKeywords: z.array(z.string()).default(['fixes', 'closes', 'implements']),\n    defaultBoard: z.string().default('personal-tasks'),\n  }),\n\n  // Backup configuration\n  backup: z.object({\n    enabled: z.boolean().default(true),\n    schedule: z.string().default('0 2 * * *'), // 2 AM daily\n    retentionDays: z.number().int().positive().default(30),\n    compress: z.boolean().default(true),\n    encrypt: z.boolean().default(false),\n    encryptionKey: z.string().optional(),\n    incremental: z.boolean().default(true),\n    verifyIntegrity: z.boolean().default(true),\n  }),\n\n  // Logging configuration\n  logging: z.object({\n    level: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n    file: z.string().default('./logs/kanban.log'),\n    maxSize: z.number().int().positive().default(10485760), // 10MB\n    maxFiles: z.number().int().positive().default(5),\n    console: z.boolean().default(true),\n    consoleLevel: z.enum(['error', 'warn', 'info', 'debug']).default('debug'),\n  }),\n\n  // Performance settings\n  performance: z.object({\n    maxRequestSize: z.string().default('10mb'),\n    requestTimeout: z.number().int().positive().default(30000),\n    keepAliveTimeout: z.number().int().positive().default(5000),\n    maxMemoryUsage: z.number().int().positive().default(512), // MB\n    memoryCheckInterval: z.number().int().positive().default(60000),\n  }),\n\n  // MCP configuration\n  mcp: z.object({\n    serverName: z.string().default('mcp-kanban'),\n    serverVersion: z.string().default('0.1.0'),\n    toolsEnabled: z.boolean().default(true),\n    maxContextItems: z.number().int().positive().default(50),\n    contextLookbackDays: z.number().int().positive().default(14),\n    contextCacheTtl: z.number().int().positive().default(300), // 5 minutes\n    maxRelatedTasks: z.number().int().positive().default(10),\n  }),\n\n  // Priority calculation\n  priority: z.object({\n    recalcInterval: z.number().int().positive().default(3600), // 1 hour\n    staleThresholdDays: z.number().int().positive().default(7),\n    factors: z.object({\n      age: z.number().min(0).max(1).default(0.15),\n      dependency: z.number().min(0).max(1).default(0.3),\n      deadline: z.number().min(0).max(1).default(0.25),\n      priority: z.number().min(0).max(1).default(0.2),\n      context: z.number().min(0).max(1).default(0.1),\n    }),\n  }),\n\n  // Development settings\n  development: z.object({\n    seedDatabase: z.boolean().default(false),\n    resetOnStart: z.boolean().default(false),\n    mockGitIntegration: z.boolean().default(false),\n    enableDebugRoutes: z.boolean().default(false),\n    watchFiles: z.boolean().default(true),\n  }),\n});\n\n/**\n * Parses environment variable values to their appropriate types\n *\n * @param {string | undefined} value - The raw environment variable value\n * @param {unknown} defaultValue - The default value which determines the expected type\n * @returns {unknown} The parsed value in the appropriate type\n *\n * @example\n * ```typescript\n * parseEnvVar('true', false); // returns boolean true\n * parseEnvVar('3000', 8080); // returns number 3000\n * parseEnvVar('a,b,c', []); // returns ['a', 'b', 'c']\n * parseEnvVar('{\"key\":\"value\"}', {}); // returns {key: 'value'}\n * ```\n *\n * @private\n */\nfunction parseEnvVar(value: string | undefined, defaultValue: unknown): unknown {\n  if (value === undefined) return defaultValue;\n\n  // Handle boolean values\n  if (typeof defaultValue === 'boolean') {\n    return value.toLowerCase() === 'true';\n  }\n\n  // Handle number values\n  if (typeof defaultValue === 'number') {\n    const parsed = Number(value);\n    return isNaN(parsed) ? defaultValue : parsed;\n  }\n\n  // Handle array values (comma-separated)\n  if (Array.isArray(defaultValue)) {\n    return value\n      .split(',')\n      .map(item => item.trim())\n      .filter(Boolean);\n  }\n\n  // Handle object values (JSON)\n  if (typeof defaultValue === 'object' && defaultValue !== null) {\n    try {\n      return JSON.parse(value);\n    } catch {\n      return defaultValue;\n    }\n  }\n\n  return value;\n}\n\n// Helper function to access environment variables with bracket notation\nconst getEnv = (key: string): string | undefined => process.env[key];\n\n// Build configuration from environment variables\nconst rawConfig = {\n  server: {\n    port: parseEnvVar(getEnv('PORT'), 3000),\n    host: parseEnvVar(getEnv('HOST'), 'localhost'),\n    nodeEnv: parseEnvVar(getEnv('NODE_ENV'), 'development'),\n  },\n  database: {\n    path: parseEnvVar(getEnv('DATABASE_PATH'), './data/kanban.db'),\n    backupPath: parseEnvVar(getEnv('DATABASE_BACKUP_PATH'), './data/backups'),\n    walMode: parseEnvVar(getEnv('DATABASE_WAL_MODE'), true),\n    memoryLimit: parseEnvVar(getEnv('DATABASE_MEMORY_LIMIT'), 268435456),\n    timeout: parseEnvVar(getEnv('DATABASE_TIMEOUT'), 30000),\n    verbose: parseEnvVar(getEnv('DATABASE_VERBOSE'), false),\n  },\n  api: {\n    keySecret: parseEnvVar(getEnv('API_KEY_SECRET'), 'dev-secret-key-change-in-production'),\n    keys: parseEnvVar(getEnv('API_KEYS'), ['dev-key-1']),\n    corsOrigin: parseEnvVar(getEnv('CORS_ORIGIN'), '*'),\n    corsCredentials: parseEnvVar(getEnv('CORS_CREDENTIALS'), true),\n  },\n  rateLimit: {\n    windowMs: parseEnvVar(getEnv('RATE_LIMIT_WINDOW_MS'), 60000),\n    maxRequests: parseEnvVar(getEnv('RATE_LIMIT_MAX_REQUESTS'), 1000),\n    skipSuccessfulRequests: parseEnvVar(getEnv('RATE_LIMIT_SKIP_SUCCESSFUL_REQUESTS'), false),\n  },\n  websocket: {\n    port: parseEnvVar(getEnv('WEBSOCKET_PORT'), 3001),\n    host: parseEnvVar(getEnv('WEBSOCKET_HOST'), 'localhost'),\n    path: parseEnvVar(getEnv('WEBSOCKET_PATH'), '/socket.io'),\n    corsOrigin: parseEnvVar(getEnv('WEBSOCKET_CORS_ORIGIN'), '*'),\n    heartbeatInterval: parseEnvVar(getEnv('WEBSOCKET_HEARTBEAT_INTERVAL'), 25000),\n    heartbeatTimeout: parseEnvVar(getEnv('WEBSOCKET_HEARTBEAT_TIMEOUT'), 60000),\n    authRequired: parseEnvVar(getEnv('WEBSOCKET_AUTH_REQUIRED'), false),\n    authTimeout: parseEnvVar(getEnv('WEBSOCKET_AUTH_TIMEOUT'), 30000),\n    maxConnections: parseEnvVar(getEnv('WEBSOCKET_MAX_CONNECTIONS'), 1000),\n    maxMessagesPerMinute: parseEnvVar(getEnv('WEBSOCKET_MAX_MESSAGES_PER_MINUTE'), 100),\n    maxSubscriptionsPerClient: parseEnvVar(getEnv('WEBSOCKET_MAX_SUBSCRIPTIONS_PER_CLIENT'), 50),\n    compression: parseEnvVar(getEnv('WEBSOCKET_COMPRESSION'), true),\n    maxPayload: parseEnvVar(getEnv('WEBSOCKET_MAX_PAYLOAD'), 1048576),\n  },\n  git: {\n    autoDetect: parseEnvVar(getEnv('GIT_AUTO_DETECT'), true),\n    branchPatterns: parseEnvVar(getEnv('GIT_BRANCH_PATTERNS'), [\n      'feature/{taskId}-*',\n      '{taskId}-*',\n    ]),\n    commitKeywords: parseEnvVar(getEnv('GIT_COMMIT_KEYWORDS'), ['fixes', 'closes', 'implements']),\n    defaultBoard: parseEnvVar(getEnv('GIT_DEFAULT_BOARD'), 'personal-tasks'),\n  },\n  backup: {\n    enabled: parseEnvVar(getEnv('BACKUP_ENABLED'), true),\n    schedule: parseEnvVar(getEnv('BACKUP_SCHEDULE'), '0 2 * * *'),\n    retentionDays: parseEnvVar(getEnv('BACKUP_RETENTION_DAYS'), 30),\n    compress: parseEnvVar(getEnv('BACKUP_COMPRESS'), true),\n    encrypt: parseEnvVar(getEnv('BACKUP_ENCRYPT'), false),\n    encryptionKey: parseEnvVar(getEnv('BACKUP_ENCRYPTION_KEY'), undefined),\n    incremental: parseEnvVar(getEnv('BACKUP_INCREMENTAL'), true),\n    verifyIntegrity: parseEnvVar(getEnv('BACKUP_VERIFY_INTEGRITY'), true),\n  },\n  logging: {\n    level: parseEnvVar(getEnv('LOG_LEVEL'), 'info'),\n    file: parseEnvVar(getEnv('LOG_FILE'), './logs/kanban.log'),\n    maxSize: parseEnvVar(getEnv('LOG_MAX_SIZE'), 10485760),\n    maxFiles: parseEnvVar(getEnv('LOG_MAX_FILES'), 5),\n    console: parseEnvVar(getEnv('LOG_CONSOLE'), true),\n    consoleLevel: parseEnvVar(getEnv('LOG_CONSOLE_LEVEL'), 'debug'),\n  },\n  performance: {\n    maxRequestSize: parseEnvVar(getEnv('MAX_REQUEST_SIZE'), '10mb'),\n    requestTimeout: parseEnvVar(getEnv('REQUEST_TIMEOUT'), 30000),\n    keepAliveTimeout: parseEnvVar(getEnv('KEEP_ALIVE_TIMEOUT'), 5000),\n    maxMemoryUsage: parseEnvVar(getEnv('MAX_MEMORY_USAGE'), 512),\n    memoryCheckInterval: parseEnvVar(getEnv('MEMORY_CHECK_INTERVAL'), 60000),\n  },\n  mcp: {\n    serverName: parseEnvVar(getEnv('MCP_SERVER_NAME'), 'mcp-kanban'),\n    serverVersion: parseEnvVar(getEnv('MCP_SERVER_VERSION'), '0.1.0'),\n    toolsEnabled: parseEnvVar(getEnv('MCP_TOOLS_ENABLED'), true),\n    maxContextItems: parseEnvVar(getEnv('MCP_MAX_CONTEXT_ITEMS'), 50),\n    contextLookbackDays: parseEnvVar(getEnv('MCP_CONTEXT_LOOKBACK_DAYS'), 14),\n    contextCacheTtl: parseEnvVar(getEnv('CONTEXT_CACHE_TTL'), 300),\n    maxRelatedTasks: parseEnvVar(getEnv('CONTEXT_MAX_RELATED_TASKS'), 10),\n  },\n  priority: {\n    recalcInterval: parseEnvVar(getEnv('PRIORITY_RECALC_INTERVAL'), 3600),\n    staleThresholdDays: parseEnvVar(getEnv('PRIORITY_STALE_THRESHOLD_DAYS'), 7),\n    factors: parseEnvVar(getEnv('PRIORITY_FACTORS'), {\n      age: 0.15,\n      dependency: 0.3,\n      deadline: 0.25,\n      priority: 0.2,\n      context: 0.1,\n    }),\n  },\n  development: {\n    seedDatabase: parseEnvVar(process.env.DEV_SEED_DATABASE, false),\n    resetOnStart: parseEnvVar(process.env.DEV_RESET_ON_START, false),\n    mockGitIntegration: parseEnvVar(process.env.DEV_MOCK_GIT_INTEGRATION, false),\n    enableDebugRoutes: parseEnvVar(process.env.DEV_ENABLE_DEBUG_ROUTES, false),\n    watchFiles: parseEnvVar(process.env.DEV_WATCH_FILES, true),\n  },\n};\n\n/**\n * The validated configuration object for the MCP Kanban server\n *\n * @constant {Config}\n * @description This object contains all validated configuration values loaded from environment\n * variables and defaults. It is immutable and type-safe thanks to Zod validation.\n *\n * @throws {ZodError} If configuration validation fails\n *\n * @example\n * ```typescript\n * // Access server configuration\n * logger.log(`Server running on ${String(String(config.server.host))}:${String(String(config.server.port))}`);\n *\n * // Access database configuration\n * const db = new Database(config.database.path);\n *\n * // Check environment\n * if (config.server['nodeEnv'] = == 'production') {\n *   // Production-specific logic\n * }\n * ```\n */\nexport const config = configSchema.parse(rawConfig);\n\n/**\n * Type definition for the complete configuration object\n *\n * @typedef {Object} Config\n * @property {Object} server - Server configuration\n * @property {number} server.port - Server port number (1-65535)\n * @property {string} server.host - Server host address\n * @property {'development'|'production'|'test'} server.nodeEnv - Environment mode\n * @property {Object} database - Database configuration\n * @property {string} database.path - SQLite database file path\n * @property {string} database.backupPath - Backup directory path\n * @property {boolean} database.walMode - Enable Write-Ahead Logging\n * @property {number} database.memoryLimit - Memory limit in bytes\n * @property {number} database.timeout - Connection timeout in milliseconds\n * @property {boolean} database.verbose - Enable verbose logging\n * @property {Object} api - API security configuration\n * @property {string} api.keySecret - Secret for API key generation (min 16 chars)\n * @property {string[]} api.keys - Array of valid API keys\n * @property {string|string[]} api.corsOrigin - CORS allowed origins\n * @property {boolean} api.corsCredentials - Allow CORS credentials\n * @property {Object} rateLimit - Rate limiting configuration\n * @property {Object} websocket - WebSocket server configuration\n * @property {Object} git - Git integration configuration\n * @property {Object} backup - Backup system configuration\n * @property {Object} logging - Logging configuration\n * @property {Object} performance - Performance settings\n * @property {Object} mcp - MCP protocol configuration\n * @property {Object} priority - Task priority calculation settings\n * @property {Object} development - Development-only settings\n */\nexport type Config = z.infer<typeof configSchema>;\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/connection.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 156,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 156,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 156,
        "column": 43,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 156,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4074, 4077], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4074, 4077], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 332,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 332,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8848, 8851], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8848, 8851], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 366,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 366,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10086, 10089], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10086, 10089], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 483,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 483,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .transaction_state on an `any` value.",
        "line": 484,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 484,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 538,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 544,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 549,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 549,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .size on an `any` value.",
        "line": 549,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 549,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 550,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 550,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .page_count on an `any` value.",
        "line": 550,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 550,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 551,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 551,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .page_size on an `any` value.",
        "line": 551,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 551,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 680,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 680,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 682,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 682,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .version on an `any` value.",
        "line": 682,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 682,
        "endColumn": 37
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 755,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 755,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [22673, 22679], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 775,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 775,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [23228, 23234], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 795,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 795,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [23762, 23768], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 830,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 830,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [24724, 24730], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 850,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 850,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [25233, 25239], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 866,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 866,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [25570, 25576], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * SQLite database connection module\n * Handles database initialization, connection management, and configuration\n *\n * @module database/connection\n * @description This module provides a singleton database connection manager for SQLite.\n * It handles connection lifecycle, query execution, transactions, and health monitoring.\n * The connection is configured with optimal settings for performance and reliability.\n *\n * @example\n * ```typescript\n * import { dbConnection } from '@/database/connection';\n *\n * // Initialize connection\n * await dbConnection.initialize();\n *\n * // Execute queries\n * const users = await dbConnection.query('SELECT * FROM users WHERE active = ?', [true]);\n *\n * // Use transactions\n * await dbConnection.transaction(async (db) => {\n *   await db.run('INSERT INTO tasks (title) VALUES (?)', ['New Task']);\n *   await db.run('UPDATE boards SET updated_at = ?', [new Date()]);\n * });\n * ```\n */\n\nimport sqlite3 from 'sqlite3';\nimport { open, type Database } from 'sqlite';\nimport path from 'path';\nimport fs from 'fs/promises';\nimport { logger } from '@/utils/logger';\nimport { config } from '@/config';\nimport { SchemaManager } from './schema';\nimport { MigrationRunner } from './migrations';\nimport { SeedRunner } from './seeds';\n\n/**\n * Database query parameter types\n */\nexport type QueryParameter = string | number | boolean | null | Date | Buffer;\n\n/**\n * Database query parameters array\n */\nexport type QueryParameters = QueryParameter[];\n\n/**\n * Database configuration\n */\nexport interface DatabaseConfig {\n  path: string;\n  walMode: boolean;\n  memoryLimit: number;\n  timeout: number;\n  verbose: boolean;\n}\n\n/**\n * Database statistics\n */\nexport interface DatabaseStats {\n  size: number;\n  pageCount: number;\n  pageSize: number;\n  walMode: boolean;\n  tables: number;\n  responseTime?: number;\n}\n\n/**\n * Database health check result\n */\nexport interface DatabaseHealthCheck {\n  connected: boolean;\n  responsive: boolean;\n  stats: DatabaseStats;\n  error?: string;\n}\n\n/**\n * Database execution result\n */\nexport interface DatabaseExecutionResult {\n  lastID?: number | undefined;\n  changes: number;\n}\n\n/**\n * Singleton database connection manager for SQLite\n *\n * @class DatabaseConnection\n * @description Manages a single SQLite database connection with optimal settings,\n * transaction support, and health monitoring. Uses the singleton pattern to ensure\n * only one connection exists throughout the application lifecycle.\n *\n * @example\n * ```typescript\n * const db = DatabaseConnection.getInstance();\n * await db.initialize();\n *\n * // Check health\n * const health = await db.healthCheck();\n * logger.log('Database healthy:', health.responsive);\n * ```\n */\nexport class DatabaseConnection {\n  private static instance: DatabaseConnection;\n\n  private db: Database<sqlite3.Database, sqlite3.Statement> | null = null;\n\n  private readonly config: DatabaseConfig;\n\n  private schemaManager: SchemaManager | null = null;\n\n  private migrationRunner: MigrationRunner | null = null;\n\n  private seedRunner: SeedRunner | null = null;\n\n  private constructor() {\n    this.config = {\n      path: config.database.path,\n      walMode: config.database.walMode,\n      memoryLimit: config.database.memoryLimit,\n      timeout: config.database.timeout,\n      verbose: config.database.verbose,\n    };\n  }\n\n  /**\n   * Gets the singleton instance of DatabaseConnection\n   *\n   * @returns {DatabaseConnection} The singleton database connection instance\n   *\n   * @example\n   * ```typescript\n   * const db = DatabaseConnection.getInstance();\n   * ```\n   */\n  public static getInstance(): DatabaseConnection {\n    if (!DatabaseConnection.instance) {\n      DatabaseConnection.instance = new DatabaseConnection();\n    }\n    return DatabaseConnection.instance;\n  }\n\n  /**\n   * Reset the singleton instance (for testing purposes)\n   */\n  public static resetInstance(): void {\n    if (DatabaseConnection.instance) {\n      DatabaseConnection.instance.close().catch(() => {\n        // Ignore errors during cleanup\n      });\n    }\n    DatabaseConnection.instance = null as any;\n  }\n\n  /**\n   * Initialize database connection and configure SQLite\n   *\n   * @param {Object} options - Initialization options\n   * @param {boolean} [options['skipSchema'] = false] - Skip automatic schema creation/validation\n   * @returns {Promise<void>}\n   * @throws {Error} If database initialization fails\n   *\n   * @example\n   * ```typescript\n   * // Normal initialization with schema\n   * await db.initialize();\n   *\n   * // Skip schema for testing\n   * await db.initialize({ skipSchema: true });\n   * ```\n   */\n  public async initialize(options: { skipSchema?: boolean } = {}): Promise<void> {\n    try {\n      logger.info('Initializing database connection', {\n        path: this.config.path,\n        walMode: this.config.walMode,\n      });\n\n      // Ensure database directory exists\n      await this.ensureDirectoryExists();\n\n      // Open database connection\n      this.db = await open({\n        filename: this.config.path,\n        driver: this.config.verbose ? sqlite3.verbose().Database : sqlite3.Database,\n      });\n\n      // Configure SQLite pragmas\n      await this.configurePragmas();\n\n      // Initialize schema manager\n      this.schemaManager = new SchemaManager(this);\n\n      // Initialize migration runner\n      if (this.db) {\n        this.migrationRunner = new MigrationRunner(this.db.getDatabaseInstance(), {\n          migrationsPath: path.join(__dirname, 'migrations'),\n          validateChecksums: true,\n        });\n\n        // Initialize seed runner\n        this.seedRunner = new SeedRunner(this.db, {\n          seedsPath: path.join(__dirname, 'seeds'),\n        });\n      }\n\n      // Ensure schema exists (unless skipped for testing)\n      if (!options.skipSchema) {\n        await this.ensureSchemaExists();\n      }\n\n      // Test connection\n      await this.testConnection();\n\n      logger.info('Database connection initialized successfully');\n    } catch (error) {\n      logger.error('Failed to initialize database connection', { error });\n      throw new Error(`Database initialization failed: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Get the underlying SQLite database instance\n   *\n   * @returns {Database} The SQLite database instance\n   * @throws {Error} If database is not initialized\n   *\n   * @example\n   * ```typescript\n   * const database = db.getDatabase();\n   * await database.exec('PRAGMA optimize');\n   * ```\n   */\n  public getDatabase(): Database<sqlite3.Database, sqlite3.Statement> {\n    if (!this.db) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n    return this.db;\n  }\n\n  /**\n   * Get the schema manager instance\n   *\n   * @returns {SchemaManager} The schema manager for database operations\n   * @throws {Error} If schema manager is not initialized\n   *\n   * @example\n   * ```typescript\n   * const schema = db.getSchemaManager();\n   * const info = await schema.getSchemaInfo();\n   * ```\n   */\n  public getSchemaManager(): SchemaManager {\n    if (!this.schemaManager) {\n      throw new Error('Schema manager not initialized. Call initialize() first.');\n    }\n    return this.schemaManager;\n  }\n\n  /**\n   * Check if database connection is active\n   *\n   * @returns {boolean} True if connected, false otherwise\n   *\n   * @example\n   * ```typescript\n   * if (db.isConnected()) {\n   *   await db.query('SELECT 1');\n   * }\n   * ```\n   */\n  public isConnected(): boolean {\n    return this.db !== null;\n  }\n\n  /**\n   * Close the database connection\n   *\n   * @returns {Promise<void>}\n   *\n   * @example\n   * ```typescript\n   * // Graceful shutdown\n   * process.on('SIGTERM', async () => {\n   *   await db.close();\n   *   process.exit(0);\n   * });\n   * ```\n   */\n  public async close(): Promise<void> {\n    if (this.db) {\n      logger.info('Closing database connection');\n      await this.db.close();\n      this.db = null;\n      logger.info('Database connection closed');\n    }\n  }\n\n  /**\n   * Execute a query and return all results\n   *\n   * @template T - The expected result type\n   * @param {string} sql - SQL query to execute\n   * @param {QueryParameters} [params=[]] - Query parameters for prepared statement\n   * @returns {Promise<T[]>} Array of results\n   * @throws {Error} If query execution fails\n   *\n   * @example\n   * ```typescript\n   * // Simple query\n   * const boards = await db.query<{id: string, name: string}>('SELECT * FROM boards');\n   *\n   * // Parameterized query\n   * const tasks = await db.query<Task>(\n   *   'SELECT * FROM tasks WHERE board_id = ? AND archived = ?',\n   *   ['board-123', false]\n   * );\n   *\n   * // With type inference\n   * interface User {\n   *   id: string;\n   *   name: string;\n   *   email: string;\n   * }\n   * const users = await db.query<User>('SELECT * FROM users WHERE active = ?', [true]);\n   * ```\n   */\n  public async query<T = any>(sql: string, params: QueryParameters = []): Promise<T[]> {\n    const db = this.getDatabase();\n    try {\n      logger.debug('Executing query', { sql, params });\n      const result = await db.all<T[]>(sql, params);\n      logger.debug('Query executed successfully', { rowCount: result.length });\n      return result;\n    } catch (error) {\n      logger.error('Query execution failed', { sql, params, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a query and return the first result\n   *\n   * @template T - The expected result type\n   * @param {string} sql - SQL query to execute\n   * @param {QueryParameters} [params=[]] - Query parameters for prepared statement\n   * @returns {Promise<T | undefined>} First result or undefined if no results\n   * @throws {Error} If query execution fails\n   *\n   * @example\n   * ```typescript\n   * // Get single result\n   * const board = await db.queryOne<Board>('SELECT * FROM boards WHERE id = ?', ['board-123']);\n   *\n   * // Check existence\n   * const exists = await db.queryOne<{count: number}>('SELECT COUNT(*) as count FROM tasks WHERE title = ?', ['My Task']);\n   * if (exists?.count > 0) {\n   *   logger.log('Task already exists');\n   * }\n   * ```\n   */\n  public async queryOne<T = any>(\n    sql: string,\n    params: QueryParameters = []\n  ): Promise<T | undefined> {\n    const db = this.getDatabase();\n    try {\n      logger.debug('Executing query (single result)', { sql, params });\n      const result = await db.get<T>(sql, params);\n      logger.debug('Query executed successfully', { hasResult: !!result });\n      return result;\n    } catch (error) {\n      logger.error('Query execution failed', { sql, params, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a data modification statement (INSERT, UPDATE, DELETE)\n   *\n   * @param {string} sql - SQL statement to execute\n   * @param {QueryParameters} [params=[]] - Statement parameters for prepared statement\n   * @returns {Promise<DatabaseExecutionResult>} Result containing lastID and changes\n   * @throws {Error} If statement execution fails\n   *\n   * @example\n   * ```typescript\n   * // Insert with auto-generated ID\n   * const result = await db.execute(\n   *   'INSERT INTO tasks (title, description) VALUES (?, ?)',\n   *   ['New Task', 'Task description']\n   * );\n   * logger.log('New task ID:', result.lastID);\n   *\n   * // Update with affected rows\n   * const updateResult = await db.execute(\n   *   'UPDATE tasks SET archived = ? WHERE created_at < ?',\n   *   [true, new Date('2024-01-01')]\n   * );\n   * logger.log('Archived tasks:', updateResult.changes);\n   *\n   * // Delete\n   * const deleteResult = await db.execute('DELETE FROM tasks WHERE id = ?', ['task-123']);\n   * if (deleteResult['changes'] = == 0) {\n   *   logger.log('Task not found');\n   * }\n   * ```\n   */\n  public async execute(\n    sql: string,\n    params: QueryParameters = []\n  ): Promise<DatabaseExecutionResult> {\n    const db = this.getDatabase();\n    try {\n      logger.debug('Executing statement', { sql, params });\n      const result = await db.run(sql, params);\n      logger.debug('Statement executed successfully', {\n        lastID: result.lastID,\n        changes: result.changes,\n      });\n      return {\n        lastID: result.lastID,\n        changes: result.changes ?? 0,\n      };\n    } catch (error) {\n      logger.error('Statement execution failed', { sql, params, error });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute multiple statements in a transaction with automatic rollback on error\n   *\n   * @template T - The return type of the transaction callback\n   * @param {Function} callback - Async function that performs database operations\n   * @returns {Promise<T>} The result returned by the callback\n   * @throws {Error} If any operation in the transaction fails\n   *\n   * @example\n   * ```typescript\n   * // Simple transaction\n   * await db.transaction(async (database) => {\n   *   await database.run('INSERT INTO boards (id, name) VALUES (?, ?)', ['b1', 'My Board']);\n   *   await database.run('INSERT INTO columns (id, board_id, name) VALUES (?, ?, ?)', ['c1', 'b1', 'Todo']);\n   * });\n   *\n   * // Transaction with return value\n   * const taskId = await db.transaction(async (database) => {\n   *   const result = await database.run('INSERT INTO tasks (title) VALUES (?)', ['New Task']);\n   *   await database.run('INSERT INTO task_history (task_id, action) VALUES (?, ?)', [result.lastID, 'created']);\n   *   return result.lastID;\n   * });\n   *\n   * // Transaction with error handling (automatic rollback)\n   * try {\n   *   await db.transaction(async (database) => {\n   *     await database.run('UPDATE accounts SET balance = balance - ? WHERE id = ?', [100, 'acc1']);\n   *     await database.run('UPDATE accounts SET balance = balance + ? WHERE id = ?', [100, 'acc2']);\n   *\n   *     // This will cause rollback if balance goes negative\n   *     const account = await database.get('SELECT balance FROM accounts WHERE id = ?', ['acc1']);\n   *     if (account.balance < 0) {\n   *       throw new Error('Insufficient funds');\n   *     }\n   *   });\n   * } catch (error) {\n   *   logger.error('Transaction rolled back:', error);\n   * }\n   * ```\n   */\n  public async transaction<T>(\n    callback: (db: Database<sqlite3.Database, sqlite3.Statement>) => Promise<T>\n  ): Promise<T> {\n    const db = this.getDatabase();\n    let transactionStarted = false;\n\n    try {\n      // Check if we're already in a transaction\n      const transactionState = await db.get('PRAGMA transaction_state');\n      if (transactionState?.transaction_state === 'none') {\n        logger.debug('Starting transaction');\n        await db.exec('BEGIN TRANSACTION');\n        transactionStarted = true;\n      } else {\n        logger.debug('Transaction already active, using existing transaction');\n      }\n\n      const result = await callback(db);\n\n      if (transactionStarted) {\n        await db.exec('COMMIT');\n        logger.debug('Transaction committed successfully');\n      }\n      return result;\n    } catch (error) {\n      logger.error('Transaction failed, rolling back', { error });\n      if (transactionStarted) {\n        try {\n          await db.exec('ROLLBACK');\n        } catch (rollbackError) {\n          logger.error('Failed to rollback transaction', { rollbackError });\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get comprehensive database statistics\n   *\n   * @returns {Promise<Object>} Database statistics\n   * @returns {number} returns.size - Database file size in bytes\n   * @returns {number} returns.pageCount - Number of database pages\n   * @returns {number} returns.pageSize - Size of each page in bytes\n   * @returns {boolean} returns.walMode - Whether WAL mode is enabled\n   * @returns {number} returns.tables - Number of user tables\n   *\n   * @example\n   * ```typescript\n   * const stats = await db.getStats();\n   * logger.log(`Database size: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);\n   * logger.log(`Tables: ${stats.tables}`);\n   * logger.log(`WAL mode: ${stats.walMode ? 'enabled' : 'disabled'}`);\n   * ```\n   */\n  public async getStats(): Promise<DatabaseStats> {\n    const db = this.getDatabase();\n\n    const [, tableCount] = await Promise.all([\n      db.all('PRAGMA database_list'),\n      db.get<{ count: number }>(\"SELECT COUNT(*) as count FROM sqlite_master WHERE type='table'\"),\n    ]);\n\n    const stats = await db.get(`\n      SELECT \n        page_count * page_size as size,\n        page_count,\n        page_size\n      FROM pragma_page_count(), pragma_page_size()\n    `);\n\n    const walMode = await db.get<{ journal_mode: string }>('PRAGMA journal_mode');\n\n    return {\n      size: stats?.size ?? 0,\n      pageCount: stats?.page_count ?? 0,\n      pageSize: stats?.page_size ?? 0,\n      walMode: walMode?.journal_mode === 'wal',\n      tables: tableCount?.count ?? 0,\n    };\n  }\n\n  /**\n   * Perform a comprehensive health check on the database connection\n   *\n   * @returns {Promise<Object>} Health check results\n   * @returns {boolean} returns.connected - Whether database is connected\n   * @returns {boolean} returns.responsive - Whether database responds within timeout\n   * @returns {Object|null} returns.stats - Database statistics if healthy\n   * @returns {string} [returns.error] - Error message if unhealthy\n   *\n   * @example\n   * ```typescript\n   * const health = await db.healthCheck();\n   *\n   * if (!health.connected) {\n   *   logger.error('Database disconnected:', health.error);\n   * } else if (!health.responsive) {\n   *   logger.warn('Database slow to respond');\n   * } else {\n   *   logger.log('Database healthy, response time:', health.stats.responseTime, 'ms');\n   * }\n   * ```\n   */\n  public async healthCheck(): Promise<DatabaseHealthCheck> {\n    try {\n      const connected = this.isConnected();\n      if (!connected) {\n        return {\n          connected: false,\n          responsive: false,\n          stats: { size: 0, pageCount: 0, pageSize: 0, walMode: false, tables: 0 },\n        };\n      }\n\n      // Test responsiveness with a simple query\n      const start = Date.now();\n      await this.queryOne('SELECT 1 as test');\n      const responseTime = Date.now() - start;\n\n      const stats = await this.getStats();\n\n      return {\n        connected: true,\n        responsive: responseTime < 1000, // Consider responsive if < 1s\n        stats: {\n          ...stats,\n          responseTime,\n        },\n      };\n    } catch (error) {\n      return {\n        connected: false,\n        responsive: false,\n        stats: { size: 0, pageCount: 0, pageSize: 0, walMode: false, tables: 0 },\n        error: (error as Error).message,\n      };\n    }\n  }\n\n  /**\n   * Ensure database directory exists\n   */\n  private async ensureDirectoryExists(): Promise<void> {\n    const dbPath = this.config.path;\n    if (dbPath === ':memory:') return;\n\n    const directory = path.dirname(dbPath);\n    try {\n      await fs.access(directory);\n    } catch {\n      logger.info('Creating database directory', { directory });\n      await fs.mkdir(directory, { recursive: true });\n    }\n  }\n\n  /**\n   * Configure SQLite pragmas for optimal performance\n   */\n  private async configurePragmas(): Promise<void> {\n    if (!this.db) return;\n\n    const pragmas = [\n      // Enable foreign key constraints\n      'PRAGMA foreign_keys = ON',\n\n      // Set journal mode (WAL for better concurrency)\n      `PRAGMA journal_mode = ${this.config.walMode ? 'WAL' : 'DELETE'}`,\n\n      // Set synchronous mode for performance vs durability balance\n      'PRAGMA synchronous = NORMAL',\n\n      // Set memory-mapped I/O size\n      `PRAGMA mmap_size = ${this.config.memoryLimit}`,\n\n      // Set temp store to memory for better performance\n      'PRAGMA temp_store = MEMORY',\n\n      // Set busy timeout\n      `PRAGMA busy_timeout = ${this.config.timeout}`,\n\n      // Optimize for read-heavy workload\n      'PRAGMA cache_size = -64000', // 64MB cache\n\n      // Enable auto-vacuum for automatic cleanup\n      'PRAGMA auto_vacuum = INCREMENTAL',\n    ];\n\n    try {\n      await Promise.all(\n        pragmas.map(async pragma => {\n          await this.db!.exec(pragma);\n        })\n      );\n    } catch (error) {\n      logger.warn('Failed to apply pragma', { error });\n    }\n  }\n\n  /**\n   * Test database connection\n   */\n  private async testConnection(): Promise<void> {\n    if (!this.db) return;\n\n    const result = await this.db.get('SELECT sqlite_version() as version');\n    logger.info('Database connection test successful', {\n      sqliteVersion: result?.version,\n    });\n  }\n\n  /**\n   * Ensure database schema exists and is valid\n   */\n  private async ensureSchemaExists(): Promise<void> {\n    if (!this.schemaManager) return;\n\n    try {\n      const schemaExists = await this.schemaManager.schemaExists();\n\n      if (!schemaExists) {\n        logger.info('Database schema not found, creating...');\n        await this.schemaManager.createSchema();\n        logger.info('Database schema created successfully');\n      } else {\n        logger.debug('Database schema exists, validating...');\n        const validation = await this.schemaManager.validateSchema();\n\n        if (!validation.isValid) {\n          logger.warn('Database schema validation failed', {\n            missingTables: validation.missingTables,\n            missingIndexes: validation.missingIndexes,\n            missingViews: validation.missingViews,\n            errors: validation.errors,\n          });\n\n          // For now, just log the issues. In production, you might want to\n          // run migrations or recreate the schema\n          logger.info('Schema validation issues detected but continuing...');\n        } else {\n          logger.debug('Database schema validation passed');\n        }\n      }\n    } catch (error) {\n      logger.error('Failed to ensure schema exists', { error });\n      throw new Error(`Schema initialization failed: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Get the migration runner instance\n   *\n   * @returns {MigrationRunner} The migration runner instance\n   * @throws {Error} If migration runner is not initialized\n   */\n  public getMigrationRunner(): MigrationRunner {\n    if (!this.migrationRunner) {\n      throw new Error('Migration runner not initialized. Call initialize() first.');\n    }\n    return this.migrationRunner;\n  }\n\n  /**\n   * Run pending migrations\n   *\n   * @param {string} [target] - Optional target migration ID to migrate up to\n   * @returns {Promise<number>} Number of migrations run\n   *\n   * @example\n   * ```typescript\n   * // Run all pending migrations\n   * const count = await db.runMigrations();\n   * logger.log(`Ran ${count} migrations`);\n   *\n   * // Run migrations up to specific target\n   * await db.runMigrations('002_add_user_preferences');\n   * ```\n   */\n  public async runMigrations(target?: string): Promise<number> {\n    const runner = this.getMigrationRunner();\n    return await runner.up(target);\n  }\n\n  /**\n   * Rollback migrations\n   *\n   * @param {string} [target] - Optional target migration ID to rollback to\n   * @returns {Promise<number>} Number of migrations rolled back\n   *\n   * @example\n   * ```typescript\n   * // Rollback last migration\n   * await db.rollbackMigrations();\n   *\n   * // Rollback to specific migration\n   * await db.rollbackMigrations('001_initial_schema');\n   * ```\n   */\n  public async rollbackMigrations(target?: string): Promise<number> {\n    const runner = this.getMigrationRunner();\n    return await runner.down(target);\n  }\n\n  /**\n   * Get migration status\n   *\n   * @returns {Promise<{applied: string[], pending: string[], total: number}>} Migration status\n   *\n   * @example\n   * ```typescript\n   * const status = await db.getMigrationStatus();\n   * logger.log(`Applied: ${status.applied.length}, Pending: ${status.pending.length}`);\n   * ```\n   */\n  public async getMigrationStatus(): Promise<{\n    applied: string[];\n    pending: string[];\n    total: number;\n  }> {\n    const runner = this.getMigrationRunner();\n    return await runner.status();\n  }\n\n  /**\n   * Get the seed runner instance\n   *\n   * @returns {SeedRunner} The seed runner instance\n   * @throws {Error} If seed runner is not initialized\n   */\n  public getSeedRunner(): SeedRunner {\n    if (!this.seedRunner) {\n      throw new Error('Seed runner not initialized. Call initialize() first.');\n    }\n    return this.seedRunner;\n  }\n\n  /**\n   * Run database seeds\n   *\n   * @param {Object} options - Seed options\n   * @param {boolean} [options.force] - Force re-run seeds that have already been applied\n   * @returns {Promise<number>} Number of seeds run\n   *\n   * @example\n   * ```typescript\n   * // Run all pending seeds\n   * const count = await db.runSeeds();\n   * logger.log(`Ran ${count} seeds`);\n   *\n   * // Force re-run all seeds\n   * await db.runSeeds({ force: true });\n   * ```\n   */\n  public async runSeeds(options: { force?: boolean } = {}): Promise<number> {\n    const runner = this.getSeedRunner();\n    return await runner.run(options);\n  }\n\n  /**\n   * Get seed status\n   *\n   * @returns {Promise<{applied: string[], pending: string[], total: number}>} Seed status\n   *\n   * @example\n   * ```typescript\n   * const status = await db.getSeedStatus();\n   * logger.log(`Applied: ${status.applied.length}, Pending: ${status.pending.length}`);\n   * ```\n   */\n  public async getSeedStatus(): Promise<{\n    applied: string[];\n    pending: string[];\n    total: number;\n  }> {\n    const runner = this.getSeedRunner();\n    return await runner.status();\n  }\n\n  /**\n   * Reset all seed records\n   *\n   * @returns {Promise<void>}\n   *\n   * @example\n   * ```typescript\n   * // Clear all seed tracking records (seeds can be re-run)\n   * await db.resetSeeds();\n   * ```\n   */\n  public async resetSeeds(): Promise<void> {\n    const runner = this.getSeedRunner();\n    return await runner.reset();\n  }\n}\n\n/**\n * Pre-configured singleton database connection instance\n *\n * @constant {DatabaseConnection} dbConnection\n * @description This is the primary way to interact with the database throughout the application.\n * The connection is lazily initialized on first use.\n *\n * @example\n * ```typescript\n * import { dbConnection } from '@/database/connection';\n *\n * // Initialize at app startup\n * await dbConnection.initialize();\n *\n * // Use throughout the app\n * const tasks = await dbConnection.query('SELECT * FROM tasks');\n * ```\n */\nexport const dbConnection = DatabaseConnection.getInstance();\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/integrity.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 59,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 59,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1836, 1839], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1836, 1839], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 207,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 207,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6298, 6301], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6298, 6301], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 375,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 375,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11519, 11522], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11519, 11522], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 388,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 388,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 389,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 389,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 390,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 390,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 390,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 390,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 406,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 406,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 408,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 408,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 410,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 410,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 410,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 410,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 429,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 429,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 429,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 429,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 430,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 430,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 430,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 430,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 464,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 464,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14619, 14622], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14619, 14622], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 511,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 520,
        "endColumn": 10
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [dep.task_id] on an `any` value.",
        "line": 513,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 513,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [dep.task_id] resolves to an any value.",
        "line": 513,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 513,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task_id on an `any` value.",
        "line": 513,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 513,
        "endColumn": 36
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'groups'.",
        "line": 514,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 514,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [dep.task_id] on an `any` value.",
        "line": 514,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 514,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [dep.task_id] resolves to an any value.",
        "line": 514,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 514,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task_id on an `any` value.",
        "line": 514,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 514,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 516,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 516,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [dep.task_id] on an `any` value.",
        "line": 516,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 516,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [dep.task_id] resolves to an any value.",
        "line": 516,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 516,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task_id on an `any` value.",
        "line": 516,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 516,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 517,
        "column": 13,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 517,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 519,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 519,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16650, 16653], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16650, 16653], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{}`.",
        "line": 522,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 522,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ArrayLike<unknown> | { [s: string]: unknown; }`.",
        "line": 523,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 523,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 525,
        "column": 25,
        "nodeType": "MemberExpression",
        "messageId": "unsafeReturn",
        "endLine": 525,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 525,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 525,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16856, 16859], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16856, 16859], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .path on an `any` value.",
        "line": 525,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 525,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 622,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 622,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20101, 20104], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20101, 20104], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 634,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 634,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 635,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 635,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 636,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 636,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 636,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 636,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 646,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 646,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 647,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 647,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 648,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 648,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 648,
        "column": 67,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 648,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 658,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 658,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 659,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 659,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 660,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 660,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 660,
        "column": 69,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 660,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 670,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 670,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 671,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 671,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 672,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 672,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 672,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 672,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 699,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 699,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 700,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 700,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 701,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 701,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 701,
        "column": 72,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 701,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 712,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 712,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 713,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 713,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 714,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 714,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 714,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 714,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 724,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 724,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 726,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 726,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 728,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 728,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 728,
        "column": 75,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 728,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 732,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 732,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 732,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 732,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 733,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 733,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 733,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 733,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 734,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 734,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 734,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 734,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 735,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 735,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 735,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 735,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 736,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 736,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 736,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 736,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 769,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 769,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [25425, 25428], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [25425, 25428], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 817,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 817,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 818,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 818,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 819,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 819,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 819,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 819,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 828,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 828,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 829,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 829,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 830,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 830,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 830,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 830,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 840,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 840,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 841,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 841,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 842,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 842,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 842,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 842,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 851,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 851,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 852,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 852,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 853,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 853,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 853,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 853,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 859,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 859,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 859,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 859,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 860,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 860,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 860,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 860,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 861,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 861,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 861,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 861,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 862,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 862,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 862,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 862,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 895,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 895,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [29778, 29781], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [29778, 29781], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 917,
        "column": 61,
        "nodeType": "MemberExpression",
        "messageId": "unsafeReturn",
        "endLine": 917,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 917,
        "column": 65,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 917,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 937,
        "column": 7,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 944,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [idx.table_name] on an `any` value.",
        "line": 939,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 939,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [idx.table_name] resolves to an any value.",
        "line": 939,
        "column": 20,
        "nodeType": "MemberExpression",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 939,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .table_name on an `any` value.",
        "line": 939,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 939,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [idx.table_name] on an `any` value.",
        "line": 939,
        "column": 41,
        "nodeType": "MemberExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 939,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [idx.table_name] resolves to an any value.",
        "line": 939,
        "column": 41,
        "nodeType": "MemberExpression",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 939,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .table_name on an `any` value.",
        "line": 939,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 939,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 940,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 940,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [idx.table_name] on an `any` value.",
        "line": 940,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 940,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Computed name [idx.table_name] resolves to an any value.",
        "line": 940,
        "column": 15,
        "nodeType": "MemberExpression",
        "messageId": "unsafeComputedMemberAccess",
        "endLine": 940,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .table_name on an `any` value.",
        "line": 940,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 940,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 940,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 940,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 941,
        "column": 11,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 941,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .stats_status on an `any` value.",
        "line": 958,
        "column": 66,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 958,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .stats_status on an `any` value.",
        "line": 967,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 967,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 979,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 979,
        "endColumn": 63
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 116,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Database integrity check utilities\n * Provides comprehensive validation of database consistency, constraints, and data quality\n *\n * @module database/integrity\n * @description This module provides tools for validating database integrity including\n * foreign key constraints, data consistency, circular dependency detection, and\n * schema validation. Used for health checks and data quality monitoring.\n *\n * @example\n * ```typescript\n * import { DatabaseIntegrityChecker } from '@/database/integrity';\n *\n * const checker = new DatabaseIntegrityChecker(dbConnection);\n * const results = await checker.runFullIntegrityCheck();\n *\n * if (!results.isValid) {\n *   console.error('Database integrity issues found:', results.errors);\n * }\n * ```\n */\n\nimport { logger } from '../utils/logger';\nimport type { DatabaseConnection } from './connection';\n\n/**\n * Configuration for integrity check operations\n */\nexport interface IntegrityCheckConfig {\n  /** Check foreign key constraints */\n  checkForeignKeys: boolean;\n  /** Check for orphaned records */\n  checkOrphans: boolean;\n  /** Check for circular dependencies */\n  checkCircularDependencies: boolean;\n  /** Validate data types and constraints */\n  checkDataTypes: boolean;\n  /** Check full-text search consistency */\n  checkFtsConsistency: boolean;\n  /** Check index integrity */\n  checkIndexes: boolean;\n  /** Maximum depth for dependency checking */\n  maxDependencyDepth: number;\n}\n\n/**\n * Result of an integrity check operation\n */\nexport interface IntegrityCheckResult {\n  /** Whether the check passed */\n  isValid: boolean;\n  /** Array of error messages */\n  errors: string[];\n  /** Array of warning messages */\n  warnings: string[];\n  /** Check execution time in milliseconds */\n  executionTime: number;\n  /** Additional metadata about the check */\n  metadata: Record<string, any>;\n}\n\n/**\n * Comprehensive database integrity check results\n */\nexport interface FullIntegrityCheckResult {\n  /** Overall validity status */\n  isValid: boolean;\n  /** Individual check results */\n  checks: {\n    foreignKeys: IntegrityCheckResult;\n    orphans: IntegrityCheckResult;\n    circularDependencies: IntegrityCheckResult;\n    dataTypes: IntegrityCheckResult;\n    ftsConsistency: IntegrityCheckResult;\n    indexes: IntegrityCheckResult;\n  };\n  /** Summary statistics */\n  summary: {\n    totalErrors: number;\n    totalWarnings: number;\n    totalExecutionTime: number;\n    checksRun: number;\n    checksPassed: number;\n  };\n}\n\n/**\n * Database integrity checker providing comprehensive validation tools\n *\n * @class DatabaseIntegrityChecker\n * @description Provides methods for validating database consistency, constraints,\n * and data quality. Can run individual checks or comprehensive validation.\n *\n * @example\n * ```typescript\n * const checker = new DatabaseIntegrityChecker(dbConnection);\n *\n * // Run individual checks\n * const fkResult = await checker.checkForeignKeyConstraints();\n * const orphansResult = await checker.checkOrphanedRecords();\n *\n * // Run comprehensive check\n * const fullResult = await checker.runFullIntegrityCheck();\n * ```\n */\nexport class DatabaseIntegrityChecker {\n  private readonly db: DatabaseConnection;\n\n  private readonly config: IntegrityCheckConfig;\n\n  constructor(database: DatabaseConnection, config: Partial<IntegrityCheckConfig> = {}) {\n    this.db = database;\n    this.config = {\n      checkForeignKeys: true,\n      checkOrphans: true,\n      checkCircularDependencies: true,\n      checkDataTypes: true,\n      checkFtsConsistency: true,\n      checkIndexes: true,\n      maxDependencyDepth: 10,\n      ...config,\n    };\n  }\n\n  /**\n   * Run a comprehensive integrity check covering all aspects\n   *\n   * @returns {Promise<FullIntegrityCheckResult>} Complete integrity check results\n   *\n   * @example\n   * ```typescript\n   * const results = await checker.runFullIntegrityCheck();\n   *\n   * console.log(`Overall valid: ${results.isValid}`);\n   * console.log(`Total errors: ${results.summary.totalErrors}`);\n   * console.log(`Execution time: ${results.summary.totalExecutionTime}ms`);\n   *\n   * // Check specific results\n   * if (!results.checks.foreignKeys.isValid) {\n   *   console.error('Foreign key violations:', results.checks.foreignKeys.errors);\n   * }\n   * ```\n   */\n  public async runFullIntegrityCheck(): Promise<FullIntegrityCheckResult> {\n    const startTime = Date.now();\n    logger.info('Starting comprehensive database integrity check');\n\n    const checks = {\n      foreignKeys: await this.checkForeignKeyConstraints(),\n      orphans: await this.checkOrphanedRecords(),\n      circularDependencies: await this.checkCircularDependencies(),\n      dataTypes: await this.checkDataTypeConstraints(),\n      ftsConsistency: await this.checkFullTextSearchConsistency(),\n      indexes: await this.checkIndexIntegrity(),\n    };\n\n    const totalExecutionTime = Date.now() - startTime;\n    const totalErrors = Object.values(checks).reduce((sum, check) => sum + check.errors.length, 0);\n    const totalWarnings = Object.values(checks).reduce(\n      (sum, check) => sum + check.warnings.length,\n      0\n    );\n    const checksRun = Object.keys(checks).length;\n    const checksPassed = Object.values(checks).filter(check => check.isValid).length;\n    const isValid = totalErrors === 0;\n\n    const result: FullIntegrityCheckResult = {\n      isValid,\n      checks,\n      summary: {\n        totalErrors,\n        totalWarnings,\n        totalExecutionTime,\n        checksRun,\n        checksPassed,\n      },\n    };\n\n    logger.info('Database integrity check completed', {\n      isValid,\n      totalErrors,\n      totalWarnings,\n      executionTime: totalExecutionTime,\n      checksPassed: `${checksPassed}/${checksRun}`,\n    });\n\n    return result;\n  }\n\n  /**\n   * Check foreign key constraints across all tables\n   *\n   * @returns {Promise<IntegrityCheckResult>} Foreign key check results\n   *\n   * @example\n   * ```typescript\n   * const result = await checker.checkForeignKeyConstraints();\n   * if (!result.isValid) {\n   *   console.error('Foreign key violations found:', result.errors);\n   * }\n   * ```\n   */\n  public async checkForeignKeyConstraints(): Promise<IntegrityCheckResult> {\n    const startTime = Date.now();\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const metadata: Record<string, any> = {};\n\n    try {\n      logger.debug('Checking foreign key constraints');\n\n      // Enable foreign key constraint checking\n      await this.db.execute('PRAGMA foreign_key_check');\n\n      // Check specific foreign key relationships\n      const foreignKeyChecks = [\n        {\n          table: 'columns',\n          column: 'board_id',\n          reference: 'boards(id)',\n          query: `\n            SELECT 'columns' as table_name, id, board_id as foreign_key\n            FROM columns \n            WHERE board_id NOT IN (SELECT id FROM boards)\n          `,\n        },\n        {\n          table: 'tasks',\n          column: 'board_id',\n          reference: 'boards(id)',\n          query: `\n            SELECT 'tasks' as table_name, id, board_id as foreign_key\n            FROM tasks \n            WHERE board_id NOT IN (SELECT id FROM boards)\n          `,\n        },\n        {\n          table: 'tasks',\n          column: 'column_id',\n          reference: 'columns(id)',\n          query: `\n            SELECT 'tasks' as table_name, id, column_id as foreign_key\n            FROM tasks \n            WHERE column_id NOT IN (SELECT id FROM columns)\n          `,\n        },\n        {\n          table: 'tasks',\n          column: 'parent_task_id',\n          reference: 'tasks(id)',\n          query: `\n            SELECT 'tasks' as table_name, id, parent_task_id as foreign_key\n            FROM tasks \n            WHERE parent_task_id IS NOT NULL \n            AND parent_task_id NOT IN (SELECT id FROM tasks)\n          `,\n        },\n        {\n          table: 'task_dependencies',\n          column: 'task_id',\n          reference: 'tasks(id)',\n          query: `\n            SELECT 'task_dependencies' as table_name, id, task_id as foreign_key\n            FROM task_dependencies \n            WHERE task_id NOT IN (SELECT id FROM tasks)\n          `,\n        },\n        {\n          table: 'task_dependencies',\n          column: 'depends_on_task_id',\n          reference: 'tasks(id)',\n          query: `\n            SELECT 'task_dependencies' as table_name, id, depends_on_task_id as foreign_key\n            FROM task_dependencies \n            WHERE depends_on_task_id NOT IN (SELECT id FROM tasks)\n          `,\n        },\n        {\n          table: 'notes',\n          column: 'task_id',\n          reference: 'tasks(id)',\n          query: `\n            SELECT 'notes' as table_name, id, task_id as foreign_key\n            FROM notes \n            WHERE task_id IS NOT NULL \n            AND task_id NOT IN (SELECT id FROM tasks)\n          `,\n        },\n\n        {\n          table: 'task_tags',\n          column: 'task_id',\n          reference: 'tasks(id)',\n          query: `\n            SELECT 'task_tags' as table_name, task_id || '-' || tag_id as id, task_id as foreign_key\n            FROM task_tags \n            WHERE task_id NOT IN (SELECT id FROM tasks)\n          `,\n        },\n        {\n          table: 'task_tags',\n          column: 'tag_id',\n          reference: 'tags(id)',\n          query: `\n            SELECT 'task_tags' as table_name, task_id || '-' || tag_id as id, tag_id as foreign_key\n            FROM task_tags \n            WHERE tag_id NOT IN (SELECT id FROM tags)\n          `,\n        },\n      ];\n\n      let totalViolations = 0;\n\n      // Process all checks in parallel\n      const checkResults = await Promise.all(\n        foreignKeyChecks.map(async check => {\n          const violations = await this.db.query(check.query);\n          return { check, violations };\n        })\n      );\n\n      // Process results\n      for (const { check, violations } of checkResults) {\n        if (violations.length > 0) {\n          totalViolations += violations.length;\n          errors.push(\n            `${check.table}.${check.column} -> ${check.reference}: ` +\n              `${violations.length} invalid references found`\n          );\n\n          // Log first few violations for debugging\n          const sampleViolations = violations.slice(0, 3);\n          metadata[`${check.table}_${check.column}_violations`] = sampleViolations;\n        }\n      }\n\n      metadata.totalViolations = totalViolations;\n      metadata.tablesChecked = foreignKeyChecks.length;\n\n      logger.debug('Foreign key constraint check completed', {\n        violations: totalViolations,\n        tablesChecked: foreignKeyChecks.length,\n      });\n    } catch (error) {\n      errors.push(`Foreign key check failed: ${(error as Error).message}`);\n      logger.error('Foreign key constraint check failed', { error });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      executionTime: Date.now() - startTime,\n      metadata,\n    };\n  }\n\n  /**\n   * Check for orphaned records that should have been cleaned up\n   *\n   * @returns {Promise<IntegrityCheckResult>} Orphaned records check results\n   *\n   * @example\n   * ```typescript\n   * const result = await checker.checkOrphanedRecords();\n   * if (result.warnings.length > 0) {\n   *   console.warn('Orphaned records found:', result.warnings);\n   * }\n   * ```\n   */\n  public async checkOrphanedRecords(): Promise<IntegrityCheckResult> {\n    const startTime = Date.now();\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const metadata: Record<string, any> = {};\n\n    try {\n      logger.debug('Checking for orphaned records');\n\n      // Check for tasks with invalid parent relationships\n      const invalidParentTasks = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM tasks t1\n        WHERE t1.parent_task_id IS NOT NULL\n        AND t1.parent_task_id NOT IN (SELECT id FROM tasks WHERE archived = FALSE)\n      `);\n\n      if (invalidParentTasks[0]?.count > 0) {\n        warnings.push(`Found ${invalidParentTasks[0].count} tasks with invalid parent references`);\n        metadata.invalidParentTasks = invalidParentTasks[0].count;\n      }\n\n      // Check for tags with zero usage but existing in task_tags\n      const unusedTagsWithReferences = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM tags t\n        WHERE t.id IN (SELECT DISTINCT tag_id FROM task_tags)\n        AND t.id NOT IN (\n          SELECT DISTINCT tag_id \n          FROM task_tags tt \n          JOIN tasks task ON tt['task_id'] = task['id'] \n          WHERE task.archived = FALSE\n        )\n      `);\n\n      if (unusedTagsWithReferences[0]?.count > 0) {\n        warnings.push(\n          `Found ${unusedTagsWithReferences[0].count} tags with zero usage count but active references`\n        );\n        metadata.unusedTagsWithReferences = unusedTagsWithReferences[0].count;\n      }\n\n      // Check for columns without any tasks\n      const emptyColumns = await this.db.query(`\n        SELECT c.id, c.name, c.board_id, COUNT(t.id) as task_count\n        FROM columns c\n        LEFT JOIN tasks t ON c['id'] = t['column_id'] AND t['archived'] = FALSE\n        GROUP BY c['id'], c['name'], c['board_id']\n        HAVING task_count = 0\n      `);\n\n      if (emptyColumns.length > 0) {\n        warnings.push(`Found ${emptyColumns.length} columns with no active tasks`);\n        metadata.emptyColumns = emptyColumns.length;\n        metadata.emptyColumnDetails = emptyColumns.slice(0, 5); // Sample for review\n      }\n\n      logger.debug('Orphaned records check completed', {\n        invalidParentTasks: invalidParentTasks[0]?.count ?? 0,\n        unusedTags: unusedTagsWithReferences[0]?.count ?? 0,\n        emptyColumns: emptyColumns.length,\n      });\n    } catch (error) {\n      errors.push(`Orphaned records check failed: ${(error as Error).message}`);\n      logger.error('Orphaned records check failed', { error });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      executionTime: Date.now() - startTime,\n      metadata,\n    };\n  }\n\n  /**\n   * Check for circular dependencies in task relationships\n   *\n   * @returns {Promise<IntegrityCheckResult>} Circular dependency check results\n   *\n   * @example\n   * ```typescript\n   * const result = await checker.checkCircularDependencies();\n   * if (!result.isValid) {\n   *   console.error('Circular dependencies detected:', result.errors);\n   * }\n   * ```\n   */\n  public async checkCircularDependencies(): Promise<IntegrityCheckResult> {\n    const startTime = Date.now();\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const metadata: Record<string, any> = {};\n\n    try {\n      logger.debug('Checking for circular dependencies');\n\n      // Check for circular dependencies using recursive CTE\n      const circularDependencies = await this.db.query(\n        `\n        WITH RECURSIVE dependency_cycle_check(task_id, depends_on_task_id, depth, path) AS (\n          -- Start with direct dependencies\n          SELECT task_id, depends_on_task_id, 0 as depth, task_id || ' -> ' || depends_on_task_id as path\n          FROM task_dependencies\n          \n          UNION ALL\n          \n          -- Follow the dependency chain\n          SELECT \n            dc.task_id,\n            td.depends_on_task_id,\n            dc.depth + 1,\n            dc.path ?? ' -> ' || td.depends_on_task_id\n          FROM dependency_cycle_check dc\n          JOIN task_dependencies td ON dc['depends_on_task_id'] = td['task_id']\n          WHERE dc.depth < ? -- Prevent infinite recursion\n        )\n        -- Find cycles where a task depends on itself through the chain\n        SELECT DISTINCT \n          task_id,\n          depends_on_task_id,\n          depth,\n          path,\n          t1.title as task_title,\n          t2.title as dependency_title\n        FROM dependency_cycle_check dc\n        JOIN tasks t1 ON dc['task_id'] = t1['id']\n        JOIN tasks t2 ON dc['depends_on_task_id'] = t2['id']\n        WHERE dc['task_id'] = dc['depends_on_task_id'] -- Circular dependency detected\n        ORDER BY task_id, depth\n      `,\n        [this.config.maxDependencyDepth]\n      );\n\n      if (circularDependencies.length > 0) {\n        errors.push(`Found ${circularDependencies.length} circular dependency chains`);\n        metadata.circularDependencies = circularDependencies;\n\n        // Group by task for better reporting\n        const taskGroups = circularDependencies.reduce(\n          (groups, dep) => {\n            if (!groups[dep.task_id]) {\n              groups[dep.task_id] = [];\n            }\n            groups[dep.task_id].push(dep);\n            return groups;\n          },\n          {} as Record<string, any[]>\n        );\n\n        metadata.affectedTasks = Object.keys(taskGroups).length;\n        metadata.sampleCircularPaths = Object.values(taskGroups)\n          .slice(0, 3)\n          .map(group => (group as any[])[0].path);\n      }\n\n      // Check for self-referencing tasks (parent_task_id = id)\n      const selfReferencingTasks = await this.db.query(`\n        SELECT id, title, parent_task_id\n        FROM tasks\n        WHERE id = parent_task_id\n      `);\n\n      if (selfReferencingTasks.length > 0) {\n        errors.push(\n          `Found ${selfReferencingTasks.length} tasks that reference themselves as parent`\n        );\n        metadata.selfReferencingTasks = selfReferencingTasks;\n      }\n\n      // Check for potential cycles in parent-child relationships\n      const parentChildCycles = await this.db.query(\n        `\n        WITH RECURSIVE parent_cycle_check(child_id, parent_id, depth, path) AS (\n          -- Start with direct parent relationships\n          SELECT id as child_id, parent_task_id as parent_id, 0 as depth, id ?? ' -> ' || parent_task_id as path\n          FROM tasks\n          WHERE parent_task_id IS NOT NULL\n          \n          UNION ALL\n          \n          -- Follow the parent chain\n          SELECT \n            pc.child_id,\n            t.parent_task_id as parent_id,\n            pc.depth + 1,\n            pc.path ?? ' -> ' || t.parent_task_id\n          FROM parent_cycle_check pc\n          JOIN tasks t ON pc['parent_id'] = t['id']\n          WHERE t['parent_task_id'] IS NOT NULL\n          AND pc.depth < ? -- Prevent infinite recursion\n        )\n        -- Find cycles where a child is its own ancestor\n        SELECT DISTINCT \n          child_id,\n          parent_id,\n          depth,\n          path,\n          t1.title as child_title,\n          t2.title as parent_title\n        FROM parent_cycle_check pc\n        JOIN tasks t1 ON pc['child_id'] = t1['id']\n        JOIN tasks t2 ON pc['parent_id'] = t2['id']\n        WHERE pc['child_id'] = pc['parent_id'] -- Parent-child cycle detected\n        ORDER BY child_id, depth\n      `,\n        [this.config.maxDependencyDepth]\n      );\n\n      if (parentChildCycles.length > 0) {\n        errors.push(`Found ${parentChildCycles.length} parent-child relationship cycles`);\n        metadata.parentChildCycles = parentChildCycles;\n      }\n\n      logger.debug('Circular dependency check completed', {\n        circularDependencies: circularDependencies.length,\n        selfReferencingTasks: selfReferencingTasks.length,\n        parentChildCycles: parentChildCycles.length,\n      });\n    } catch (error) {\n      errors.push(`Circular dependency check failed: ${(error as Error).message}`);\n      logger.error('Circular dependency check failed', { error });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      executionTime: Date.now() - startTime,\n      metadata,\n    };\n  }\n\n  /**\n   * Check data type constraints and value validity\n   *\n   * @returns {Promise<IntegrityCheckResult>} Data type validation results\n   *\n   * @example\n   * ```typescript\n   * const result = await checker.checkDataTypeConstraints();\n   * if (!result.isValid) {\n   *   console.error('Data validation issues:', result.errors);\n   * }\n   * ```\n   */\n  public async checkDataTypeConstraints(): Promise<IntegrityCheckResult> {\n    const startTime = Date.now();\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const metadata: Record<string, any> = {};\n\n    try {\n      logger.debug('Checking data type constraints');\n\n      // Check task priority values (should be integers)\n      const invalidPriorities = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM tasks\n        WHERE priority IS NOT NULL AND priority NOT BETWEEN 0 AND 10\n      `);\n\n      if (invalidPriorities[0]?.count > 0) {\n        errors.push(`Found ${invalidPriorities[0].count} tasks with invalid priority values`);\n        metadata.invalidPriorities = invalidPriorities[0].count;\n      }\n\n      // Check note category values\n      const invalidNoteCategories = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM notes\n        WHERE category NOT IN ('general', 'progress', 'blocker', 'decision', 'question')\n      `);\n\n      if (invalidNoteCategories[0]?.count > 0) {\n        errors.push(`Found ${invalidNoteCategories[0].count} notes with invalid category values`);\n        metadata.invalidNoteCategories = invalidNoteCategories[0].count;\n      }\n\n      // Check dependency types\n      const invalidDependencyTypes = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM task_dependencies\n        WHERE dependency_type NOT IN ('blocks', 'relates_to', 'duplicates')\n      `);\n\n      if (invalidDependencyTypes[0]?.count > 0) {\n        errors.push(`Found ${invalidDependencyTypes[0].count} dependencies with invalid types`);\n        metadata.invalidDependencyTypes = invalidDependencyTypes[0].count;\n      }\n\n      // Check for negative priority values\n      const negativePriorities = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM tasks\n        WHERE priority < 0\n      `);\n\n      if (negativePriorities[0]?.count > 0) {\n        warnings.push(`Found ${negativePriorities[0].count} tasks with negative priority values`);\n        metadata.negativePriorities = negativePriorities[0].count;\n      }\n\n      // Check for invalid JSON in metadata columns\n      const jsonColumns = [{ table: 'tasks', column: 'metadata' }];\n\n      const jsonCheckResults = await Promise.all(\n        jsonColumns.map(async ({ table, column }) => {\n          try {\n            const invalidJson = await this.db.query(`\n              SELECT COUNT(*) as count\n              FROM ${table}\n              WHERE json_valid(${column}) = 0\n            `);\n            return { table, column, invalidJson, error: null };\n          } catch (error) {\n            return { table, column, invalidJson: null, error };\n          }\n        })\n      );\n\n      for (const { table, column, invalidJson, error } of jsonCheckResults) {\n        if (error) {\n          // SQLite version might not support json_valid\n          warnings.push(\n            `Could not validate JSON in ${table}.${column}: ${(error as Error).message}`\n          );\n        } else if (invalidJson && invalidJson[0]?.count > 0) {\n          errors.push(`Found ${invalidJson[0].count} invalid JSON values in ${table}.${column}`);\n          metadata[`invalid_json_${table}_${column}`] = invalidJson[0].count;\n        }\n      }\n\n      // Check for tasks with invalid progress percentages\n      const invalidProgress = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM task_progress\n        WHERE percent_complete < 0 OR percent_complete > 100\n      `);\n\n      if (invalidProgress[0]?.count > 0) {\n        errors.push(`Found ${invalidProgress[0].count} tasks with invalid progress percentages`);\n        metadata.invalidProgress = invalidProgress[0].count;\n      }\n\n      // Check for inconsistent subtask counts\n      const inconsistentSubtaskCounts = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM task_progress tp\n        WHERE tp['subtasks_completed'] > tp['subtasks_total']\n      `);\n\n      if (inconsistentSubtaskCounts[0]?.count > 0) {\n        errors.push(\n          `Found ${inconsistentSubtaskCounts[0].count} tasks with more completed than total subtasks`\n        );\n        metadata.inconsistentSubtaskCounts = inconsistentSubtaskCounts[0].count;\n      }\n\n      logger.debug('Data type constraint check completed', {\n        invalidPriorities: invalidPriorities[0]?.count ?? 0,\n        invalidNoteCategories: invalidNoteCategories[0]?.count ?? 0,\n        invalidDependencyTypes: invalidDependencyTypes[0]?.count ?? 0,\n        negativePriorities: negativePriorities[0]?.count ?? 0,\n        invalidProgress: invalidProgress[0]?.count ?? 0,\n      });\n    } catch (error) {\n      errors.push(`Data type constraint check failed: ${(error as Error).message}`);\n      logger.error('Data type constraint check failed', { error });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      executionTime: Date.now() - startTime,\n      metadata,\n    };\n  }\n\n  /**\n   * Check full-text search table consistency\n   *\n   * @returns {Promise<IntegrityCheckResult>} FTS consistency check results\n   *\n   * @example\n   * ```typescript\n   * const result = await checker.checkFullTextSearchConsistency();\n   * if (!result.isValid) {\n   *   console.error('FTS inconsistencies found:', result.errors);\n   * }\n   * ```\n   */\n  public async checkFullTextSearchConsistency(): Promise<IntegrityCheckResult> {\n    const startTime = Date.now();\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const metadata: Record<string, any> = {};\n\n    try {\n      logger.debug('Checking full-text search consistency');\n\n      // Check tasks FTS table consistency\n      const tasksCount = await this.db.queryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM tasks'\n      );\n      const tasksFtsCount = await this.db.queryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM tasks_fts'\n      );\n\n      if (tasksCount?.count !== tasksFtsCount?.count) {\n        errors.push(\n          `Tasks FTS table inconsistency: ${tasksCount?.count ?? 0} tasks vs ${tasksFtsCount?.count ?? 0} FTS entries`\n        );\n        metadata.tasksCountMismatch = {\n          tasks: tasksCount?.count ?? 0,\n          fts: tasksFtsCount?.count ?? 0,\n        };\n      }\n\n      // Check notes FTS table consistency\n      const notesCount = await this.db.queryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM notes'\n      );\n      const notesFtsCount = await this.db.queryOne<{ count: number }>(\n        'SELECT COUNT(*) as count FROM notes_fts'\n      );\n\n      if (notesCount?.count !== notesFtsCount?.count) {\n        errors.push(\n          `Notes FTS table inconsistency: ${notesCount?.count ?? 0} notes vs ${notesFtsCount?.count ?? 0} FTS entries`\n        );\n        metadata.notesCountMismatch = {\n          notes: notesCount?.count ?? 0,\n          fts: notesFtsCount?.count ?? 0,\n        };\n      }\n\n      // Check for orphaned FTS entries\n      const orphanedTasksFts = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM tasks_fts\n        WHERE rowid NOT IN (SELECT rowid FROM tasks)\n      `);\n\n      if (orphanedTasksFts[0]?.count > 0) {\n        warnings.push(`Found ${orphanedTasksFts[0].count} orphaned entries in tasks FTS table`);\n        metadata.orphanedTasksFts = orphanedTasksFts[0].count;\n      }\n\n      const orphanedNotesFts = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM notes_fts\n        WHERE rowid NOT IN (SELECT rowid FROM notes)\n      `);\n\n      if (orphanedNotesFts[0]?.count > 0) {\n        warnings.push(`Found ${orphanedNotesFts[0].count} orphaned entries in notes FTS table`);\n        metadata.orphanedNotesFts = orphanedNotesFts[0].count;\n      }\n\n      // Check for missing FTS entries\n      const missingTasksFts = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM tasks\n        WHERE rowid NOT IN (SELECT rowid FROM tasks_fts)\n      `);\n\n      if (missingTasksFts[0]?.count > 0) {\n        warnings.push(`Found ${missingTasksFts[0].count} tasks missing from FTS table`);\n        metadata.missingTasksFts = missingTasksFts[0].count;\n      }\n\n      const missingNotesFts = await this.db.query(`\n        SELECT COUNT(*) as count\n        FROM notes\n        WHERE rowid NOT IN (SELECT rowid FROM notes_fts)\n      `);\n\n      if (missingNotesFts[0]?.count > 0) {\n        warnings.push(`Found ${missingNotesFts[0].count} notes missing from FTS table`);\n        metadata.missingNotesFts = missingNotesFts[0].count;\n      }\n\n      logger.debug('Full-text search consistency check completed', {\n        tasksCountMatch: tasksCount?.count === tasksFtsCount?.count,\n        notesCountMatch: notesCount?.count === notesFtsCount?.count,\n        orphanedTasksFts: orphanedTasksFts[0]?.count ?? 0,\n        orphanedNotesFts: orphanedNotesFts[0]?.count ?? 0,\n        missingTasksFts: missingTasksFts[0]?.count ?? 0,\n        missingNotesFts: missingNotesFts[0]?.count ?? 0,\n      });\n    } catch (error) {\n      errors.push(`Full-text search consistency check failed: ${(error as Error).message}`);\n      logger.error('Full-text search consistency check failed', { error });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      executionTime: Date.now() - startTime,\n      metadata,\n    };\n  }\n\n  /**\n   * Check database index integrity and effectiveness\n   *\n   * @returns {Promise<IntegrityCheckResult>} Index integrity check results\n   *\n   * @example\n   * ```typescript\n   * const result = await checker.checkIndexIntegrity();\n   * if (result.warnings.length > 0) {\n   *   console.warn('Index optimization recommended:', result.warnings);\n   * }\n   * ```\n   */\n  public async checkIndexIntegrity(): Promise<IntegrityCheckResult> {\n    const startTime = Date.now();\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const metadata: Record<string, any> = {};\n\n    try {\n      logger.debug('Checking index integrity');\n\n      // Check for missing critical indexes\n      const expectedIndexes = [\n        'idx_tasks_board_id',\n        'idx_tasks_column_id',\n        'idx_tasks_parent_id',\n        'idx_tasks_priority',\n        'idx_columns_board_id',\n        'idx_notes_task_id',\n        'idx_task_deps_task_id',\n        'idx_task_tags_tag_id',\n      ];\n\n      const existingIndexes = await this.db.query(`\n        SELECT name FROM sqlite_master \n        WHERE type='index' AND name NOT LIKE 'sqlite_%'\n      `);\n\n      const existingIndexNames = existingIndexes.map(idx => idx.name);\n      const missingIndexes = expectedIndexes.filter(idx => !existingIndexNames.includes(idx));\n\n      if (missingIndexes.length > 0) {\n        warnings.push(`Missing critical indexes: ${missingIndexes.join(', ')}`);\n        metadata.missingIndexes = missingIndexes;\n      }\n\n      // Check for duplicate or redundant indexes\n      const allIndexes = await this.db.query(`\n        SELECT \n          name,\n          tbl_name as table_name,\n          sql\n        FROM sqlite_master \n        WHERE type='index' AND name NOT LIKE 'sqlite_%'\n        ORDER BY tbl_name, name\n      `);\n\n      metadata.totalIndexes = allIndexes.length;\n      metadata.indexesByTable = allIndexes.reduce(\n        (acc, idx) => {\n          if (!acc[idx.table_name]) acc[idx.table_name] = [];\n          acc[idx.table_name].push(idx.name);\n          return acc;\n        },\n        {} as Record<string, string[]>\n      );\n\n      // Check index usage statistics (if available)\n      try {\n        const indexStats = await this.db.query(`\n          SELECT \n            sm.name,\n            sm.tbl_name as tbl,\n            CASE WHEN s1.stat IS NOT NULL THEN 'has_stats' ELSE 'no_stats' END as stats_status\n          FROM sqlite_master sm\n          LEFT JOIN sqlite_stat1 s1 ON sm['name'] = s1['idx']\n          WHERE sm.type = 'index' AND sm.name NOT LIKE 'sqlite_%'\n        `);\n\n        const indexesWithoutStats = indexStats.filter(idx => idx.stats_status === 'no_stats');\n        if (indexesWithoutStats.length > 0) {\n          warnings.push(\n            `${indexesWithoutStats.length} indexes lack statistics (consider running ANALYZE)`\n          );\n          metadata.indexesWithoutStats = indexesWithoutStats.length;\n        }\n\n        metadata.indexesWithStats = indexStats.filter(\n          idx => idx.stats_status === 'has_stats'\n        ).length;\n      } catch (error) {\n        // sqlite_stat1 might not be available\n        warnings.push('Could not check index statistics');\n        metadata.indexesWithoutStats = 0;\n        metadata.indexesWithStats = 0;\n      }\n\n      logger.debug('Index integrity check completed', {\n        totalIndexes: allIndexes.length,\n        missingCriticalIndexes: missingIndexes.length,\n        indexesWithoutStats: metadata.indexesWithoutStats ?? 0,\n      });\n    } catch (error) {\n      errors.push(`Index integrity check failed: ${(error as Error).message}`);\n      logger.error('Index integrity check failed', { error });\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n      executionTime: Date.now() - startTime,\n      metadata,\n    };\n  }\n\n  /**\n   * Get a quick health summary of the database\n   *\n   * @returns {Promise<{isHealthy: boolean, issues: string[], recommendations: string[]}>} Health summary\n   *\n   * @example\n   * ```typescript\n   * const health = await checker.getHealthSummary();\n   * console.log(`Database healthy: ${health.isHealthy}`);\n   * if (health.issues.length > 0) {\n   *   console.error('Issues:', health.issues);\n   * }\n   * ```\n   */\n  public async getHealthSummary(): Promise<{\n    isHealthy: boolean;\n    issues: string[];\n    recommendations: string[];\n  }> {\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n\n    try {\n      // Quick checks for common issues\n      const quickChecks = await Promise.all([\n        this.db.queryOne<{ count: number }>(\n          'SELECT COUNT(*) as count FROM sqlite_master WHERE type=\"table\"'\n        ),\n        this.db.queryOne<{ integrity: string }>('PRAGMA integrity_check(5)'),\n        this.db.queryOne<{ mode: string }>('PRAGMA journal_mode'),\n      ]);\n\n      const [tableCount, integrityResult, journalMode] = quickChecks;\n\n      if ((tableCount?.count ?? 0) < 5) {\n        issues.push('Database appears to be missing core tables');\n      }\n\n      if (integrityResult?.integrity !== 'ok') {\n        issues.push(`Database integrity check failed: ${integrityResult?.integrity}`);\n      }\n\n      if (journalMode?.mode !== 'wal') {\n        recommendations.push('Consider enabling WAL mode for better concurrency');\n      }\n\n      // Check database size and recommend maintenance\n      const stats = await this.db.getStats();\n      if (stats.size > 100 * 1024 * 1024) {\n        // 100MB\n        recommendations.push('Database is large, consider running VACUUM or incremental vacuum');\n      }\n    } catch (error) {\n      issues.push(`Health check failed: ${(error as Error).message}`);\n    }\n\n    return {\n      isHealthy: issues.length === 0,\n      issues,\n      recommendations,\n    };\n  }\n}\n\n/**\n * Convenience function to run a quick integrity check\n *\n * @param {DatabaseConnection} db - Database connection\n * @returns {Promise<boolean>} True if database integrity is valid\n *\n * @example\n * ```typescript\n * import { quickIntegrityCheck } from '@/database/integrity';\n *\n * const isValid = await quickIntegrityCheck(dbConnection);\n * if (!isValid) {\n *   console.error('Database integrity issues detected');\n * }\n * ```\n */\nexport async function quickIntegrityCheck(db: DatabaseConnection): Promise<boolean> {\n  const checker = new DatabaseIntegrityChecker(db, {\n    checkForeignKeys: true,\n    checkOrphans: false,\n    checkCircularDependencies: true,\n    checkDataTypes: true,\n    checkFtsConsistency: false,\n    checkIndexes: false,\n    maxDependencyDepth: 5,\n  });\n\n  try {\n    const results = await checker.runFullIntegrityCheck();\n    return results.isValid;\n  } catch (error) {\n    logger.error('Quick integrity check failed', { error });\n    return false;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/kyselyConnection.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 21,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 23,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 202,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 202,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5271, 5274], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5271, 5274], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Kysely database connection and query builder setup\n *\n * This provides a type-safe query builder alternative to raw SQL queries.\n * Can be used alongside the existing connection for incremental migration.\n */\n\nimport { Kysely, SqliteDialect } from 'kysely';\nimport Database from 'better-sqlite3';\nimport { logger } from '@/utils/logger';\nimport { config } from '@/config';\nimport type { Database as DatabaseSchema } from './kyselySchema';\n\nexport class KyselyConnection {\n  private static instance: KyselyConnection | null = null;\n\n  private readonly _db: Kysely<DatabaseSchema> | null = null;\n\n  private readonly _sqliteDb: Database.Database | null = null;\n\n  private constructor() {\n    // Private constructor for singleton pattern\n  }\n\n  /**\n   * Initialize the Kysely database connection\n   */\n  public static initialize(): KyselyConnection {\n    if (this.instance) {\n      logger.warn('Kysely connection already initialized');\n      return this.instance;\n    }\n\n    this.instance = new KyselyConnection();\n\n    try {\n      // Create SQLite database instance\n      this.instance._sqliteDb = new Database(config.database.path, {\n        verbose: config.database.verbose ? logger.debug.bind(logger) : undefined,\n      });\n\n      // Configure SQLite pragmas for optimal performance\n      this.instance._sqliteDb.pragma('journal_mode = WAL');\n      this.instance._sqliteDb.pragma('synchronous = NORMAL');\n      this.instance._sqliteDb.pragma('cache_size = 1000');\n      this.instance._sqliteDb.pragma('foreign_keys = ON');\n      this.instance._sqliteDb.pragma('temp_store = MEMORY');\n\n      // Create Kysely instance with SQLite dialect\n      this.instance._db = new Kysely<DatabaseSchema>({\n        dialect: new SqliteDialect({\n          database: this.instance._sqliteDb,\n        }),\n      });\n\n      logger.info('Kysely database connection initialized', {\n        path: config.database.path,\n        walMode: true,\n      });\n\n      return this.instance;\n    } catch (error) {\n      logger.error('Failed to initialize Kysely connection', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Get the singleton instance\n   */\n  public static getInstance(): KyselyConnection {\n    if (!this.instance) {\n      throw new Error('Kysely connection not initialized. Call initialize() first.');\n    }\n    return this.instance;\n  }\n\n  /**\n   * Get the Kysely database instance\n   */\n  public get db(): Kysely<DatabaseSchema> {\n    if (!this._db) {\n      throw new Error('Kysely database not initialized. Call initialize() first.');\n    }\n    return this._db;\n  }\n\n  /**\n   * Get the underlying SQLite database instance\n   */\n  public get sqlite(): Database.Database {\n    if (!this._sqliteDb) {\n      throw new Error('SQLite database not initialized. Call initialize() first.');\n    }\n    return this._sqliteDb;\n  }\n\n  /**\n   * Close the database connection\n   */\n  public async close(): Promise<void> {\n    try {\n      if (this._db) {\n        await this._db.destroy();\n        this._db = null;\n      }\n\n      if (this._sqliteDb) {\n        this._sqliteDb.close();\n        this._sqliteDb = null;\n      }\n\n      logger.info('Kysely database connection closed');\n    } catch (error) {\n      logger.error('Error closing Kysely database connection', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a transaction\n   */\n  public async transaction<T>(callback: (trx: Kysely<DatabaseSchema>) => Promise<T>): Promise<T> {\n    if (!this._db) {\n      throw new Error('Database not initialized');\n    }\n    return this._db.transaction().execute(callback);\n  }\n\n  /**\n   * Health check for the database connection\n   */\n  public async healthCheck(): Promise<{\n    status: 'healthy' | 'unhealthy';\n    details: {\n      connected: boolean;\n      tablesExist: boolean;\n      canQuery: boolean;\n      errorMessage?: string;\n    };\n  }> {\n    if (!this._db) {\n      return {\n        status: 'unhealthy',\n        details: {\n          connected: false,\n          tablesExist: false,\n          canQuery: false,\n          errorMessage: 'Database not initialized',\n        },\n      };\n    }\n\n    try {\n      // Test basic query\n      await this._db.selectFrom('boards').select(['id']).limit(1).execute();\n\n      return {\n        status: 'healthy',\n        details: {\n          connected: true,\n          tablesExist: true,\n          canQuery: true,\n        },\n      };\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        details: {\n          connected: this._db !== null,\n          tablesExist: false,\n          canQuery: false,\n          errorMessage: error instanceof Error ? error.message : 'Unknown error',\n        },\n      };\n    }\n  }\n\n  /**\n   * Get database statistics\n   */\n  public async getStats(): Promise<{\n    tableStats: Array<{\n      name: string;\n      rowCount: number;\n      diskSize: number;\n    }>;\n    totalSize: number;\n    walSize: number;\n  }> {\n    if (!this._db ?? !this._sqliteDb) {\n      throw new Error('Database not initialized');\n    }\n\n    try {\n      // Get table statistics\n      const tables = ['boards', 'tasks', 'notes', 'tags', 'task_tags', 'task_dependencies'];\n\n      const tableStats = await Promise.all(\n        tables.map(async table => {\n          const countResult = await this._db\n            .selectFrom(table as any)\n            .select([this._db.fn.count<number>('id').as('count')])\n            .executeTakeFirst();\n\n          const sizeResult = this._sqliteDb\n            .prepare<\n              unknown[],\n              { size: number }\n            >(`SELECT SUM(pgsize) as size FROM dbstat WHERE name = ?`)\n            .get(table);\n\n          return {\n            name: table,\n            rowCount: countResult?.count ?? 0,\n            diskSize: sizeResult?.size ?? 0,\n          };\n        })\n      );\n\n      // Get total database size\n      const totalSizeResult = this._sqliteDb\n        .prepare<\n          unknown[],\n          { size: number }\n        >(`SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()`)\n        .get();\n\n      // Get WAL file size\n      const walSizeResult = this._sqliteDb\n        .prepare<\n          unknown[],\n          { size: number }\n        >(`SELECT SUM(pgsize) as size FROM dbstat WHERE name LIKE '%-wal'`)\n        .get();\n\n      return {\n        tableStats,\n        totalSize: totalSizeResult?.size ?? 0,\n        walSize: walSizeResult?.size ?? 0,\n      };\n    } catch (error) {\n      logger.error('Failed to get Kysely database stats', { error });\n      throw error;\n    }\n  }\n}\n\n// Export singleton instance\nexport const kyselyDb = KyselyConnection.getInstance();\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/kyselySchema.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/maintenance.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 62,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 62,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1794, 1797], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1794, 1797], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 522,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 522,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15001, 15004], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15001, 15004], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Database maintenance utilities for SQLite optimization and cleanup\n *\n * @module database/maintenance\n * @description This module provides utilities for database maintenance operations\n * including vacuum, analyze, integrity checks, and performance optimization.\n * These operations help maintain database performance and ensure data integrity.\n *\n * @example\n * ```typescript\n * import { MaintenanceManager } from '@/database/maintenance';\n *\n * const maintenance = new MaintenanceManager(dbConnection);\n *\n * // Run full maintenance\n * await maintenance.performFullMaintenance();\n *\n * // Run specific operations\n * await maintenance.vacuum();\n * await maintenance.analyze();\n * ```\n */\n\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection } from './connection';\n\n/**\n * Configuration options for maintenance operations\n */\nexport interface MaintenanceConfig {\n  /** Enable auto-vacuum operations */\n  autoVacuum: boolean;\n  /** Enable auto-analyze operations */\n  autoAnalyze: boolean;\n  /** Vacuum threshold in MB of freed space */\n  vacuumThreshold: number;\n  /** Maximum time in seconds for each operation */\n  operationTimeout: number;\n  /** Enable maintenance logging */\n  enableLogging: boolean;\n}\n\n/**\n * Result of a maintenance operation\n */\nexport interface MaintenanceResult {\n  /** Operation that was performed */\n  operation: string;\n  /** Whether the operation succeeded */\n  success: boolean;\n  /** Duration in milliseconds */\n  duration: number;\n  /** Size before operation in bytes */\n  sizeBefore?: number;\n  /** Size after operation in bytes */\n  sizeAfter?: number;\n  /** Space reclaimed in bytes */\n  spaceReclaimed?: number;\n  /** Error message if operation failed */\n  error?: string;\n  /** Additional details */\n  details?: Record<string, any>;\n}\n\n/**\n * Database maintenance manager for SQLite operations\n *\n * @class MaintenanceManager\n * @description Provides comprehensive database maintenance capabilities including\n * vacuum operations, analyze statistics updates, integrity checks, and automated\n * maintenance scheduling.\n */\nexport class MaintenanceManager {\n  private readonly db: DatabaseConnection;\n\n  private readonly config: MaintenanceConfig;\n\n  constructor(db: DatabaseConnection, config: Partial<MaintenanceConfig> = {}) {\n    this.db = db;\n    this.config = {\n      autoVacuum: true,\n      autoAnalyze: true,\n      vacuumThreshold: 10, // 10MB\n      operationTimeout: 300, // 5 minutes\n      enableLogging: true,\n      ...config,\n    };\n  }\n\n  /**\n   * Perform VACUUM operation to reclaim free space and optimize database\n   *\n   * @param {Object} options - Vacuum options\n   * @param {boolean} [options['incremental'] = false] - Use incremental vacuum\n   * @param {number} [options.pages] - Number of pages to vacuum (incremental only)\n   * @returns {Promise<MaintenanceResult>} Operation result\n   *\n   * @example\n   * ```typescript\n   * // Full vacuum\n   * const result = await maintenance.vacuum();\n   * logger.log(`Reclaimed ${String(String(result.spaceReclaimed))} bytes`);\n   *\n   * // Incremental vacuum\n   * await maintenance.vacuum({ incremental: true, pages: 1000 });\n   * ```\n   */\n  public async vacuum(\n    options: {\n      incremental?: boolean;\n      pages?: number;\n    } = {}\n  ): Promise<MaintenanceResult> {\n    const startTime = Date.now();\n    const operation = options.incremental ? 'incremental_vacuum' : 'vacuum';\n\n    try {\n      if (this.config.enableLogging) {\n        logger.info('Starting vacuum operation', { operation, options });\n      }\n\n      // Get size before vacuum\n      const statsBefore = await this.db.getStats();\n      const sizeBefore = statsBefore.size;\n\n      // Perform vacuum operation\n      if (options.incremental) {\n        const pages = options.pages ?? 1000;\n        await this.db.getDatabase().exec(`PRAGMA incremental_vacuum(${String(pages)})`);\n      } else {\n        await this.db.getDatabase().exec('VACUUM');\n      }\n\n      // Get size after vacuum\n      const statsAfter = await this.db.getStats();\n      const sizeAfter = statsAfter.size;\n      const spaceReclaimed = sizeBefore - sizeAfter;\n      const duration = Date.now() - startTime;\n\n      const result: MaintenanceResult = {\n        operation,\n        success: true,\n        duration,\n        sizeBefore,\n        sizeAfter,\n        spaceReclaimed,\n        details: {\n          pagesFreed: Math.floor(spaceReclaimed / statsAfter.pageSize),\n          percentageReduced:\n            sizeBefore > 0 ? ((spaceReclaimed / sizeBefore) * 100).toFixed(2) : '0',\n        },\n      };\n\n      if (this.config.enableLogging) {\n        logger.info('Vacuum operation completed', {\n          duration: `${String(duration)}ms`,\n          spaceReclaimed: `${String(String((spaceReclaimed / 1024 / 1024).toFixed(2)))}MB`,\n          percentageReduced: `${String(String(result.details?.percentageReduced))}%`,\n        });\n      }\n\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const result: MaintenanceResult = {\n        operation,\n        success: false,\n        duration,\n        error: (error as Error).message,\n      };\n\n      if (this.config.enableLogging) {\n        logger.error('Vacuum operation failed', {\n          operation,\n          duration: `${String(duration)}ms`,\n          error: (error as Error).message,\n        });\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Perform ANALYZE operation to update query planner statistics\n   *\n   * @param {Object} options - Analyze options\n   * @param {string[]} [options.tables] - Specific tables to analyze (default: all)\n   * @returns {Promise<MaintenanceResult>} Operation result\n   *\n   * @example\n   * ```typescript\n   * // Analyze all tables\n   * await maintenance.analyze();\n   *\n   * // Analyze specific tables\n   * await maintenance.analyze({ tables: ['tasks', 'boards'] });\n   * ```\n   */\n  public async analyze(\n    options: {\n      tables?: string[];\n    } = {}\n  ): Promise<MaintenanceResult> {\n    const startTime = Date.now();\n    const operation = 'analyze';\n\n    try {\n      if (this.config.enableLogging) {\n        logger.info('Starting analyze operation', { options });\n      }\n\n      const tables = options.tables ?? (await this.getAllTableNames());\n      const analyzedTables: string[] = [];\n\n      await Promise.all(\n        tables.map(async table => {\n          await this.db.getDatabase().exec(`ANALYZE ${String(table)}`);\n        })\n      );\n\n      // Update general statistics\n      await this.db.getDatabase().exec('ANALYZE');\n\n      const duration = Date.now() - startTime;\n      const result: MaintenanceResult = {\n        operation,\n        success: true,\n        duration,\n        details: {\n          tablesAnalyzed: analyzedTables,\n          totalTables: tables.length,\n          successRate: `${String(String(((analyzedTables.length / tables.length) * 100).toFixed(1)))}%`,\n        },\n      };\n\n      if (this.config.enableLogging) {\n        logger.info('Analyze operation completed', {\n          duration: `${String(duration)}ms`,\n          tablesAnalyzed: analyzedTables.length,\n          totalTables: tables.length,\n        });\n      }\n\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const result: MaintenanceResult = {\n        operation,\n        success: false,\n        duration,\n        error: (error as Error).message,\n      };\n\n      if (this.config.enableLogging) {\n        logger.error('Analyze operation failed', {\n          duration: `${String(duration)}ms`,\n          error: (error as Error).message,\n        });\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Optimize database by running PRAGMA optimize\n   *\n   * @returns {Promise<MaintenanceResult>} Operation result\n   *\n   * @example\n   * ```typescript\n   * const result = await maintenance.optimize();\n   * logger.log('Optimization completed:', result.success);\n   * ```\n   */\n  public async optimize(): Promise<MaintenanceResult> {\n    const startTime = Date.now();\n    const operation = 'optimize';\n\n    try {\n      if (this.config.enableLogging) {\n        logger.info('Starting optimization operation');\n      }\n\n      // Run SQLite optimization\n      await this.db.getDatabase().exec('PRAGMA optimize');\n\n      const duration = Date.now() - startTime;\n      const result: MaintenanceResult = {\n        operation,\n        success: true,\n        duration,\n        details: {\n          optimizations: 'Query planner optimizations applied',\n        },\n      };\n\n      if (this.config.enableLogging) {\n        logger.info('Optimization operation completed', {\n          duration: `${String(duration)}ms`,\n        });\n      }\n\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const result: MaintenanceResult = {\n        operation,\n        success: false,\n        duration,\n        error: (error as Error).message,\n      };\n\n      if (this.config.enableLogging) {\n        logger.error('Optimization operation failed', {\n          duration: `${String(duration)}ms`,\n          error: (error as Error).message,\n        });\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Check and defragment WAL file if needed\n   *\n   * @returns {Promise<MaintenanceResult>} Operation result\n   *\n   * @example\n   * ```typescript\n   * const result = await maintenance.checkpointWal();\n   * logger.log('WAL checkpoint completed:', result.success);\n   * ```\n   */\n  public async checkpointWal(): Promise<MaintenanceResult> {\n    const startTime = Date.now();\n    const operation = 'wal_checkpoint';\n\n    try {\n      if (this.config.enableLogging) {\n        logger.info('Starting WAL checkpoint operation');\n      }\n\n      // Check if WAL mode is enabled\n      const walMode = await this.db.queryOne<{ journal_mode: string }>('PRAGMA journal_mode');\n      if (walMode?.journal_mode !== 'wal') {\n        return {\n          operation,\n          success: true,\n          duration: Date.now() - startTime,\n          details: {\n            message: 'WAL mode not enabled, checkpoint not needed',\n          },\n        };\n      }\n\n      // Perform WAL checkpoint\n      const checkpointResult = await this.db.queryOne<{\n        busy: number;\n        log: number;\n        checkpointed: number;\n      }>('PRAGMA wal_checkpoint(TRUNCATE)');\n\n      const duration = Date.now() - startTime;\n      const result: MaintenanceResult = {\n        operation,\n        success: true,\n        duration,\n        details: {\n          pagesCheckpointed: checkpointResult?.checkpointed ?? 0,\n          logPages: checkpointResult?.log ?? 0,\n          busyPages: checkpointResult?.busy ?? 0,\n        },\n      };\n\n      if (this.config.enableLogging) {\n        logger.info('WAL checkpoint completed', {\n          duration: `${String(duration)}ms`,\n          pagesCheckpointed: checkpointResult?.checkpointed,\n          logPages: checkpointResult?.log,\n        });\n      }\n\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const result: MaintenanceResult = {\n        operation,\n        success: false,\n        duration,\n        error: (error as Error).message,\n      };\n\n      if (this.config.enableLogging) {\n        logger.error('WAL checkpoint failed', {\n          duration: `${String(duration)}ms`,\n          error: (error as Error).message,\n        });\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * Perform comprehensive database maintenance\n   *\n   * @param {Object} options - Maintenance options\n   * @param {boolean} [options['includeVacuum'] = true] - Include vacuum operation\n   * @param {boolean} [options.includeAnalyze=true] - Include analyze operation\n   * @param {boolean} [options.includeOptimize=true] - Include optimize operation\n   * @param {boolean} [options.includeWalCheckpoint=true] - Include WAL checkpoint\n   * @returns {Promise<MaintenanceResult[]>} Array of operation results\n   *\n   * @example\n   * ```typescript\n   * // Full maintenance\n   * const results = await maintenance.performFullMaintenance();\n   * const successful = results.filter(r => r.success).length;\n   * logger.log(`${String(successful)}/${String(String(results.length))} operations successful`);\n   *\n   * // Selective maintenance\n   * const results = await maintenance.performFullMaintenance({\n   *   includeVacuum: false,\n   *   includeAnalyze: true\n   * });\n   * ```\n   */\n  public async performFullMaintenance(\n    options: {\n      includeVacuum?: boolean;\n      includeAnalyze?: boolean;\n      includeOptimize?: boolean;\n      includeWalCheckpoint?: boolean;\n    } = {}\n  ): Promise<MaintenanceResult[]> {\n    const {\n      includeVacuum = true,\n      includeAnalyze = true,\n      includeOptimize = true,\n      includeWalCheckpoint = true,\n    } = options;\n\n    const results: MaintenanceResult[] = [];\n    const startTime = Date.now();\n\n    if (this.config.enableLogging) {\n      logger.info('Starting full database maintenance', {\n        includeVacuum,\n        includeAnalyze,\n        includeOptimize,\n        includeWalCheckpoint,\n      });\n    }\n\n    try {\n      // WAL checkpoint first (if enabled)\n      if (includeWalCheckpoint) {\n        const walResult = await this.checkpointWal();\n        results.push(walResult);\n      }\n\n      // Analyze statistics (before vacuum for better planning)\n      if (includeAnalyze) {\n        const analyzeResult = await this.analyze();\n        results.push(analyzeResult);\n      }\n\n      // Vacuum (space reclamation)\n      if (includeVacuum) {\n        const vacuumResult = await this.vacuum();\n        results.push(vacuumResult);\n      }\n\n      // Optimize (query planner updates)\n      if (includeOptimize) {\n        const optimizeResult = await this.optimize();\n        results.push(optimizeResult);\n      }\n\n      const totalDuration = Date.now() - startTime;\n      const successful = results.filter(r => r.success).length;\n      const failed = results.length - successful;\n\n      if (this.config.enableLogging) {\n        logger.info('Full database maintenance completed', {\n          totalDuration: `${String(totalDuration)}ms`,\n          operationsRun: results.length,\n          successful,\n          failed,\n          operations: results.map(r => ({ operation: r.operation, success: r.success })),\n        });\n      }\n\n      return results;\n    } catch (error) {\n      if (this.config.enableLogging) {\n        logger.error('Full database maintenance failed', {\n          error: (error as Error).message,\n          completedOperations: results.length,\n        });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get maintenance recommendations based on database statistics\n   *\n   * @returns {Promise<{recommendations: string[], stats: any}>} Maintenance recommendations\n   *\n   * @example\n   * ```typescript\n   * const { recommendations, stats } = await maintenance.getRecommendations();\n   * recommendations.forEach(rec => logger.log('Recommendation:', rec));\n   * ```\n   */\n  public async getRecommendations(): Promise<{\n    recommendations: string[];\n    stats: any;\n  }> {\n    const stats = await this.db.getStats();\n    const recommendations: string[] = [];\n\n    // Check database size\n    const sizeMB = stats.size / 1024 / 1024;\n    if (sizeMB > 100) {\n      recommendations.push('Database is large (>100MB). Consider running VACUUM to reclaim space.');\n    }\n\n    // Check page count vs optimal\n    const optimalPages = Math.ceil(stats.size / 4096); // 4KB pages\n    if (stats.pageCount > optimalPages * 1.2) {\n      recommendations.push('Database may be fragmented. VACUUM recommended.');\n    }\n\n    // Check if WAL mode checkpoint is needed\n    try {\n      const walMode = await this.db.queryOne<{ journal_mode: string }>('PRAGMA journal_mode');\n      if (walMode?.journal_mode === 'wal') {\n        const walInfo = await this.db.queryOne<{ wal_size: number }>(\n          'PRAGMA wal_checkpoint(PASSIVE)'\n        );\n        if (walInfo && walInfo.wal_size > 1000) {\n          recommendations.push('WAL file is large. Consider running WAL checkpoint.');\n        }\n      }\n    } catch {\n      // WAL info not available, skip recommendation\n    }\n\n    // Check for missing analyze\n    try {\n      const lastAnalyze = await this.db.queryOne<{ value: string }>(`\n        SELECT value FROM pragma_stats WHERE name = 'analyze_last_run'\n      `);\n\n      if (!lastAnalyze) {\n        recommendations.push('Statistics may be outdated. Run ANALYZE to update query planner.');\n      }\n    } catch {\n      recommendations.push('Statistics status unknown. Consider running ANALYZE.');\n    }\n\n    // General recommendations\n    if (recommendations.length === 0) {\n      recommendations.push(\n        'Database appears to be in good condition. Regular maintenance recommended.'\n      );\n    }\n\n    return {\n      recommendations,\n      stats: {\n        sizeMB: parseFloat(sizeMB.toFixed(2)),\n        pageCount: stats.pageCount,\n        pageSize: stats.pageSize,\n        walMode: stats.walMode,\n        tables: stats.tables,\n      },\n    };\n  }\n\n  /**\n   * Get all table names in the database\n   *\n   * @private\n   * @returns {Promise<string[]>} Array of table names\n   */\n  private async getAllTableNames(): Promise<string[]> {\n    const tables = await this.db.query<{ name: string }>(`\n      SELECT name FROM sqlite_master \n      WHERE type = 'table' \n      AND name NOT LIKE 'sqlite_%'\n      ORDER BY name\n    `);\n\n    return tables.map(table => table.name);\n  }\n}\n\n/**\n * Create a maintenance manager instance with database connection\n *\n * @param {DatabaseConnection} db - Database connection instance\n * @param {Partial<MaintenanceConfig>} [config] - Optional configuration\n * @returns {MaintenanceManager} Configured maintenance manager\n *\n * @example\n * ```typescript\n * import { dbConnection } from '@/database/connection';\n * import { createMaintenanceManager } from '@/database/maintenance';\n *\n * const maintenance = createMaintenanceManager(dbConnection, {\n *   autoVacuum: true,\n *   vacuumThreshold: 20 // 20MB threshold\n * });\n * ```\n */\nexport function createMaintenanceManager(\n  db: DatabaseConnection,\n  config?: Partial<MaintenanceConfig>\n): MaintenanceManager {\n  return new MaintenanceManager(db, config);\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/migrations/001_initial_schema.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/migrations/MigrationRunner.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 119,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 119,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 120,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 120,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .default on an `any` value.",
        "line": 120,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 120,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .up on an `any` value.",
        "line": 122,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 122,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .down on an `any` value.",
        "line": 122,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 122,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 130,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 130,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .up on an `any` value.",
        "line": 130,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 130,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 131,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 131,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .down on an `any` value.",
        "line": 131,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 131,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 179,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 179,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"unknown\" of template literal expression.",
        "line": 234,
        "column": 69,
        "nodeType": "Identifier",
        "messageId": "invalidType",
        "endLine": 234,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 280,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 280,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8202, 8205], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8202, 8205], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 281,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 281,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8225, 8228], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8225, 8228], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'calculateChecksum'.",
        "line": 321,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 321,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Database } from 'sqlite3';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { promisify } from 'util';\nimport { logger } from '../../utils/logger';\nimport type { Migration, MigrationFile, AppliedMigration, MigrationOptions } from './types';\n\nexport class MigrationRunner {\n  private readonly db: Database;\n\n  private readonly migrationsPath: string;\n\n  private readonly tableName: string;\n\n  private readonly validateChecksums: boolean;\n\n  constructor(db: Database, options: MigrationOptions = {}) {\n    this.db = db;\n    this.migrationsPath = options.migrationsPath ?? path.join(__dirname, '.');\n    this.tableName = options.tableName ?? 'schema_migrations';\n    this.validateChecksums = options.validateChecksums !== false;\n  }\n\n  /**\n   * Initialize the migrations table\n   */\n  async initialize(): Promise<void> {\n    const run = promisify(this.db.run.bind(this.db));\n\n    await run(`\n      CREATE TABLE IF NOT EXISTS ${this.tableName} (\n        id TEXT PRIMARY KEY,\n        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        checksum TEXT NOT NULL\n      )\n    `);\n\n    logger.info('Migration table initialized');\n  }\n\n  /**\n   * Get all applied migrations\n   */\n  async getAppliedMigrations(): Promise<AppliedMigration[]> {\n    const all = promisify(this.db.all.bind(this.db));\n\n    const result = (await all(\n      `SELECT id, applied_at, checksum FROM ${this.tableName} ORDER BY id`\n    )) as AppliedMigration[];\n\n    return result ?? [];\n  }\n\n  /**\n   * Get all migration files from the migrations directory\n   */\n  async getMigrationFiles(): Promise<MigrationFile[]> {\n    try {\n      const files = await fs.readdir(this.migrationsPath);\n\n      const migrationFilePromises = files\n        .filter(\n          file => file.endsWith('.ts') && file !== 'types.ts' && file !== 'MigrationRunner.ts'\n        )\n        .map(async file => {\n          const filePath = path.join(this.migrationsPath, file);\n          const content = await fs.readFile(filePath, 'utf-8');\n\n          // Extract migration info from filename (e.g., 001_create_initial_schema.ts)\n          const match = file.match(/^(\\d{3})_(.+)\\.ts$/);\n          if (!match) {\n            logger.warn(`Skipping invalid migration filename: ${file}`);\n            return null;\n          }\n\n          const [, number, description] = match;\n          if (!number || !description) {\n            logger.warn(`Invalid migration filename format: ${file}`);\n            return null;\n          }\n\n          const id = `${number}_${description}`;\n          const checksum = this.calculateChecksum(content);\n\n          return {\n            id,\n            timestamp: parseInt(number, 10),\n            description: description.replace(/_/g, ' '),\n            checksum,\n            up: '', // Will be loaded dynamically\n            down: '', // Will be loaded dynamically\n          };\n        });\n\n      const migrationResults = await Promise.all(migrationFilePromises);\n      const migrationFiles = migrationResults.filter(\n        (file): file is MigrationFile => file !== null\n      );\n\n      return migrationFiles.sort((a, b) => a.timestamp - b.timestamp);\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        logger.warn(`Migrations directory not found: ${this.migrationsPath}`);\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Load a migration module dynamically\n   */\n  async loadMigration(file: MigrationFile): Promise<Migration> {\n    const filename = `${file.id}.ts`;\n    const filePath = path.join(this.migrationsPath, filename);\n\n    // Dynamic import of the migration file\n    const migrationModule = await import(filePath);\n    const migration = migrationModule.default ?? migrationModule;\n\n    if (!migration.up || !migration.down) {\n      throw new Error(`Migration ${file.id} must export 'up' and 'down' functions`);\n    }\n\n    return {\n      id: file.id,\n      timestamp: file.timestamp,\n      description: file.description,\n      up: migration.up,\n      down: migration.down,\n    };\n  }\n\n  /**\n   * Run pending migrations\n   */\n  async up(target?: string): Promise<number> {\n    await this.initialize();\n\n    const applied = await this.getAppliedMigrations();\n    const appliedIds = new Set(applied.map(m => m.id));\n    const files = await this.getMigrationFiles();\n\n    let migrationsRun = 0;\n\n    for (const file of files) {\n      if (appliedIds.has(file.id)) {\n        // Validate checksum if enabled\n        if (this.validateChecksums) {\n          const appliedMigration = applied.find(m => m.id === file.id);\n          if (appliedMigration && appliedMigration.checksum !== file.checksum) {\n            throw new Error(\n              `Migration ${file.id} has been modified after being applied. ` +\n                `Expected checksum: ${appliedMigration.checksum}, ` +\n                `Current checksum: ${file.checksum}`\n            );\n          }\n        }\n        continue;\n      }\n\n      if (target && file.id > target) {\n        break;\n      }\n\n      logger.info(`Running migration: ${file.id} - ${file.description}`);\n\n      // eslint-disable-next-line no-await-in-loop\n      const migration = await this.loadMigration(file);\n\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        await this.runMigration(migration, file.checksum, 'up');\n        migrationsRun++;\n        logger.info(`Migration ${file.id} completed successfully`);\n      } catch (error) {\n        logger.error(`Migration ${file.id} failed:`, error);\n        throw new Error(`Migration ${file.id} failed: ${error}`);\n      }\n    }\n\n    if (migrationsRun === 0) {\n      logger.info('No pending migrations');\n    } else {\n      logger.info(`Successfully ran ${migrationsRun} migration(s)`);\n    }\n\n    return migrationsRun;\n  }\n\n  /**\n   * Rollback migrations\n   */\n  async down(target?: string): Promise<number> {\n    await this.initialize();\n\n    const applied = await this.getAppliedMigrations();\n    const files = await this.getMigrationFiles();\n    const fileMap = new Map(files.map(f => [f.id, f]));\n\n    let migrationsRolledBack = 0;\n\n    // Process in reverse order\n    for (let i = applied.length - 1; i >= 0; i--) {\n      const appliedMigration = applied[i];\n      if (!appliedMigration) {\n        continue;\n      }\n\n      if (target && appliedMigration.id <= target) {\n        break;\n      }\n\n      const file = fileMap.get(appliedMigration.id);\n      if (!file) {\n        throw new Error(\n          `Cannot rollback migration ${appliedMigration.id}: migration file not found`\n        );\n      }\n\n      logger.info(`Rolling back migration: ${file.id} - ${file.description}`);\n\n      // eslint-disable-next-line no-await-in-loop\n      const migration = await this.loadMigration(file);\n\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        await this.rollbackMigration(migration);\n        migrationsRolledBack++;\n        logger.info(`Migration ${file.id} rolled back successfully`);\n      } catch (error) {\n        logger.error(`Rollback of migration ${file.id} failed:`, error);\n        throw new Error(`Rollback of migration ${file.id} failed: ${error}`);\n      }\n    }\n\n    if (migrationsRolledBack === 0) {\n      logger.info('No migrations to rollback');\n    } else {\n      logger.info(`Successfully rolled back ${migrationsRolledBack} migration(s)`);\n    }\n\n    return migrationsRolledBack;\n  }\n\n  /**\n   * Get migration status\n   */\n  async status(): Promise<{\n    applied: string[];\n    pending: string[];\n    total: number;\n  }> {\n    await this.initialize();\n\n    const applied = await this.getAppliedMigrations();\n    const appliedIds = new Set(applied.map(m => m.id));\n    const files = await this.getMigrationFiles();\n\n    const pending = files.filter(f => !appliedIds.has(f.id)).map(f => f.id);\n\n    return {\n      applied: applied.map(m => m.id),\n      pending,\n      total: files.length,\n    };\n  }\n\n  /**\n   * Run a single migration\n   */\n  private async runMigration(\n    migration: Migration,\n    checksum: string,\n    direction: 'up' | 'down'\n  ): Promise<void> {\n    const run = promisify(this.db.run.bind(this.db)) as (\n      sql: string,\n      ...params: any[]\n    ) => Promise<any>;\n\n    // Start transaction\n    await run('BEGIN TRANSACTION');\n\n    try {\n      // Run the migration\n      await migration[direction](this.db);\n\n      if (direction === 'up') {\n        // Record the migration\n        await run(\n          `INSERT INTO ${this.tableName} (id, checksum) VALUES (?, ?)`,\n          migration.id,\n          checksum\n        );\n      } else {\n        // Remove the migration record\n        await run(`DELETE FROM ${this.tableName} WHERE id = ?`, migration.id);\n      }\n\n      // Commit transaction\n      await run('COMMIT');\n    } catch (error) {\n      // Rollback on error\n      await run('ROLLBACK');\n      throw error;\n    }\n  }\n\n  /**\n   * Rollback a single migration\n   */\n  private async rollbackMigration(migration: Migration): Promise<void> {\n    await this.runMigration(migration, '', 'down');\n  }\n\n  /**\n   * Calculate checksum for a file content\n   */\n  private calculateChecksum(content: string): string {\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  /**\n   * Create a new migration file\n   */\n  static async createMigration(name: string, migrationsPath: string): Promise<string> {\n    const timestamp = Date.now();\n    const number = String(Math.floor(timestamp / 1000))\n      .slice(-3)\n      .padStart(3, '0');\n    const filename = `${number}_${name.replace(/\\s+/g, '_').toLowerCase()}.ts`;\n    const filePath = path.join(migrationsPath, filename);\n\n    const template = `import { Database } from 'sqlite3';\nimport { promisify } from 'util';\n\nexport async function up(db: Database): Promise<void> {\n  const run = promisify(db.run.bind(db));\n  \n  // Add your migration logic here\n  // Example:\n  // await run(\\`\n  //   CREATE TABLE example (\n  //     id INTEGER PRIMARY KEY AUTOINCREMENT,\n  //     name TEXT NOT NULL\n  //   )\n  // \\`);\n}\n\nexport async function down(db: Database): Promise<void> {\n  const run = promisify(db.run.bind(db));\n  \n  // Add your rollback logic here\n  // Example:\n  // await run('DROP TABLE IF EXISTS example');\n}\n`;\n\n    await fs.writeFile(filePath, template);\n    logger.info(`Created migration: ${filename}`);\n\n    return filename;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/migrations/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/migrations/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/schema.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 154,
        "column": 30,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 154,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [4477, 4482], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 241,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 241,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 261,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 261,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 276,
        "column": 81,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 276,
        "endColumn": 85
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 287,
        "column": 77,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 287,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 297,
        "column": 75,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 297,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 308,
        "column": 80,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 308,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 350,
        "column": 79,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 350,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 373,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 373,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11116, 11119], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11116, 11119], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 387,
        "column": 87,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 387,
        "endColumn": 91
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 487,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 489,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 490,
        "column": 7,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 490,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .value on an `any` value.",
        "line": 490,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 490,
        "endColumn": 27
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'getExpectedSchema'.",
        "line": 496,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 496,
        "endColumn": 28
      },
      {
        "ruleId": "default-case",
        "severity": 2,
        "message": "Expected a default case.",
        "line": 531,
        "column": 7,
        "nodeType": "SwitchStatement",
        "messageId": "missingDefaultCase",
        "endLine": 544,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 531,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 531,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 533,
        "column": 30,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 533,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 533,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 533,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 536,
        "column": 31,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 536,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 536,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 536,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 539,
        "column": 29,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 539,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 539,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 539,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 542,
        "column": 32,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 542,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 542,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 542,
        "endColumn": 40
      },
      {
        "ruleId": "no-cond-assign",
        "severity": 2,
        "message": "Unexpected assignment within a 'while' statement.",
        "line": 558,
        "column": 13,
        "nodeType": "AssignmentExpression",
        "messageId": "unexpected",
        "endLine": 558,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 8,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Database schema management module\n * Handles schema creation, validation, and maintenance\n *\n * @module database/schema\n * @description This module manages the SQLite database schema lifecycle including\n * creation, validation, migrations, and maintenance operations. It ensures the database\n * structure matches the application requirements and handles schema versioning.\n *\n * @example\n * ```typescript\n * import { dbConnection } from '@/database/connection';\n *\n * const schemaManager = dbConnection.getSchemaManager();\n *\n * // Create schema\n * await schemaManager.createSchema();\n *\n * // Validate schema\n * const validation = await schemaManager.validateSchema();\n * if (!validation.isValid) {\n *   logger.error('Schema issues:', validation.errors);\n * }\n * ```\n */\n\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection } from './connection';\n\n/**\n * Information about the current database schema\n *\n * @interface SchemaInfo\n * @property {string} version - Current schema version\n * @property {string[]} tables - List of table names\n * @property {string[]} indexes - List of index names\n * @property {string[]} views - List of view names\n * @property {string[]} triggers - List of trigger names\n */\nexport interface SchemaInfo {\n  version: string;\n  tables: string[];\n  indexes: string[];\n  views: string[];\n  triggers: string[];\n}\n\n/**\n * Result of schema validation check\n *\n * @interface SchemaValidationResult\n * @property {boolean} isValid - Whether schema is valid\n * @property {string[]} missingTables - Tables that should exist but don't\n * @property {string[]} missingIndexes - Indexes that should exist but don't\n * @property {string[]} missingViews - Views that should exist but don't\n * @property {string[]} errors - Validation error messages\n */\nexport interface SchemaValidationResult {\n  isValid: boolean;\n  missingTables: string[];\n  missingIndexes: string[];\n  missingViews: string[];\n  errors: string[];\n}\n\n/**\n * Manages database schema operations\n *\n * @class SchemaManager\n * @description Handles schema creation from SQL files, validation of existing schema,\n * version tracking, and schema maintenance operations like dropping and recreation.\n *\n * @example\n * ```typescript\n * const manager = new SchemaManager(dbConnection);\n *\n * // Check if schema exists\n * if (!await manager.schemaExists()) {\n *   await manager.createSchema();\n * }\n *\n * // Get schema information\n * const info = await manager.getSchemaInfo();\n * logger.log('Tables:', info.tables.join(', '));\n * ```\n */\nexport class SchemaManager {\n  private static readonly SCHEMA_VERSION = '1.0.0';\n\n  private static readonly SCHEMA_FILE = join(__dirname, 'schema.sql');\n\n  private readonly db: DatabaseConnection;\n\n  constructor(dbConnection: DatabaseConnection) {\n    this.db = dbConnection;\n  }\n\n  /**\n   * Create the complete database schema from SQL file\n   *\n   * @returns {Promise<void>}\n   * @throws {Error} If schema creation fails\n   *\n   * @example\n   * ```typescript\n   * await schemaManager.createSchema();\n   * logger.log('Schema created successfully');\n   * ```\n   */\n  async createSchema(): Promise<void> {\n    logger.info('Creating database schema...');\n\n    try {\n      const schemaSQL = SchemaManager.readSchemaFile();\n\n      await this.db.transaction(async database => {\n        // Execute the entire schema file at once\n        await database.exec(schemaSQL);\n\n        // Create schema info record\n        await this.createSchemaInfoTable();\n        await this.recordSchemaVersion();\n      });\n\n      logger.info('Database schema created successfully');\n    } catch (error) {\n      logger.error('Failed to create database schema:', error);\n      throw new Error(\n        `Schema creation failed: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n      );\n    }\n  }\n\n  /**\n   * Validate the current database schema against expected structure\n   *\n   * @returns {Promise<SchemaValidationResult>} Validation result with details\n   *\n   * @example\n   * ```typescript\n   * const result = await schemaManager.validateSchema();\n   * if (!result.isValid) {\n   *   logger.error('Missing tables:', result.missingTables);\n   *   logger.error('Missing indexes:', result.missingIndexes);\n   * }\n   * ```\n   */\n  async validateSchema(): Promise<SchemaValidationResult> {\n    logger.info('Validating database schema...');\n\n    try {\n      const expectedSchema = await this.getExpectedSchema();\n      const currentSchema = await this.getCurrentSchema();\n\n      const result: SchemaValidationResult = {\n        isValid: true,\n        missingTables: [],\n        missingIndexes: [],\n        missingViews: [],\n        errors: [],\n      };\n\n      // Check tables\n      for (const table of expectedSchema.tables) {\n        if (!currentSchema.tables.includes(table)) {\n          result.missingTables.push(table);\n          result.isValid = false;\n        }\n      }\n\n      // Check indexes\n      for (const index of expectedSchema.indexes) {\n        if (!currentSchema.indexes.includes(index)) {\n          result.missingIndexes.push(index);\n          result.isValid = false;\n        }\n      }\n\n      // Check views\n      for (const view of expectedSchema.views) {\n        if (!currentSchema.views.includes(view)) {\n          result.missingViews.push(view);\n          result.isValid = false;\n        }\n      }\n\n      // Check schema version\n      const currentVersion = await this.getCurrentSchemaVersion();\n      if (currentVersion !== SchemaManager.SCHEMA_VERSION) {\n        result.errors.push(\n          `Schema version mismatch: expected ${String(String(SchemaManager.SCHEMA_VERSION))}, got ${String(currentVersion)}`\n        );\n        result.isValid = false;\n      }\n\n      logger.info(`Schema validation completed. Valid: ${String(String(result.isValid))}`);\n      return result;\n    } catch (error) {\n      logger.error('Schema validation failed:', error);\n      return {\n        isValid: false,\n        missingTables: [],\n        missingIndexes: [],\n        missingViews: [],\n        errors: [error instanceof Error ? error.message : 'Unknown validation error'],\n      };\n    }\n  }\n\n  /**\n   * Get schema information from the database\n   */\n  async getSchemaInfo(): Promise<SchemaInfo> {\n    const currentSchema = await this.getCurrentSchema();\n    const version = await this.getCurrentSchemaVersion();\n\n    return {\n      version,\n      tables: currentSchema.tables,\n      indexes: currentSchema.indexes,\n      views: currentSchema.views,\n      triggers: currentSchema.triggers,\n    };\n  }\n\n  /**\n   * Check if schema exists\n   */\n  async schemaExists(): Promise<boolean> {\n    try {\n      // Check for multiple core tables to ensure schema really exists\n      const tables = await this.db.query(`\n        SELECT COUNT(*) as count FROM sqlite_master \n        WHERE type='table' \n        AND name IN ('boards', 'tasks', 'columns', 'notes', 'tags')\n        AND name NOT LIKE 'sqlite_%'\n      `);\n      // Consider schema exists if we have at least 3 of the core tables\n      return tables[0]?.count >= 3;\n    } catch (error) {\n      logger.error('Error checking schema existence:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Drop all schema objects (for testing/reset)\n   */\n  async dropSchema(): Promise<void> {\n    logger.warn('Dropping database schema...');\n\n    try {\n      // First check if any schema exists\n      const tables = await this.db.query(`\n        SELECT COUNT(*) as count FROM sqlite_master \n        WHERE type='table' AND name NOT LIKE 'sqlite_%'\n      `);\n\n      if (!tables || tables[0]?.count === 0) {\n        logger.info('No schema to drop');\n        return;\n      }\n\n      await this.db.transaction(async database => {\n        // First, disable foreign key constraints to allow dropping in any order\n        await database.run('PRAGMA foreign_keys = OFF');\n\n        // Drop all triggers first\n        const triggers = await database.all(`\n          SELECT name FROM sqlite_master WHERE type='trigger'\n        `);\n        await Promise.all(\n          triggers.map(async trigger => {\n            await database.run(`DROP TRIGGER IF EXISTS \"${String(String(trigger.name))}\"`);\n          })\n        );\n\n        // Drop all indexes\n        const indexes = await database.all(`\n          SELECT name FROM sqlite_master \n          WHERE type='index' AND name NOT LIKE 'sqlite_%'\n        `);\n        await Promise.all(\n          indexes.map(async index => {\n            await database.run(`DROP INDEX IF EXISTS \"${String(String(index.name))}\"`);\n          })\n        );\n\n        // Drop all views\n        const views = await database.all(`\n          SELECT name FROM sqlite_master WHERE type='view'\n        `);\n        await Promise.all(\n          views.map(async view => {\n            await database.run(`DROP VIEW IF EXISTS \"${String(String(view.name))}\"`);\n          })\n        );\n\n        // Drop FTS virtual tables first\n        const ftsTables = await database.all(`\n          SELECT name FROM sqlite_master \n          WHERE type='table' AND name LIKE '%_fts' AND name NOT LIKE '%_fts_%'\n        `);\n        await Promise.all(\n          ftsTables.map(async ftsTable => {\n            await database.run(`DROP TABLE IF EXISTS \"${String(String(ftsTable.name))}\"`);\n          })\n        );\n\n        // Get tables in dependency order (reverse of creation order)\n        const tableOrder = [\n          'backup_metadata',\n          'context_analytics',\n          'repository_mappings',\n          'task_tags',\n          'tags',\n          'notes',\n          'task_dependencies',\n          'task_progress',\n          'tasks',\n          'columns',\n          'boards',\n          'schema_info',\n        ];\n\n        // Drop tables in specific order\n        try {\n          await Promise.all(\n            tableOrder.map(async tableName => {\n              await database.run(`DROP TABLE IF EXISTS \"${String(tableName)}\"`);\n            })\n          );\n        } catch (e) {\n          logger.debug('Failed to drop tables:', e);\n        }\n\n        // Drop any remaining tables\n        const remainingTables = await database.all(`\n          SELECT name FROM sqlite_master \n          WHERE type='table' \n          AND name NOT LIKE 'sqlite_%'\n          AND name NOT LIKE '%_fts%'\n        `);\n\n        try {\n          await Promise.all(\n            remainingTables.map(async table => {\n              await database.run(`DROP TABLE IF EXISTS \"${String(String(table.name))}\"`);\n            })\n          );\n        } catch (e) {\n          logger.debug('Failed to drop remaining tables:', e);\n        }\n\n        // Re-enable foreign key constraints\n        await database.run('PRAGMA foreign_keys = ON');\n      });\n\n      logger.info('Database schema dropped successfully');\n    } catch (error) {\n      logger.error('Failed to drop database schema:', error);\n      throw new Error(\n        `Schema drop failed: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n      );\n    }\n  }\n\n  /**\n   * Get database statistics\n   */\n  async getDatabaseStats(): Promise<Record<string, any>> {\n    try {\n      const stats = await this.db.getStats();\n\n      // Get table row counts\n      const tables = await this.db.query(`\n        SELECT name FROM sqlite_master \n        WHERE type='table' AND name NOT LIKE 'sqlite_%'\n        ORDER BY name\n      `);\n\n      const tableCounts: Record<string, number> = {};\n      await Promise.all(\n        tables.map(async table => {\n          await this.db.queryOne(`SELECT COUNT(*) as count FROM ${String(String(table.name))}`);\n        })\n      );\n\n      return {\n        ...stats,\n        tableCounts,\n        totalRecords: Object.values(tableCounts).reduce((sum, count) => sum + count, 0),\n      };\n    } catch (error) {\n      logger.error('Error getting database statistics:', error);\n      throw error;\n    }\n  }\n\n  // Private helper methods\n\n  private static readSchemaFile(): string {\n    try {\n      return readFileSync(SchemaManager.SCHEMA_FILE, 'utf-8');\n    } catch (error) {\n      throw new Error(\n        `Failed to read schema file: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`\n      );\n    }\n  }\n\n  private static parseSchemaStatements(schemaSQL: string): string[] {\n    // Remove comments but preserve line structure for better debugging\n    const cleanSQL = schemaSQL\n      .replace(/--.*$/gm, '') // Remove line comments\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, ''); // Remove block comments\n\n    // Split statements more intelligently\n    const statements = [];\n    let currentStatement = '';\n    let inQuotes = false;\n    let quoteChar = '';\n\n    const lines = cleanSQL.split('\\n');\n\n    for (const line of lines) {\n      const trimmedLine = line.trim();\n\n      // Skip empty lines\n      if (!trimmedLine) continue;\n\n      // Check for quote boundaries\n      for (let i = 0; i < trimmedLine.length; i++) {\n        const char = trimmedLine[i];\n\n        if (!inQuotes && (char === \"'\" || char === '\"')) {\n          inQuotes = true;\n          quoteChar = char;\n        } else if (inQuotes && char === quoteChar) {\n          inQuotes = false;\n          quoteChar = '';\n        }\n      }\n\n      currentStatement += `${line}\\n`;\n\n      // If we're not in quotes and the line ends with semicolon, it's a complete statement\n      if (!inQuotes && trimmedLine.endsWith(';')) {\n        statements.push(currentStatement.trim());\n        currentStatement = '';\n      }\n    }\n\n    // Add any remaining statement\n    if (currentStatement.trim()) {\n      statements.push(currentStatement.trim());\n    }\n\n    return statements;\n  }\n\n  private async createSchemaInfoTable(): Promise<void> {\n    await this.db.execute(`\n      CREATE TABLE IF NOT EXISTS schema_info (\n        key TEXT PRIMARY KEY,\n        value TEXT NOT NULL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n  }\n\n  private async recordSchemaVersion(): Promise<void> {\n    await this.db.execute(\n      `\n      INSERT OR REPLACE INTO schema_info (key, value, updated_at)\n      VALUES ('version', ?, CURRENT_TIMESTAMP)\n    `,\n      [SchemaManager.SCHEMA_VERSION]\n    );\n  }\n\n  private async getCurrentSchemaVersion(): Promise<string> {\n    try {\n      const result = await this.db.queryOne(`\n        SELECT value FROM schema_info WHERE key = 'version'\n      `);\n      return result?.value ?? 'unknown';\n    } catch (error) {\n      return 'unknown';\n    }\n  }\n\n  private getExpectedSchema(): SchemaInfo {\n    // Parse the schema file to extract expected objects\n    const schemaSQL = SchemaManager.readSchemaFile();\n\n    const tables = SchemaManager.extractObjectNames(schemaSQL, 'CREATE TABLE');\n    const indexes = SchemaManager.extractObjectNames(schemaSQL, 'CREATE INDEX');\n    const views = SchemaManager.extractObjectNames(schemaSQL, 'CREATE VIEW');\n    const triggers = SchemaManager.extractObjectNames(schemaSQL, 'CREATE TRIGGER');\n\n    return {\n      version: SchemaManager.SCHEMA_VERSION,\n      tables,\n      indexes,\n      views,\n      triggers,\n    };\n  }\n\n  private async getCurrentSchema(): Promise<SchemaInfo> {\n    const objects = await this.db.query(`\n      SELECT name, type FROM sqlite_master \n      WHERE type IN ('table', 'index', 'view', 'trigger')\n      AND name NOT LIKE 'sqlite_%'\n      ORDER BY name\n    `);\n\n    const schema: SchemaInfo = {\n      version: await this.getCurrentSchemaVersion(),\n      tables: [],\n      indexes: [],\n      views: [],\n      triggers: [],\n    };\n\n    for (const obj of objects) {\n      switch (obj.type) {\n        case 'table':\n          schema.tables.push(obj.name);\n          break;\n        case 'index':\n          schema.indexes.push(obj.name);\n          break;\n        case 'view':\n          schema.views.push(obj.name);\n          break;\n        case 'trigger':\n          schema.triggers.push(obj.name);\n          break;\n      }\n    }\n\n    return schema;\n  }\n\n  private static extractObjectNames(sql: string, createStatement: string): string[] {\n    const regex = new RegExp(\n      `${String(createStatement)}\\\\s+(?:IF NOT EXISTS\\\\s+)?(?:\\\\w+\\\\.)?([\\\\w_]+)`,\n      'gi'\n    );\n    const matches: string[] = [];\n    let match;\n\n    while ((match = regex.exec(sql)) !== null) {\n      if (match[1]) {\n        matches.push(match[1]);\n      }\n    }\n\n    return matches;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/seeds/001_sample_boards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/seeds/002_sample_tasks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/seeds/003_sample_tags_and_notes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/seeds/SeedRunner.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 73,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 73,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 74,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 74,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .default on an `any` value.",
        "line": 74,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 74,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 76,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 76,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .run on an `any` value.",
        "line": 76,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 76,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 81,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 81,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 81,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 81,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 82,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 82,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 82,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 82,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 83,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 83,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .run on an `any` value.",
        "line": 83,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 83,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 11,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Database } from 'sqlite';\nimport type { Database as SQLiteDB } from 'sqlite3';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { logger } from '../../utils/logger';\nimport type { Seed, SeedOptions, AppliedSeed } from './types';\n\nexport class SeedRunner {\n  private readonly db: Database<SQLiteDB>;\n\n  private readonly seedsPath: string;\n\n  private readonly seedsTable: string;\n\n  constructor(db: Database<SQLiteDB>, options: SeedOptions = {}) {\n    this.db = db;\n    this.seedsPath = options.seedsPath ?? path.join(__dirname, '.');\n    this.seedsTable = options.seedsTable ?? 'seed_status';\n  }\n\n  /**\n   * Initialize the seeds tracking table\n   */\n  async initialize(): Promise<void> {\n    await this.db.run(`\n      CREATE TABLE IF NOT EXISTS ${String(String(this.seedsTable))} (\n        name TEXT PRIMARY KEY,\n        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        checksum TEXT NOT NULL\n      )\n    `);\n\n    logger.info('Seed tracking table initialized');\n  }\n\n  /**\n   * Get all applied seeds\n   */\n  async getAppliedSeeds(): Promise<AppliedSeed[]> {\n    return this.db.all<AppliedSeed[]>(\n      `SELECT name, applied_at, checksum FROM ${String(String(this.seedsTable))} ORDER BY name`\n    );\n  }\n\n  /**\n   * Get all seed files from the seeds directory\n   */\n  async getSeedFiles(): Promise<string[]> {\n    try {\n      const files = await fs.readdir(this.seedsPath);\n      return files\n        .filter(\n          file => file.endsWith('.ts') && !['types.ts', 'SeedRunner.ts', 'index.ts'].includes(file)\n        )\n        .sort();\n    } catch (error) {\n      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n        logger.warn(`Seeds directory not found: ${String(String(this.seedsPath))}`);\n        return [];\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Load a seed module dynamically\n   */\n  async loadSeed(filename: string): Promise<Seed> {\n    const filePath = path.join(this.seedsPath, filename);\n\n    // Dynamic import of the seed file\n    const seedModule = await import(filePath);\n    const seed = seedModule.default ?? seedModule;\n\n    if (!seed.name || !seed.run) {\n      throw new Error(`Seed ${String(filename)} must export 'name' and 'run' properties`);\n    }\n\n    return {\n      name: seed.name,\n      description: seed.description ?? '',\n      run: seed.run,\n    };\n  }\n\n  /**\n   * Run seeds\n   */\n  async run(options: { force?: boolean } = {}): Promise<number> {\n    await this.initialize();\n\n    const seedFiles = await this.getSeedFiles();\n\n    let seedsRun = 0;\n\n    for (const filename of seedFiles) {\n      // eslint-disable-next-line no-await-in-loop\n      const seed = await this.loadSeed(filename);\n\n      if (!seed) {\n        logger.warn(`Skipping invalid seed file: ${filename}`);\n        continue;\n      }\n\n      logger.info(\n        `Running seed: ${String(String(seed.name))} - ${String(String(seed.description))}`\n      );\n\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        await this.runSeed(seed, filename, options.force);\n        seedsRun++;\n        logger.info(`Seed ${String(String(seed.name))} completed successfully`);\n      } catch (error) {\n        logger.error(`Seed ${String(String(seed.name))} failed:`, error);\n        throw new Error(`Seed ${String(String(seed.name))} failed: ${String(error)}`);\n      }\n    }\n\n    if (seedsRun === 0) {\n      logger.info('No seeds to run');\n    } else {\n      logger.info(`Successfully ran ${String(seedsRun)} seed(s)`);\n    }\n\n    return seedsRun;\n  }\n\n  /**\n   * Get seed status\n   */\n  async status(): Promise<{\n    applied: string[];\n    pending: string[];\n    total: number;\n  }> {\n    await this.initialize();\n\n    const applied = await this.getAppliedSeeds();\n    const appliedSet = new Set(applied.map(s => s.name));\n    const seedFiles = await this.getSeedFiles();\n\n    const seedPromises = seedFiles.map(async filename => {\n      const seed = await this.loadSeed(filename);\n      return seed ? seed.name : null;\n    });\n\n    const seedResults = await Promise.all(seedPromises);\n    const allSeeds = seedResults.filter((name): name is string => name !== null);\n\n    const pending = allSeeds.filter(name => !appliedSet.has(name));\n\n    return {\n      applied: applied.map(s => s.name),\n      pending,\n      total: allSeeds.length,\n    };\n  }\n\n  /**\n   * Reset all seeds (remove tracking records)\n   */\n  async reset(): Promise<void> {\n    await this.initialize();\n    await this.db.run(`DELETE FROM ${String(String(this.seedsTable))}`);\n    logger.info('All seed records cleared');\n  }\n\n  /**\n   * Run a single seed\n   */\n  private async runSeed(seed: Seed, filename: string, force = false): Promise<void> {\n    const content = await fs.readFile(path.join(this.seedsPath, filename), 'utf-8');\n    const checksum = SeedRunner.calculateChecksum(content);\n\n    // Start transaction\n    await this.db.run('BEGIN TRANSACTION');\n\n    try {\n      // Run the seed\n      await seed.run(this.db);\n\n      if (force) {\n        // Update existing record\n        await this.db.run(\n          `INSERT OR REPLACE INTO ${String(String(this.seedsTable))} (name, checksum) VALUES (?, ?)`,\n          [seed.name, checksum]\n        );\n      } else {\n        // Insert new record\n        await this.db.run(\n          `INSERT INTO ${String(String(this.seedsTable))} (name, checksum) VALUES (?, ?)`,\n          [seed.name, checksum]\n        );\n      }\n\n      // Commit transaction\n      await this.db.run('COMMIT');\n    } catch (error) {\n      // Rollback on error\n      await this.db.run('ROLLBACK');\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate checksum for file content\n   */\n  private static calculateChecksum(content: string): string {\n    return crypto.createHash('sha256').update(content).digest('hex');\n  }\n\n  /**\n   * Create a new seed file\n   */\n  static async createSeed(name: string, description: string, seedsPath: string): Promise<string> {\n    const filename = `${String(String(name.replace(/\\s+/g, '_').toLowerCase()))}.ts`;\n    const filePath = path.join(seedsPath, filename);\n\n    const template = `import { Database } from 'sqlite';\nimport { Database as SQLiteDB } from 'sqlite3';\n\nexport const name = '${String(name)}';\nexport const description = '${String(description)}';\n\nexport async function run(): Promise<void>(db: Database<SQLiteDB>): Promise<void> {\n  // Add your seed data here\n  // Example:\n  // await db.run(\\`\n  //   INSERT INTO boards (id, name, description) VALUES \n  //   ('board-1', 'Sample Board', 'A sample board for development');\n  // \\`);\n  \n  logger.log('${String(name)} seed completed');\n}\n`;\n\n    await fs.writeFile(filePath, template);\n    logger.info(`Created seed: ${String(filename)}`);\n\n    return filename;\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/seeds/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/seeds/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/database/stats.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'slowest' is already declared in the upper scope on line 439 column 11.",
        "line": 441,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 441,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'fastest' is already declared in the upper scope on line 446 column 11.",
        "line": 448,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 448,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 548,
        "column": 28,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 548,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [15239, 15244], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\[.",
        "line": 706,
        "column": 46,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 706,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [19658, 19659], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [19658, 19658], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Database statistics collection and monitoring utilities\n *\n * @module database/stats\n * @description This module provides comprehensive database statistics collection,\n * performance monitoring, and health metrics for SQLite databases. It tracks\n * query performance, table statistics, index usage, and system metrics.\n *\n * @example\n * ```typescript\n * import { StatisticsCollector } from '@/database/stats';\n *\n * const stats = new StatisticsCollector(dbConnection);\n *\n * // Get comprehensive stats\n * const summary = await stats.getStatsSummary();\n * logger.log('Database health:', summary.health.score);\n *\n * // Monitor query performance\n * stats.startQueryMonitoring();\n * ```\n */\n\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection } from './connection';\n\n/**\n * Database performance statistics\n */\nexport interface DatabaseStats {\n  /** Database file information */\n  database: {\n    size: number;\n    sizeFormatted: string;\n    pageCount: number;\n    pageSize: number;\n    utilization: number;\n  };\n  /** Table statistics */\n  tables: TableStats[];\n  /** Index usage statistics */\n  indexes: IndexStats[];\n  /** Query performance metrics */\n  queries: QueryStats;\n  /** System health metrics */\n  health: HealthMetrics;\n  /** Timestamp when stats were collected */\n  timestamp: Date;\n}\n\n/**\n * Statistics for a single table\n */\nexport interface TableStats {\n  name: string;\n  rowCount: number;\n  size: number;\n  sizeFormatted: string;\n  averageRowSize: number;\n  indexCount: number;\n  lastModified?: Date;\n}\n\n/**\n * Index usage statistics\n */\nexport interface IndexStats {\n  name: string;\n  tableName: string;\n  columns: string[];\n  isUnique: boolean;\n  usageCount: number;\n  lastUsed?: Date;\n  efficiency: number;\n}\n\n/**\n * Query performance statistics\n */\nexport interface QueryStats {\n  totalQueries: number;\n  averageExecutionTime: number;\n  slowestQuery: {\n    sql: string;\n    duration: number;\n    timestamp: Date;\n  } | null;\n  fastestQuery: {\n    sql: string;\n    duration: number;\n    timestamp: Date;\n  } | null;\n  errorRate: number;\n  queryTypes: {\n    select: number;\n    insert: number;\n    update: number;\n    delete: number;\n    other: number;\n  };\n}\n\n/**\n * System health metrics\n */\nexport interface HealthMetrics {\n  score: number; // 0-100\n  status: 'excellent' | 'good' | 'fair' | 'poor' | 'critical';\n  issues: string[];\n  recommendations: string[];\n  lastCheck: Date;\n  responseTime: number;\n  connectionStatus: 'connected' | 'disconnected' | 'error';\n}\n\n/**\n * Configuration for statistics collection\n */\nexport interface StatsConfig {\n  /** Enable query performance monitoring */\n  enableQueryMonitoring: boolean;\n  /** Maximum number of queries to track */\n  maxQueryHistory: number;\n  /** Threshold for slow queries in milliseconds */\n  slowQueryThreshold: number;\n  /** Enable automatic statistics collection */\n  autoCollect: boolean;\n  /** Collection interval in milliseconds */\n  collectionInterval: number;\n  /** Enable detailed logging */\n  enableLogging: boolean;\n}\n\n/**\n * Query execution record for monitoring\n */\ninterface QueryRecord {\n  sql: string;\n  duration: number;\n  timestamp: Date;\n  success: boolean;\n  error?: string;\n}\n\n/**\n * Database statistics collector and monitor\n *\n * @class StatisticsCollector\n * @description Collects comprehensive database statistics including performance\n * metrics, table information, index usage, and health indicators. Provides\n * real-time monitoring and historical tracking capabilities.\n */\nexport class StatisticsCollector {\n  private readonly db: DatabaseConnection;\n\n  private readonly config: StatsConfig;\n\n  private readonly queryHistory: QueryRecord[] = [];\n\n  private readonly monitoringActive = false;\n\n  constructor(db: DatabaseConnection, config: Partial<StatsConfig> = {}) {\n    this.db = db;\n    this.config = {\n      enableQueryMonitoring: true,\n      maxQueryHistory: 1000,\n      slowQueryThreshold: 1000, // 1 second\n      autoCollect: false,\n      collectionInterval: 300000, // 5 minutes\n      enableLogging: true,\n      ...config,\n    };\n  }\n\n  /**\n   * Get comprehensive database statistics summary\n   *\n   * @returns {Promise<DatabaseStats>} Complete database statistics\n   *\n   * @example\n   * ```typescript\n   * const stats = await collector.getStatsSummary();\n   * logger.log(`Database size: ${String(String(stats.database.sizeFormatted))}`);\n   * logger.log(`Health score: ${String(String(stats.health.score))}/100`);\n   * logger.log(`Total tables: ${String(String(stats.tables.length))}`);\n   * ```\n   */\n  public async getStatsSummary(): Promise<DatabaseStats> {\n    const startTime = Date.now();\n\n    try {\n      if (this.config.enableLogging) {\n        logger.debug('Collecting database statistics');\n      }\n\n      const [databaseStats, tableStats, indexStats, queryStats, healthMetrics] = await Promise.all([\n        this.getDatabaseInfo(),\n        this.getTableStatistics(),\n        this.getIndexStatistics(),\n        this.getQueryStatistics(),\n        this.getHealthMetrics(),\n      ]);\n\n      const stats: DatabaseStats = {\n        database: databaseStats,\n        tables: tableStats,\n        indexes: indexStats,\n        queries: queryStats,\n        health: healthMetrics,\n        timestamp: new Date(),\n      };\n\n      const duration = Date.now() - startTime;\n      if (this.config.enableLogging) {\n        logger.debug('Database statistics collected', {\n          duration: `${String(duration)}ms`,\n          tablesAnalyzed: tableStats.length,\n          indexesAnalyzed: indexStats.length,\n          healthScore: healthMetrics.score,\n        });\n      }\n\n      return stats;\n    } catch (error) {\n      logger.error('Failed to collect database statistics', {\n        error: (error as Error).message,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Get basic database information\n   *\n   * @returns {Promise<DatabaseStats['database']>} Database file information\n   */\n  public async getDatabaseInfo(): Promise<DatabaseStats['database']> {\n    const stats = await this.db.getStats();\n    const utilization =\n      stats.pageCount > 0 ? (stats.size / (stats.pageCount * stats.pageSize)) * 100 : 0;\n\n    return {\n      size: stats.size,\n      sizeFormatted: StatisticsCollector.formatBytes(stats.size),\n      pageCount: stats.pageCount,\n      pageSize: stats.pageSize,\n      utilization: Math.round(utilization * 100) / 100,\n    };\n  }\n\n  /**\n   * Get statistics for all tables\n   *\n   * @returns {Promise<TableStats[]>} Array of table statistics\n   */\n  public async getTableStatistics(): Promise<TableStats[]> {\n    const tables = await this.db.query<{ name: string }>(`\n      SELECT name FROM sqlite_master \n      WHERE type = 'table' \n      AND name NOT LIKE 'sqlite_%'\n      AND name NOT LIKE '%_migrations'\n      ORDER BY name\n    `);\n\n    const tableStatsPromises = tables.map(async table => {\n      try {\n        const [rowCountResult, sizeResult, indexCountResult] = await Promise.all([\n          this.db.queryOne<{ count: number }>(\n            `SELECT COUNT(*) as count FROM \"${String(table.name)}\"`\n          ),\n          this.db.queryOne<{ size: number }>(\n            `\n              SELECT SUM(pgsize) as size \n              FROM dbstat \n              WHERE name = ?\n            `,\n            [table.name]\n          ),\n          this.db.queryOne<{ count: number }>(\n            `\n              SELECT COUNT(*) as count \n              FROM sqlite_master \n              WHERE type = 'index' \n              AND tbl_name = ?\n              AND name NOT LIKE 'sqlite_%'\n            `,\n            [table.name]\n          ),\n        ]);\n\n        const rowCount = rowCountResult?.count ?? 0;\n        const size = sizeResult?.size ?? 0;\n        const indexCount = indexCountResult?.count ?? 0;\n        const averageRowSize = rowCount > 0 ? Math.round(size / rowCount) : 0;\n\n        let lastModified: Date | undefined;\n        try {\n          // Check both possible timestamp columns\n          const timestampResults = await Promise.all(\n            ['last_modified', 'last_update'].map(col =>\n              this.db\n                .queryOne<{ max_time: string }>(\n                  `\n                  SELECT MAX(\"${String(col)}\") as max_time \n                  FROM \"${String(table.name)}\"\n                `\n                )\n                .catch(() => null)\n            )\n          );\n\n          // Find the first valid timestamp\n          const validResult = timestampResults.find(result => result?.max_time);\n          if (validResult?.max_time) {\n            lastModified = new Date(validResult.max_time);\n          }\n        } catch {\n          // Column doesn't exist or other error, skip timestamp\n        }\n\n        const tableStatRecord: TableStats = {\n          name: table.name,\n          rowCount,\n          size,\n          sizeFormatted: StatisticsCollector.formatBytes(size),\n          averageRowSize,\n          indexCount,\n        };\n\n        if (lastModified) {\n          tableStatRecord.lastModified = lastModified;\n        }\n\n        return tableStatRecord;\n      } catch (error) {\n        logger.warn('Failed to get statistics for table', {\n          table: table.name,\n          error: (error as Error).message,\n        });\n        return null;\n      }\n    });\n\n    const tableStatsResults = await Promise.all(tableStatsPromises);\n    const tableStats = tableStatsResults.filter((stat): stat is TableStats => stat !== null);\n\n    return tableStats.sort((a, b) => b.size - a.size);\n  }\n\n  /**\n   * Get index usage statistics\n   *\n   * @returns {Promise<IndexStats[]>} Array of index statistics\n   */\n  public async getIndexStatistics(): Promise<IndexStats[]> {\n    const indexes = await this.db.query<{\n      name: string;\n      tbl_name: string;\n      unique: number;\n      sql: string;\n    }>(`\n      SELECT name, tbl_name, \"unique\", sql\n      FROM sqlite_master \n      WHERE type = 'index' \n      AND name NOT LIKE 'sqlite_%'\n      ORDER BY tbl_name, name\n    `);\n\n    const indexStats: IndexStats[] = [];\n\n    await Promise.all(\n      indexes.map(async index => {\n        const statResult = await this.db.queryOne<{ stat: string }>(\n          `SELECT stat FROM sqlite_stat1 WHERE tbl = ? AND idx = ?`,\n          [index.tbl_name, index.name]\n        );\n\n        let usageCount = 0;\n        let efficiency = 0;\n\n        try {\n          if (statResult?.stat) {\n            const stats = statResult.stat.split(' ');\n            if (stats.length >= 2) {\n              usageCount = parseInt(stats[0], 10) || 0;\n              efficiency = parseFloat(stats[1]) || 0;\n            }\n          }\n        } catch {\n          // Statistics not available\n        }\n\n        const columns = StatisticsCollector.parseIndexColumns(index.sql ?? '');\n\n        indexStats.push({\n          name: index.name,\n          tableName: index.tbl_name,\n          columns,\n          isUnique: index.unique === 1,\n          usageCount,\n          efficiency,\n        });\n      })\n    );\n\n    return indexStats;\n  }\n\n  /**\n   * Get query performance statistics\n   *\n   * @returns {Promise<QueryStats>} Query performance metrics\n   */\n  public getQueryStatistics(): QueryStats {\n    if (!this.config.enableQueryMonitoring || this.queryHistory.length === 0) {\n      return {\n        totalQueries: 0,\n        averageExecutionTime: 0,\n        slowestQuery: null,\n        fastestQuery: null,\n        errorRate: 0,\n        queryTypes: {\n          select: 0,\n          insert: 0,\n          update: 0,\n          delete: 0,\n          other: 0,\n        },\n      };\n    }\n\n    const successfulQueries = this.queryHistory.filter(q => q.success);\n    const totalQueries = this.queryHistory.length;\n    const totalDuration = successfulQueries.reduce((sum, q) => sum + q.duration, 0);\n    const averageExecutionTime =\n      successfulQueries.length > 0 ? totalDuration / successfulQueries.length : 0;\n\n    // Find slowest and fastest queries\n    const slowest =\n      successfulQueries.length > 0\n        ? successfulQueries.reduce((slowest, current) =>\n            current.duration > slowest.duration ? current : slowest\n          )\n        : undefined;\n\n    const fastest =\n      successfulQueries.length > 0\n        ? successfulQueries.reduce((fastest, current) =>\n            current.duration < fastest.duration ? current : fastest\n          )\n        : undefined;\n\n    // Calculate error rate\n    const errorCount = this.queryHistory.filter(q => !q.success).length;\n    const errorRate = totalQueries > 0 ? (errorCount / totalQueries) * 100 : 0;\n\n    // Categorize query types\n    const queryTypes = {\n      select: 0,\n      insert: 0,\n      update: 0,\n      delete: 0,\n      other: 0,\n    };\n\n    this.queryHistory.forEach(query => {\n      const sql = query.sql.trim().toLowerCase();\n      if (sql.startsWith('select')) {\n        queryTypes.select++;\n      } else if (sql.startsWith('insert')) {\n        queryTypes.insert++;\n      } else if (sql.startsWith('update')) {\n        queryTypes.update++;\n      } else if (sql.startsWith('delete')) {\n        queryTypes.delete++;\n      } else {\n        queryTypes.other++;\n      }\n    });\n\n    return {\n      totalQueries,\n      averageExecutionTime: Math.round(averageExecutionTime * 100) / 100,\n      slowestQuery: slowest\n        ? {\n            sql: slowest.sql.substring(0, 100) + (slowest.sql.length > 100 ? '...' : ''),\n            duration: slowest.duration,\n            timestamp: slowest.timestamp,\n          }\n        : null,\n      fastestQuery: fastest\n        ? {\n            sql: fastest.sql.substring(0, 100) + (fastest.sql.length > 100 ? '...' : ''),\n            duration: fastest.duration,\n            timestamp: fastest.timestamp,\n          }\n        : null,\n      errorRate: Math.round(errorRate * 100) / 100,\n      queryTypes,\n    };\n  }\n\n  /**\n   * Get system health metrics\n   *\n   * @returns {Promise<HealthMetrics>} Health assessment\n   */\n  public async getHealthMetrics(): Promise<HealthMetrics> {\n    const startTime = Date.now();\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    let score = 100;\n\n    try {\n      // Test database responsiveness\n      await this.db.queryOne('SELECT 1');\n      const responseTime = Date.now() - startTime;\n\n      // Check response time\n      if (responseTime > 1000) {\n        issues.push('Slow database response time');\n        recommendations.push('Consider running VACUUM and ANALYZE');\n        score -= 20;\n      } else if (responseTime > 500) {\n        issues.push('Moderately slow response time');\n        score -= 10;\n      }\n\n      // Check database size and fragmentation\n      const stats = await this.db.getStats();\n      const sizeMB = stats.size / 1024 / 1024;\n\n      if (sizeMB > 500) {\n        issues.push('Large database size');\n        recommendations.push('Consider archiving old data or partitioning');\n        score -= 10;\n      }\n\n      // Check for potential fragmentation\n      if (stats.pageCount > (stats.size / stats.pageSize) * 1.3) {\n        issues.push('Database may be fragmented');\n        recommendations.push('Run VACUUM to reclaim space and defragment');\n        score -= 15;\n      }\n\n      // Check query performance\n      if (this.config.enableQueryMonitoring && this.queryHistory.length > 0) {\n        const queryStats = await this.getQueryStatistics();\n\n        if (queryStats.errorRate > 5) {\n          issues.push(`High query error rate: ${String(String(queryStats.errorRate))}%`);\n          recommendations.push('Review and fix failing queries');\n          score -= 25;\n        }\n\n        if (queryStats.averageExecutionTime > this.config.slowQueryThreshold) {\n          issues.push('Slow average query execution time');\n          recommendations.push('Optimize slow queries and add indexes');\n          score -= 15;\n        }\n      }\n\n      // Determine status based on score\n      let status: HealthMetrics['status'];\n      if (score >= 90) status = 'excellent';\n      else if (score >= 75) status = 'good';\n      else if (score >= 50) status = 'fair';\n      else if (score >= 25) status = 'poor';\n      else status = 'critical';\n\n      return {\n        score: Math.max(0, score),\n        status,\n        issues,\n        recommendations,\n        lastCheck: new Date(),\n        responseTime,\n        connectionStatus: 'connected',\n      };\n    } catch (error) {\n      return {\n        score: 0,\n        status: 'critical',\n        issues: ['Database connection failed'],\n        recommendations: ['Check database connection and restart if necessary'],\n        lastCheck: new Date(),\n        responseTime: Date.now() - startTime,\n        connectionStatus: 'error',\n      };\n    }\n  }\n\n  /**\n   * Start monitoring query performance\n   *\n   * @example\n   * ```typescript\n   * // Start monitoring\n   * collector.startQueryMonitoring();\n   *\n   * // Run some queries...\n   * await db.query('SELECT * FROM tasks');\n   *\n   * // Get performance stats\n   * const stats = await collector.getQueryStatistics();\n   * ```\n   */\n  public startQueryMonitoring(): void {\n    if (this.monitoringActive) return;\n\n    this.monitoringActive = true;\n    if (this.config.enableLogging) {\n      logger.info('Started query performance monitoring');\n    }\n\n    // Hook into database query methods (this is a simplified example)\n    // In a real implementation, you'd intercept queries at the database layer\n  }\n\n  /**\n   * Stop monitoring query performance\n   */\n  public stopQueryMonitoring(): void {\n    this.monitoringActive = false;\n    if (this.config.enableLogging) {\n      logger.info('Stopped query performance monitoring');\n    }\n  }\n\n  /**\n   * Record a query execution for monitoring\n   *\n   * @param {string} sql - SQL query that was executed\n   * @param {number} duration - Execution time in milliseconds\n   * @param {boolean} success - Whether the query succeeded\n   * @param {string} [error] - Error message if query failed\n   */\n  public recordQuery(sql: string, duration: number, success: boolean, error?: string): void {\n    if (!this.config.enableQueryMonitoring) return;\n\n    const record: QueryRecord = {\n      sql,\n      duration,\n      timestamp: new Date(),\n      success,\n    };\n\n    if (error !== undefined) {\n      record.error = error;\n    }\n\n    this.queryHistory.push(record);\n\n    // Trim history if it exceeds max size\n    if (this.queryHistory.length > this.config.maxQueryHistory) {\n      this.queryHistory = this.queryHistory.slice(-this.config.maxQueryHistory);\n    }\n\n    // Log slow queries\n    if (duration > this.config.slowQueryThreshold && this.config.enableLogging) {\n      logger.warn('Slow query detected', {\n        sql: sql.substring(0, 200) + (sql.length > 200 ? '...' : ''),\n        duration: `${String(duration)}ms`,\n        success,\n        error,\n      });\n    }\n  }\n\n  /**\n   * Clear query history\n   */\n  public clearQueryHistory(): void {\n    this.queryHistory = [];\n    if (this.config.enableLogging) {\n      logger.info('Query history cleared');\n    }\n  }\n\n  /**\n   * Export statistics to JSON\n   *\n   * @returns {Promise<string>} JSON string of statistics\n   */\n  public async exportStats(): Promise<string> {\n    const stats = await this.getStatsSummary();\n    return JSON.stringify(stats, null, 2);\n  }\n\n  /**\n   * Parse columns from CREATE INDEX SQL statement\n   *\n   * @private\n   * @param {string} sql - CREATE INDEX SQL statement\n   * @returns {string[]} Array of column names\n   */\n  private static parseIndexColumns(sql: string): string[] {\n    if (!sql) return [];\n\n    try {\n      // Extract column list from CREATE INDEX statement\n      const match = sql.match(/\\((.*?)\\)/);\n      if (match?.[1]) {\n        return match[1]\n          .split(',')\n          .map(col => col.trim().replace(/[\"`\\[\\]]/g, ''))\n          .filter(col => col.length > 0);\n      }\n    } catch {\n      // Parsing failed, return empty array\n    }\n\n    return [];\n  }\n\n  /**\n   * Format bytes to human-readable string\n   *\n   * @private\n   * @param {number} bytes - Number of bytes\n   * @returns {string} Formatted string\n   */\n  private static formatBytes(bytes: number): string {\n    if (bytes === 0) return '0 B';\n\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n    return `${String(String(parseFloat((bytes / k ** i).toFixed(2))))} ${String(sizes[i])}`;\n  }\n}\n\n/**\n * Create a statistics collector instance\n *\n * @param {DatabaseConnection} db - Database connection\n * @param {Partial<StatsConfig>} [config] - Optional configuration\n * @returns {StatisticsCollector} Configured statistics collector\n *\n * @example\n * ```typescript\n * import { dbConnection } from '@/database/connection';\n * import { createStatsCollector } from '@/database/stats';\n *\n * const collector = createStatsCollector(dbConnection, {\n *   enableQueryMonitoring: true,\n *   slowQueryThreshold: 500\n * });\n * ```\n */\nexport function createStatsCollector(\n  db: DatabaseConnection,\n  config?: Partial<StatsConfig>\n): StatisticsCollector {\n  return new StatisticsCollector(db, config);\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/mcp/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/mcp/prompts.ts",
    "messages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'listPrompts'.",
        "line": 17,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 17,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 277,
        "column": 54,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 277,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8309, 8312], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8309, 8312], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 285,
        "column": 18,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 285,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [8581, 8586], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 291,
        "column": 18,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 291,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [8893, 8898], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 318,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 318,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10091, 10094], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10091, 10094], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 319,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 319,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 333,
        "column": 74,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 333,
        "endColumn": 82
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'focus_area' is not in camel case.",
        "line": 336,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 336,
        "endColumn": 19
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'generateTaskBreakdownPrompt'.",
        "line": 371,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 371,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 371,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 371,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11585, 11588], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11585, 11588], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 372,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 372,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 418,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 418,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12944, 12947], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12944, 12947], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 419,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 419,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 426,
        "column": 64,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 426,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 432,
        "column": 77,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 432,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.",
        "line": 442,
        "column": 70,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 442,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 487,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 487,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15030, 15033], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15030, 15033], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 488,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 488,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 502,
        "column": 74,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 502,
        "endColumn": 82
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'sprint_duration' is not in camel case.",
        "line": 504,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 504,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 542,
        "column": 60,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 542,
        "endColumn": 63,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16726, 16729], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16726, 16729], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 543,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 543,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 594,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 594,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [18201, 18204], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [18201, 18204], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 595,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 595,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 609,
        "column": 74,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 609,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 665,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 665,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20072, 20075], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20072, 20075], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 666,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 666,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 675,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 675,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 731,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 731,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [21928, 21931], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [21928, 21931], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 732,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 732,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 746,
        "column": 74,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 746,
        "endColumn": 82
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'optimization_goal' is not in camel case.",
        "line": 748,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 748,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 801,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 801,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [23850, 23853], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [23850, 23853], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 802,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 802,
        "endColumn": 55
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'since_date' is not in camel case.",
        "line": 808,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 808,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 809,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 809,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 813,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 813,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 874,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 874,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [25845, 25848], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [25845, 25848], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 875,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 875,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 889,
        "column": 74,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 889,
        "endColumn": 82
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'focus_areas' is not in camel case.",
        "line": 892,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 892,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 952,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 952,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [28017, 28020], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [28017, 28020], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 953,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 953,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .board_id on an `any` value.",
        "line": 953,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 953,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .boardId on an `any` value.",
        "line": 953,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 953,
        "endColumn": 51
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'planning_horizon' is not in camel case.",
        "line": 954,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 954,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 954,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 954,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .planning_horizon on an `any` value.",
        "line": 954,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 954,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .planningHorizon on an `any` value.",
        "line": 954,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 954,
        "endColumn": 75
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'focus_area' is not in camel case.",
        "line": 955,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 955,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 955,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 955,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .focus_area on an `any` value.",
        "line": 955,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 955,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .focusArea on an `any` value.",
        "line": 955,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 955,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 967,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 967,
        "endColumn": 49
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'planning_horizon' is not in camel case.",
        "line": 967,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 967,
        "endColumn": 37
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'focus_area' is not in camel case.",
        "line": 968,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 968,
        "endColumn": 29
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'generateTaskBreakdownBasicPrompt'.",
        "line": 996,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 996,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 996,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 996,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [29383, 29386], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [29383, 29386], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 998,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1000,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task_description on an `any` value.",
        "line": 999,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 999,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 1000,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1000,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 1000,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1000,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .description on an `any` value.",
        "line": 1000,
        "column": 71,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1000,
        "endColumn": 82
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'complexity_level' is not in camel case.",
        "line": 1001,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1001,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1001,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1001,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .complexity_level on an `any` value.",
        "line": 1001,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1001,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .complexity on an `any` value.",
        "line": 1001,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1001,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1007,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1007,
        "endColumn": 52
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'complexity_level' is not in camel case.",
        "line": 1007,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1007,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 1039,
        "column": 57,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1039,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [30767, 30770], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [30767, 30770], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1040,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1040,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .board_id on an `any` value.",
        "line": 1040,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1040,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .boardId on an `any` value.",
        "line": 1040,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1040,
        "endColumn": 51
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'sprint_duration' is not in camel case.",
        "line": 1041,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1041,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1041,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1041,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .sprint_duration on an `any` value.",
        "line": 1041,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1041,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .sprintDuration on an `any` value.",
        "line": 1041,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1041,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1042,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1042,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .team_capacity on an `any` value.",
        "line": 1042,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1042,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .teamCapacity on an `any` value.",
        "line": 1042,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1042,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1048,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1048,
        "endColumn": 43
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'sprint_duration' is not in camel case.",
        "line": 1048,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1048,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1049,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1049,
        "endColumn": 63
      }
    ],
    "suppressedMessages": [],
    "errorCount": 27,
    "fatalErrorCount": 0,
    "warningCount": 56,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Prompt, PromptMessage } from '@modelcontextprotocol/sdk/types.js';\nimport { logger } from '@/utils/logger';\nimport type { MCPServices } from './tools';\n\nexport interface PromptContent {\n  description: string;\n  messages: PromptMessage[];\n}\n\nexport class MCPPromptRegistry {\n  private readonly services: MCPServices;\n\n  constructor(services: MCPServices) {\n    this.services = services;\n  }\n\n  listPrompts(): Promise<Prompt[]> {\n    return [\n      {\n        name: 'task_planning',\n        description: 'Help plan and organize tasks with intelligent suggestions',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board to plan tasks for',\n            required: true,\n          },\n          {\n            name: 'planning_horizon',\n            description: 'Time horizon for planning (day, week, sprint, month)',\n            required: false,\n          },\n          {\n            name: 'focus_area',\n            description: 'Specific area to focus planning on',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'task_breakdown',\n        description: 'Break down complex tasks into manageable subtasks',\n        arguments: [\n          {\n            name: 'task_description',\n            description: 'Description of the complex task to break down',\n            required: true,\n          },\n          {\n            name: 'board_id',\n            description: 'ID of the board where tasks will be created',\n            required: false,\n          },\n          {\n            name: 'complexity_level',\n            description: 'Desired complexity level for subtasks',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'sprint_planning',\n        description: 'Assist with sprint planning and capacity estimation',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board for sprint planning',\n            required: true,\n          },\n          {\n            name: 'sprint_duration',\n            description: 'Duration of the sprint in days',\n            required: false,\n          },\n          {\n            name: 'team_capacity',\n            description: 'Available team capacity for the sprint',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'analyze_project_status',\n        description: 'Analyze the current status of a project/board and provide insights',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board to analyze',\n            required: true,\n          },\n          {\n            name: 'focus_area',\n            description:\n              'Specific area to focus analysis on (progress, blockers, team_performance, timeline)',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'task_breakdown_assistant',\n        description: 'Help break down a complex task into smaller, manageable subtasks',\n        arguments: [\n          {\n            name: 'task_description',\n            description: 'Description of the complex task to break down',\n            required: true,\n          },\n          {\n            name: 'context',\n            description: 'Additional context about the project or requirements',\n            required: false,\n          },\n          {\n            name: 'timeline',\n            description: 'Target timeline for completion',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'blocker_resolution_helper',\n        description: 'Analyze blocked tasks and suggest resolution strategies',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board to analyze blocked tasks for',\n            required: false,\n          },\n          {\n            name: 'task_id',\n            description: 'Specific task ID if analyzing a single blocked task',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'sprint_planning_assistant',\n        description: 'Help plan a sprint based on current board state and team capacity',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board for sprint planning',\n            required: true,\n          },\n          {\n            name: 'sprint_duration',\n            description: 'Duration of the sprint in days/weeks',\n            required: false,\n          },\n          {\n            name: 'team_capacity',\n            description: 'Available team capacity or constraints',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'priority_recommendation',\n        description: 'Get recommendations for task prioritization based on current workload',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board to analyze',\n            required: true,\n          },\n          {\n            name: 'criteria',\n            description: 'Prioritization criteria (deadline, impact, effort, dependencies)',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'progress_report_generator',\n        description: 'Generate a comprehensive progress report for stakeholders',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board to generate report for',\n            required: true,\n          },\n          {\n            name: 'timeframe',\n            description: 'Timeframe for the report (week, month, sprint)',\n            required: false,\n          },\n          {\n            name: 'audience',\n            description: 'Target audience (team, management, client)',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'task_estimation_helper',\n        description: 'Help estimate effort and timeline for tasks based on historical data',\n        arguments: [\n          {\n            name: 'task_description',\n            description: 'Description of the task to estimate',\n            required: true,\n          },\n          {\n            name: 'board_id',\n            description: 'Board ID for historical context',\n            required: false,\n          },\n          {\n            name: 'complexity',\n            description: 'Perceived complexity level (low, medium, high)',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'workflow_optimization',\n        description: 'Analyze workflow patterns and suggest optimizations',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board to analyze workflow for',\n            required: true,\n          },\n          {\n            name: 'optimization_goal',\n            description: 'Goal for optimization (speed, quality, efficiency, collaboration)',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'standup_preparation',\n        description: 'Prepare content for daily standup meetings based on recent activity',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board for standup',\n            required: true,\n          },\n          {\n            name: 'team_member',\n            description: 'Specific team member to prepare updates for',\n            required: false,\n          },\n          {\n            name: 'since_date',\n            description: 'Date to include updates since (ISO format)',\n            required: false,\n          },\n        ],\n      },\n      {\n        name: 'retrospective_insights',\n        description: 'Generate insights and talking points for retrospective meetings',\n        arguments: [\n          {\n            name: 'board_id',\n            description: 'ID of the board for retrospective',\n            required: true,\n          },\n          {\n            name: 'timeframe',\n            description: 'Period to analyze (sprint, month, quarter)',\n            required: false,\n          },\n          {\n            name: 'focus_areas',\n            description:\n              'Specific areas to focus on (what went well, what could improve, action items)',\n            required: false,\n          },\n        ],\n      },\n    ];\n  }\n\n  async getPrompt(name: string, args: Record<string, any>): Promise<PromptContent> {\n    logger.info('MCP prompt request', { promptName: name, args });\n\n    try {\n      switch (name) {\n        case 'task_planning':\n          return await this.generateTaskPlanningPrompt(args);\n        case 'task_breakdown':\n          return await this.generateTaskBreakdownBasicPrompt(args);\n        case 'sprint_planning':\n          return await this.generateSprintPlanningBasicPrompt(args);\n        case 'analyze_project_status':\n          return await this.generateProjectStatusPrompt(args);\n        case 'task_breakdown_assistant':\n          return await this.generateTaskBreakdownPrompt(args);\n        case 'blocker_resolution_helper':\n          return await this.generateBlockerResolutionPrompt(args);\n        case 'sprint_planning_assistant':\n          return await this.generateSprintPlanningPrompt(args);\n        case 'priority_recommendation':\n          return await this.generatePriorityRecommendationPrompt(args);\n        case 'progress_report_generator':\n          return await this.generateProgressReportPrompt(args);\n        case 'task_estimation_helper':\n          return await this.generateTaskEstimationPrompt(args);\n        case 'workflow_optimization':\n          return await this.generateWorkflowOptimizationPrompt(args);\n        case 'standup_preparation':\n          return await this.generateStandupPreparationPrompt(args);\n        case 'retrospective_insights':\n          return await this.generateRetrospectiveInsightsPrompt(args);\n        default:\n          throw new Error(`Unknown prompt: ${String(name)}`);\n      }\n    } catch (error) {\n      logger.error('Prompt generation error', { promptName: name, args, error });\n      throw error;\n    }\n  }\n\n  // Prompt generators\n  private async generateProjectStatusPrompt(args: any): Promise<PromptContent> {\n    const { board_id, focus_area } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: true,\n      days_back: 30,\n      max_items: 200,\n      include_metrics: true,\n      detail_level: 'comprehensive',\n    });\n\n    const analytics = await this.services.boardService.getBoardWithStats(board_id);\n\n    let focusInstruction = '';\n    if (focus_area) {\n      focusInstruction = `Focus specifically on: ${String(focus_area)}. `;\n    }\n\n    return {\n      description: 'Analyze project status and provide actionable insights',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please analyze the current status of this project and provide insights. ${String(focusInstruction)}\n\nProject Context:\n${String(context)}\n\nAnalytics Data:\n${String(String(JSON.stringify(analytics, null, 2)))}\n\nProvide a comprehensive analysis including:\n1. Current progress and completion rate\n2. Key accomplishments and milestones reached\n3. Active blockers and risks\n4. Team performance and workload distribution\n5. Timeline assessment and potential delays\n6. Recommendations for improvement\n7. Next steps and priorities\n\nFormat your response in a clear, actionable manner suitable for stakeholders.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private generateTaskBreakdownPrompt(args: any): PromptContent {\n    const { task_description, context, timeline } = args;\n\n    if (!task_description) {\n      throw new Error('task_description is required');\n    }\n\n    let additionalContext = '';\n    if (context) {\n      additionalContext = `\\n\\nAdditional Context:\\n${String(context)}`;\n    }\n\n    let timelineInfo = '';\n    if (timeline) {\n      timelineInfo = `\\n\\nTarget Timeline: ${String(timeline)}`;\n    }\n\n    return {\n      description: 'Break down complex task into manageable subtasks',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please help me break down this complex task into smaller, manageable subtasks:\n\nTask Description:\n${String(task_description)}${String(additionalContext)}${String(timelineInfo)}\n\nPlease provide:\n1. A list of 3-8 subtasks that logically break down the main task\n2. For each subtask:\n   - Clear, actionable description\n   - Estimated effort/complexity (S/M/L/XL)\n   - Any dependencies between subtasks\n   - Suggested priority level (1-5)\n   - Potential risks or considerations\n3. Recommended order of execution\n4. Any missing information or clarifications needed\n\nFormat the subtasks in a way that can be easily added to a kanban board.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateBlockerResolutionPrompt(args: any): Promise<PromptContent> {\n    const { board_id, task_id } = args;\n\n    let blockedTasks;\n    let contextInfo = '';\n\n    if (task_id) {\n      // Single task analysis\n      const task = await this.services.taskService.getTaskById(task_id);\n      if (!task) {\n        throw new Error(`Task not found: ${String(task_id)}`);\n      }\n      blockedTasks = [task];\n\n      const taskContext = await this.services.contextService.getTaskContext(task_id, {\n        include_completed: true,\n        days_back: 30,\n        max_items: 100,\n        include_metrics: true,\n        detail_level: 'detailed',\n      });\n      contextInfo = `\\nTask Context:\\n${String(taskContext)}`;\n    } else {\n      // Board-wide analysis\n      blockedTasks = await this.services.taskService.getBlockedTasks(board_id);\n\n      if (board_id) {\n        const projectContext = await this.services.contextService.getProjectContext({\n          include_completed: false,\n          days_back: 30,\n          max_items: 100,\n          include_metrics: false,\n          detail_level: 'summary',\n        });\n        contextInfo = `\\nProject Context:\\n${String(projectContext)}`;\n      }\n    }\n\n    return {\n      description: 'Analyze blocked tasks and suggest resolution strategies',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please analyze these blocked tasks and provide resolution strategies:\n\nBlocked Tasks:\n${String(String(JSON.stringify(blockedTasks, null, 2)))}${String(contextInfo)}\n\nFor each blocked task, please provide:\n1. Root cause analysis of the blocker\n2. Immediate actions that can be taken\n3. Who should be involved in resolution\n4. Alternative approaches or workarounds\n5. Prevention strategies for similar future blockers\n6. Estimated time to resolution\n7. Impact if blocker is not resolved quickly\n\nAlso provide:\n- Priority order for addressing blockers\n- Any patterns or systemic issues\n- Recommendations for process improvements`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateSprintPlanningPrompt(args: any): Promise<PromptContent> {\n    const { board_id, sprint_duration, team_capacity } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: false,\n      days_back: 30,\n      max_items: 200,\n      include_metrics: true,\n      detail_level: 'detailed',\n    });\n\n    const analytics = await this.services.boardService.getBoardWithStats(board_id);\n\n    const durationInfo = sprint_duration ? `\\nSprint Duration: ${String(sprint_duration)}` : '';\n    const capacityInfo = team_capacity ? `\\nTeam Capacity: ${String(team_capacity)}` : '';\n\n    return {\n      description: 'Plan sprint based on current board state and team capacity',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please help plan the next sprint based on the current project state:\n\nProject Context:\n${String(context)}\n\nAnalytics:\n${String(String(JSON.stringify(analytics, null, 2)))}${String(durationInfo)}${String(capacityInfo)}\n\nPlease provide:\n1. Recommended tasks for the sprint based on:\n   - Priority and business value\n   - Team capacity and skills\n   - Dependencies and blockers\n   - Sprint duration\n2. Sprint goals and objectives\n3. Risk assessment and mitigation strategies\n4. Resource allocation recommendations\n5. Definition of done for the sprint\n6. Potential stretch goals if time permits\n7. Backlog prioritization for future sprints\n\nFormat the recommendations in a way that can guide sprint planning meetings.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generatePriorityRecommendationPrompt(args: any): Promise<PromptContent> {\n    const { board_id, criteria } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: false,\n      days_back: 30,\n      max_items: 100,\n      include_metrics: true,\n      detail_level: 'detailed',\n    });\n\n    const criteriaInfo = criteria ? `\\nPrioritization Criteria: ${String(criteria)}` : '';\n\n    return {\n      description: 'Get task prioritization recommendations',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please analyze the current tasks and provide prioritization recommendations:\n\nProject Context:\n${String(context)}${String(criteriaInfo)}\n\nPlease provide:\n1. Task prioritization recommendations with reasoning\n2. High-impact, low-effort tasks (quick wins)\n3. Critical path items that could block progress\n4. Tasks that can be deprioritized or deferred\n5. Recommendations for priority level adjustments (1-5 scale)\n6. Dependencies that affect prioritization\n7. Risk-based prioritization considerations\n8. Resource optimization suggestions\n\nConsider factors like:\n- Business impact and value\n- Technical dependencies\n- Team capacity and skills\n- Deadlines and time constraints\n- Risk and complexity\n- Customer/stakeholder needs`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateProgressReportPrompt(args: any): Promise<PromptContent> {\n    const { board_id, timeframe, audience } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: true,\n      days_back: 30,\n      max_items: 200,\n      include_metrics: true,\n      detail_level: 'comprehensive',\n    });\n\n    const analytics = await this.services.boardService.getBoardWithStats(board_id);\n\n    const timeframeInfo = timeframe ? `\\nTimeframe: ${String(timeframe)}` : '';\n    const audienceInfo = audience ? `\\nTarget Audience: ${String(audience)}` : '';\n\n    return {\n      description: 'Generate comprehensive progress report',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please generate a comprehensive progress report for this project:\n\nProject Context:\n${String(context)}\n\nAnalytics:\n${String(String(JSON.stringify(analytics, null, 2)))}${String(timeframeInfo)}${String(audienceInfo)}\n\nPlease create a report including:\n1. Executive Summary\n   - Overall progress percentage\n   - Key achievements\n   - Major challenges\n   - Timeline status\n2. Detailed Progress Analysis\n   - Completed vs planned work\n   - Quality metrics\n   - Team performance\n   - Resource utilization\n3. Key Metrics and KPIs\n   - Velocity trends\n   - Cycle time\n   - Defect rates\n   - Customer satisfaction\n4. Risks and Issues\n   - Current blockers\n   - Potential risks\n   - Mitigation strategies\n5. Upcoming Milestones\n   - Next deliverables\n   - Key dates\n   - Resource requirements\n6. Recommendations\n   - Process improvements\n   - Resource adjustments\n   - Timeline modifications\n\nTailor the language and detail level for the specified audience.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateTaskEstimationPrompt(args: any): Promise<PromptContent> {\n    const { task_description, board_id, complexity } = args;\n\n    if (!task_description) {\n      throw new Error('task_description is required');\n    }\n\n    let historicalContext = '';\n    if (board_id) {\n      const recentTasks = await this.services.taskService.getTasks({\n        board_id,\n        limit: 50,\n        sortBy: 'updated_at',\n        sortOrder: 'desc',\n      });\n\n      historicalContext = `\\nRecent Similar Tasks:\\n${String(String(JSON.stringify(recentTasks.slice(0, 10), null, 2)))}`;\n    }\n\n    const complexityInfo = complexity ? `\\nPerceived Complexity: ${String(complexity)}` : '';\n\n    return {\n      description: 'Help estimate task effort and timeline',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please help estimate the effort and timeline for this task:\n\nTask Description:\n${String(task_description)}${String(complexityInfo)}${String(historicalContext)}\n\nPlease provide:\n1. Effort Estimation\n   - Story points or time estimate\n   - Confidence level (low/medium/high)\n   - Factors affecting the estimate\n2. Timeline Estimation\n   - Optimistic scenario\n   - Most likely scenario\n   - Pessimistic scenario\n3. Breakdown of Work\n   - Major components or phases\n   - Dependencies and prerequisites\n   - Testing and review time\n4. Risk Factors\n   - Technical risks\n   - Resource risks\n   - External dependencies\n5. Estimation Methodology\n   - Comparison to similar tasks\n   - Bottom-up vs top-down approach\n   - Assumptions made\n6. Recommendations\n   - Ways to reduce uncertainty\n   - Prototype or spike work needed\n   - Alternative approaches\n\nBase your estimates on the historical data provided and industry best practices.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateWorkflowOptimizationPrompt(args: any): Promise<PromptContent> {\n    const { board_id, optimization_goal } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: true,\n      days_back: 30,\n      max_items: 200,\n      include_metrics: true,\n      detail_level: 'comprehensive',\n    });\n\n    const analytics = await this.services.boardService.getBoardWithStats(board_id);\n\n    const goalInfo = optimization_goal ? `\\nOptimization Goal: ${String(optimization_goal)}` : '';\n\n    return {\n      description: 'Analyze workflow and suggest optimizations',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please analyze the current workflow and suggest optimizations:\n\nProject Context:\n${String(context)}\n\nAnalytics:\n${String(String(JSON.stringify(analytics, null, 2)))}${String(goalInfo)}\n\nPlease provide:\n1. Current Workflow Analysis\n   - Process flow mapping\n   - Bottlenecks and delays\n   - Inefficiencies identified\n   - Time spent in each stage\n2. Optimization Opportunities\n   - Process improvements\n   - Automation possibilities\n   - Tool and technology upgrades\n   - Skill development needs\n3. Specific Recommendations\n   - Short-term improvements (quick wins)\n   - Medium-term optimizations\n   - Long-term strategic changes\n4. Implementation Plan\n   - Priority order of changes\n   - Resource requirements\n   - Timeline for implementation\n   - Success metrics\n5. Risk Assessment\n   - Potential disruptions\n   - Change management considerations\n   - Rollback strategies\n6. Expected Benefits\n   - Quantified improvements\n   - ROI estimation\n   - Quality improvements\n\nFocus on the specified optimization goal while considering overall workflow efficiency.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateStandupPreparationPrompt(args: any): Promise<PromptContent> {\n    const { board_id, team_member, since_date } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    const sinceDate = since_date\n      ? new Date(since_date)\n      : new Date(Date.now() - 24 * 60 * 60 * 1000);\n\n    const recentTasks = await this.services.taskService.getTasks({\n      board_id,\n      limit: 100,\n      sortBy: 'updated_at',\n      sortOrder: 'desc',\n    });\n\n    // Filter tasks updated since the specified date\n    const updatedTasks = recentTasks.filter(task => new Date(task.updated_at) >= sinceDate);\n\n    // Filter by team member if specified\n    const relevantTasks = team_member\n      ? updatedTasks.filter(task => task.assignee === team_member)\n      : updatedTasks;\n\n    const memberInfo = team_member ? `\\nTeam Member: ${String(team_member)}` : '';\n\n    return {\n      description: 'Prepare content for daily standup meeting',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please help prepare standup content based on recent activity:\n\nRecent Task Updates (since ${String(String(sinceDate.toISOString()))}):\n${String(String(JSON.stringify(relevantTasks, null, 2)))}${String(memberInfo)}\n\nPlease provide standup talking points for:\n\n1. YESTERDAY/RECENT ACCOMPLISHMENTS\n   - Tasks completed\n   - Significant progress made\n   - Milestones reached\n   - Problems solved\n\n2. TODAY'S PLAN\n   - Tasks to work on\n   - Priorities for the day\n   - Expected deliverables\n   - Key focus areas\n\n3. BLOCKERS AND IMPEDIMENTS\n   - Current blockers\n   - Help needed from team\n   - External dependencies\n   - Risks or concerns\n\n4. TEAM UPDATES\n   - Cross-team dependencies\n   - Important announcements\n   - Schedule changes\n   - Resource needs\n\nFormat the content to be concise and suitable for a brief standup meeting (2-3 minutes per person).`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateRetrospectiveInsightsPrompt(args: any): Promise<PromptContent> {\n    const { board_id, timeframe, focus_areas } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: true,\n      days_back: 30,\n      max_items: 200,\n      include_metrics: true,\n      detail_level: 'comprehensive',\n    });\n\n    const analytics = await this.services.boardService.getBoardWithStats(board_id);\n\n    const timeframeInfo = timeframe ? `\\nTimeframe: ${String(timeframe)}` : '';\n    const focusInfo = focus_areas ? `\\nFocus Areas: ${String(focus_areas)}` : '';\n\n    return {\n      description: 'Generate insights for retrospective meeting',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `Please generate insights and talking points for a retrospective meeting:\n\nProject Context:\n${String(context)}\n\nAnalytics:\n${String(String(JSON.stringify(analytics, null, 2)))}${String(timeframeInfo)}${String(focusInfo)}\n\nPlease provide retrospective insights organized by:\n\n1. WHAT WENT WELL\n   - Successful deliveries and achievements\n   - Effective processes and practices\n   - Team collaboration highlights\n   - Tool and technology wins\n   - Quality improvements\n\n2. WHAT COULD BE IMPROVED\n   - Process bottlenecks and pain points\n   - Communication challenges\n   - Technical debt or quality issues\n   - Resource or capacity constraints\n   - Tool or technology limitations\n\n3. WHAT WE LEARNED\n   - New insights about the project\n   - Technical discoveries\n   - Process learnings\n   - Team dynamics observations\n   - Customer feedback insights\n\n4. ACTION ITEMS\n   - Specific, actionable improvements\n   - Process changes to implement\n   - Tools or training needed\n   - Experiments to try\n   - Metrics to track\n\n5. METRICS AND TRENDS\n   - Velocity and throughput analysis\n   - Quality metrics\n   - Team satisfaction indicators\n   - Customer satisfaction trends\n\nFormat the insights to encourage constructive discussion and actionable outcomes.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateTaskPlanningPrompt(args: any): Promise<PromptContent> {\n    const board_id = args.board_id ?? args.boardId;\n    const planning_horizon = args.planning_horizon ?? args.planningHorizon;\n    const focus_area = args.focus_area ?? args.focusArea;\n\n    if (!board_id) {\n      throw new Error('board_id (or boardId) is required');\n    }\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: false,\n      days_back: 14,\n      max_items: 100,\n    });\n\n    const horizon = planning_horizon ?? 'sprint';\n    const focus = focus_area ? ` with focus on ${String(focus_area)}` : '';\n\n    return {\n      description: 'Generate a comprehensive task planning strategy',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `You are a project planning assistant. Help create an effective task plan for the ${String(horizon)}${String(focus)}.\n\nCurrent Context:\n${String(context)}\n\nCreate a comprehensive task plan that includes:\n1. Priority assessment of existing tasks\n2. Recommended task sequencing\n3. Capacity planning considerations\n4. Risk assessment and mitigation\n5. Dependencies and blocking factors\n\nFocus on actionable recommendations that will improve team productivity and project outcomes.`,\n          },\n        },\n      ],\n    };\n  }\n\n  private generateTaskBreakdownBasicPrompt(args: any): PromptContent {\n    // Handle both task_description and taskId (if taskId is provided, create a generic description)\n    const task_description =\n      args.task_description ||\n      (args.taskId ? `Task ID: ${String(String(args.taskId))}` : args.description);\n    const complexity_level = args.complexity_level ?? args.complexity;\n\n    if (!task_description) {\n      throw new Error('task_description (or taskId) is required');\n    }\n\n    const complexity = complexity_level ?? 'medium';\n\n    return {\n      description: 'Break down complex tasks into manageable subtasks',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `You are a task breakdown specialist. Help break down this complex task into manageable subtasks.\n\nTask to Break Down: \"${String(task_description)}\"\nTarget Complexity Level: ${String(complexity)}\n\nPlease provide:\n1. A logical breakdown of the task into 3-7 subtasks\n2. Estimated effort for each subtask\n3. Dependencies between subtasks\n4. Acceptance criteria for each subtask\n5. Recommended order of execution\n\nMake sure each subtask is:\n- Specific and actionable\n- Testable with clear completion criteria\n- Appropriately sized for the target complexity\n- Independent where possible`,\n          },\n        },\n      ],\n    };\n  }\n\n  private async generateSprintPlanningBasicPrompt(args: any): Promise<PromptContent> {\n    const board_id = args.board_id ?? args.boardId;\n    const sprint_duration = args.sprint_duration ?? args.sprintDuration;\n    const team_capacity = args.team_capacity ?? args.teamCapacity;\n\n    if (!board_id) {\n      throw new Error('board_id (or boardId) is required');\n    }\n\n    const duration = sprint_duration ?? 14;\n    const capacity = team_capacity ?? 'standard team capacity';\n\n    const context = await this.services.contextService.getProjectContext({\n      include_completed: false,\n      days_back: 30,\n      max_items: 100,\n    });\n\n    return {\n      description: 'Generate sprint planning recommendations',\n      messages: [\n        {\n          role: 'user',\n          content: {\n            type: 'text',\n            text: `You are a sprint planning facilitator. Help plan an effective ${String(duration)}-day sprint.\n\nCurrent Project State:\n${String(context)}\n\nTeam Capacity: ${String(capacity)}\n\nPlease provide:\n1. Sprint goal recommendation\n2. Task prioritization for the sprint\n3. Capacity allocation suggestions\n4. Risk assessment for the sprint\n5. Success metrics to track\n6. Recommended scope adjustments if needed\n\nFocus on creating a realistic, achievable sprint plan that balances ambition with deliverability.`,\n          },\n        },\n      ],\n    };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/mcp/resources.ts",
    "messages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'listResources'.",
        "line": 17,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 17,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 193,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 193,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5767, 5770], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5767, 5770], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 194,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 194,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 196,
        "column": 74,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 196,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 196,
        "column": 84,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 196,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 198,
        "column": 69,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 198,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 201,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 201,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 204,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 204,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 204,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 204,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 211,
        "column": 15,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 211,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 211,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 211,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 224,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 224,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 224,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 224,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 257,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 257,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7338, 7341], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7338, 7341], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 258,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 258,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 260,
        "column": 72,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 260,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 260,
        "column": 82,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 260,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 262,
        "column": 68,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 262,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 266,
        "column": 66,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 266,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 266,
        "column": 76,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 266,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 267,
        "column": 63,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 267,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 267,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 267,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 282,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 282,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 284,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 284,
        "endColumn": 31
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 286,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 286,
        "endColumn": 82
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 301,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 301,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 316,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 316,
        "endColumn": 28
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 319,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 319,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 319,
        "column": 37,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 319,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 319,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 319,
        "endColumn": 49
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 320,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 324,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 340,
        "column": 75,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 340,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 360,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 360,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10157, 10160], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10157, 10160], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 361,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 361,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 362,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 362,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .params on an `any` value.",
        "line": 362,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 362,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 367,
        "column": 67,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 367,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 373,
        "column": 13,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 373,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 399,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 399,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11029, 11032], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11029, 11032], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 400,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 400,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 433,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 433,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11734, 11737], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11734, 11737], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 434,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 434,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 434,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 434,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 435,
        "column": 76,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 435,
        "endColumn": 88
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 435,
        "column": 86,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 435,
        "endColumn": 88
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 445,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 445,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12133, 12136], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12133, 12136], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 446,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 446,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 446,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 446,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 460,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 460,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 460,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 460,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 461,
        "column": 73,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 461,
        "endColumn": 85
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 461,
        "column": 83,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 461,
        "endColumn": 85
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 477,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 477,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13086, 13089], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13086, 13089], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 478,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 478,
        "endColumn": 29
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 480,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 486,
        "endColumn": 12
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 495,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 495,
        "endColumn": 84
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 496,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 496,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 496,
        "column": 43,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 496,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13730, 13733], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13730, 13733], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .total_tasks on an `any` value.",
        "line": 513,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 513,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [task.status] on an `any` value.",
        "line": 514,
        "column": 33,
        "nodeType": "MemberExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 514,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .high_priority on an `any` value.",
        "line": 517,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 517,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .overdue on an `any` value.",
        "line": 521,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 521,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 539,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 539,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 543,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 543,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14988, 14991], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14988, 14991], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .action on an `any` value.",
        "line": 544,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 544,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 544,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 544,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 545,
        "column": 74,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 545,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 545,
        "column": 84,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 545,
        "endColumn": 86
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 547,
        "column": 69,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 547,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 551,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 551,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 551,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 551,
        "endColumn": 31
      }
    ],
    "suppressedMessages": [],
    "errorCount": 16,
    "fatalErrorCount": 0,
    "warningCount": 55,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Resource } from '@modelcontextprotocol/sdk/types.js';\nimport { logger } from '@/utils/logger';\nimport type { MCPServices } from './tools';\n\nexport interface ResourceContent {\n  text: string;\n  mimeType?: string;\n}\n\nexport class MCPResourceRegistry {\n  private readonly services: MCPServices;\n\n  constructor(services: MCPServices) {\n    this.services = services;\n  }\n\n  listResources(): Promise<Resource[]> {\n    return [\n      {\n        uri: 'kanban://boards',\n        name: 'All Boards',\n        description: 'List of all kanban boards with their metadata',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://boards/{board_id}',\n        name: 'Board Details',\n        description: 'Detailed information about a specific board including columns and tasks',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://boards/{board_id}/tasks',\n        name: 'Board Tasks',\n        description: 'All tasks within a specific board',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://tasks',\n        name: 'All Tasks',\n        description: 'List of all tasks across all boards',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://tasks/{task_id}',\n        name: 'Task Details',\n        description:\n          'Detailed information about a specific task including subtasks, dependencies, notes, and tags',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://tasks/blocked',\n        name: 'Blocked Tasks',\n        description: 'All tasks that are currently blocked',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://tasks/overdue',\n        name: 'Overdue Tasks',\n        description: 'All tasks that are past their due date',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://tasks/priority/{level}',\n        name: 'Tasks by Priority',\n        description: 'Tasks filtered by priority level (1-5)',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://notes',\n        name: 'All Notes',\n        description: 'All notes across all tasks',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://notes/search?q={query}',\n        name: 'Search Notes',\n        description: 'Full-text search results for notes',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://tags',\n        name: 'All Tags',\n        description: 'List of all tags with usage statistics',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://tags/hierarchy',\n        name: 'Tag Hierarchy',\n        description: 'Hierarchical structure of all tags',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://analytics/boards/{board_id}',\n        name: 'Board Analytics',\n        description: 'Performance analytics and insights for a specific board',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://context/project/{board_id}',\n        name: 'Project Context',\n        description: 'AI-optimized context for a project/board',\n        mimeType: 'text/plain',\n      },\n      {\n        uri: 'kanban://context/task/{task_id}',\n        name: 'Task Context',\n        description: 'AI-optimized context for a specific task',\n        mimeType: 'text/plain',\n      },\n      {\n        uri: 'kanban://reports/summary',\n        name: 'System Summary',\n        description: 'Overall system summary with key metrics and recent activity',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://reports/workload',\n        name: 'Workload Report',\n        description: 'Current workload distribution across users and boards',\n        mimeType: 'application/json',\n      },\n      {\n        uri: 'kanban://exports/board/{board_id}',\n        name: 'Board Export',\n        description: 'Complete board data export including all tasks, notes, and metadata',\n        mimeType: 'application/json',\n      },\n    ];\n  }\n\n  async readResource(uri: string): Promise<ResourceContent> {\n    logger.info('MCP resource read', { uri });\n\n    try {\n      const parsedUri = MCPResourceRegistry.parseUri(uri);\n\n      switch (parsedUri.type) {\n        case 'boards':\n          return await this.readBoards(parsedUri);\n        case 'tasks':\n          return await this.readTasks(parsedUri);\n        case 'notes':\n          return await this.readNotes(parsedUri);\n        case 'tags':\n          return await this.readTags(parsedUri);\n        case 'analytics':\n          return await this.readAnalytics(parsedUri);\n        case 'context':\n          return await this.readContext(parsedUri);\n        case 'reports':\n          return await this.readReports(parsedUri);\n        case 'exports':\n          return await this.readExports(parsedUri);\n        default:\n          throw new Error(`Unknown resource type: ${String(String(parsedUri.type))}`);\n      }\n    } catch (error) {\n      logger.error('Resource read error', { uri, error });\n      throw error;\n    }\n  }\n\n  private static parseUri(uri: string): {\n    type: string;\n    action?: string;\n    id: string;\n    params?: Record<string, string>;\n  } {\n    const url = new URL(uri);\n    const pathParts = url.pathname.split('/').filter(Boolean);\n\n    const [type, action, id] = pathParts;\n    const params: Record<string, string> = {};\n\n    url.searchParams.forEach((value, key) => {\n      params[key] = value;\n    });\n\n    const result: { type: string; action?: string; id: string; params?: Record<string, string> } = {\n      type: type ?? '',\n      id: id ?? '',\n      params,\n    };\n\n    if (action) {\n      result.action = action;\n    }\n\n    return result;\n  }\n\n  // Resource readers\n  private async readBoards(parsedUri: any): Promise<ResourceContent> {\n    if (parsedUri.id) {\n      // Specific board\n      const board = await this.services.boardService.getBoardWithColumns(parsedUri.id);\n      if (!board) {\n        throw new Error(`Board not found: ${String(String(parsedUri.id))}`);\n      }\n\n      if (parsedUri.action === 'tasks') {\n        // Board tasks\n        const tasks = await this.services.taskService.getTasks({\n          board_id: parsedUri.id,\n          limit: 1000,\n        });\n\n        return {\n          text: JSON.stringify(\n            {\n              board_id: parsedUri.id,\n              board_name: board.name,\n              tasks,\n              count: tasks.length,\n            },\n            null,\n            2\n          ),\n          mimeType: 'application/json',\n        };\n      }\n      // Board details\n      const tasks = await this.services.taskService.getTasks({\n        board_id: parsedUri.id,\n        limit: 100,\n      });\n\n      return {\n        text: JSON.stringify(\n          {\n            ...board,\n            tasks: tasks.slice(0, 10), // Include only first 10 tasks for overview\n            task_count: tasks.length,\n          },\n          null,\n          2\n        ),\n        mimeType: 'application/json',\n      };\n    }\n    // All boards\n    const boards = await this.services.boardService.getBoards({ limit: 100 });\n\n    return {\n      text: JSON.stringify(\n        {\n          boards,\n          count: boards.length,\n        },\n        null,\n        2\n      ),\n      mimeType: 'application/json',\n    };\n  }\n\n  private async readTasks(parsedUri: any): Promise<ResourceContent> {\n    if (parsedUri.id) {\n      // Specific task\n      const task = await this.services.taskService.getTaskWithSubtasks(parsedUri.id);\n      if (!task) {\n        throw new Error(`Task not found: ${String(String(parsedUri.id))}`);\n      }\n\n      // Get additional data\n      const notes = await this.services.noteService.getTaskNotes(parsedUri.id, { limit: 50 });\n      const tags = await this.services.tagService.getTaskTags(parsedUri.id);\n\n      return {\n        text: JSON.stringify(\n          {\n            ...task,\n            notes,\n            tags,\n          },\n          null,\n          2\n        ),\n        mimeType: 'application/json',\n      };\n    }\n    if (parsedUri.action) {\n      // Task collections\n      switch (parsedUri.action) {\n        case 'blocked':\n          const blockedTasks = await this.services.taskService.getBlockedTasks();\n          return {\n            text: JSON.stringify(\n              {\n                type: 'blocked_tasks',\n                tasks: blockedTasks,\n                count: blockedTasks.length,\n              },\n              null,\n              2\n            ),\n            mimeType: 'application/json',\n          };\n\n        case 'overdue':\n          const overdueTasks = await this.services.taskService.getOverdueTasks();\n          return {\n            text: JSON.stringify(\n              {\n                type: 'overdue_tasks',\n                tasks: overdueTasks,\n                count: overdueTasks.length,\n              },\n              null,\n              2\n            ),\n            mimeType: 'application/json',\n          };\n\n        case 'priority':\n          if (!parsedUri.id) {\n            throw new Error('Priority level required');\n          }\n          const priority = parseInt(parsedUri.id, 10);\n          const priorityTasks = await this.services.taskService.getTasks({\n            priority_min: priority,\n            priority_max: priority,\n            limit: 200,\n          });\n          return {\n            text: JSON.stringify(\n              {\n                type: 'priority_tasks',\n                priority_level: priority,\n                tasks: priorityTasks,\n                count: priorityTasks.length,\n              },\n              null,\n              2\n            ),\n            mimeType: 'application/json',\n          };\n\n        default:\n          throw new Error(`Unknown task action: ${String(String(parsedUri.action))}`);\n      }\n    } else {\n      // All tasks\n      const tasks = await this.services.taskService.getTasks({ limit: 500 });\n\n      return {\n        text: JSON.stringify(\n          {\n            tasks,\n            count: tasks.length,\n          },\n          null,\n          2\n        ),\n        mimeType: 'application/json',\n      };\n    }\n  }\n\n  private async readNotes(parsedUri: any): Promise<ResourceContent> {\n    if (parsedUri.action === 'search') {\n      const query = parsedUri.params.q;\n      if (!query) {\n        throw new Error('Search query required');\n      }\n\n      const notes = await this.services.noteService.searchNotes({ query, limit: 100 });\n\n      return {\n        text: JSON.stringify(\n          {\n            type: 'search_results',\n            query,\n            notes,\n            count: notes.length,\n          },\n          null,\n          2\n        ),\n        mimeType: 'application/json',\n      };\n    }\n    // All notes\n    const notes = await this.services.noteService.getNotes({ limit: 500 });\n\n    return {\n      text: JSON.stringify(\n        {\n          notes,\n          count: notes.length,\n        },\n        null,\n        2\n      ),\n      mimeType: 'application/json',\n    };\n  }\n\n  private async readTags(parsedUri: any): Promise<ResourceContent> {\n    if (parsedUri.action === 'hierarchy') {\n      const tagTree = await this.services.tagService.getTagHierarchy();\n\n      return {\n        text: JSON.stringify(\n          {\n            type: 'tag_hierarchy',\n            tree: tagTree,\n          },\n          null,\n          2\n        ),\n        mimeType: 'application/json',\n      };\n    }\n    // All tags\n    const tags = await this.services.tagService.getTags({\n      limit: 200,\n    });\n\n    return {\n      text: JSON.stringify(\n        {\n          tags,\n          count: tags.length,\n        },\n        null,\n        2\n      ),\n      mimeType: 'application/json',\n    };\n  }\n\n  private async readAnalytics(parsedUri: any): Promise<ResourceContent> {\n    if (parsedUri.action === 'boards' && parsedUri.id) {\n      const analytics = await this.services.boardService.getBoardWithStats(parsedUri.id);\n\n      return {\n        text: JSON.stringify(analytics, null, 2),\n        mimeType: 'application/json',\n      };\n    }\n    throw new Error('Board ID required for analytics');\n  }\n\n  private async readContext(parsedUri: any): Promise<ResourceContent> {\n    if (parsedUri.action === 'project' && parsedUri.id) {\n      const context = await this.services.contextService.getProjectContext({\n        include_completed: false,\n        days_back: 30,\n        max_items: 100,\n        include_metrics: true,\n        detail_level: 'detailed',\n      });\n\n      return {\n        text: JSON.stringify(context, null, 2),\n        mimeType: 'application/json',\n      };\n    }\n    if (parsedUri.action === 'task' && parsedUri.id) {\n      const context = await this.services.contextService.getTaskContext(parsedUri.id, {\n        include_completed: true,\n        days_back: 30,\n        max_items: 100,\n        include_metrics: true,\n        detail_level: 'detailed',\n      });\n\n      return {\n        text: JSON.stringify(context, null, 2),\n        mimeType: 'application/json',\n      };\n    }\n    throw new Error('Invalid context resource URI');\n  }\n\n  private async readReports(parsedUri: any): Promise<ResourceContent> {\n    switch (parsedUri.action) {\n      case 'summary':\n        const summary = await this.services.contextService.getProjectContext({\n          include_completed: true,\n          days_back: 7,\n          max_items: 50,\n          include_metrics: true,\n          detail_level: 'summary',\n        });\n\n        return {\n          text: JSON.stringify(summary, null, 2),\n          mimeType: 'application/json',\n        };\n\n      case 'workload':\n        // Get all tasks grouped by assignee\n        const allTasks = await this.services.taskService.getTasks({ limit: 1000 });\n        const workloadMap: Record<string, any> = {};\n\n        allTasks.forEach(task => {\n          const assignee = task.assignee ?? 'unassigned';\n          if (!workloadMap[assignee]) {\n            workloadMap[assignee] = {\n              assignee,\n              total_tasks: 0,\n              todo: 0,\n              in_progress: 0,\n              done: 0,\n              blocked: 0,\n              overdue: 0,\n              high_priority: 0,\n            };\n          }\n\n          workloadMap[assignee].total_tasks++;\n          workloadMap[assignee][task.status]++;\n\n          if (task.priority >= 4) {\n            workloadMap[assignee].high_priority++;\n          }\n\n          if (task.due_date && new Date(task.due_date) < new Date() && task.status !== 'done') {\n            workloadMap[assignee].overdue++;\n          }\n        });\n\n        return {\n          text: JSON.stringify(\n            {\n              type: 'workload_report',\n              workload: Object.values(workloadMap),\n              generated_at: new Date().toISOString(),\n            },\n            null,\n            2\n          ),\n          mimeType: 'application/json',\n        };\n\n      default:\n        throw new Error(`Unknown report type: ${String(String(parsedUri.action))}`);\n    }\n  }\n\n  private async readExports(parsedUri: any): Promise<ResourceContent> {\n    if (parsedUri.action === 'board' && parsedUri.id) {\n      const board = await this.services.boardService.getBoardWithColumns(parsedUri.id);\n      if (!board) {\n        throw new Error(`Board not found: ${String(String(parsedUri.id))}`);\n      }\n\n      const tasks = await this.services.taskService.getTasks({\n        board_id: parsedUri.id,\n        limit: 10000,\n      });\n      const allNotes = [];\n      const allTags = [];\n\n      // Get all notes and tags for tasks\n      await Promise.all(\n        tasks.map(async task => {\n          await this.services.noteService.getTaskNotes(task.id, { limit: 100 });\n        })\n      );\n\n      return {\n        text: JSON.stringify(\n          {\n            export_type: 'board_complete',\n            board,\n            tasks,\n            notes: allNotes,\n            tags: allTags,\n            exported_at: new Date().toISOString(),\n            counts: {\n              tasks: tasks.length,\n              notes: allNotes.length,\n              tags: allTags.length,\n            },\n          },\n          null,\n          2\n        ),\n        mimeType: 'application/json',\n      };\n    }\n    throw new Error('Board ID required for export');\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/mcp/server.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 231,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 231,
        "endColumn": 35
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 279,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 279,
        "endColumn": 25
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 283,
        "column": 9,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 283,
        "endColumn": 25
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'getServerInfo'.",
        "line": 395,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 395,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * MCP Kanban Server - Model Context Protocol server implementation\n *\n * @module mcp/server\n * @description Provides MCP (Model Context Protocol) server implementation for the Kanban system.\n * This allows AI agents like Claude to interact with the kanban board through standardized\n * tools, resources, and prompts. The server handles tool execution, resource access, and\n * prompt generation for AI-powered task management workflows.\n *\n * @example\n * ```typescript\n * import { mcpServer } from '@/mcp/server';\n *\n * // Start the MCP server\n * await mcpServer.start();\n *\n * // The server will be available via stdio transport\n * // AI agents can now call tools like:\n * // - create_task\n * // - get_context\n * // - search_tasks\n * ```\n */\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\n\nimport { config } from '@/config';\nimport { logger } from '@/utils/logger';\nimport { dbConnection } from '@/database/connection';\nimport { TaskService } from '@/services/TaskService';\nimport { BoardService } from '@/services/BoardService';\nimport { NoteService } from '@/services/NoteService';\nimport { TagService } from '@/services/TagService';\nimport { ContextService } from '@/services/ContextService';\nimport { MCPToolRegistry } from './tools';\nimport { MCPResourceRegistry } from './resources';\nimport { MCPPromptRegistry } from './prompts';\n\n/**\n * MCP Kanban Server - Main server class for Model Context Protocol integration\n *\n * @class MCPKanbanServer\n * @description Implements the MCP server specification to provide AI agents with\n * access to kanban functionality through tools, resources, and prompts. Handles\n * all MCP protocol communications and delegates actual work to service layers.\n */\nexport class MCPKanbanServer {\n  private readonly server: Server;\n\n  private readonly taskService: TaskService;\n\n  private readonly boardService: BoardService;\n\n  private readonly noteService: NoteService;\n\n  private readonly tagService: TagService;\n\n  private readonly contextService: ContextService;\n\n  private readonly toolRegistry: MCPToolRegistry;\n\n  private readonly resourceRegistry: MCPResourceRegistry;\n\n  private readonly promptRegistry: MCPPromptRegistry;\n\n  /**\n   * Creates a new MCP Kanban Server instance\n   *\n   * @description Initializes the MCP server with kanban capabilities:\n   * - Tools: For task manipulation and querying\n   * - Resources: For accessing board and task data\n   * - Prompts: For AI-guided task management workflows\n   */\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'mcp-kanban-server',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n          resources: {},\n          prompts: {},\n        },\n      }\n    );\n\n    // Initialize services\n    this.taskService = new TaskService(dbConnection);\n    this.boardService = new BoardService(dbConnection);\n    this.noteService = new NoteService(dbConnection);\n    this.tagService = new TagService(dbConnection);\n    this.contextService = new ContextService(\n      dbConnection,\n      this.boardService,\n      this.taskService,\n      this.noteService,\n      this.tagService\n    );\n\n    // Initialize registries\n    this.toolRegistry = new MCPToolRegistry({\n      taskService: this.taskService,\n      boardService: this.boardService,\n      noteService: this.noteService,\n      tagService: this.tagService,\n      contextService: this.contextService,\n    });\n\n    this.resourceRegistry = new MCPResourceRegistry({\n      taskService: this.taskService,\n      boardService: this.boardService,\n      noteService: this.noteService,\n      tagService: this.tagService,\n      contextService: this.contextService,\n    });\n\n    this.promptRegistry = new MCPPromptRegistry({\n      taskService: this.taskService,\n      boardService: this.boardService,\n      noteService: this.noteService,\n      tagService: this.tagService,\n      contextService: this.contextService,\n    });\n\n    this.setupHandlers();\n  }\n\n  /**\n   * Sets up all MCP protocol request handlers\n   *\n   * @private\n   * @description Configures handlers for:\n   * - Tool listing and execution\n   * - Resource listing and reading\n   * - Prompt listing and generation\n   * - Error handling and logging\n   */\n  private setupHandlers(): void {\n    // Tool handlers\n    this.server.setRequestHandler(ListToolsRequestSchema, async () => {\n      const tools = await this.toolRegistry.listTools();\n      return { tools };\n    });\n\n    this.server.setRequestHandler(CallToolRequestSchema, async request => {\n      const { name, arguments: args } = request.params;\n\n      try {\n        const result = await this.toolRegistry.callTool(name, args ?? {});\n        return {\n          content: [\n            {\n              type: 'text',\n              text: JSON.stringify(result, null, 2),\n            },\n          ],\n        };\n      } catch (error) {\n        logger.error('MCP tool call failed', { toolName: name, args, error });\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error: ${String(String(error instanceof Error ? error.message : 'Unknown error'))}`,\n            },\n          ],\n          isError: true,\n        };\n      }\n    });\n\n    // Resource handlers\n    this.server.setRequestHandler(ListResourcesRequestSchema, async () => {\n      const resources = await this.resourceRegistry.listResources();\n      return { resources };\n    });\n\n    this.server.setRequestHandler(ReadResourceRequestSchema, async request => {\n      const { uri } = request.params;\n\n      try {\n        const resource = await this.resourceRegistry.readResource(uri);\n        return {\n          contents: [\n            {\n              uri,\n              mimeType: resource.mimeType ?? 'application/json',\n              text: resource.text,\n            },\n          ],\n        };\n      } catch (error) {\n        logger.error('MCP resource read failed', { uri, error });\n        throw error;\n      }\n    });\n\n    // Prompt handlers\n    this.server.setRequestHandler(ListPromptsRequestSchema, async () => {\n      const prompts = await this.promptRegistry.listPrompts();\n      return { prompts };\n    });\n\n    this.server.setRequestHandler(GetPromptRequestSchema, async request => {\n      const { name, arguments: args } = request.params;\n\n      try {\n        const prompt = await this.promptRegistry.getPrompt(name, args ?? {});\n        return {\n          description: prompt.description,\n          messages: prompt.messages,\n        };\n      } catch (error) {\n        logger.error('MCP prompt get failed', { promptName: name, args, error });\n        throw error;\n      }\n    });\n\n    // Error handler\n    this.server.onerror = error => {\n      logger.error('MCP server error', { error });\n    };\n  }\n\n  /**\n   * Starts the MCP server and establishes transport connection\n   *\n   * @returns Promise that resolves when server is fully started\n   *\n   * @throws {Error} When database initialization fails\n   * @throws {Error} When MCP transport connection fails\n   *\n   * @description This method:\n   * - Initializes the database connection\n   * - Sets up stdio transport for CLI communication\n   * - Registers signal handlers for graceful shutdown\n   * - Logs server startup information\n   *\n   * @example\n   * ```typescript\n   * const server = new MCPKanbanServer();\n   * await server.start();\n   * ```\n   */\n  async start(): Promise<void> {\n    try {\n      logger.info('Starting MCP Kanban server...');\n\n      // Initialize database connection\n      if (!dbConnection.isConnected()) {\n        await dbConnection.initialize();\n      }\n\n      // Connect to transport (stdio for CLI usage)\n      const transport = new StdioServerTransport();\n      await this.server.connect(transport);\n\n      logger.info('MCP Kanban server started successfully', {\n        name: config.mcp.serverName,\n        version: config.mcp.serverVersion,\n        tools: (await this.toolRegistry.listTools()).length,\n        resources: (await this.resourceRegistry.listResources()).length,\n        prompts: (await this.promptRegistry.listPrompts()).length,\n      });\n\n      // Keep the process running\n      process.on('SIGINT', () => {\n        void this.stop();\n      });\n\n      process.on('SIGTERM', () => {\n        void this.stop();\n      });\n    } catch (error) {\n      logger.error('Failed to start MCP server', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Gracefully stops the MCP server and cleans up resources\n   *\n   * @returns Promise that resolves when server is fully stopped\n   *\n   * @description This method:\n   * - Closes the MCP server connection\n   * - Closes the database connection\n   * - Logs shutdown information\n   * - Exits the process with appropriate code\n   *\n   * @example\n   * ```typescript\n   * await server.stop();\n   * ```\n   */\n  async stop(exitProcess: boolean = true): Promise<void> {\n    try {\n      logger.info('Stopping MCP Kanban server...');\n\n      await this.server.close();\n\n      if (dbConnection.isConnected()) {\n        await dbConnection.close();\n      }\n\n      logger.info('MCP Kanban server stopped');\n\n      if (exitProcess) {\n        process.exit(0);\n      }\n    } catch (error) {\n      logger.error('Error stopping MCP server', { error });\n      if (exitProcess) {\n        process.exit(1);\n      }\n    }\n  }\n\n  /**\n   * Performs a comprehensive health check of the MCP server\n   *\n   * @returns Promise resolving to health status with detailed metrics\n   *\n   * @description Checks:\n   * - Database connection health\n   * - Number of available tools, resources, and prompts\n   * - Server uptime\n   * - Overall system status\n   *\n   * @example\n   * ```typescript\n   * const health = await server.healthCheck();\n   * logger.log(`Server status: ${String(String(health.status))}`);\n   * logger.log(`Tools available: ${String(String(health.tools))}`);\n   * ```\n   */\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'unhealthy';\n    database: boolean;\n    tools: number;\n    resources: number;\n    prompts: number;\n    uptime: number;\n  }> {\n    try {\n      const dbHealth = await dbConnection.healthCheck();\n      const tools = await this.toolRegistry.listTools();\n      const resources = await this.resourceRegistry.listResources();\n      const prompts = await this.promptRegistry.listPrompts();\n\n      return {\n        status: dbHealth.connected ? 'healthy' : 'unhealthy',\n        database: dbHealth.connected,\n        tools: tools.length,\n        resources: resources.length,\n        prompts: prompts.length,\n        uptime: process.uptime(),\n      };\n    } catch (error) {\n      logger.error('MCP health check failed', { error });\n      return {\n        status: 'unhealthy',\n        database: false,\n        tools: 0,\n        resources: 0,\n        prompts: 0,\n        uptime: process.uptime(),\n      };\n    }\n  }\n\n  /**\n   * Gets basic server information and capabilities\n   *\n   * @returns Server metadata including name, version, and capabilities\n   *\n   * @example\n   * ```typescript\n   * const info = server.getServerInfo();\n   * logger.log(`${String(String(info.name))} v${String(String(info.version))}`);\n   * logger.log(`Capabilities: ${String(String(info.capabilities.join(', ')))}`);\n   * ```\n   */\n  getServerInfo(): {\n    name: string;\n    version: string;\n    capabilities: string[];\n    description: string;\n  } {\n    return {\n      name: config.mcp.serverName,\n      version: config.mcp.serverVersion,\n      capabilities: ['tools', 'resources', 'prompts'],\n      description: 'MCP server for Kanban task management with AI integration',\n    };\n  }\n\n  /**\n   * Gets the tool registry for external access\n   *\n   * @returns The MCPToolRegistry instance\n   *\n   * @example\n   * ```typescript\n   * const tools = server.getToolRegistry();\n   * const toolList = await tools.listTools();\n   * ```\n   */\n  getToolRegistry(): MCPToolRegistry {\n    return this.toolRegistry;\n  }\n\n  /**\n   * Gets the resource registry for external access\n   *\n   * @returns The MCPResourceRegistry instance\n   */\n  getResourceRegistry(): MCPResourceRegistry {\n    return this.resourceRegistry;\n  }\n\n  /**\n   * Gets the prompt registry for external access\n   *\n   * @returns The MCPPromptRegistry instance\n   */\n  getPromptRegistry(): MCPPromptRegistry {\n    return this.promptRegistry;\n  }\n}\n\n// Create singleton instance\nexport const mcpServer = new MCPKanbanServer();\n\n// Start server if this file is run directly\nif (require.main === module) {\n  mcpServer.start().catch(error => {\n    logger.error('Failed to start MCP server:', error);\n    process.exit(1);\n  });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/mcp/tools.ts",
    "messages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'listTools'.",
        "line": 152,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 152,
        "endColumn": 12
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_subtasks' is not in camel case.",
        "line": 728,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 728,
        "endColumn": 25
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_dependencies' is not in camel case.",
        "line": 730,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 730,
        "endColumn": 36
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_notes' is not in camel case.",
        "line": 743,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 743,
        "endColumn": 22
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_tags' is not in camel case.",
        "line": 748,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 748,
        "endColumn": 21
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_columns' is not in camel case.",
        "line": 899,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 899,
        "endColumn": 24
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_tasks' is not in camel case.",
        "line": 911,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 911,
        "endColumn": 22
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'tag_ids' is not in camel case.",
        "line": 1073,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1073,
        "endColumn": 14
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'tag_id' is not in camel case.",
        "line": 1073,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1073,
        "endColumn": 25
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_history' is not in camel case.",
        "line": 1176,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1176,
        "endColumn": 24
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_related' is not in camel case.",
        "line": 1180,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1180,
        "endColumn": 24
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_blockers' is not in camel case.",
        "line": 1184,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1184,
        "endColumn": 25
      },
      {
        "ruleId": "no-nested-ternary",
        "severity": 2,
        "message": "Do not nest ternary expressions.",
        "line": 1216,
        "column": 18,
        "nodeType": "ConditionalExpression",
        "messageId": "noNestedTernary",
        "endLine": 1216,
        "endColumn": 88
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'blocked_tasks' is not in camel case.",
        "line": 1255,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1255,
        "endColumn": 24
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_reasons' is not in camel case.",
        "line": 1257,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1257,
        "endColumn": 26
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'overdue_tasks' is not in camel case.",
        "line": 1275,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1275,
        "endColumn": 24
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'days_overdue' is not in camel case.",
        "line": 1287,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1287,
        "endColumn": 36
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'days_overdue' is not in camel case.",
        "line": 1287,
        "column": 61,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1287,
        "endColumn": 73
      }
    ],
    "suppressedMessages": [],
    "errorCount": 18,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * MCP tool registry for kanban operations\n *\n * @module mcp/tools\n * @description Provides a comprehensive set of tools for AI agents to interact with the kanban system\n * through the Model Context Protocol. Includes tools for task management, board operations,\n * notes, tags, context generation, and analytics.\n *\n * @example\n * ```typescript\n * const registry = new MCPToolRegistry(services);\n *\n * // List available tools\n * const tools = await registry.listTools();\n *\n * // Execute a tool\n * const result = await registry.callTool('create_task', {\n *   title: 'New Feature',\n *   board_id: 'board123',\n *   priority: 3\n * });\n * ```\n */\n\nimport type { Tool } from '@modelcontextprotocol/sdk/types.js';\nimport { logger } from '@/utils/logger';\nimport type { TaskService, CreateTaskRequest } from '@/services/TaskService';\nimport type { BoardService } from '@/services/BoardService';\nimport type { NoteService } from '@/services/NoteService';\nimport type { TagService } from '@/services/TagService';\nimport type { ContextService } from '@/services/ContextService';\nimport type { Task, Note as NoteType, Tag as TagType } from '@/types';\nimport type {\n  MCPResponse as ToolResponse,\n  CreateTaskArgs,\n  UpdateTaskArgs,\n  GetTaskArgs,\n  ListTasksArgs,\n  SearchTasksArgs,\n  DeleteTaskArgs,\n  CreateBoardArgs,\n  GetBoardArgs,\n  ListBoardsArgs,\n  AddNoteArgs,\n  SearchNotesArgs,\n  CreateTagArgs,\n  AssignTagArgs,\n  GetProjectContextArgs,\n  GetTaskContextArgs,\n  AnalyzeBoardArgs,\n  GetBlockedTasksArgs,\n  GetOverdueTasksArgs,\n  TaskResponse,\n  TasksResponse,\n  BoardResponse,\n  BoardsResponse,\n  NoteResponse,\n  NotesResponse,\n  TagResponse,\n  GetTaskDetailedResponse,\n  ProjectContextResponse,\n  TaskContextResponse,\n  BoardAnalysisResponse,\n  BlockedTasksResponse,\n  OverdueTasksResponse,\n} from './types';\n\n/**\n * Collection of services required for MCP tool operations\n *\n * @interface MCPServices\n * @property {TaskService} taskService - Service for task operations\n * @property {BoardService} boardService - Service for board operations\n * @property {NoteService} noteService - Service for note operations\n * @property {TagService} tagService - Service for tag operations\n * @property {ContextService} contextService - Service for context generation\n */\nexport interface MCPServices {\n  taskService: TaskService;\n  boardService: BoardService;\n  noteService: NoteService;\n  tagService: TagService;\n  contextService: ContextService;\n}\n\n/**\n * Registry of MCP tools for kanban board operations\n *\n * @class MCPToolRegistry\n * @description Manages the registration and execution of MCP tools that AI agents can use\n * to interact with the kanban system. Provides tools for task management, board operations,\n * notes, tags, context generation, and analytics.\n *\n * Available tools:\n * - Task operations: create_task, update_task, get_task, list_tasks, search_tasks, delete_task\n * - Board operations: create_board, get_board, list_boards\n * - Note operations: add_note, search_notes\n * - Tag operations: create_tag, assign_tag\n * - Context tools: get_project_context, get_task_context\n * - Analytics: analyze_board, get_blocked_tasks, get_overdue_tasks\n *\n * @example\n * ```typescript\n * const registry = new MCPToolRegistry({\n *   taskService,\n *   boardService,\n *   noteService,\n *   tagService,\n *   contextService\n * });\n *\n * // Execute a tool\n * const result = await registry.callTool('create_task', {\n *   title: 'Implement feature',\n *   board_id: 'board123',\n *   status: 'todo'\n * });\n * ```\n */\nexport class MCPToolRegistry {\n  /** Services used by tools */\n  private readonly services: MCPServices;\n\n  /**\n   * Creates a new MCPToolRegistry instance\n   *\n   * @param {MCPServices} services - Collection of services for tool operations\n   */\n  constructor(services: MCPServices) {\n    this.services = services;\n  }\n\n  /**\n   * Lists all available MCP tools with their schemas\n   *\n   * @returns {Promise<Tool[]>} Array of tool definitions with input schemas\n   *\n   * @description Returns comprehensive tool definitions including:\n   * - Tool name and description\n   * - Input schema with type definitions\n   * - Required and optional parameters\n   * - Parameter validation rules\n   *\n   * @example\n   * ```typescript\n   * const tools = await registry.listTools();\n   * tools.forEach(tool => {\n   *   console.log(`${tool.name}: ${tool.description}`);\n   * });\n   * ```\n   */\n  listTools(): Promise<Tool[]> {\n    return [\n      {\n        name: 'create_task',\n        description: 'Create a new task in a board',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            title: { type: 'string', description: 'Task title' },\n            description: { type: 'string', description: 'Task description' },\n            board_id: { type: 'string', description: 'Board ID where task will be created' },\n            column_id: { type: 'string', description: 'Column ID for task placement' },\n            priority: {\n              type: 'number',\n              description: 'Task priority (1-5)',\n              minimum: 1,\n              maximum: 5,\n            },\n            status: {\n              type: 'string',\n              enum: ['todo', 'in_progress', 'done', 'blocked', 'archived'],\n              description: 'Task status',\n            },\n            assignee: { type: 'string', description: 'User ID of assignee' },\n            due_date: {\n              type: 'string',\n              format: 'date-time',\n              description: 'Due date in ISO format',\n            },\n            tags: { type: 'array', items: { type: 'string' }, description: 'Array of tag IDs' },\n          },\n          required: ['title', 'board_id'],\n        },\n      },\n      {\n        name: 'update_task',\n        description: 'Update an existing task',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task_id: { type: 'string', description: 'Task ID to update' },\n            title: { type: 'string', description: 'New task title' },\n            description: { type: 'string', description: 'New task description' },\n            priority: {\n              type: 'number',\n              description: 'Task priority (1-5)',\n              minimum: 1,\n              maximum: 5,\n            },\n            status: {\n              type: 'string',\n              enum: ['todo', 'in_progress', 'done', 'blocked', 'archived'],\n              description: 'Task status',\n            },\n            assignee: { type: 'string', description: 'User ID of assignee' },\n            due_date: {\n              type: 'string',\n              format: 'date-time',\n              description: 'Due date in ISO format',\n            },\n            progress: {\n              type: 'number',\n              description: 'Progress percentage (0-100)',\n              minimum: 0,\n              maximum: 100,\n            },\n          },\n          required: ['task_id'],\n        },\n      },\n      {\n        name: 'get_task',\n        description: 'Get task details by ID',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task_id: { type: 'string', description: 'Task ID to retrieve' },\n            include_subtasks: {\n              type: 'boolean',\n              description: 'Include subtasks in response',\n              default: false,\n            },\n            include_dependencies: {\n              type: 'boolean',\n              description: 'Include dependencies in response',\n              default: false,\n            },\n            include_notes: {\n              type: 'boolean',\n              description: 'Include notes in response',\n              default: false,\n            },\n            include_tags: {\n              type: 'boolean',\n              description: 'Include tags in response',\n              default: false,\n            },\n          },\n          required: ['task_id'],\n        },\n      },\n      {\n        name: 'list_tasks',\n        description: 'List tasks with optional filtering',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            board_id: { type: 'string', description: 'Filter by board ID' },\n            column_id: { type: 'string', description: 'Filter by column ID' },\n            status: {\n              type: 'string',\n              enum: ['todo', 'in_progress', 'done', 'blocked', 'archived'],\n              description: 'Filter by status',\n            },\n            assignee: { type: 'string', description: 'Filter by assignee' },\n            priority_min: { type: 'number', description: 'Minimum priority level' },\n            priority_max: { type: 'number', description: 'Maximum priority level' },\n            search: { type: 'string', description: 'Search in title and description' },\n            limit: { type: 'number', description: 'Maximum number of results', default: 50 },\n            offset: { type: 'number', description: 'Offset for pagination', default: 0 },\n            sort_by: { type: 'string', description: 'Sort field', default: 'updated_at' },\n            sort_order: {\n              type: 'string',\n              enum: ['asc', 'desc'],\n              description: 'Sort order',\n              default: 'desc',\n            },\n          },\n          required: [],\n        },\n      },\n      {\n        name: 'search_tasks',\n        description: 'Search tasks across boards with full-text search capabilities',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: { type: 'string', description: 'Search query for task title and description' },\n            board_id: { type: 'string', description: 'Filter by board ID' },\n            column_id: { type: 'string', description: 'Filter by column ID' },\n            status: {\n              type: 'string',\n              enum: ['todo', 'in_progress', 'done', 'blocked', 'archived'],\n              description: 'Filter by status',\n            },\n            assignee: { type: 'string', description: 'Filter by assignee' },\n            tags: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Filter by tags',\n            },\n            limit: { type: 'number', description: 'Maximum number of results', default: 20 },\n            offset: { type: 'number', description: 'Offset for pagination', default: 0 },\n          },\n          required: ['query'],\n        },\n      },\n      {\n        name: 'delete_task',\n        description: 'Delete a task by ID',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task_id: { type: 'string', description: 'Task ID to delete' },\n          },\n          required: ['task_id'],\n        },\n      },\n      {\n        name: 'create_board',\n        description: 'Create a new board',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: { type: 'string', description: 'Board name' },\n            description: { type: 'string', description: 'Board description' },\n            color: { type: 'string', description: 'Board color (hex code)' },\n          },\n          required: ['name'],\n        },\n      },\n      {\n        name: 'get_board',\n        description: 'Get board details by ID',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            board_id: { type: 'string', description: 'Board ID to retrieve' },\n            include_columns: {\n              type: 'boolean',\n              description: 'Include columns in response',\n              default: false,\n            },\n            include_tasks: {\n              type: 'boolean',\n              description: 'Include tasks in response',\n              default: false,\n            },\n          },\n          required: ['board_id'],\n        },\n      },\n      {\n        name: 'list_boards',\n        description: 'List all boards',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            search: { type: 'string', description: 'Search in board names and descriptions' },\n            archived: { type: 'boolean', description: 'Filter by archived status' },\n            limit: { type: 'number', description: 'Maximum number of results', default: 50 },\n            offset: { type: 'number', description: 'Offset for pagination', default: 0 },\n          },\n          required: [],\n        },\n      },\n      {\n        name: 'add_note',\n        description: 'Add a note to a task',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task_id: { type: 'string', description: 'Task ID to add note to' },\n            content: { type: 'string', description: 'Note content' },\n            category: {\n              type: 'string',\n              enum: ['general', 'progress', 'blocker', 'decision', 'question'],\n              description: 'Note category',\n              default: 'general',\n            },\n            pinned: { type: 'boolean', description: 'Pin the note', default: false },\n          },\n          required: ['task_id', 'content'],\n        },\n      },\n      {\n        name: 'search_notes',\n        description: 'Search notes with full-text search',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            query: { type: 'string', description: 'Search query' },\n            task_id: { type: 'string', description: 'Filter by task ID' },\n            board_id: { type: 'string', description: 'Filter by board ID' },\n            category: {\n              type: 'string',\n              enum: ['general', 'progress', 'blocker', 'decision', 'question'],\n              description: 'Filter by category',\n            },\n            limit: { type: 'number', description: 'Maximum number of results', default: 50 },\n          },\n          required: ['query'],\n        },\n      },\n      {\n        name: 'create_tag',\n        description: 'Create a new tag',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            name: { type: 'string', description: 'Tag name' },\n            color: { type: 'string', description: 'Tag color (hex code)' },\n            description: { type: 'string', description: 'Tag description' },\n            parent_tag_id: { type: 'string', description: 'Parent tag ID for hierarchical tags' },\n          },\n          required: ['name'],\n        },\n      },\n      {\n        name: 'assign_tag',\n        description: 'Assign a tag to a task',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task_id: { type: 'string', description: 'Task ID' },\n            tag_id: { type: 'string', description: 'Tag ID to assign' },\n          },\n          required: ['task_id', 'tag_id'],\n        },\n      },\n      {\n        name: 'get_project_context',\n        description: 'Generate AI context for a project/board',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            board_id: { type: 'string', description: 'Board ID to generate context for' },\n            include_completed: {\n              type: 'boolean',\n              description: 'Include completed tasks',\n              default: false,\n            },\n            include_notes: { type: 'boolean', description: 'Include task notes', default: true },\n            include_tags: { type: 'boolean', description: 'Include tags', default: true },\n            max_tasks: { type: 'number', description: 'Maximum tasks to include', default: 100 },\n            max_notes: { type: 'number', description: 'Maximum notes to include', default: 50 },\n          },\n          required: ['board_id'],\n        },\n      },\n      {\n        name: 'get_task_context',\n        description: 'Generate AI context for a specific task',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            task_id: { type: 'string', description: 'Task ID to generate context for' },\n            include_subtasks: { type: 'boolean', description: 'Include subtasks', default: true },\n            include_dependencies: {\n              type: 'boolean',\n              description: 'Include dependencies',\n              default: true,\n            },\n            include_notes: { type: 'boolean', description: 'Include notes', default: true },\n            include_tags: { type: 'boolean', description: 'Include tags', default: true },\n            include_related: {\n              type: 'boolean',\n              description: 'Include related tasks',\n              default: false,\n            },\n          },\n          required: ['task_id'],\n        },\n      },\n      {\n        name: 'analyze_board',\n        description: 'Analyze board performance and provide insights',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            board_id: { type: 'string', description: 'Board ID to analyze' },\n            timeframe_days: {\n              type: 'number',\n              description: 'Analysis timeframe in days',\n              default: 30,\n            },\n            include_recommendations: {\n              type: 'boolean',\n              description: 'Include improvement recommendations',\n              default: true,\n            },\n            include_blockers: {\n              type: 'boolean',\n              description: 'Include blocker analysis',\n              default: true,\n            },\n            include_metrics: {\n              type: 'boolean',\n              description: 'Include performance metrics',\n              default: true,\n            },\n          },\n          required: ['board_id'],\n        },\n      },\n      {\n        name: 'get_blocked_tasks',\n        description: 'Get all blocked tasks across boards or for a specific board',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            board_id: { type: 'string', description: 'Filter by board ID (optional)' },\n          },\n          required: [],\n        },\n      },\n      {\n        name: 'get_overdue_tasks',\n        description: 'Get all overdue tasks across boards or for a specific board',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            board_id: { type: 'string', description: 'Filter by board ID (optional)' },\n          },\n          required: [],\n        },\n      },\n    ];\n  }\n\n  /**\n   * Executes a specific MCP tool with provided arguments\n   *\n   * @param {string} name - Name of the tool to execute\n   * @param {unknown} args - Tool-specific arguments\n   * @returns {Promise<ToolResponse>} Tool execution result\n   *\n   * @throws {Error} When tool name is unknown\n   * @throws {Error} When required arguments are missing\n   * @throws {Error} When service operations fail\n   *\n   * @description Routes tool calls to appropriate implementation methods,\n   * validates arguments, and handles errors consistently. All tool responses\n   * follow a standard format with success status and relevant data.\n   *\n   * @example\n   * ```typescript\n   * try {\n   *   const result = await registry.callTool('update_task', {\n   *     task_id: 'task123',\n   *     status: 'done',\n   *     progress: 100\n   *   });\n   *   console.log('Task updated:', result.task);\n   * } catch (error) {\n   *   console.error('Tool execution failed:', error);\n   * }\n   * ```\n   */\n  async callTool(name: string, args: unknown): Promise<ToolResponse> {\n    logger.info('MCP tool call', { toolName: name, args });\n\n    try {\n      switch (name) {\n        case 'create_task':\n          return await this.createTask(args as CreateTaskArgs);\n        case 'update_task':\n          return await this.updateTask(args as UpdateTaskArgs);\n        case 'get_task':\n          return await this.getTask(args as GetTaskArgs);\n        case 'list_tasks':\n          return await this.listTasks(args as ListTasksArgs);\n        case 'search_tasks':\n          return await this.searchTasks(args as SearchTasksArgs);\n        case 'delete_task':\n          return await this.deleteTask(args as DeleteTaskArgs);\n        case 'create_board':\n          return await this.createBoard(args as CreateBoardArgs);\n        case 'get_board':\n          return await this.getBoard(args as GetBoardArgs);\n        case 'list_boards':\n          return await this.listBoards(args as ListBoardsArgs);\n        case 'add_note':\n          return await this.addNote(args as AddNoteArgs);\n        case 'search_notes':\n          return await this.searchNotes(args as SearchNotesArgs);\n        case 'create_tag':\n          return await this.createTag(args as CreateTagArgs);\n        case 'assign_tag':\n          return await this.assignTag(args as AssignTagArgs);\n        case 'get_project_context':\n          return await this.getProjectContext(args as GetProjectContextArgs);\n        case 'get_task_context':\n          return await this.getTaskContext(args as GetTaskContextArgs);\n        case 'analyze_board':\n          return await this.analyzeBoard(args as AnalyzeBoardArgs);\n        case 'get_blocked_tasks':\n          return await this.getBlockedTasks(args as GetBlockedTasksArgs);\n        case 'get_overdue_tasks':\n          return await this.getOverdueTasks(args as GetOverdueTasksArgs);\n        default:\n          throw new Error(`Unknown tool: ${String(name)}`);\n      }\n    } catch (error) {\n      logger.error('Tool execution error', { toolName: name, args, error });\n      throw error;\n    }\n  }\n\n  // Tool implementations\n\n  /**\n   * Creates a new task in the specified board\n   *\n   * @private\n   * @param {CreateTaskArgs} args - Task creation arguments\n   * @returns {Promise<TaskResponse>} Created task\n   *\n   * @throws {Error} When board_id is missing\n   * @throws {Error} When board is not found\n   *\n   * @description Creates a task with required title and board_id,\n   * plus optional fields like description, priority, assignee, and due date.\n   * Validates board existence before creation.\n   */\n  private async createTask(args: CreateTaskArgs): Promise<TaskResponse> {\n    const { board_id, column_id = 'todo' } = args;\n\n    if (!board_id) {\n      throw new Error('board_id is required');\n    }\n\n    // Validate board exists\n    const boards = await this.services.boardService.getBoards();\n    const board = boards.find(b => b.id === board_id);\n    if (!board) {\n      throw new Error('Board not found');\n    }\n\n    const createData: CreateTaskRequest = {\n      title: args.title,\n      board_id,\n      column_id,\n      status: args.status ?? 'todo',\n    };\n\n    // Only add optional properties if they are defined\n    if (args.description !== undefined) {\n      createData.description = args.description;\n    }\n    if (args.priority !== undefined) {\n      createData.priority = args.priority;\n    }\n    if (args.assignee !== undefined) {\n      createData.assignee = args.assignee;\n    }\n    if (args.due_date) {\n      createData.due_date = new Date(args.due_date);\n    }\n\n    const task = await this.services.taskService.createTask(createData);\n    return { success: true, task };\n  }\n\n  /**\n   * Updates an existing task with new values\n   *\n   * @private\n   * @param {UpdateTaskArgs} args - Task update arguments\n   * @returns {Promise<TaskResponse>} Updated task\n   *\n   * @throws {Error} When task_id is missing\n   *\n   * @description Updates task fields including title, description, status,\n   * priority, assignee, due date, and progress. Only provided fields are updated.\n   */\n  private async updateTask(args: UpdateTaskArgs): Promise<TaskResponse> {\n    const { task_id, due_date, ...updates } = args;\n\n    if (!task_id) {\n      throw new Error('task_id is required');\n    }\n\n    interface UpdateTaskData {\n      title?: string;\n      description?: string;\n      priority?: number;\n      status?: 'todo' | 'in_progress' | 'done' | 'blocked' | 'archived';\n      assignee?: string;\n      due_date?: Date;\n      progress?: number;\n    }\n\n    const updateData: UpdateTaskData = updates;\n    if (due_date) {\n      updateData.due_date = new Date(due_date);\n    }\n\n    const task = await this.services.taskService.updateTask(task_id, updateData);\n    return { success: true, task };\n  }\n\n  /**\n   * Retrieves detailed task information with optional related data\n   *\n   * @private\n   * @param {GetTaskArgs} args - Task retrieval arguments\n   * @returns {Promise<GetTaskDetailedResponse>} Task with optional related data\n   *\n   * @throws {Error} When task_id is missing\n   * @throws {Error} When task is not found\n   *\n   * @description Fetches task details with options to include:\n   * - Subtasks\n   * - Dependencies\n   * - Notes\n   * - Tags\n   */\n  private async getTask(args: GetTaskArgs): Promise<GetTaskDetailedResponse> {\n    const { task_id, include_subtasks, include_dependencies, include_notes, include_tags } = args;\n\n    if (!task_id) {\n      throw new Error('task_id (or id) is required');\n    }\n\n    let task;\n    if (include_subtasks) {\n      task = await this.services.taskService.getTaskWithSubtasks(task_id);\n    } else if (include_dependencies) {\n      task = await this.services.taskService.getTaskWithDependencies(task_id);\n    } else {\n      task = await this.services.taskService.getTaskById(task_id);\n    }\n\n    if (!task) {\n      throw new Error(`Task not found: ${String(task_id)}`);\n    }\n\n    // Add additional data if requested\n    const result: GetTaskDetailedResponse = { success: true, task };\n\n    if (include_notes) {\n      const notes = await this.services.noteService.getTaskNotes(task_id, { limit: 100 });\n      result.notes = notes;\n    }\n\n    if (include_tags) {\n      const tags = await this.services.tagService.getTaskTags(task_id);\n      result.tags = tags;\n    }\n\n    return result;\n  }\n\n  /**\n   * Lists tasks with flexible filtering and sorting options\n   *\n   * @private\n   * @param {ListTasksArgs} args - Task listing arguments\n   * @returns {Promise<TasksResponse>} Array of tasks matching criteria\n   *\n   * @throws {Error} When status value is invalid\n   *\n   * @description Supports filtering by:\n   * - Board and column\n   * - Status and assignee\n   * - Priority range\n   * - Text search\n   * With pagination and custom sorting.\n   */\n  private async listTasks(args: ListTasksArgs): Promise<TasksResponse> {\n    const { status, ...restArgs } = args;\n    interface TaskFilters {\n      board_id?: string;\n      column_id?: string;\n      status?: Task['status'];\n      assignee?: string;\n      priority_min?: number;\n      priority_max?: number;\n      search?: string;\n      limit?: number;\n      offset?: number;\n      sortBy?: string;\n      sortOrder?: 'asc' | 'desc';\n    }\n    const filters: TaskFilters = { ...restArgs };\n\n    // Validate and cast status if provided\n    if (status) {\n      const validStatuses = ['todo', 'in_progress', 'done', 'blocked', 'archived'];\n      if (!validStatuses.includes(status)) {\n        throw new Error(\n          `Invalid status: ${String(status)}. Must be one of: ${String(String(validStatuses.join(', ')))}`\n        );\n      }\n      filters.status = status as Task['status'];\n    }\n\n    const tasks = await this.services.taskService.getTasks(filters);\n    return { success: true, tasks, count: tasks.length };\n  }\n\n  /**\n   * Searches tasks using full-text search with filters\n   *\n   * @private\n   * @param {SearchTasksArgs} args - Search arguments\n   * @returns {Promise<TasksResponse>} Tasks matching search criteria\n   *\n   * @throws {Error} When status value is invalid\n   *\n   * @description Performs full-text search across task titles and descriptions\n   * with additional filtering by board, column, status, assignee, and tags.\n   */\n  private async searchTasks(args: SearchTasksArgs): Promise<TasksResponse> {\n    const { query, status, ...restArgs } = args;\n\n    // Convert SearchTasksArgs to ListTasksArgs format\n    interface TaskFilters {\n      board_id?: string;\n      column_id?: string;\n      status?: Task['status'];\n      assignee?: string;\n      tags?: string[];\n      search: string; // Required for search\n      limit?: number;\n      offset?: number;\n    }\n\n    const filters: TaskFilters = {\n      ...restArgs,\n      search: query, // Use query as the search parameter\n    };\n\n    // Validate and cast status if provided\n    if (status) {\n      const validStatuses = ['todo', 'in_progress', 'done', 'blocked', 'archived'];\n      if (!validStatuses.includes(status)) {\n        throw new Error(\n          `Invalid status: ${String(status)}. Must be one of: ${String(String(validStatuses.join(', ')))}`\n        );\n      }\n      filters.status = status as Task['status'];\n    }\n\n    const tasks = await this.services.taskService.getTasks(filters);\n    return { success: true, data: tasks, tasks, count: tasks.length };\n  }\n\n  /**\n   * Deletes a task by ID\n   *\n   * @private\n   * @param {DeleteTaskArgs} args - Deletion arguments\n   * @returns {Promise<{success: boolean; message: string}>} Deletion confirmation\n   *\n   * @description Permanently deletes a task and all associated data\n   * including notes, tags, and relationships.\n   */\n  private async deleteTask(args: DeleteTaskArgs): Promise<{ success: boolean; message: string }> {\n    const { task_id } = args;\n    await this.services.taskService.deleteTask(task_id);\n    return { success: true, message: `Task ${String(task_id)} deleted` };\n  }\n\n  /**\n   * Creates a new kanban board\n   *\n   * @private\n   * @param {CreateBoardArgs} args - Board creation arguments\n   * @returns {Promise<BoardResponse>} Created board\n   *\n   * @description Creates a board with name, optional description,\n   * and color for visual identification.\n   */\n  private async createBoard(args: CreateBoardArgs): Promise<BoardResponse> {\n    const board = await this.services.boardService.createBoard(args);\n    return { success: true, board };\n  }\n\n  /**\n   * Retrieves board details with optional columns and tasks\n   *\n   * @private\n   * @param {GetBoardArgs} args - Board retrieval arguments\n   * @returns {Promise<BoardResponse>} Board with optional related data\n   *\n   * @throws {Error} When board is not found\n   *\n   * @description Fetches board details with options to include:\n   * - Column structure\n   * - All tasks in the board\n   */\n  private async getBoard(args: GetBoardArgs): Promise<BoardResponse> {\n    const { board_id, include_columns, include_tasks } = args;\n\n    let board;\n    if (include_columns) {\n      board = await this.services.boardService.getBoardWithColumns(board_id);\n    } else {\n      board = await this.services.boardService.getBoardById(board_id);\n    }\n\n    if (!board) {\n      throw new Error(`Board not found: ${String(board_id)}`);\n    }\n\n    const result: BoardResponse = { success: true, board };\n\n    if (include_tasks) {\n      const tasks = await this.services.taskService.getTasks({ board_id, limit: 1000 });\n      result.tasks = tasks;\n    }\n\n    return result;\n  }\n\n  /**\n   * Lists all boards with optional filtering\n   *\n   * @private\n   * @param {ListBoardsArgs} args - Board listing arguments\n   * @returns {Promise<BoardsResponse>} Array of boards\n   *\n   * @description Lists boards with options to:\n   * - Search by name/description\n   * - Filter by archived status\n   * - Paginate results\n   */\n  private async listBoards(args: ListBoardsArgs): Promise<BoardsResponse> {\n    const boards = await this.services.boardService.getBoards(args);\n    return { success: true, boards, count: boards.length };\n  }\n\n  /**\n   * Adds a note to a task\n   *\n   * @private\n   * @param {AddNoteArgs} args - Note creation arguments\n   * @returns {Promise<NoteResponse>} Created note\n   *\n   * @throws {Error} When task_id is missing\n   *\n   * @description Creates a note with content, category (general, progress,\n   * blocker, decision, question), and optional pinned status.\n   */\n  private async addNote(args: AddNoteArgs): Promise<NoteResponse> {\n    // task_id is required for createNote\n    if (!args.task_id) {\n      throw new Error('task_id is required for creating a note');\n    }\n\n    const { category } = args;\n    interface CreateNoteData {\n      content: string;\n      task_id: string;\n      category?: 'general' | 'progress' | 'blocker' | 'decision' | 'question';\n      pinned?: boolean;\n    }\n    const noteData: CreateNoteData = {\n      content: args.content,\n      task_id: args.task_id,\n    };\n\n    if (args.pinned !== undefined) {\n      noteData.pinned = args.pinned;\n    }\n\n    // Map categories if provided\n    if (category) {\n      const categoryMap: Record<\n        string,\n        'general' | 'progress' | 'blocker' | 'decision' | 'question'\n      > = {\n        general: 'general',\n        meeting: 'general',\n        idea: 'general',\n        todo: 'progress',\n        reminder: 'general',\n      };\n      noteData.category = categoryMap[category] ?? 'general';\n    }\n\n    const note = await this.services.noteService.createNote(noteData);\n    return { success: true, note };\n  }\n\n  /**\n   * Searches notes using full-text search\n   *\n   * @private\n   * @param {SearchNotesArgs} args - Note search arguments\n   * @returns {Promise<NotesResponse>} Notes matching search criteria\n   *\n   * @throws {Error} When query is missing\n   * @throws {Error} When category value is invalid\n   *\n   * @description Searches note content with filters for task, board,\n   * and category. Supports result limiting.\n   */\n  private async searchNotes(args: SearchNotesArgs): Promise<NotesResponse> {\n    // query is required for searchNotes\n    if (!args.query) {\n      throw new Error('query is required for searching notes');\n    }\n\n    const { category } = args;\n    interface SearchNotesOptions {\n      query: string;\n      task_id?: string;\n      board_id?: string;\n      category?: 'general' | 'progress' | 'blocker' | 'decision' | 'question';\n      limit?: number;\n    }\n    const searchOptions: SearchNotesOptions = {\n      query: args.query,\n    };\n\n    // Add optional properties only if they have values\n    if (args.task_id) searchOptions.task_id = args.task_id;\n    if (args.board_id) searchOptions.board_id = args.board_id;\n    if (args.limit) searchOptions.limit = args.limit;\n\n    // Validate and cast category if provided\n    if (category) {\n      const validCategories = ['general', 'progress', 'blocker', 'decision', 'question'];\n      if (!validCategories.includes(category)) {\n        throw new Error(\n          `Invalid category: ${String(category)}. Must be one of: ${String(String(validCategories.join(', ')))}`\n        );\n      }\n      searchOptions.category = category as\n        | 'general'\n        | 'progress'\n        | 'blocker'\n        | 'decision'\n        | 'question';\n    }\n\n    const notes = await this.services.noteService.searchNotes(searchOptions);\n    return { success: true, notes, count: notes.length };\n  }\n\n  /**\n   * Creates a new tag for task categorization\n   *\n   * @private\n   * @param {CreateTagArgs} args - Tag creation arguments\n   * @returns {Promise<TagResponse>} Created tag\n   *\n   * @description Creates a tag with name, color, optional description,\n   * and parent tag for hierarchical organization.\n   */\n  private async createTag(args: CreateTagArgs): Promise<TagResponse> {\n    const tag = await this.services.tagService.createTag(args);\n    return { success: true, tag };\n  }\n\n  /**\n   * Assigns tags to a task\n   *\n   * @private\n   * @param {AssignTagArgs} args - Tag assignment arguments\n   * @returns {Promise<{success: boolean; assignment: unknown}>} Assignment confirmation\n   *\n   * @description Assigns one or more tags to a task for categorization\n   * and filtering purposes.\n   */\n  private async assignTag(args: AssignTagArgs): Promise<{ success: boolean; assignment: unknown }> {\n    const { task_id, tag_ids } = args;\n    const assignments = await Promise.all(\n      tag_ids.map(tag_id => this.services.tagService.addTagToTask(task_id, tag_id))\n    );\n    return { success: true, assignment: assignments };\n  }\n\n  /**\n   * Generates AI-friendly project context\n   *\n   * @private\n   * @param {GetProjectContextArgs} args - Context generation arguments\n   * @returns {Promise<ProjectContextResponse>} Structured project context\n   *\n   * @description Generates comprehensive project context including:\n   * - Summary and active tasks\n   * - Recent activity and priorities\n   * - Bottlenecks and metrics\n   * - Optional recommendations\n   * Optimized for AI agent understanding.\n   */\n  private async getProjectContext(args: GetProjectContextArgs): Promise<ProjectContextResponse> {\n    // Map args to ContextOptions\n    interface ProjectContextOptions {\n      days_back: number;\n      include_metrics?: boolean;\n      detail_level: 'comprehensive' | 'summary';\n    }\n    const options: ProjectContextOptions = {\n      days_back: 30, // Default to 30 days\n      include_metrics: args.include_metrics ?? false,\n      detail_level: 'comprehensive',\n    };\n\n    const context = await this.services.contextService.getProjectContext(options);\n\n    // Transform context to match expected response format\n    const result: ProjectContextResponse['context'] = {\n      summary: context.summary,\n      active_tasks: context.priorities.map(p => p.task),\n      recent_activity: context.recent_activities,\n      priorities: context.priorities.map(p => p.task),\n      bottlenecks: context.blockers,\n      metrics: context.key_metrics as unknown as Record<string, unknown>,\n    };\n\n    if (args.include_recommendations) {\n      result.recommendations = context.priorities.map(\n        p => `Priority: ${String(String(p.task.title))}`\n      );\n    }\n\n    return { success: true, context: result };\n  }\n\n  /**\n   * Generates AI-friendly task context\n   *\n   * @private\n   * @param {GetTaskContextArgs} args - Context generation arguments\n   * @returns {Promise<TaskContextResponse>} Structured task context\n   *\n   * @description Generates detailed task context including:\n   * - Task details and relationships\n   * - Dependencies and subtasks\n   * - Notes and tags\n   * - Optional history and blockers\n   * Optimized for AI agent task understanding.\n   */\n  private async getTaskContext(args: GetTaskContextArgs): Promise<TaskContextResponse> {\n    const { task_id, include_history, include_related, include_blockers } = args;\n\n    // Map args to ContextOptions\n    interface TaskContextOptions {\n      detail_level: 'comprehensive' | 'summary';\n      include_completed: boolean;\n    }\n    const options: TaskContextOptions = {\n      detail_level: 'comprehensive',\n      include_completed: true,\n    };\n\n    const context = await this.services.contextService.getTaskContext(task_id, options);\n\n    // Transform context to match expected response format\n    interface TaskContextResult {\n      task: Task;\n      dependencies?: Task[];\n      subtasks?: Task[];\n      notes?: NoteType[];\n      tags?: TagType[];\n      history?: unknown[];\n      blockers?: unknown[];\n      related?: Task[];\n    }\n    const result: TaskContextResult = {\n      task: context.task,\n      dependencies: context.related_tasks\n        .filter(rt => rt.relationship === 'dependency')\n        .map(rt => rt.task),\n      subtasks: context.related_tasks.filter(rt => rt.relationship === 'child').map(rt => rt.task),\n      notes: context.notes,\n      tags: context.tags,\n    };\n\n    if (include_history) {\n      result.history = context.history;\n    }\n\n    if (include_related) {\n      result.related = context.related_tasks.map(rt => rt.task);\n    }\n\n    if (include_blockers) {\n      result.blockers = context.related_tasks\n        .filter(rt => rt.relationship === 'dependency')\n        .map(rt => rt.task);\n    }\n\n    return { success: true, context: result as TaskContextResponse['context'] };\n  }\n\n  /**\n   * Analyzes board performance and provides insights\n   *\n   * @private\n   * @param {AnalyzeBoardArgs} args - Analysis arguments\n   * @returns {Promise<BoardAnalysisResponse>} Board analysis with metrics and insights\n   *\n   * @description Performs comprehensive board analysis including:\n   * - Performance metrics\n   * - Workflow insights\n   * - Improvement recommendations\n   * Based on configurable time ranges.\n   */\n  private async analyzeBoard(args: AnalyzeBoardArgs): Promise<BoardAnalysisResponse> {\n    const { board_id } = args;\n\n    // Map args to ContextOptions\n    interface AnalyzeOptions {\n      days_back: number;\n      include_metrics: boolean;\n      detail_level: 'comprehensive' | 'summary';\n    }\n    const options: AnalyzeOptions = {\n      days_back: args.time_range === 'week' ? 7 : args.time_range === 'month' ? 30 : 90,\n      include_metrics: true,\n      detail_level: 'comprehensive',\n    };\n\n    const analysis = await this.services.contextService.getProjectContext(options);\n\n    // Get board-specific data\n    const boards = await this.services.boardService.getBoards();\n    const board = boards.find(b => b.id === board_id);\n\n    return {\n      success: true,\n      analysis: {\n        board: board!,\n        metrics: analysis.key_metrics as unknown as Record<string, unknown>,\n        insights: analysis.priorities.map(\n          p => `Task \"${String(String(p.task.title))}\" is high priority`\n        ),\n        recommendations: analysis.priorities\n          .slice(0, 3)\n          .map(p => `Focus on: ${String(String(p.task.title))}`),\n      },\n    };\n  }\n\n  /**\n   * Retrieves all blocked tasks with optional reasons\n   *\n   * @private\n   * @param {GetBlockedTasksArgs} args - Query arguments\n   * @returns {Promise<BlockedTasksResponse>} Blocked tasks with optional blocking reasons\n   *\n   * @description Finds all tasks with 'blocked' status,\n   * optionally including reasons for the blockage.\n   */\n  private async getBlockedTasks(args: GetBlockedTasksArgs): Promise<BlockedTasksResponse> {\n    const { board_id, include_reasons } = args;\n    const blockedTasks = await this.services.taskService.getBlockedTasks(board_id);\n    const blocked_tasks = blockedTasks.map(task => ({\n      task,\n      ...(include_reasons && { blocking_reasons: ['Dependency not completed'] }),\n    }));\n    return { success: true, blocked_tasks };\n  }\n\n  /**\n   * Retrieves all overdue tasks with days overdue calculation\n   *\n   * @private\n   * @param {GetOverdueTasksArgs} args - Query arguments\n   * @returns {Promise<OverdueTasksResponse>} Overdue tasks with days overdue\n   *\n   * @description Finds tasks past their due date, calculates\n   * days overdue, and optionally filters by minimum days overdue.\n   */\n  private async getOverdueTasks(args: GetOverdueTasksArgs): Promise<OverdueTasksResponse> {\n    const { board_id, days_overdue } = args;\n    const overdueTasks = await this.services.taskService.getOverdueTasks(board_id);\n    const overdue_tasks = overdueTasks\n      .map(task => {\n        const dueDate = task.due_date ? new Date(task.due_date) : null;\n        const now = new Date();\n        const daysDiff = dueDate\n          ? Math.floor((now.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24))\n          : 0;\n        return {\n          task,\n          days_overdue: Math.max(0, daysDiff),\n        };\n      })\n      .filter(item => !days_overdue || item.days_overdue >= days_overdue);\n    return { success: true, overdue_tasks };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/mcp/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/middleware/auth.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'validateApiKey' was used before it was defined.",
        "line": 86,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 86,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'hashApiKey' was used before it was defined.",
        "line": 103,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 103,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 181,
        "column": 56,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 181,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [5166, 5168], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 185,
        "column": 56,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 185,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [5324, 5326], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 266,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 266,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [7368, 7403], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement.",
        "line": 273,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unexpected",
        "endLine": 273,
        "endColumn": 16,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [7558, 7598], "text": "" },
            "desc": "Remove the console.log()."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @module middleware/auth\n * @description Authentication and authorization middleware for the API.\n *\n * Provides API key-based authentication and permission-based authorization\n * for all protected routes. Supports both header-based authentication methods.\n *\n * @example\n * ```typescript\n * // Using in routes\n * router.get('/protected', requirePermission('read'), handler);\n * router.post('/admin', requirePermissions(['admin', 'write'], true), handler);\n *\n * // Client authentication\n * fetch('/api/v1/tasks', {\n *   headers: {\n *     'X-API-Key': 'your-api-key'\n *     // or\n *     'Authorization': 'Bearer your-api-key'\n *   }\n * });\n * ```\n */\n\nimport type { Request, Response, NextFunction } from 'express';\nimport crypto from 'crypto';\nimport { config } from '@/config';\nimport { logger } from '@/utils/logger';\nimport { UnauthorizedError, ForbiddenError } from '@/utils/errors';\n\ninterface AuthenticatedRequest extends Request {\n  apiKey?: string;\n  user?: {\n    id: string;\n    name: string;\n    permissions: string[];\n  };\n}\n\n/**\n * Authentication middleware for API key validation.\n *\n * This middleware validates API keys from the X-API-Key header or Authorization header.\n * It also handles public endpoints that don't require authentication.\n *\n * @example\n * ```typescript\n * // Apply to all routes\n * app.use(authenticationMiddleware);\n *\n * // Apply to specific routes\n * router.use('/api', authenticationMiddleware);\n * ```\n */\nexport function authenticationMiddleware(\n  req: AuthenticatedRequest,\n  _res: Response,\n  next: NextFunction\n): void {\n  // Skip authentication for public endpoints\n  const publicEndpoints = ['/health', '/docs'];\n  const fullPath = req.originalUrl ?? req.url;\n\n  // Check for exact match or path that starts with endpoint followed by / or query\n  const isPublicEndpoint =\n    publicEndpoints.some(\n      endpoint =>\n        fullPath === endpoint ||\n        fullPath.startsWith(`${String(endpoint)}/`) ||\n        fullPath.startsWith(`${String(endpoint)}?`)\n    ) || fullPath === '/'; // Allow root path exactly\n\n  if (isPublicEndpoint) {\n    next();\n    return;\n  }\n\n  const apiKey = req.get('X-API-Key') ?? req.get('Authorization')?.replace('Bearer ', '');\n\n  if (!apiKey) {\n    next(new UnauthorizedError('API key required'));\n    return;\n  }\n\n  // Validate API key\n  const isValidKey = validateApiKey(apiKey);\n  if (!isValidKey) {\n    logger.warn('Invalid API key attempt', {\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      requestId: req.requestId,\n    });\n    next(new UnauthorizedError('Invalid API key'));\n    return;\n  }\n\n  // Attach API key to request\n  req.apiKey = apiKey;\n\n  // For now, create a basic user object\n  // In a real implementation, you'd look up the user associated with the API key\n  req.user = {\n    id: hashApiKey(apiKey),\n    name: 'API User',\n    permissions: ['read', 'write', 'admin'], // Full permissions for now\n  };\n\n  logger.debug('Request authenticated', {\n    userId: req.user.id,\n    requestId: req.requestId,\n  });\n\n  next();\n}\n\n/**\n * Create middleware that requires a specific permission.\n *\n * @param permission - Required permission: 'read', 'write', or 'admin'\n * @returns Express middleware function\n *\n * Permission hierarchy:\n * - `admin`: Full access to all operations\n * - `write`: Can create, update, and delete resources\n * - `read`: Can only view resources\n *\n * @example\n * ```typescript\n * // Require read permission\n * router.get('/tasks', requirePermission('read'), getTasks);\n *\n * // Require write permission\n * router.post('/tasks', requirePermission('write'), createTask);\n *\n * // Require admin permission\n * router.delete('/boards/:id', requirePermission('admin'), deleteBoard);\n * ```\n */\nexport function requirePermission(permission: string) {\n  return (req: AuthenticatedRequest, _res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      next(new UnauthorizedError('Authentication required'));\n      return;\n    }\n\n    if (!req.user.permissions.includes(permission) && !req.user.permissions.includes('admin')) {\n      next(new ForbiddenError(`Permission '${String(permission)}' required`));\n      return;\n    }\n\n    next();\n  };\n}\n\n/**\n * Create middleware that requires multiple permissions.\n *\n * @param permissions - Array of required permissions\n * @param requireAll - If true, all permissions are required. If false, any permission is sufficient.\n * @returns Express middleware function\n *\n * @example\n * ```typescript\n * // Require both read and write permissions\n * router.post('/tasks', requirePermissions(['read', 'write'], true), createTask);\n *\n * // Require either read or write permission\n * router.get('/tasks', requirePermissions(['read', 'write'], false), getTasks);\n * ```\n */\nexport function requirePermissions(permissions: string[], requireAll: boolean = false) {\n  return (req: AuthenticatedRequest, _res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      next(new UnauthorizedError('Authentication required'));\n      return;\n    }\n\n    const hasPermission = requireAll\n      ? permissions.every(\n          permission =>\n            req.user?.permissions.includes(permission) || req.user?.permissions.includes('admin')\n        )\n      : permissions.some(\n          permission =>\n            req.user?.permissions.includes(permission) || req.user?.permissions.includes('admin')\n        );\n\n    if (!hasPermission) {\n      const permissionText = requireAll ? 'all of' : 'one of';\n      next(\n        new ForbiddenError(\n          `Permission ${permissionText} [${String(permissions.join(', '))}] required`\n        )\n      );\n      return;\n    }\n\n    next();\n  };\n}\n\n/**\n * Validate an API key.\n *\n * @param apiKey - The API key to validate\n * @returns True if the API key is valid, false otherwise\n */\nfunction validateApiKey(apiKey: string): boolean {\n  // For now, accept any non-empty string\n  // In a real implementation, you'd validate against a database or external service\n  return apiKey.length > 0;\n}\n\n/**\n * Hash an API key for use as a user ID.\n *\n * @param apiKey - The API key to hash\n * @returns A hash of the API key\n */\nfunction hashApiKey(apiKey: string): string {\n  return crypto.createHash('sha256').update(apiKey).digest('hex').substring(0, 8);\n}\n\n/**\n * Generate a new secure API key.\n *\n * @returns A 64-character hexadecimal API key\n *\n * @example\n * ```typescript\n * const newApiKey = generateApiKey();\n * logger.log(newApiKey); // \"a3f4b2c1d5e6...\" (64 chars)\n * ```\n */\nexport function generateApiKey(): string {\n  return crypto.randomBytes(32).toString('hex');\n}\n\nexport function revokeApiKey(apiKey: string): boolean {\n  // In a real implementation, you'd mark the key as revoked in the database\n  // For now, just remove it from the config (which won't persist)\n  const index = config.api.keys.indexOf(apiKey);\n  if (index > -1) {\n    config.api.keys.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Authenticate an API key and return user information.\n *\n * @param req - The request object\n * @param res - The response object\n * @param next - The next function\n */\nexport function authenticateApiKey(\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n): void {\n  const apiKey = req.get('X-API-Key') ?? req.get('Authorization')?.replace('Bearer ', '');\n\n  if (!apiKey) {\n    // eslint-disable-next-line no-console\n    console.log('No API key provided');\n    res.status(401).json({ error: 'API key required' });\n    return;\n  }\n\n  if (!validateApiKey(apiKey)) {\n    // eslint-disable-next-line no-console\n    console.log('Invalid API key provided');\n    res.status(401).json({ error: 'Invalid API key' });\n    return;\n  }\n\n  req.apiKey = apiKey;\n  req.user = {\n    id: hashApiKey(apiKey),\n    name: 'API User',\n    permissions: ['read', 'write', 'admin'],\n  };\n\n  next();\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/middleware/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/middleware/logging.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 4,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 4,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 19,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 19,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [577, 580], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [577, 580], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 19,
        "column": 22,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 19,
        "endColumn": 31
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 19,
        "column": 22,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 19,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 19,
        "column": 57,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 19,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [619, 622], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [619, 622], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 41,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 41,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1234, 1237], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1234, 1237], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response, NextFunction } from 'express';\nimport { logger } from '@/utils/logger';\n\nexport function requestLoggingMiddleware(req: Request, res: Response, next: NextFunction) {\n  const startTime = Date.now();\n\n  // Log incoming request\n  logger.info('HTTP request started', {\n    requestId: req.requestId,\n    method: req.method,\n    url: req.originalUrl,\n    userAgent: req.get('User-Agent'),\n    ip: req.ip,\n    contentLength: req.get('Content-Length'),\n  });\n\n  // Override res.end to log response\n  const originalEnd = res.end.bind(res);\n  (res.end as any) = function (this: Response, ...args: any[]) {\n    const duration = Date.now() - startTime;\n\n    logger.info('HTTP request completed', {\n      requestId: req.requestId,\n      method: req.method,\n      url: req.originalUrl,\n      statusCode: res.statusCode,\n      duration: `${String(duration)}ms`,\n      contentLength: res.get('Content-Length'),\n    });\n\n    // Log slow requests\n    if (duration > 1000) {\n      logger.warn('Slow HTTP request detected', {\n        requestId: req.requestId,\n        method: req.method,\n        url: req.originalUrl,\n        duration: `${String(duration)}ms`,\n      });\n    }\n\n    return originalEnd.apply(this, args as [any, BufferEncoding, (() => void)?]);\n  };\n\n  next();\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/middleware/requestId.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-namespace",
        "severity": 2,
        "message": "ES2015 module syntax is preferred over namespaces.",
        "line": 5,
        "column": 3,
        "nodeType": "TSModuleDeclaration",
        "messageId": "moduleSyntaxIsPreferred",
        "endLine": 9,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 12,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 12,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 13,
        "column": 45,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 13,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [334, 336], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response, NextFunction } from 'express';\nimport { v4 as uuidv4 } from 'uuid';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      requestId: string;\n    }\n  }\n}\n\nexport function requestIdMiddleware(req: Request, res: Response, next: NextFunction) {\n  const requestId = req.get('X-Request-ID') || uuidv4();\n\n  req.requestId = requestId;\n  res.set('X-Request-ID', requestId);\n\n  next();\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/middleware/response.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 3,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 3,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [98, 101], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [98, 101], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [202, 205], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [202, 205], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-namespace",
        "severity": 2,
        "message": "ES2015 module syntax is preferred over namespaces.",
        "line": 25,
        "column": 3,
        "nodeType": "TSModuleDeclaration",
        "messageId": "moduleSyntaxIsPreferred",
        "endLine": 37,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 28,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 28,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [627, 630], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [627, 630], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 40,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 40,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 42,
        "column": 20,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 42,
        "endColumn": 32
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 42,
        "column": 20,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 42,
        "endColumn": 32
      },
      {
        "ruleId": "space-before-function-paren",
        "severity": 2,
        "message": "Missing space before function parentheses.",
        "line": 42,
        "column": 32,
        "nodeType": "FunctionExpression",
        "messageId": "missingSpace",
        "endLine": 42,
        "endColumn": 33,
        "fix": { "range": [982, 982], "text": " " }
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 57,
        "column": 18,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 57,
        "endColumn": 27
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 57,
        "column": 18,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 57,
        "endColumn": 27
      },
      {
        "ruleId": "default-param-last",
        "severity": 2,
        "message": "Default parameters should be last.",
        "line": 57,
        "column": 59,
        "nodeType": "AssignmentPattern",
        "messageId": "shouldBeLast",
        "endLine": 57,
        "endColumn": 75
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 57,
        "column": 87,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 57,
        "endColumn": 90,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1378, 1381], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1378, 1381], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 63,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 63,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 75,
        "column": 23,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 75,
        "endColumn": 35
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 75,
        "column": 23,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 75,
        "endColumn": 35
      },
      {
        "ruleId": "space-before-function-paren",
        "severity": 2,
        "message": "Missing space before function parentheses.",
        "line": 75,
        "column": 35,
        "nodeType": "FunctionExpression",
        "messageId": "missingSpace",
        "endLine": 75,
        "endColumn": 36,
        "fix": { "range": [1745, 1745], "text": " " }
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 127,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 127,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2774, 2777], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2774, 2777], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 133,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 133,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 2,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response, NextFunction } from 'express';\n\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: {\n    code: string;\n    message: string;\n    details?: any;\n  };\n  meta?: {\n    timestamp: string;\n    requestId: string;\n    pagination?: {\n      page: number;\n      limit: number;\n      total: number;\n      hasNext: boolean;\n      hasPrev: boolean;\n    };\n  };\n}\n\ndeclare global {\n  namespace Express {\n    interface Response {\n      apiSuccess<T>(data: T, meta?: Partial<ApiResponse['meta']>): void;\n      apiError(code: string, message: string, statusCode?: number, details?: any): void;\n      apiPagination<T>(\n        data: T[],\n        page: number,\n        limit: number,\n        total: number,\n        meta?: Partial<ApiResponse['meta']>\n      ): void;\n    }\n  }\n}\n\nexport function responseFormattingMiddleware(req: Request, res: Response, next: NextFunction) {\n  // Add success response helper\n  res.apiSuccess = function <T>(data: T, meta?: Partial<ApiResponse['meta']>) {\n    const response: ApiResponse<T> = {\n      success: true,\n      data,\n      meta: {\n        timestamp: new Date().toISOString(),\n        requestId: req.requestId,\n        ...meta,\n      },\n    };\n\n    this.json(response);\n  };\n\n  // Add error response helper\n  res.apiError = function (code: string, message: string, statusCode = 500, details?: any) {\n    const response: ApiResponse = {\n      success: false,\n      error: {\n        code,\n        message,\n        details,\n      },\n      meta: {\n        timestamp: new Date().toISOString(),\n        requestId: req.requestId,\n      },\n    };\n\n    this.status(statusCode).json(response);\n  };\n\n  // Add pagination response helper\n  res.apiPagination = function <T>(\n    data: T[],\n    page: number,\n    limit: number,\n    total: number,\n    meta?: Partial<ApiResponse['meta']>\n  ) {\n    const totalPages = Math.ceil(total / limit);\n    const hasNext = page < totalPages;\n    const hasPrev = page > 1;\n\n    const response: ApiResponse<T[]> = {\n      success: true,\n      data,\n      meta: {\n        timestamp: new Date().toISOString(),\n        requestId: req.requestId,\n        pagination: {\n          page,\n          limit,\n          total,\n          hasNext,\n          hasPrev,\n        },\n        ...meta,\n      },\n    };\n\n    this.json(response);\n  };\n\n  next();\n}\n\n/**\n * Format success response\n */\nexport function formatSuccessResponse<T>(data: T, message?: string): ApiResponse<T> {\n  return {\n    success: true,\n    data,\n    meta: {\n      timestamp: new Date().toISOString(),\n      requestId: '', // Will be set by middleware if available\n      ...(message && { message }),\n    },\n  };\n}\n\n/**\n * Format error response\n */\nexport function formatErrorResponse(message: string, details?: any): ApiResponse {\n  return {\n    success: false,\n    error: {\n      code: 'ERROR',\n      message,\n      details,\n    },\n    meta: {\n      timestamp: new Date().toISOString(),\n      requestId: '', // Will be set by middleware if available\n    },\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/middleware/validation.ts",
    "messages": [
      {
        "ruleId": "consistent-return",
        "severity": 2,
        "message": "Expected to return a value at the end of function 'requestValidationMiddleware'.",
        "line": 6,
        "column": 17,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturn",
        "endLine": 6,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 12,
        "column": 60,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 12,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [397, 399], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'extractUuidParams' was used before it was defined.",
        "line": 28,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 28,
        "endColumn": 39
      },
      {
        "ruleId": "no-restricted-globals",
        "severity": 2,
        "message": "Unexpected use of 'isNaN'. Use Number.isNaN instead https://github.com/airbnb/javascript#standard-library--isnan",
        "line": 39,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "customMessage",
        "endLine": 39,
        "endColumn": 14
      },
      {
        "ruleId": "no-restricted-globals",
        "severity": 2,
        "message": "Unexpected use of 'isNaN'. Use Number.isNaN instead https://github.com/airbnb/javascript#standard-library--isnan",
        "line": 46,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "customMessage",
        "endLine": 46,
        "endColumn": 14
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\/.",
        "line": 59,
        "column": 30,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 59,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [1926, 1927], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [1926, 1926], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-cond-assign",
        "severity": 2,
        "message": "Unexpected assignment within a 'while' statement.",
        "line": 64,
        "column": 11,
        "nodeType": "AssignmentExpression",
        "messageId": "unexpected",
        "endLine": 64,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 78,
        "column": 61,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 78,
        "endColumn": 63
      },
      {
        "ruleId": "consistent-return",
        "severity": 2,
        "message": "Expected to return a value at the end of arrow function.",
        "line": 78,
        "column": 61,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturn",
        "endLine": 78,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 80,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 84,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 98,
        "column": 7,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 98,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 98,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 98,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2925, 2928], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2925, 2928], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response, NextFunction } from 'express';\nimport { ValidationError } from '@/utils/errors';\nimport { CommonValidations } from '@/utils/validation';\nimport type { z } from 'zod';\n\nexport function requestValidationMiddleware(\n  req: Request,\n  _res: Response,\n  next: NextFunction\n): void {\n  // Validate request size\n  const contentLength = parseInt(req.get('Content-Length') || '0', 10);\n  const maxSize = 10 * 1024 * 1024; // 10MB\n\n  if (contentLength > maxSize) {\n    return next(new ValidationError('Request too large'));\n  }\n\n  // Validate content type for POST/PUT/PATCH requests\n  if (['POST', 'PUT', 'PATCH'].includes(req.method)) {\n    const contentType = req.get('Content-Type');\n    if (!contentType || !contentType.includes('application/json')) {\n      return next(new ValidationError('Content-Type must be application/json'));\n    }\n  }\n\n  // Validate UUIDs in path parameters\n  const uuidParams = extractUuidParams(req.path);\n  for (const param of uuidParams) {\n    const value = req.params[param];\n    if (value && !CommonValidations.uuid.safeParse(value).success) {\n      return next(new ValidationError(`Invalid UUID format for parameter: ${String(param)}`));\n    }\n  }\n\n  // Validate query parameters\n  if (req.query.limit) {\n    const limit = parseInt(req.query.limit as string, 10);\n    if (isNaN(limit) || limit <= 0 || limit > 1000) {\n      return next(new ValidationError('Invalid limit parameter'));\n    }\n  }\n\n  if (req.query.offset) {\n    const offset = parseInt(req.query.offset as string, 10);\n    if (isNaN(offset) || offset < 0) {\n      return next(new ValidationError('Invalid offset parameter'));\n    }\n  }\n\n  if (req.query.sortOrder && !['asc', 'desc'].includes(req.query.sortOrder as string)) {\n    return next(new ValidationError('Sort order must be \"asc\" or \"desc\"'));\n  }\n\n  next();\n}\n\nfunction extractUuidParams(path: string): string[] {\n  const uuidPattern = /\\/:([^\\/]+)/g;\n  const params: string[] = [];\n  let match;\n\n  // Extract parameter names that likely contain UUIDs\n  while ((match = uuidPattern.exec(path)) !== null) {\n    const paramName = match[1];\n    if (paramName && (paramName.endsWith('Id') || paramName === 'id')) {\n      params.push(paramName);\n    }\n  }\n\n  return params;\n}\n\n/**\n * Create a validation middleware for request body/query/params\n */\nexport function validateRequest<T>(schema: z.ZodSchema<T>) {\n  return (req: Request, _res: Response, next: NextFunction) => {\n    try {\n      const data = {\n        ...req.body,\n        ...req.query,\n        ...req.params,\n      };\n\n      const result = schema.safeParse(data);\n\n      if (!result.success) {\n        const errors = result.error.errors.map(err => ({\n          path: err.path.join('.'),\n          message: err.message,\n        }));\n\n        return next(new ValidationError('Validation failed', { errors }));\n      }\n\n      // Merge validated data back\n      req.body = result.data as any;\n      next();\n    } catch (error) {\n      next(new ValidationError('Invalid request data'));\n    }\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/backup.ts",
    "messages": [
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 101,
        "column": 3,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 130,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 101,
        "column": 18,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 101,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 103,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 103,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .type on an `any` value.",
        "line": 106,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 106,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .parentBackupId on an `any` value.",
        "line": 107,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 107,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `CreateBackupOptions` assigned to a parameter of type `CreateBackupOptions`.",
        "line": 112,
        "column": 62,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 112,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `CreateBackupOptions` assigned to a parameter of type `CreateBackupOptions`.",
        "line": 114,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 114,
        "endColumn": 62
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 182,
        "column": 3,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 209,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 182,
        "column": 18,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 182,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 243,
        "column": 20,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 267,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 320,
        "column": 67,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 343,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 326,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 326,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `RestoreOptions`.",
        "line": 328,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 328,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 399,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 444,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 401,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 401,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | number | Date`.",
        "line": 408,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 408,
        "endColumn": 43
      },
      {
        "ruleId": "no-restricted-globals",
        "severity": 2,
        "message": "Unexpected use of 'isNaN'. Use Number.isNaN instead https://github.com/airbnb/javascript#standard-library--isnan",
        "line": 409,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "customMessage",
        "endLine": 409,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 421,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 421,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 422,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 422,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 423,
        "column": 7,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 423,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 429,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 429,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 482,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 507,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 547,
        "column": 27,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 605,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 640,
        "column": 23,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 661,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 732,
        "column": 70,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 755,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 738,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 738,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `RestoreOptions`.",
        "line": 740,
        "column": 71,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 740,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 795,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 812,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 878,
        "column": 76,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 901,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 884,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 884,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PartialRestoreOptions`.",
        "line": 886,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 886,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 888,
        "column": 66,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 888,
        "endColumn": 88
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .tables on an `any` value.",
        "line": 888,
        "column": 82,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 888,
        "endColumn": 88
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 961,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 986,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 967,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 967,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `RestoreOptions`.",
        "line": 969,
        "column": 80,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 969,
        "endColumn": 87
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 1039,
        "column": 37,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 1063,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 1096,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 1118,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 22,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Backup Routes - REST API endpoints for backup management\n *\n * @module routes/backup\n * @description Provides REST API endpoints for database backup and restore operations,\n * including full and incremental backups, verification, scheduling, and metadata management.\n */\n\nimport { Router } from 'express';\nimport { BackupService } from '@/services/BackupService';\nimport { dbConnection } from '@/database/connection';\nimport { authenticateApiKey } from '@/middleware/auth';\nimport { validateRequest } from '@/middleware/validation';\nimport { formatSuccessResponse, formatErrorResponse } from '@/middleware/response';\nimport { logger } from '@/utils/logger';\nimport { z } from 'zod';\n\nconst router = Router();\nconst backupService = new BackupService(dbConnection);\n\n// Validation schemas\nconst CreateBackupSchema = z.object({\n  name: z.string().optional(),\n  description: z.string().optional(),\n  type: z.enum(['full', 'incremental']).optional().default('full'),\n  compress: z.boolean().optional().default(true),\n  verify: z.boolean().optional().default(true),\n  parentBackupId: z.string().uuid().optional(),\n});\n\nconst RestoreBackupSchema = z.object({\n  verify: z.boolean().optional().default(true),\n  pointInTime: z.string().datetime().optional(),\n  preserveExisting: z.boolean().optional().default(false),\n});\n\nconst ListBackupsSchema = z.object({\n  limit: z.coerce.number().min(1).max(100).optional().default(20),\n  offset: z.coerce.number().min(0).optional().default(0),\n  type: z.enum(['full', 'incremental']).optional(),\n  status: z.enum(['pending', 'in_progress', 'completed', 'failed', 'corrupted']).optional(),\n});\n\nconst ValidateRestoreSchema = z.object({\n  verify: z.boolean().optional().default(true),\n  pointInTime: z.string().datetime().optional(),\n  preserveExisting: z.boolean().optional().default(false),\n});\n\nconst PartialRestoreSchema = z.object({\n  tables: z.array(z.string()).min(1),\n  includeSchema: z.boolean().optional().default(false),\n  preserveExisting: z.boolean().optional().default(false),\n  validateAfter: z.boolean().optional().default(true),\n  verify: z.boolean().optional().default(true),\n  pointInTime: z.string().datetime().optional(),\n});\n\nconst RestoreWithProgressSchema = z.object({\n  verify: z.boolean().optional().default(true),\n  pointInTime: z.string().datetime().optional(),\n  preserveExisting: z.boolean().optional().default(false),\n});\n\n// Apply authentication to all backup routes\nrouter.use(authenticateApiKey);\n\n/**\n * @openapi\n * /api/backup/create:\n *   post:\n *     summary: Create a new backup\n *     description: Creates a full or incremental backup of the database\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             $ref: '#/components/schemas/CreateBackupRequest'\n *     responses:\n *       201:\n *         description: Backup created successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   $ref: '#/components/schemas/BackupMetadata'\n *       400:\n *         description: Invalid request\n *       500:\n *         description: Backup creation failed\n */\nrouter.post('/create', validateRequest(CreateBackupSchema), (req, res) => {\n  void (async () => {\n    try {\n      const options = req.body as CreateBackupOptions;\n\n      let backup;\n      if (options.type === 'incremental') {\n        if (!options.parentBackupId) {\n          return res\n            .status(400)\n            .json(formatErrorResponse('Parent backup ID is required for incremental backups'));\n        }\n        backup = await backupService.createIncrementalBackup(options);\n      } else {\n        backup = await backupService.createFullBackup(options);\n      }\n\n      logger.info(`Backup created via API: ${String(backup.id)}`);\n      return res.status(201).json(formatSuccessResponse(backup));\n    } catch (error) {\n      logger.error('Backup creation failed:', error);\n      return res\n        .status(500)\n        .json(\n          formatErrorResponse(\n            'Backup creation failed',\n            error instanceof Error ? error.message : 'Unknown error'\n          )\n        );\n    }\n  })();\n});\n\n/**\n * @openapi\n * /api/backup/list:\n *   get:\n *     summary: List all backups\n *     description: Retrieves a list of all backups with optional filtering\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: query\n *         name: limit\n *         schema:\n *           type: integer\n *           minimum: 1\n *           maximum: 100\n *           default: 20\n *       - in: query\n *         name: offset\n *         schema:\n *           type: integer\n *           minimum: 0\n *           default: 0\n *       - in: query\n *         name: type\n *         schema:\n *           type: string\n *           enum: [full, incremental]\n *       - in: query\n *         name: status\n *         schema:\n *           type: string\n *           enum: [pending, in_progress, completed, failed, corrupted]\n *     responses:\n *       200:\n *         description: Backups retrieved successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/BackupMetadata'\n */\nrouter.get('/list', validateRequest(ListBackupsSchema), (req, res) => {\n  void (async () => {\n    try {\n      const options = req.query as {\n        limit?: string;\n        offset?: string;\n        type?: string;\n        status?: string;\n      };\n      const backups = await backupService.listBackups({\n        limit: options.limit ? parseInt(options.limit, 10) : undefined,\n        offset: options.offset ? parseInt(options.offset, 10) : undefined,\n        type: options.type as 'full' | 'incremental' | undefined,\n        status: options.status,\n      });\n\n      return res.json(formatSuccessResponse(backups));\n    } catch (error) {\n      logger.error('Failed to list backups:', error);\n      return res\n        .status(500)\n        .json(\n          formatErrorResponse(\n            'Failed to list backups',\n            error instanceof Error ? error.message : 'Unknown error'\n          )\n        );\n    }\n  })();\n});\n\n/**\n * @openapi\n * /api/backup/{id}:\n *   get:\n *     summary: Get backup details\n *     description: Retrieves detailed information about a specific backup\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Backup details retrieved successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   $ref: '#/components/schemas/BackupMetadata'\n *       404:\n *         description: Backup not found\n */\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Backup ID is required'));\n    }\n    const backup = await backupService.getBackupMetadata(id);\n\n    if (!backup) {\n      return res.status(404).json(formatErrorResponse('Backup not found'));\n    }\n\n    return res.json(formatSuccessResponse(backup));\n  } catch (error) {\n    logger.error(`Failed to get backup ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to get backup',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/{id}/restore:\n *   post:\n *     summary: Restore from backup\n *     description: Restores the database from a specific backup\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     requestBody:\n *       required: false\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               verify:\n *                 type: boolean\n *                 default: true\n *               pointInTime:\n *                 type: string\n *                 format: date-time\n *               preserveExisting:\n *                 type: boolean\n *                 default: false\n *     responses:\n *       200:\n *         description: Database restored successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 message:\n *                   type: string\n *       400:\n *         description: Invalid restore options\n *       404:\n *         description: Backup not found\n *       500:\n *         description: Restore failed\n */\nrouter.post('/:id/restore', validateRequest(RestoreBackupSchema), async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Backup ID is required'));\n    }\n    const options = req.body;\n\n    await backupService.restoreFromBackup(id, options);\n\n    logger.info(`Database restored from backup: ${String(id)}`);\n    return res.json(formatSuccessResponse(null, 'Database restored successfully'));\n  } catch (error) {\n    logger.error(`Restore failed for backup ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Restore failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/restore-to-time:\n *   post:\n *     summary: Restore database to specific point in time\n *     description: Restores the database to a specific point in time using available backups\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required: [targetTime]\n *             properties:\n *               targetTime:\n *                 type: string\n *                 format: date-time\n *                 description: ISO timestamp to restore to\n *               verify:\n *                 type: boolean\n *                 default: true\n *                 description: Verify backups before restoration\n *               preserveExisting:\n *                 type: boolean\n *                 default: false\n *                 description: Create backup of current state before restoration\n *     responses:\n *       200:\n *         description: Point-in-time restoration completed successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 message:\n *                   type: string\n *                 data:\n *                   type: object\n *                   properties:\n *                     restoredTo:\n *                       type: string\n *                       format: date-time\n *                     backupsApplied:\n *                       type: integer\n *       400:\n *         description: Invalid target time or no suitable backups found\n *       500:\n *         description: Point-in-time restoration failed\n */\nrouter.post('/restore-to-time', async (req, res) => {\n  try {\n    const { targetTime, verify = true, preserveExisting = false } = req.body;\n\n    if (!targetTime) {\n      return res.status(400).json(formatErrorResponse('Target time is required'));\n    }\n\n    // Validate target time format\n    const targetDate = new Date(targetTime);\n    if (isNaN(targetDate.getTime())) {\n      return res\n        .status(400)\n        .json(\n          formatErrorResponse(\n            'Invalid target time format. Use ISO format (e.g., 2025-07-26T10:30:00Z)'\n          )\n        );\n    }\n\n    logger.info(`Point-in-time restoration requested to: ${String(targetTime)}`);\n\n    await backupService.restoreToPointInTime(targetTime, {\n      verify,\n      preserveExisting,\n    });\n\n    logger.info(`Point-in-time restoration completed to: ${String(targetTime)}`);\n    return res.json(\n      formatSuccessResponse({\n        restoredTo: targetTime,\n        message: 'Point-in-time restoration completed successfully',\n      })\n    );\n  } catch (error) {\n    logger.error('Point-in-time restoration failed:', error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Point-in-time restoration failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/{id}/verify:\n *   post:\n *     summary: Verify backup integrity\n *     description: Verifies the integrity of a backup file\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Backup verification result\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   type: object\n *                   properties:\n *                     valid:\n *                       type: boolean\n *                     message:\n *                       type: string\n *       404:\n *         description: Backup not found\n */\nrouter.post('/:id/verify', async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Backup ID is required'));\n    }\n    const isValid = await backupService.verifyBackup(id);\n\n    return res.json(\n      formatSuccessResponse({\n        valid: isValid,\n        message: isValid ? 'Backup verification passed' : 'Backup verification failed',\n      })\n    );\n  } catch (error) {\n    logger.error(`Backup verification failed for ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Backup verification failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/{id}/export:\n *   get:\n *     summary: Export backup data\n *     description: Exports backup data in various formats\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *       - in: query\n *         name: format\n *         schema:\n *           type: string\n *           enum: [json, sql, csv]\n *           default: json\n *     responses:\n *       200:\n *         description: Backup exported successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *           application/sql:\n *             schema:\n *               type: string\n *           text/csv:\n *             schema:\n *               type: string\n *       404:\n *         description: Backup not found\n */\nrouter.get('/:id/export', async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Backup ID is required'));\n    }\n    const format = (req.query.format as string) || 'json';\n\n    const backup = await backupService.getBackupMetadata(id);\n    if (!backup) {\n      return res.status(404).json(formatErrorResponse('Backup not found'));\n    }\n\n    // For now, return backup metadata in requested format\n    // In a full implementation, you'd export the actual backup content\n    switch (format) {\n      case 'json':\n        res.setHeader('Content-Type', 'application/json');\n        res.setHeader(\n          'Content-Disposition',\n          `attachment; filename=\"${String(String(backup.name))}.json\"`\n        );\n        return res.json(backup);\n        break;\n      case 'sql':\n        res.setHeader('Content-Type', 'application/sql');\n        res.setHeader(\n          'Content-Disposition',\n          `attachment; filename=\"${String(String(backup.name))}.sql\"`\n        );\n        return res.send(\n          `-- Backup metadata for ${String(String(backup.name))}\\n-- ID: ${String(String(backup.id))}\\n-- Created: ${String(String(backup.createdAt))}`\n        );\n        break;\n      case 'csv':\n        res.setHeader('Content-Type', 'text/csv');\n        res.setHeader(\n          'Content-Disposition',\n          `attachment; filename=\"${String(String(backup.name))}.csv\"`\n        );\n        return res.send(\n          `id,name,type,status,size,created_at\\n${String(String(backup.id))},${String(String(backup.name))},${String(String(backup.type))},${String(String(backup.status))},${String(String(backup.size))},${String(String(backup.createdAt))}`\n        );\n        break;\n      default:\n        return res.status(400).json(formatErrorResponse('Unsupported export format'));\n    }\n  } catch (error) {\n    logger.error(`Backup export failed for ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Backup export failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/{id}:\n *   delete:\n *     summary: Delete backup\n *     description: Deletes a backup and its associated files\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Backup deleted successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 message:\n *                   type: string\n *       404:\n *         description: Backup not found\n *       500:\n *         description: Delete failed\n */\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Backup ID is required'));\n    }\n    await backupService.deleteBackup(id);\n\n    logger.info(`Backup deleted via API: ${String(id)}`);\n    return res.json(formatSuccessResponse(null, 'Backup deleted successfully'));\n  } catch (error) {\n    logger.error(`Failed to delete backup ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to delete backup',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/{id}/validate:\n *   post:\n *     summary: Validate restore options\n *     description: Validates restore options and backup compatibility before restoration\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     requestBody:\n *       required: false\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               verify:\n *                 type: boolean\n *                 default: true\n *               pointInTime:\n *                 type: string\n *                 format: date-time\n *               preserveExisting:\n *                 type: boolean\n *                 default: false\n *     responses:\n *       200:\n *         description: Validation completed\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   type: object\n *                   properties:\n *                     isValid:\n *                       type: boolean\n *                     tableChecks:\n *                       type: array\n *                       items:\n *                         type: object\n *                         properties:\n *                           tableName:\n *                             type: string\n *                           rowCount:\n *                             type: integer\n *                           isValid:\n *                             type: boolean\n *                           message:\n *                             type: string\n *                     errors:\n *                       type: array\n *                       items:\n *                         type: string\n *       404:\n *         description: Backup not found\n *       500:\n *         description: Validation failed\n */\nrouter.post('/:id/validate', validateRequest(ValidateRestoreSchema), async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Backup ID is required'));\n    }\n    const options = req.body;\n\n    const validation = await backupService.validateRestoreOptions(id, options);\n\n    logger.info(`Restore validation completed for backup: ${id}`, { isValid: validation.isValid });\n    return res.json(formatSuccessResponse(validation, 'Validation completed'));\n  } catch (error) {\n    logger.error(`Restore validation failed for backup ${req.params.id}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Validation failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/integrity-check:\n *   post:\n *     summary: Perform data integrity check\n *     description: Performs comprehensive data integrity checks on the database\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     responses:\n *       200:\n *         description: Integrity check completed\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   type: object\n *                   properties:\n *                     isPassed:\n *                       type: boolean\n *                     checks:\n *                       type: array\n *                       items:\n *                         type: object\n *                         properties:\n *                           name:\n *                             type: string\n *                           passed:\n *                             type: boolean\n *                           message:\n *                             type: string\n *       500:\n *         description: Integrity check failed\n */\nrouter.post('/integrity-check', async (req, res) => {\n  try {\n    const integrityCheck = await backupService.performDataIntegrityCheck();\n\n    logger.info('Data integrity check completed', { passed: integrityCheck.isPassed });\n    return res.json(formatSuccessResponse(integrityCheck, 'Integrity check completed'));\n  } catch (error) {\n    logger.error('Data integrity check failed:', error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Integrity check failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/{id}/restore-partial:\n *   post:\n *     summary: Restore specific tables from backup\n *     description: Restores specific tables from a backup while preserving other data\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - tables\n *             properties:\n *               tables:\n *                 type: array\n *                 items:\n *                   type: string\n *                 description: List of table names to restore\n *               includeSchema:\n *                 type: boolean\n *                 default: false\n *               preserveExisting:\n *                 type: boolean\n *                 default: false\n *               validateAfter:\n *                 type: boolean\n *                 default: true\n *               verify:\n *                 type: boolean\n *                 default: true\n *               pointInTime:\n *                 type: string\n *                 format: date-time\n *     responses:\n *       200:\n *         description: Partial restore completed successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 message:\n *                   type: string\n *       400:\n *         description: Invalid restore options\n *       404:\n *         description: Backup not found\n *       500:\n *         description: Partial restore failed\n */\nrouter.post('/:id/restore-partial', validateRequest(PartialRestoreSchema), async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Backup ID is required'));\n    }\n    const options = req.body;\n\n    await backupService.restorePartialData(id, options);\n\n    logger.info(`Partial restore completed for backup: ${id}`, { tables: options.tables });\n    return res.json(formatSuccessResponse(null, 'Partial restore completed successfully'));\n  } catch (error) {\n    logger.error(`Partial restore failed for backup ${req.params.id}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Partial restore failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/{id}/restore-with-progress:\n *   post:\n *     summary: Restore with progress tracking\n *     description: Restores from backup with progress tracking and returns a progress ID\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     requestBody:\n *       required: false\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               verify:\n *                 type: boolean\n *                 default: true\n *               pointInTime:\n *                 type: string\n *                 format: date-time\n *               preserveExisting:\n *                 type: boolean\n *                 default: false\n *     responses:\n *       200:\n *         description: Restore started with progress tracking\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   type: object\n *                   properties:\n *                     progressId:\n *                       type: string\n *                       format: uuid\n *       400:\n *         description: Invalid restore options\n *       404:\n *         description: Backup not found\n *       500:\n *         description: Restore failed\n */\nrouter.post(\n  '/:id/restore-with-progress',\n  validateRequest(RestoreWithProgressSchema),\n  async (req, res) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        return res.status(400).json(formatErrorResponse('Backup ID is required'));\n      }\n      const options = req.body;\n\n      const progressId = await backupService.restoreFromBackupWithProgress(id, options);\n\n      logger.info(`Restore with progress started for backup: ${id}`, { progressId });\n      return res.json(\n        formatSuccessResponse({ progressId }, 'Restore started with progress tracking')\n      );\n    } catch (error) {\n      logger.error(`Restore with progress failed for backup ${req.params.id}:`, error);\n      return res\n        .status(500)\n        .json(\n          formatErrorResponse(\n            'Restore failed',\n            error instanceof Error ? error.message : 'Unknown error'\n          )\n        );\n    }\n  }\n);\n\n/**\n * @openapi\n * /api/backup/progress/{progressId}:\n *   get:\n *     summary: Get restore progress\n *     description: Gets the current progress of a restore operation\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: progressId\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Progress information retrieved\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 data:\n *                   type: object\n *                   properties:\n *                     id:\n *                       type: string\n *                       format: uuid\n *                     totalSteps:\n *                       type: integer\n *                     currentStep:\n *                       type: integer\n *                     progress:\n *                       type: integer\n *                       minimum: 0\n *                       maximum: 100\n *                     message:\n *                       type: string\n *                     updatedAt:\n *                       type: string\n *                       format: date-time\n *       404:\n *         description: Progress not found\n *       500:\n *         description: Failed to get progress\n */\nrouter.get('/progress/:progressId', async (req, res) => {\n  try {\n    const { progressId } = req.params;\n    if (!progressId) {\n      return res.status(400).json(formatErrorResponse('Progress ID is required'));\n    }\n\n    const progress = await backupService.getRestoreProgress(progressId);\n    if (!progress) {\n      return res.status(404).json(formatErrorResponse('Progress not found'));\n    }\n\n    return res.json(formatSuccessResponse(progress, 'Progress retrieved'));\n  } catch (error) {\n    logger.error(`Failed to get progress ${req.params.progressId}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to get progress',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/backup/progress/{progressId}:\n *   delete:\n *     summary: Clear restore progress\n *     description: Clears the progress tracking for a restore operation\n *     tags: [Backup]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: progressId\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Progress cleared successfully\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 success:\n *                   type: boolean\n *                 message:\n *                   type: string\n *       500:\n *         description: Failed to clear progress\n */\nrouter.delete('/progress/:progressId', async (req, res) => {\n  try {\n    const { progressId } = req.params;\n    if (!progressId) {\n      return res.status(400).json(formatErrorResponse('Progress ID is required'));\n    }\n\n    await backupService.clearRestoreProgress(progressId);\n\n    logger.info(`Progress cleared: ${progressId}`);\n    return res.json(formatSuccessResponse(null, 'Progress cleared successfully'));\n  } catch (error) {\n    logger.error(`Failed to clear progress ${req.params.progressId}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to clear progress',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/boards.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 83,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 126,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 94,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 94,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2776, 2779], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2776, 2779], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .archived on an `any` value.",
        "line": 103,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 103,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .archived on an `any` value.",
        "line": 105,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 105,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PaginationOptions & FilterOptions`.",
        "line": 108,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 108,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 111,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 111,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 112,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 112,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .offset on an `any` value.",
        "line": 113,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 113,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PaginationOptions & FilterOptions`.",
        "line": 114,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 114,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .offset on an `any` value.",
        "line": 119,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 119,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 119,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 119,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
        "line": 120,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 120,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 120,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 120,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 169,
        "column": 48,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 177,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 213,
        "column": 49,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 239,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 272,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 289,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 309,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 322,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 353,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 366,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 369,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 382,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 421,
        "column": 61,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 436,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 429,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 429,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | undefined`.",
        "line": 431,
        "column": 62,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 431,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 439,
        "column": 57,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 457,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 547,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 598,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 566,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 566,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16518, 16521], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16518, 16521], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .column_id on an `any` value.",
        "line": 574,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 574,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .status on an `any` value.",
        "line": 575,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 575,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .assignee on an `any` value.",
        "line": 576,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 576,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .search on an `any` value.",
        "line": 577,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 577,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PaginationOptions & TaskFilters`.",
        "line": 579,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 579,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PaginationOptions & TaskFilters`.",
        "line": 582,
        "column": 53,
        "nodeType": "ObjectExpression",
        "messageId": "unsafeArgument",
        "endLine": 586,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .offset on an `any` value.",
        "line": 591,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 591,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 591,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 591,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
        "line": 592,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 592,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 592,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 592,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 648,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 661,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 18,
    "fatalErrorCount": 0,
    "warningCount": 18,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @module routes/boards\n * @description RESTful API routes for board management.\n *\n * This module provides comprehensive board operations including CRUD operations,\n * archiving, duplication, and board analytics. All routes require authentication\n * and appropriate permissions.\n *\n * Base path: `/api/v1/boards`\n *\n * @example\n * ```typescript\n * // Client usage example\n * const response = await fetch('/api/v1/boards', {\n *   method: 'GET',\n *   headers: {\n *     'X-API-Key': 'your-api-key',\n *     'Content-Type': 'application/json'\n *   }\n * });\n * ```\n */\n\nimport { Router } from 'express';\nimport { BoardService } from '@/services/BoardService';\nimport { TaskService } from '@/services/TaskService';\nimport { dbConnection } from '@/database/connection';\nimport { requirePermission } from '@/middleware/auth';\nimport { BoardValidation, validateInput } from '@/utils/validation';\nimport { NotFoundError } from '@/utils/errors';\n\n/**\n * Create and configure board routes.\n *\n * @returns Express router with all board endpoints configured\n */\nexport function boardRoutes(): Router {\n  const router = Router();\n\n  const boardService = new BoardService(dbConnection);\n  const taskService = new TaskService(dbConnection);\n\n  /**\n   * List boards with filtering, sorting, and pagination.\n   *\n   * @route GET /api/v1/boards\n   * @auth Required - Read permission\n   *\n   * @queryparam {number} limit - Maximum boards to return (default: 50)\n   * @queryparam {number} offset - Pagination offset (default: 0)\n   * @queryparam {string} sortBy - Field to sort by: updated_at, created_at, name (default: updated_at)\n   * @queryparam {string} sortOrder - Sort direction: asc or desc (default: desc)\n   * @queryparam {boolean} archived - Filter by archive status (true/false)\n   * @queryparam {string} search - Search in board names and descriptions\n   *\n   * @response 200 - Success\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": [\n   *     {\n   *       \"id\": \"board123\",\n   *       \"name\": \"Development Board\",\n   *       \"description\": \"Main development tasks\",\n   *       \"archived\": false,\n   *       \"created_at\": \"2024-01-20T10:00:00Z\",\n   *       \"updated_at\": \"2024-01-21T14:30:00Z\"\n   *     }\n   *   ],\n   *   \"pagination\": {\n   *     \"page\": 1,\n   *     \"limit\": 50,\n   *     \"total\": 10,\n   *     \"totalPages\": 1\n   *   }\n   * }\n   * ```\n   *\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   */\n  // GET /api/v1/boards - List boards\n  router.get('/', requirePermission('read'), async (req, res, next) => {\n    try {\n      const {\n        limit = 50,\n        offset = 0,\n        sortBy = 'updated_at',\n        sortOrder = 'desc',\n        archived,\n        search,\n      } = req.query;\n\n      const options: any = {\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n        sortBy: sortBy as string,\n        sortOrder: sortOrder as 'asc' | 'desc',\n        search: search as string,\n      };\n\n      if (archived === 'true') {\n        options.archived = true;\n      } else if (archived === 'false') {\n        options.archived = false;\n      }\n\n      const boards = await boardService.getBoards(options);\n\n      // Get total count for pagination\n      const countOptions = { ...options };\n      delete countOptions.limit;\n      delete countOptions.offset;\n      const totalBoards = await boardService.getBoards(countOptions);\n      const total = totalBoards.length;\n\n      return res.apiPagination(\n        boards,\n        Math.floor(options.offset / options.limit) + 1,\n        options.limit,\n        total\n      );\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Create a new board.\n   *\n   * @route POST /api/v1/boards\n   * @auth Required - Write permission\n   *\n   * @bodyparam {string} name - Board name (required)\n   * @bodyparam {string} [description] - Board description\n   * @bodyparam {boolean} [is_public] - Make board publicly accessible (default: false)\n   * @bodyparam {Object[]} [columns] - Initial columns configuration\n   * @bodyparam {string} columns[].name - Column name\n   * @bodyparam {number} columns[].order - Column position\n   * @bodyparam {number} columns[].wip_limit - Work-in-progress limit\n   *\n   * @response 201 - Board created successfully\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"board456\",\n   *     \"name\": \"New Board\",\n   *     \"description\": \"Board description\",\n   *     \"is_public\": false,\n   *     \"created_at\": \"2024-01-20T10:00:00Z\",\n   *     \"columns\": [\n   *       {\n   *         \"id\": \"col123\",\n   *         \"name\": \"To Do\",\n   *         \"order\": 0,\n   *         \"wip_limit\": null\n   *       }\n   *     ]\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid input data\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   */\n  // POST /api/v1/boards - Create board\n  router.post('/', requirePermission('write'), async (req, res, next) => {\n    try {\n      const boardData = validateInput(BoardValidation.create, req.body);\n      const board = await boardService.createBoard(boardData);\n      return res.status(201).apiSuccess(board);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Get detailed information about a specific board.\n   *\n   * @route GET /api/v1/boards/:id\n   * @auth Required - Read permission\n   *\n   * @param {string} id - Board ID\n   * @queryparam {string} [include] - Include related data: 'columns' or 'tasks'\n   *\n   * @response 200 - Success\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"board123\",\n   *     \"name\": \"Development Board\",\n   *     \"description\": \"Main development tasks\",\n   *     \"is_public\": false,\n   *     \"archived\": false,\n   *     \"created_at\": \"2024-01-20T10:00:00Z\",\n   *     \"updated_at\": \"2024-01-21T14:30:00Z\",\n   *     \"columns\": [],  // If include=columns\n   *     \"task_count\": 45,  // If include=tasks\n   *     \"completed_tasks\": 20  // If include=tasks\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid board ID\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Board not found\n   */\n  // GET /api/v1/boards/:id - Get board details\n  router.get('/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const { include } = req.query;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      let board;\n      if (include === 'columns') {\n        board = await boardService.getBoardWithColumns(id);\n      } else if (include === 'tasks') {\n        board = await boardService.getBoardWithStats(id);\n      } else {\n        board = await boardService.getBoardById(id);\n      }\n\n      if (!board) {\n        throw new NotFoundError('Board', id);\n      }\n\n      return res.apiSuccess(board);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Update board properties.\n   *\n   * @route PATCH /api/v1/boards/:id\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Board ID\n   * @bodyparam {string} [name] - New board name\n   * @bodyparam {string} [description] - New description\n   * @bodyparam {boolean} [is_public] - Update visibility\n   * @bodyparam {boolean} [archived] - Archive status\n   *\n   * @response 200 - Board updated successfully\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"board123\",\n   *     \"name\": \"Updated Board Name\",\n   *     \"description\": \"Updated description\",\n   *     \"updated_at\": \"2024-01-21T15:00:00Z\"\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid input data\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Board not found\n   */\n  // PATCH /api/v1/boards/:id - Update board\n  router.patch('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      const rawUpdateData = validateInput(BoardValidation.update, req.body);\n      const updateData = Object.fromEntries(\n        Object.entries(rawUpdateData).filter(([, value]) => value !== undefined)\n      );\n      const board = await boardService.updateBoard(id, updateData);\n      return res.apiSuccess(board);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Delete a board permanently.\n   *\n   * @route DELETE /api/v1/boards/:id\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Board ID to delete\n   *\n   * @response 204 - Board deleted successfully (no content)\n   * @response 400 - Invalid board ID\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Board not found\n   *\n   * @warning This permanently deletes the board and all associated data\n   * including columns, tasks, notes, and tags. This action cannot be undone.\n   */\n  // DELETE /api/v1/boards/:id - Delete board\n  router.delete('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      await boardService.deleteBoard(id);\n      return res.status(204).send();\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Archive a board to hide it from active lists.\n   *\n   * @route POST /api/v1/boards/:id/archive\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Board ID to archive\n   *\n   * @response 200 - Board archived successfully\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"board123\",\n   *     \"name\": \"Archived Board\",\n   *     \"archived\": true,\n   *     \"archived_at\": \"2024-01-21T15:00:00Z\"\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid board ID\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Board not found\n   *\n   * @note Archived boards can be restored using POST /api/v1/boards/:id/restore\n   */\n  // POST /api/v1/boards/:id/archive - Archive board\n  router.post('/:id/archive', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      const board = await boardService.archiveBoard(id);\n      return res.apiSuccess(board);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/boards/:id/restore - Restore archived board\n  router.post('/:id/restore', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      const board = await boardService.unarchiveBoard(id);\n      return res.apiSuccess(board);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Duplicate an existing board with all its columns.\n   *\n   * @route POST /api/v1/boards/:id/duplicate\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Board ID to duplicate\n   * @bodyparam {string} [name] - Name for the new board (default: \"Copy of [original]\")\n   *\n   * @response 201 - Board duplicated successfully\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"board789\",\n   *     \"name\": \"Copy of Development Board\",\n   *     \"description\": \"Main development tasks\",\n   *     \"created_at\": \"2024-01-21T15:00:00Z\",\n   *     \"columns\": [\n   *       {\n   *         \"id\": \"col456\",\n   *         \"name\": \"To Do\",\n   *         \"order\": 0\n   *       }\n   *     ]\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid board ID\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Board not found\n   *\n   * @note Tasks are not duplicated, only the board structure\n   */\n  // POST /api/v1/boards/:id/duplicate - Duplicate board\n  router.post('/:id/duplicate', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      const { name } = req.body;\n\n      const newBoard = await boardService.duplicateBoard(id, name);\n      return res.status(201).apiSuccess(newBoard);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/boards/:id/columns - Get board columns\n  router.get('/:id/columns', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      const boardWithColumns = await boardService.getBoardWithColumns(id);\n\n      if (!boardWithColumns) {\n        throw new NotFoundError('Board', id);\n      }\n\n      return res.apiSuccess(boardWithColumns.columns ?? []);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // TODO: Column routes should be implemented in a separate column service\n  // These are commented out as BoardService doesn't have column management methods\n  /*\n  // POST /api/v1/boards/:id/columns - Create column\n  router.post('/:id/columns', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const columnData = validateInput(BoardValidation.column.create, {\n        ...req.body,\n        board_id: id,\n      });\n      \n      const column = await boardService.createColumn(columnData);\n      res.status(201).apiSuccess(column);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // PATCH /api/v1/boards/:id/columns/:columnId - Update column\n  router.patch('/:id/columns/:columnId', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { columnId } = req.params;\n      const updateData = validateInput(BoardValidation.column.update, req.body);\n      const column = await boardService.updateColumn(columnId, updateData);\n      res.apiSuccess(column);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // DELETE /api/v1/boards/:id/columns/:columnId - Delete column\n  router.delete('/:id/columns/:columnId', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { columnId } = req.params;\n      await boardService.deleteColumn(columnId);\n      res.status(204).send();\n    } catch (error) {\n      return next(error);\n    }\n  });\n  */\n\n  /**\n   * Get all tasks in a board with filtering and sorting.\n   *\n   * @route GET /api/v1/boards/:id/tasks\n   * @auth Required - Read permission\n   *\n   * @param {string} id - Board ID\n   * @queryparam {number} limit - Maximum tasks to return (default: 50)\n   * @queryparam {number} offset - Pagination offset (default: 0)\n   * @queryparam {string} sortBy - Sort field: position, priority, created_at (default: position)\n   * @queryparam {string} sortOrder - Sort direction: asc or desc (default: asc)\n   * @queryparam {string} column_id - Filter by specific column\n   * @queryparam {string} status - Filter by task status\n   * @queryparam {string} assignee - Filter by assignee\n   * @queryparam {string} search - Search in task titles and descriptions\n   *\n   * @response 200 - Success with paginated task list\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": [\n   *     {\n   *       \"id\": \"task123\",\n   *       \"title\": \"Task in board\",\n   *       \"column_id\": \"col123\",\n   *       \"position\": 0,\n   *       \"status\": \"in_progress\",\n   *       \"priority\": 7\n   *     }\n   *   ],\n   *   \"pagination\": {\n   *     \"page\": 1,\n   *     \"limit\": 50,\n   *     \"total\": 45,\n   *     \"totalPages\": 1\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid board ID\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Board not found\n   */\n  // GET /api/v1/boards/:id/tasks - Get board tasks\n  router.get('/:id/tasks', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      const {\n        limit = 50,\n        offset = 0,\n        sortBy = 'position',\n        sortOrder = 'asc',\n        column_id,\n        status,\n        assignee,\n        search,\n      } = req.query;\n\n      const options: any = {\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n        sortBy: sortBy as string,\n        sortOrder: sortOrder as 'asc' | 'desc',\n        board_id: id,\n      };\n\n      if (column_id) options.column_id = column_id as string;\n      if (status) options.status = status;\n      if (assignee) options.assignee = assignee as string;\n      if (search) options.search = search as string;\n\n      const tasks = await taskService.getTasks(options);\n\n      // Get total count for pagination\n      const totalTasks = await taskService.getTasks({\n        ...options,\n        limit: undefined,\n        offset: undefined,\n      });\n      const total = totalTasks.length;\n\n      return res.apiPagination(\n        tasks,\n        Math.floor(options.offset / options.limit) + 1,\n        options.limit,\n        total\n      );\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Get analytics and statistics for a board.\n   *\n   * @route GET /api/v1/boards/:id/analytics\n   * @auth Required - Read permission\n   *\n   * @param {string} id - Board ID\n   *\n   * @response 200 - Board analytics data\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"board123\",\n   *     \"name\": \"Development Board\",\n   *     \"statistics\": {\n   *       \"total_tasks\": 45,\n   *       \"completed_tasks\": 20,\n   *       \"in_progress_tasks\": 15,\n   *       \"blocked_tasks\": 3,\n   *       \"overdue_tasks\": 2,\n   *       \"completion_rate\": 0.44,\n   *       \"average_task_age_days\": 12.5\n   *     },\n   *     \"column_statistics\": [\n   *       {\n   *         \"column_id\": \"col123\",\n   *         \"column_name\": \"In Progress\",\n   *         \"task_count\": 15,\n   *         \"wip_limit\": 10,\n   *         \"is_over_limit\": true\n   *       }\n   *     ],\n   *     \"recent_activity\": {\n   *       \"tasks_created_today\": 5,\n   *       \"tasks_completed_today\": 3,\n   *       \"tasks_updated_today\": 12\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid board ID\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Board not found\n   */\n  // GET /api/v1/boards/:id/analytics - Get board analytics\n  router.get('/:id/analytics', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Board ID is required' });\n      }\n\n      const analytics = await boardService.getBoardWithStats(id);\n      return res.apiSuccess(analytics);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  return router;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/context.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 28,
        "column": 58,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 51,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 54,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 81,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 84,
        "column": 56,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 107,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 110,
        "column": 54,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 118,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 110,
        "column": 77,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 110,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 112,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 112,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 113,
        "column": 71,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 113,
        "endColumn": 89
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 121,
        "column": 65,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 143,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 121,
        "column": 88,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 121,
        "endColumn": 90
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 146,
        "column": 64,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 166,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 146,
        "column": 87,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 146,
        "endColumn": 89
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 169,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 190,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 169,
        "column": 76,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 169,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 193,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 207,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 193,
        "column": 76,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 193,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 195,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 195,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 196,
        "column": 73,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 196,
        "endColumn": 89
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 210,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 218,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 210,
        "column": 78,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 210,
        "endColumn": 80
      }
    ],
    "suppressedMessages": [],
    "errorCount": 15,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Router } from 'express';\nimport { ContextService } from '@/services/ContextService';\nimport { BoardService } from '@/services/BoardService';\nimport { TaskService } from '@/services/TaskService';\nimport { NoteService } from '@/services/NoteService';\nimport { TagService } from '@/services/TagService';\nimport { dbConnection } from '@/database/connection';\nimport { requirePermission } from '@/middleware/auth';\n// import { validateInput } from '@/utils/validation'; // Unused\nimport { NotFoundError } from '@/utils/errors';\n\nexport function contextRoutes(): Router {\n  const router = Router();\n\n  const boardService = new BoardService(dbConnection);\n  const taskService = new TaskService(dbConnection);\n  const noteService = new NoteService(dbConnection);\n  const tagService = new TagService(dbConnection);\n  const contextService = new ContextService(\n    dbConnection,\n    boardService,\n    taskService,\n    noteService,\n    tagService\n  );\n\n  // GET /api/v1/context/projects/:id - Generate project context\n  router.get('/projects/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const { includeCompletedTasks = false, maxTasks = 100 } = req.query;\n\n      const options = {\n        include_completed: includeCompletedTasks === 'true',\n        days_back: 30,\n        max_items: parseInt(maxTasks as string, 10),\n        include_metrics: true,\n        detail_level: 'detailed' as const,\n      };\n\n      const context = await contextService.getProjectContext(options);\n\n      if (!context) {\n        throw new NotFoundError('Project', id ?? 'unknown');\n      }\n\n      return res.apiSuccess(context);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/context/tasks/:id - Generate task context\n  router.get('/tasks/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const { maxRelatedTasks = 10 } = req.query;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Task ID is required' });\n      }\n\n      const options = {\n        include_completed: true,\n        days_back: 30,\n        max_items: parseInt(maxRelatedTasks as string, 10),\n        include_metrics: true,\n        detail_level: 'detailed' as const,\n      };\n\n      const context = await contextService.getTaskContext(id, options);\n\n      if (!context) {\n        throw new NotFoundError('Task', id);\n      }\n\n      return res.apiSuccess(context);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/context/boards/:id - Generate board context\n  router.get('/boards/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const { includeCompletedTasks = false, maxTasks = 200 } = req.query;\n\n      const options = {\n        include_completed: includeCompletedTasks === 'true',\n        days_back: 30,\n        max_items: parseInt(maxTasks as string, 10),\n        include_metrics: true,\n        detail_level: 'detailed' as const,\n      };\n\n      const context = await contextService.getProjectContext(options);\n\n      if (!context) {\n        throw new NotFoundError('Board', id ?? 'unknown');\n      }\n\n      return res.apiSuccess(context);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/context/analyze - Analyze context for insights\n  router.post('/analyze', requirePermission('read'), async (req, res, next) => {\n    try {\n      const analysisData = req.body;\n      const analysis = { message: 'Context analysis not implemented', data: analysisData };\n      return res.apiSuccess(analysis);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/context/insights/boards/:id - Get board insights\n  router.get('/insights/boards/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const {\n        timeframe = 30,\n        includeRecommendations = true,\n        includeBlockers = true,\n        includeMetrics = true,\n      } = req.query;\n\n      const options = {\n        timeframe: parseInt(timeframe as string, 10),\n        includeRecommendations: includeRecommendations === 'true',\n        includeBlockers: includeBlockers === 'true',\n        includeMetrics: includeMetrics === 'true',\n      };\n\n      const insights = { message: 'Board insights not implemented', boardId: id, options };\n      return res.apiSuccess(insights);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/context/insights/tasks/:id - Get task insights\n  router.get('/insights/tasks/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const {\n        includeBlockers = true,\n        includeEstimates = true,\n        includeRecommendations = true,\n      } = req.query;\n\n      const options = {\n        includeBlockers: includeBlockers === 'true',\n        includeEstimates: includeEstimates === 'true',\n        includeRecommendations: includeRecommendations === 'true',\n      };\n\n      const insights = { message: 'Task insights not implemented', taskId: id, options };\n      return res.apiSuccess(insights);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/context/summary - Get overall system summary\n  router.get('/summary', requirePermission('read'), async (req, res, next) => {\n    try {\n      const {\n        includeMetrics = true,\n        includeRecentActivity = true,\n        includeTopTags = true,\n        timeframe = 7,\n      } = req.query;\n\n      const options = {\n        includeMetrics: includeMetrics === 'true',\n        includeRecentActivity: includeRecentActivity === 'true',\n        includeTopTags: includeTopTags === 'true',\n        timeframe: parseInt(timeframe as string, 10),\n      };\n\n      const summary = { message: 'System summary not implemented', options };\n      return res.apiSuccess(summary);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/context/export - Export context data\n  router.post('/export', requirePermission('read'), async (req, res, next) => {\n    try {\n      const exportData = req.body;\n      const exportResult = { message: 'Context export not implemented', data: exportData };\n\n      res.set({\n        'Content-Type': 'application/json',\n        'Content-Disposition': `attachment; filename=\"context-export-${String(String(Date.now()))}.json\"`,\n      });\n\n      return res.apiSuccess(exportResult);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/context/templates - Get context templates\n  router.get('/templates', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { type } = req.query;\n      const templates = { message: 'Context templates not implemented', type, templates: [] };\n      return res.apiSuccess(templates);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  return router;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/export.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 49,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 90,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 57,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 57,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1950, 1953], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1950, 1953], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .includeBoards on an `any` value.",
        "line": 61,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 61,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .includeTasks on an `any` value.",
        "line": 62,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 62,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .includeTags on an `any` value.",
        "line": 63,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 63,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .includeNotes on an `any` value.",
        "line": 64,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 64,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .boardIds on an `any` value.",
        "line": 65,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 65,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskStatuses on an `any` value.",
        "line": 66,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 66,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dateFrom on an `any` value.",
        "line": 67,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 67,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .dateTo on an `any` value.",
        "line": 68,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 68,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .format on an `any` value.",
        "line": 70,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 70,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ExportOptions`.",
        "line": 71,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 71,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .outputPath on an `any` value.",
        "line": 76,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 76,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ExportOptions`.",
        "line": 77,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 77,
        "endColumn": 46
      },
      {
        "ruleId": "consistent-return",
        "severity": 2,
        "message": "Expected to return a value at the end of arrow function.",
        "line": 80,
        "column": 62,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturn",
        "endLine": 80,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 85,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 85,
        "endColumn": 33
      },
      {
        "ruleId": "global-require",
        "severity": 2,
        "message": "Unexpected require().",
        "line": 85,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "unexpected",
        "endLine": 85,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 85,
        "column": 9,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 85,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .unlinkSync on an `any` value.",
        "line": 85,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 85,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 98,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 106,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 98,
        "column": 60,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 98,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 113,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 121,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 113,
        "column": 60,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 113,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 128,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 155,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 141,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 141,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 162,
        "column": 3,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 190,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 170,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 170,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5516, 5519], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5516, 5519], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .format on an `any` value.",
        "line": 182,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 182,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ExportOptions`.",
        "line": 183,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 183,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `ExportOptions`.",
        "line": 184,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 184,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 14,
    "fatalErrorCount": 0,
    "warningCount": 16,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type { Request, Response, NextFunction } from 'express';\nimport { Router } from 'express';\nimport { ExportService } from '@/services/ExportService';\nimport { requirePermission } from '@/middleware/auth';\nimport { validateInput } from '@/utils/validation';\nimport { z } from 'zod';\n// import multer from 'multer';\nimport { dbConnection } from '@/database/connection';\n\nconst router = Router();\n// const upload = multer({ dest: '/tmp/uploads/' });\n\n// Validation schemas\nconst ExportSchema = z.object({\n  format: z.enum(['json', 'csv']),\n  includeBoards: z.boolean().optional(),\n  includeTasks: z.boolean().optional(),\n  includeTags: z.boolean().optional(),\n  includeNotes: z.boolean().optional(),\n  boardIds: z.array(z.string().uuid()).optional(),\n  taskStatuses: z.array(z.string()).optional(),\n  dateFrom: z.string().datetime().optional(),\n  dateTo: z.string().datetime().optional(),\n  anonymize: z.boolean().optional(),\n  anonymizationOptions: z\n    .object({\n      anonymizeUserData: z.boolean().optional(),\n      anonymizeTaskTitles: z.boolean().optional(),\n      anonymizeDescriptions: z.boolean().optional(),\n      anonymizeNotes: z.boolean().optional(),\n      preserveStructure: z.boolean().optional(),\n      hashSeed: z.string().optional(),\n    })\n    .optional(),\n});\n\n// const _ImportSchema = z.object({\n//   format: z.enum(['json', 'csv']),\n//   merge: z.boolean().optional(),\n//   overwrite: z.boolean().optional(),\n//   validateOnly: z.boolean().optional(),\n//   conflictResolution: z.enum(['skip', 'overwrite', 'rename']).optional()\n// });\n\n// GET /api/v1/export - Export data\nrouter.get(\n  '/export',\n  requirePermission('read'),\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const validated = validateInput(ExportSchema, req.query);\n\n      const db = dbConnection;\n      const exportService = new ExportService(db);\n\n      // Build options object omitting undefined values\n      const options: any = {\n        format: validated.format,\n      };\n\n      if (validated.includeBoards !== undefined) options.includeBoards = validated.includeBoards;\n      if (validated.includeTasks !== undefined) options.includeTasks = validated.includeTasks;\n      if (validated.includeTags !== undefined) options.includeTags = validated.includeTags;\n      if (validated.includeNotes !== undefined) options.includeNotes = validated.includeNotes;\n      if (validated.boardIds !== undefined) options.boardIds = validated.boardIds;\n      if (validated.taskStatuses !== undefined) options.taskStatuses = validated.taskStatuses;\n      if (validated.dateFrom !== undefined) options.dateFrom = new Date(validated.dateFrom);\n      if (validated.dateTo !== undefined) options.dateTo = new Date(validated.dateTo);\n\n      if (options.format === 'json') {\n        const result = await exportService.exportToJSON(options);\n        return res.apiSuccess(result);\n      }\n      // For CSV, we need to handle file output differently\n      const filePath = `/tmp/kanban-export-${String(Date.now())}.csv`;\n      options.outputPath = filePath;\n      await exportService.exportToCSV(options);\n\n      // Send file as download\n      return res.download(filePath, 'kanban-export.csv', err => {\n        if (err) {\n          return next(err);\n        }\n        // Clean up temp file\n        require('fs').unlinkSync(filePath);\n      });\n    } catch (error) {\n      return next(error);\n    }\n  }\n);\n\n// POST /api/v1/import - Import data\n// Note: This endpoint requires multer middleware which is not installed\nrouter.post(\n  '/import',\n  requirePermission('write'),\n  async (_req: Request, res: Response, next: NextFunction) => {\n    try {\n      return res\n        .status(501)\n        .apiError('Import functionality requires multer middleware', 'NOT_IMPLEMENTED');\n    } catch (error) {\n      return next(error);\n    }\n  }\n);\n\n// POST /api/v1/import/validate - Validate import data\nrouter.post(\n  '/import/validate',\n  requirePermission('read'),\n  async (_req: Request, res: Response, next: NextFunction) => {\n    try {\n      return res\n        .status(501)\n        .apiError('Import validation requires multer middleware', 'NOT_IMPLEMENTED');\n    } catch (error) {\n      return next(error);\n    }\n  }\n);\n\n// POST /api/v1/export/convert - Convert between export formats\nrouter.post(\n  '/convert',\n  requirePermission('write'),\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const ConvertSchema = z.object({\n        inputPath: z.string(),\n        outputFormat: z.enum(['json', 'csv', 'markdown', 'html']),\n        outputPath: z.string(),\n      });\n\n      const validated = validateInput(ConvertSchema, req.body);\n\n      const db = dbConnection;\n      const exportService = new ExportService(db);\n\n      await exportService.convertFormat(\n        validated.inputPath,\n        validated.outputFormat,\n        validated.outputPath\n      );\n\n      return res.apiSuccess({\n        message: 'Format conversion completed successfully',\n        outputPath: validated.outputPath,\n        format: validated.outputFormat,\n      });\n    } catch (error) {\n      return next(error);\n    }\n  }\n);\n\n// GET /api/v1/export/anonymized - Export with anonymization\nrouter.get(\n  '/anonymized',\n  requirePermission('read'),\n  async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const validated = validateInput(ExportSchema, req.query);\n\n      const db = dbConnection;\n      const exportService = new ExportService(db);\n\n      // Force anonymization\n      const options: any = {\n        ...validated,\n        anonymize: true,\n        anonymizationOptions: validated.anonymizationOptions ?? {\n          anonymizeUserData: true,\n          anonymizeTaskTitles: true,\n          anonymizeDescriptions: true,\n          anonymizeNotes: true,\n          preserveStructure: false,\n        },\n      };\n\n      const result = await (options.format === 'json'\n        ? exportService.exportToJSON(options)\n        : exportService.exportToCSV(options));\n\n      return res.apiSuccess(result);\n    } catch (error) {\n      return next(error);\n    }\n  }\n);\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/health.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 11,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 31,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 34,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 62,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 65,
        "column": 24,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 79,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Router } from 'express';\nimport { dbConnection } from '@/database/connection';\nimport { config } from '@/config';\nimport { webSocketManager } from '@/websocket';\nimport '@/middleware/response';\n\nexport function healthRoutes(): Router {\n  const router = Router();\n\n  // Basic health check\n  router.get('/health', async (_req, res) => {\n    const health = await dbConnection.healthCheck();\n\n    const status = health.connected && health.responsive ? 'healthy' : 'unhealthy';\n    const statusCode = status === 'healthy' ? 200 : 503;\n\n    res.status(statusCode).apiSuccess({\n      status,\n      version: config.mcp.serverVersion,\n      database: {\n        connected: health.connected,\n        responsive: health.responsive,\n        responseTime: health.stats?.responseTime,\n      },\n      websocket: {\n        running: !!webSocketManager,\n        clients: webSocketManager?.getClientCount() || 0,\n      },\n      uptime: process.uptime(),\n    });\n  });\n\n  // Detailed health check\n  router.get('/health/detailed', async (_req, res) => {\n    const health = await dbConnection.healthCheck();\n    const stats = await dbConnection.getStats();\n\n    res.apiSuccess({\n      status: health.connected && health.responsive ? 'healthy' : 'unhealthy',\n      timestamp: new Date().toISOString(),\n      version: config.mcp.serverVersion,\n      database: {\n        connected: health.connected,\n        responsive: health.responsive,\n        responseTime: health.stats?.responseTime,\n        size: stats.size,\n        tables: stats.tables,\n        walMode: stats.walMode,\n      },\n      websocket: {\n        running: !!webSocketManager,\n        clients: webSocketManager?.getClientCount() || 0,\n        subscriptions: webSocketManager?.getSubscriptionManager().getStats() || null,\n      },\n      system: {\n        uptime: process.uptime(),\n        memory: process.memoryUsage(),\n        nodeVersion: process.version,\n        platform: process.platform,\n      },\n    });\n  });\n\n  // Readiness check\n  router.get('/ready', async (_req, res) => {\n    try {\n      const health = await dbConnection.healthCheck();\n\n      if (health.connected && health.responsive) {\n        res.apiSuccess({ ready: true });\n      } else {\n        res.status(503).apiError('SERVICE_NOT_READY', 'Service not ready');\n      }\n    } catch (error) {\n      res.status(503).apiError('SERVICE_NOT_READY', 'Service not ready', 503, {\n        error: (error as Error).message,\n      });\n    }\n  });\n\n  // Liveness check\n  router.get('/live', (_req, res) => {\n    res.apiSuccess({ alive: true });\n  });\n\n  return router;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/index.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 16,
        "column": 19,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 16,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [515, 520], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 20,
        "column": 25,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 20,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [628, 633], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 21,
        "column": 24,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 21,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [673, 678], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 22,
        "column": 23,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 22,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [716, 721], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/await-thenable",
        "severity": 2,
        "message": "Unexpected `await` of a non-Promise (non-\"Thenable\") value.",
        "line": 23,
        "column": 26,
        "nodeType": "AwaitExpression",
        "messageId": "await",
        "endLine": 23,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [761, 766], "text": "" },
            "desc": "Remove unnecessary `await`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Router } from 'express';\nimport { taskRoutes } from './tasks';\nimport { boardRoutes } from './boards';\nimport { noteRoutes } from './notes';\nimport { tagRoutes } from './tags';\nimport { contextRoutes } from './context';\nimport { healthRoutes } from './health';\nimport backupRoutes from './backup';\nimport scheduleRoutes from './schedule';\nimport exportRoutes from './export';\n\nexport async function apiRoutes(): Promise<Router> {\n  const router = Router();\n\n  // Health and status routes\n  router.use('/', await healthRoutes());\n\n  // Core API routes\n  router.use('/tasks', await taskRoutes());\n  router.use('/boards', await boardRoutes());\n  router.use('/notes', await noteRoutes());\n  router.use('/tags', await tagRoutes());\n  router.use('/context', await contextRoutes());\n  router.use('/backup', backupRoutes);\n  router.use('/schedule', scheduleRoutes);\n  router.use('/', exportRoutes); // Export/import routes at root level\n\n  return router;\n}\n\nexport * from './tasks';\nexport * from './boards';\nexport * from './notes';\nexport * from './tags';\nexport * from './context';\nexport * from './health';\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/notes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 14,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 46,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 22,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 22,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [844, 847], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [844, 847], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task_id on an `any` value.",
        "line": 29,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 29,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .board_id on an `any` value.",
        "line": 30,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 30,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 31,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 31,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned_only on an `any` value.",
        "line": 32,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 32,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned_only on an `any` value.",
        "line": 33,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 33,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `NoteSearchOptions`.",
        "line": 35,
        "column": 59,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 35,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .offset on an `any` value.",
        "line": 39,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 39,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 39,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 39,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
        "line": 40,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 40,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 40,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 40,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 49,
        "column": 56,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 63,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 66,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 82,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 85,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 102,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 93,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 93,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 93,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 93,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3094, 3097], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3094, 3097], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 105,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 149,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 119,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 119,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3670, 3673], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3670, 3673], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .task_id on an `any` value.",
        "line": 127,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 127,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .board_id on an `any` value.",
        "line": 128,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 128,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 129,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 129,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned on an `any` value.",
        "line": 130,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 130,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned on an `any` value.",
        "line": 131,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 131,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PaginationOptions & NoteFilters`.",
        "line": 133,
        "column": 48,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 133,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 136,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 136,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_' is assigned a value but never used.",
        "line": 136,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 136,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__' is assigned a value but never used.",
        "line": 136,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 136,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PaginationOptions & NoteFilters`.",
        "line": 137,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 137,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .offset on an `any` value.",
        "line": 142,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 142,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 142,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 142,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `number`.",
        "line": 143,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 143,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .limit on an `any` value.",
        "line": 143,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 143,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 152,
        "column": 48,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 169,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 155,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 155,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4873, 4876], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4873, 4876], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .category on an `any` value.",
        "line": 161,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 161,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .pinned on an `any` value.",
        "line": 162,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 162,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `CreateNoteRequest`.",
        "line": 164,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 164,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 172,
        "column": 49,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 190,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 193,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 211,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 214,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 227,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 230,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 243,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 246,
        "column": 57,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 259,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 17,
    "fatalErrorCount": 0,
    "warningCount": 26,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Router } from 'express';\nimport { NoteService } from '@/services/NoteService';\nimport { dbConnection } from '@/database/connection';\nimport { requirePermission } from '@/middleware/auth';\nimport { NoteValidation, validateInput } from '@/utils/validation';\nimport { NotFoundError } from '@/utils/errors';\n\nexport function noteRoutes(): Router {\n  const router = Router();\n\n  const noteService = new NoteService(dbConnection);\n\n  // GET /api/v1/notes/search - Full-text search notes (must be before generic routes)\n  router.get('/search', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { query, limit = 50, offset = 0, task_id, board_id, category, pinned } = req.query;\n\n      if (!query) {\n        return res.status(400).apiError('INVALID_INPUT', 'Search query is required');\n      }\n\n      const options: any = {\n        query: query as string,\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n      };\n\n      // Add optional properties only if they have values\n      if (task_id) options.task_id = task_id as string;\n      if (board_id) options.board_id = board_id as string;\n      if (category) options.category = category;\n      if (pinned === 'true') options.pinned_only = true;\n      else if (pinned === 'false') options.pinned_only = false;\n\n      const searchResults = await noteService.searchNotes(options);\n\n      return res.apiPagination(\n        searchResults,\n        Math.floor(options.offset / options.limit) + 1,\n        options.limit,\n        searchResults.length\n      );\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/notes/categories - Get note categories with counts\n  router.get('/categories', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { task_id, board_id } = req.query;\n\n      const filters = {\n        task_id: task_id as string,\n        board_id: board_id as string,\n      };\n\n      const categories = await noteService.getNoteCategories(filters);\n      return res.apiSuccess(categories);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/notes/recent - Get recently updated notes\n  router.get('/recent', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { limit = 20, task_id, board_id, days = 7 } = req.query;\n\n      const options = {\n        limit: parseInt(limit as string, 10),\n        task_id: task_id as string,\n        board_id: board_id as string,\n        days: parseInt(days as string, 10),\n      };\n\n      const recentNotes = await noteService.getRecentNotes(options);\n      return res.apiSuccess(recentNotes);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/notes/pinned - Get pinned notes\n  router.get('/pinned', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { limit = 50, task_id, board_id, category } = req.query;\n\n      const options = {\n        limit: parseInt(limit as string, 10),\n        task_id: task_id as string,\n        board_id: board_id as string,\n        category: category as any,\n        pinned: true,\n      };\n\n      const pinnedNotes = await noteService.getNotes(options);\n      return res.apiSuccess(pinnedNotes);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/notes - List notes with filters\n  router.get('/', requirePermission('read'), async (req, res, next) => {\n    try {\n      const {\n        limit = 50,\n        offset = 0,\n        sortBy = 'updated_at',\n        sortOrder = 'desc',\n        task_id,\n        board_id,\n        category,\n        pinned,\n        search,\n      } = req.query;\n\n      const options: any = {\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n        sortBy: sortBy as string,\n        sortOrder: sortOrder as 'asc' | 'desc',\n        search: search as string,\n      };\n\n      if (task_id) options.task_id = task_id as string;\n      if (board_id) options.board_id = board_id as string;\n      if (category) options.category = category;\n      if (pinned === 'true') options.pinned = true;\n      else if (pinned === 'false') options.pinned = false;\n\n      const notes = await noteService.getNotes(options);\n\n      // Get total count for pagination\n      const { limit: _, offset: __, ...countOptions } = options;\n      const totalNotes = await noteService.getNotes(countOptions);\n      const total = totalNotes.length;\n\n      return res.apiPagination(\n        notes,\n        Math.floor(options.offset / options.limit) + 1,\n        options.limit,\n        total\n      );\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/notes - Create note\n  router.post('/', requirePermission('write'), async (req, res, next) => {\n    try {\n      const rawNoteData = validateInput(NoteValidation.create, req.body);\n      const noteData: any = {\n        task_id: rawNoteData.task_id,\n        content: rawNoteData.content,\n      };\n\n      // Add optional properties only if they have values\n      if (rawNoteData.category) noteData.category = rawNoteData.category;\n      if (rawNoteData.pinned !== undefined) noteData.pinned = rawNoteData.pinned;\n\n      const note = await noteService.createNote(noteData);\n      return res.status(201).apiSuccess(note);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/notes/:id - Get note details\n  router.get('/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Note ID is required' });\n      }\n\n      const note = await noteService.getNoteById(id);\n\n      if (!note) {\n        throw new NotFoundError('Note', id);\n      }\n\n      return res.apiSuccess(note);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // PATCH /api/v1/notes/:id - Update note\n  router.patch('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Note ID is required' });\n      }\n\n      const rawUpdateData = validateInput(NoteValidation.update, req.body);\n      // Filter out undefined values to comply with exactOptionalPropertyTypes\n      const updateData = Object.fromEntries(\n        Object.entries(rawUpdateData).filter(([, value]) => value !== undefined)\n      );\n      const note = await noteService.updateNote(id, updateData);\n      return res.apiSuccess(note);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // DELETE /api/v1/notes/:id - Delete note\n  router.delete('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Note ID is required' });\n      }\n\n      await noteService.deleteNote(id);\n      return res.status(204).send();\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/notes/:id/pin - Pin note\n  router.post('/:id/pin', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Note ID is required' });\n      }\n\n      const note = await noteService.pinNote(id);\n      return res.apiSuccess(note);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // DELETE /api/v1/notes/:id/pin - Unpin note\n  router.delete('/:id/pin', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n\n      if (!id) {\n        return res.status(400).json({ error: 'Note ID is required' });\n      }\n\n      const note = await noteService.unpinNote(id);\n      return res.apiSuccess(note);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  return router;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/schedule.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 25,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 25,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 129,
        "column": 63,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 147,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 131,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 131,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `CreateScheduleOptions`.",
        "line": 132,
        "column": 61,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 132,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 181,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 199,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 183,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 183,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 183,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 183,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6207, 6210], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6207, 6210], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 184,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 184,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{ enabled?: boolean; limit?: number; offset?: number; }`.",
        "line": 185,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 185,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 223,
        "column": 20,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 248,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 229,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 229,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 300,
        "column": 59,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 326,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 306,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 306,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `UpdateScheduleOptions`.",
        "line": 307,
        "column": 65,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 307,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 352,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 378,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 358,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 358,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 404,
        "column": 23,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 430,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 410,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 410,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 447,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 465,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 449,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 449,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 482,
        "column": 23,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 500,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 482,
        "column": 41,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 482,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 484,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 484,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 517,
        "column": 22,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 535,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 517,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 517,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'schedulingService' is already declared in the upper scope on line 23 column 5.",
        "line": 519,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 519,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 23,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Schedule Routes - REST API endpoints for backup scheduling management\n *\n * @module routes/schedule\n * @description Provides REST API endpoints for managing backup schedules, including\n * creating, updating, deleting, and executing scheduled backups.\n */\n\nimport { Router } from 'express';\nimport { SchedulingService } from '@/services/SchedulingService';\nimport { BackupService } from '@/services/BackupService';\nimport { dbConnection } from '@/database/connection';\nimport { authenticateApiKey } from '@/middleware/auth';\nimport { validateRequest } from '@/middleware/validation';\nimport { formatSuccessResponse, formatErrorResponse } from '@/middleware/response';\nimport { logger } from '@/utils/logger';\nimport { z } from 'zod';\n\nconst router = Router();\n\n// Lazy initialization of services\nlet backupService: BackupService;\nlet schedulingService: SchedulingService;\n\nfunction getServices() {\n  if (!backupService) {\n    backupService = new BackupService(dbConnection);\n  }\n  if (!schedulingService) {\n    schedulingService = new SchedulingService(dbConnection, backupService);\n  }\n  return { backupService, schedulingService };\n}\n\n// Validation schemas\nconst CreateScheduleSchema = z.object({\n  name: z.string().min(1).max(255),\n  description: z.string().optional(),\n  cronExpression: z\n    .string()\n    .regex(\n      /^(\\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\\*\\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\\*|([0-9]|1[0-9]|2[0-3])|\\*\\/([0-9]|1[0-9]|2[0-3])) (\\*|([1-9]|1[0-9]|2[0-9]|3[0-1])|\\*\\/([1-9]|1[0-9]|2[0-9]|3[0-1])) (\\*|([1-9]|1[0-2])|\\*\\/([1-9]|1[0-2])) (\\*|([0-6])|\\*\\/([0-6]))$/,\n      'Invalid cron expression'\n    ),\n  backupType: z.enum(['full', 'incremental']),\n  enabled: z.boolean().optional().default(true),\n  retentionDays: z.number().min(1).max(365).optional().default(30),\n  compressionEnabled: z.boolean().optional().default(true),\n  verificationEnabled: z.boolean().optional().default(true),\n});\n\nconst UpdateScheduleSchema = z.object({\n  name: z.string().min(1).max(255).optional(),\n  description: z.string().optional(),\n  cronExpression: z\n    .string()\n    .regex(\n      /^(\\*|([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])|\\*\\/([0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9])) (\\*|([0-9]|1[0-9]|2[0-3])|\\*\\/([0-9]|1[0-9]|2[0-3])) (\\*|([1-9]|1[0-9]|2[0-9]|3[0-1])|\\*\\/([1-9]|1[0-9]|2[0-9]|3[0-1])) (\\*|([1-9]|1[0-2])|\\*\\/([1-9]|1[0-2])) (\\*|([0-6])|\\*\\/([0-6]))$/,\n      'Invalid cron expression'\n    )\n    .optional(),\n  backupType: z.enum(['full', 'incremental']).optional(),\n  enabled: z.boolean().optional(),\n  retentionDays: z.number().min(1).max(365).optional(),\n  compressionEnabled: z.boolean().optional(),\n  verificationEnabled: z.boolean().optional(),\n});\n\nconst ListSchedulesSchema = z.object({\n  enabled: z.coerce.boolean().optional(),\n  limit: z.coerce.number().min(1).max(100).optional().default(20),\n  offset: z.coerce.number().min(0).optional().default(0),\n});\n\n// Apply authentication to all schedule routes\nrouter.use(authenticateApiKey);\n\n/**\n * @openapi\n * /api/schedule/create:\n *   post:\n *     summary: Create a new backup schedule\n *     description: Creates a new automated backup schedule with cron expression\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required: [name, cronExpression, backupType]\n *             properties:\n *               name:\n *                 type: string\n *                 description: Schedule name (must be unique)\n *               description:\n *                 type: string\n *                 description: Schedule description\n *               cronExpression:\n *                 type: string\n *                 description: Cron expression for scheduling (e.g., \"0 2 * * *\" for daily at 2 AM)\n *               backupType:\n *                 type: string\n *                 enum: [full, incremental]\n *               enabled:\n *                 type: boolean\n *                 default: true\n *               retentionDays:\n *                 type: integer\n *                 minimum: 1\n *                 maximum: 365\n *                 default: 30\n *               compressionEnabled:\n *                 type: boolean\n *                 default: true\n *               verificationEnabled:\n *                 type: boolean\n *                 default: true\n *     responses:\n *       201:\n *         description: Schedule created successfully\n *       400:\n *         description: Invalid request data\n *       500:\n *         description: Schedule creation failed\n */\nrouter.post('/create', validateRequest(CreateScheduleSchema), async (req, res) => {\n  try {\n    const { schedulingService } = getServices();\n    const schedule = await schedulingService.createSchedule(req.body);\n\n    logger.info(`Backup schedule created via API: ${String(String(schedule.id))}`);\n    return res.status(201).json(formatSuccessResponse(schedule));\n  } catch (error) {\n    logger.error('Schedule creation failed:', error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Schedule creation failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/list:\n *   get:\n *     summary: List all backup schedules\n *     description: Retrieves a list of backup schedules with optional filtering\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: query\n *         name: enabled\n *         schema:\n *           type: boolean\n *         description: Filter by enabled status\n *       - in: query\n *         name: limit\n *         schema:\n *           type: integer\n *           minimum: 1\n *           maximum: 100\n *           default: 20\n *       - in: query\n *         name: offset\n *         schema:\n *           type: integer\n *           minimum: 0\n *           default: 0\n *     responses:\n *       200:\n *         description: Schedules retrieved successfully\n */\nrouter.get('/list', validateRequest(ListSchedulesSchema), async (req, res) => {\n  try {\n    const options = req.query as any;\n    const { schedulingService } = getServices();\n    const schedules = await schedulingService.getSchedules(options);\n\n    return res.json(formatSuccessResponse(schedules));\n  } catch (error) {\n    logger.error('Failed to list schedules:', error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to list schedules',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/{id}:\n *   get:\n *     summary: Get schedule details\n *     description: Retrieves detailed information about a specific schedule\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Schedule details retrieved successfully\n *       404:\n *         description: Schedule not found\n */\nrouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Schedule ID is required'));\n    }\n    const { schedulingService } = getServices();\n    const schedule = await schedulingService.getScheduleById(id);\n\n    if (!schedule) {\n      return res.status(404).json(formatErrorResponse('Schedule not found'));\n    }\n\n    return res.json(formatSuccessResponse(schedule));\n  } catch (error) {\n    logger.error(`Failed to get schedule ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to get schedule',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/{id}:\n *   put:\n *     summary: Update backup schedule\n *     description: Updates an existing backup schedule\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             properties:\n *               name:\n *                 type: string\n *               description:\n *                 type: string\n *               cronExpression:\n *                 type: string\n *               backupType:\n *                 type: string\n *                 enum: [full, incremental]\n *               enabled:\n *                 type: boolean\n *               retentionDays:\n *                 type: integer\n *                 minimum: 1\n *                 maximum: 365\n *               compressionEnabled:\n *                 type: boolean\n *               verificationEnabled:\n *                 type: boolean\n *     responses:\n *       200:\n *         description: Schedule updated successfully\n *       404:\n *         description: Schedule not found\n *       500:\n *         description: Update failed\n */\nrouter.put('/:id', validateRequest(UpdateScheduleSchema), async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Schedule ID is required'));\n    }\n    const { schedulingService } = getServices();\n    const schedule = await schedulingService.updateSchedule(id, req.body);\n\n    logger.info(`Schedule updated via API: ${String(id)}`);\n    return res.json(formatSuccessResponse(schedule));\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      return res.status(404).json(formatErrorResponse('Schedule not found'));\n    }\n\n    logger.error(`Schedule update failed for ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Schedule update failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/{id}/execute:\n *   post:\n *     summary: Execute backup schedule manually\n *     description: Triggers a manual execution of a backup schedule\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Schedule executed successfully\n *       404:\n *         description: Schedule not found\n *       500:\n *         description: Execution failed\n */\nrouter.post('/:id/execute', async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Schedule ID is required'));\n    }\n    const { schedulingService } = getServices();\n    await schedulingService.executeSchedule(id);\n\n    logger.info(`Schedule executed manually via API: ${String(id)}`);\n    return res.json(formatSuccessResponse(null, 'Schedule executed successfully'));\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      return res.status(404).json(formatErrorResponse('Schedule not found'));\n    }\n\n    logger.error(`Schedule execution failed for ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Schedule execution failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/{id}:\n *   delete:\n *     summary: Delete backup schedule\n *     description: Deletes a backup schedule and stops any running jobs\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     parameters:\n *       - in: path\n *         name: id\n *         required: true\n *         schema:\n *           type: string\n *           format: uuid\n *     responses:\n *       200:\n *         description: Schedule deleted successfully\n *       404:\n *         description: Schedule not found\n *       500:\n *         description: Delete failed\n */\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    if (!id) {\n      return res.status(400).json(formatErrorResponse('Schedule ID is required'));\n    }\n    const { schedulingService } = getServices();\n    await schedulingService.deleteSchedule(id);\n\n    logger.info(`Schedule deleted via API: ${String(id)}`);\n    return res.json(formatSuccessResponse(null, 'Schedule deleted successfully'));\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      return res.status(404).json(formatErrorResponse('Schedule not found'));\n    }\n\n    logger.error(`Failed to delete schedule ${String(String(req.params.id))}:`, error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to delete schedule',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/cleanup:\n *   post:\n *     summary: Clean up old backups\n *     description: Manually trigger cleanup of old backups based on retention policies\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     responses:\n *       200:\n *         description: Cleanup completed successfully\n *       500:\n *         description: Cleanup failed\n */\nrouter.post('/cleanup', async (_req, res) => {\n  try {\n    const { schedulingService } = getServices();\n    await schedulingService.cleanupOldBackups();\n\n    logger.info('Manual backup cleanup executed via API');\n    return res.json(formatSuccessResponse(null, 'Backup cleanup completed successfully'));\n  } catch (error) {\n    logger.error('Backup cleanup failed:', error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Backup cleanup failed',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/start:\n *   post:\n *     summary: Start the backup scheduler\n *     description: Starts the backup scheduler and all enabled schedules\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     responses:\n *       200:\n *         description: Scheduler started successfully\n *       500:\n *         description: Failed to start scheduler\n */\nrouter.post('/start', async (_req, res) => {\n  try {\n    const { schedulingService } = getServices();\n    schedulingService.start();\n\n    logger.info('Backup scheduler started via API');\n    return res.json(formatSuccessResponse(null, 'Backup scheduler started successfully'));\n  } catch (error) {\n    logger.error('Failed to start scheduler:', error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to start scheduler',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\n/**\n * @openapi\n * /api/schedule/stop:\n *   post:\n *     summary: Stop the backup scheduler\n *     description: Stops the backup scheduler and all running scheduled jobs\n *     tags: [Schedule]\n *     security:\n *       - ApiKeyAuth: []\n *     responses:\n *       200:\n *         description: Scheduler stopped successfully\n *       500:\n *         description: Failed to stop scheduler\n */\nrouter.post('/stop', async (_req, res) => {\n  try {\n    const { schedulingService } = getServices();\n    schedulingService.stop();\n\n    logger.info('Backup scheduler stopped via API');\n    return res.json(formatSuccessResponse(null, 'Backup scheduler stopped successfully'));\n  } catch (error) {\n    logger.error('Failed to stop scheduler:', error);\n    return res\n      .status(500)\n      .json(\n        formatErrorResponse(\n          'Failed to stop scheduler',\n          error instanceof Error ? error.message : 'Unknown error'\n        )\n      );\n  }\n});\n\nexport default router;\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/tags.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 14,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 54,
        "endColumn": 4
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'parent_id' is not in camel case.",
        "line": 32,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 32,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_' is assigned a value but never used.",
        "line": 41,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 41,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__' is assigned a value but never used.",
        "line": 41,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 41,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 57,
        "column": 48,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 65,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 68,
        "column": 50,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 76,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 79,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 94,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 97,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 125,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 97,
        "column": 76,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 97,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 128,
        "column": 51,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 136,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 139,
        "column": 49,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 162,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 165,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 177,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 180,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 191,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 194,
        "column": 58,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 210,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 213,
        "column": 54,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 224,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 227,
        "column": 57,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 244,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 233,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 233,
        "endColumn": 41
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'target_tag_id' is not in camel case.",
        "line": 235,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 235,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 239,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 239,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 247,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 285,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 17,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Router } from 'express';\nimport { TagService } from '@/services/TagService';\nimport { dbConnection } from '@/database/connection';\nimport { requirePermission } from '@/middleware/auth';\nimport { TagValidation, validateInput } from '@/utils/validation';\nimport { NotFoundError } from '@/utils/errors';\n\nexport function tagRoutes(): Router {\n  const router = Router();\n\n  const tagService = new TagService(dbConnection);\n\n  // GET /api/v1/tags - List tags with filters\n  router.get('/', requirePermission('read'), async (req, res, next) => {\n    try {\n      const {\n        limit = 50,\n        offset = 0,\n        sortBy = 'name',\n        sortOrder = 'asc',\n        parent_id,\n        search,\n        color,\n        includeUsageCount = false,\n      } = req.query;\n\n      const options = {\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n        sortBy: sortBy as string,\n        sortOrder: sortOrder as 'asc' | 'desc',\n        parent_id: parent_id as string,\n        search: search as string,\n        color: color as string,\n        includeUsageCount: includeUsageCount === 'true',\n      };\n\n      const tags = await tagService.getTags(options);\n\n      // Get total count for pagination\n      const { limit: _, offset: __, ...countOptions } = options;\n      const totalTags = await tagService.getTags(countOptions);\n      const total = totalTags.length;\n\n      return res.apiPagination(\n        tags,\n        Math.floor(options.offset / options.limit) + 1,\n        options.limit,\n        total\n      );\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/tags - Create tag\n  router.post('/', requirePermission('write'), async (req, res, next) => {\n    try {\n      const tagData = validateInput(TagValidation.create, req.body);\n      const tag = await tagService.createTag(tagData);\n      return res.status(201).apiSuccess(tag);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/tree - Get tag hierarchy tree\n  router.get('/tree', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { includeUsageCount = false } = req.query;\n      const tree = await tagService.getTagTree(includeUsageCount === 'true');\n      return res.apiSuccess(tree);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/popular - Get most used tags\n  router.get('/popular', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { limit = 20, board_id, days = 30 } = req.query;\n\n      const options = {\n        limit: parseInt(limit as string, 10),\n        board_id: board_id as string,\n        days: parseInt(days as string, 10),\n      };\n\n      const popularTags = await tagService.getPopularTags(options);\n      return res.apiSuccess(popularTags);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/colors - Get available tag colors\n  router.get('/colors', requirePermission('read'), async (_req, res, next) => {\n    try {\n      const colors = [\n        '#ff6b6b',\n        '#4ecdc4',\n        '#45b7d1',\n        '#96ceb4',\n        '#ffeaa7',\n        '#dda0dd',\n        '#98d8c8',\n        '#f7dc6f',\n        '#bb8fce',\n        '#85c1e9',\n        '#f8c471',\n        '#82e0aa',\n        '#f1948a',\n        '#85c1e9',\n        '#d2b4de',\n        '#aed6f1',\n        '#a3e4d7',\n        '#f9e79f',\n        '#f5b7b1',\n        '#d5dbdb',\n      ];\n      return res.apiSuccess(colors);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/stats - Get tag usage statistics\n  router.get('/stats', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { board_id } = req.query;\n      const stats = await tagService.getTagStats(board_id as string);\n      return res.apiSuccess(stats);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/:id - Get tag details\n  router.get('/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Tag', 'ID is required');\n      }\n      const { include } = req.query;\n\n      let tag;\n      if (include === 'children') {\n        tag = await tagService.getTagWithChildren(id);\n      } else {\n        tag = await tagService.getTagById(id);\n      }\n\n      if (!tag) {\n        throw new NotFoundError('Tag', id);\n      }\n\n      return res.apiSuccess(tag);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // PATCH /api/v1/tags/:id - Update tag\n  router.patch('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Tag', 'ID is required');\n      }\n      const updateData = validateInput(TagValidation.update, req.body);\n      const tag = await tagService.updateTag(id, updateData);\n      return res.apiSuccess(tag);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // DELETE /api/v1/tags/:id - Delete tag\n  router.delete('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Tag', 'ID is required');\n      }\n      await tagService.deleteTag(id);\n      return res.status(204).send();\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/:id/children - Get tag children\n  router.get('/:id/children', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Tag', 'ID is required');\n      }\n      const tagWithChildren = await tagService.getTagWithChildren(id);\n\n      if (!tagWithChildren) {\n        throw new NotFoundError('Tag', id);\n      }\n\n      return res.apiSuccess(tagWithChildren.children ?? []);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/:id/path - Get tag hierarchy path\n  router.get('/:id/path', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Tag', 'ID is required');\n      }\n      const path = await tagService.getTagPath(id);\n      return res.apiSuccess(path);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/tags/:id/merge - Merge tags\n  router.post('/:id/merge', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Tag', 'ID is required');\n      }\n      const { target_tag_id } = req.body;\n\n      if (!target_tag_id) {\n        return res.status(400).apiError('INVALID_INPUT', 'target_tag_id is required');\n      }\n\n      await tagService.mergeTags(id, target_tag_id);\n      return res.status(204).send();\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tags/:id/tasks - Get tasks with this tag\n  router.get('/:id/tasks', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Tag', 'ID is required');\n      }\n      // Query parameters available for future filtering implementation\n      // const {\n      //   limit = 50,\n      //   offset = 0,\n      //   sortBy = 'updated_at',\n      //   sortOrder = 'desc',\n      //   board_id,\n      //   status,\n      // } = req.query;\n\n      // TODO: Pagination options could be used to limit/filter the task IDs returned\n      // const options = {\n      //   limit: parseInt(limit as string, 10),\n      //   offset: parseInt(offset as string, 10),\n      //   sortBy: sortBy as string,\n      //   sortOrder: sortOrder as 'asc' | 'desc',\n      //   board_id: board_id as string,\n      //   status: status as any,\n      // };\n\n      const taskIds = await tagService.getTaggedTasks(id);\n\n      // TODO: This currently just returns task IDs. You might want to fetch the actual task objects\n      // by using TaskService to get the full task details based on these IDs\n\n      return res.apiSuccess({\n        task_ids: taskIds,\n        message: 'Returns task IDs. Use TaskService to get full task details.',\n      });\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  return router;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/routes/tasks.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async function 'taskRoutes' has no 'await' expression.",
        "line": 39,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingAwait",
        "endLine": 39,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 92,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 166,
        "endColumn": 4
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'priority_min' is not in camel case.",
        "line": 147,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 147,
        "endColumn": 23
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'priority_min' is not in camel case.",
        "line": 147,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 147,
        "endColumn": 69
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'priority_max' is not in camel case.",
        "line": 148,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 148,
        "endColumn": 23
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'priority_max' is not in camel case.",
        "line": 148,
        "column": 57,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 148,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'_' is assigned a value but never used.",
        "line": 153,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 153,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'__' is assigned a value but never used.",
        "line": 153,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 153,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 206,
        "column": 48,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 218,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 256,
        "column": 49,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 281,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 317,
        "column": 52,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 329,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 348,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 359,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 390,
        "column": 64,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 411,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 417,
        "column": 5,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 431,
        "endColumn": 6
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 435,
        "column": 62,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 454,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 457,
        "column": 60,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 478,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `CreateTaskRequest`.",
        "line": 473,
        "column": 52,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 473,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 473,
        "column": 67,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 473,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15059, 15062], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15059, 15062], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 481,
        "column": 58,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 497,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 531,
        "column": 57,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 550,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 553,
        "column": 55,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 573,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 561,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 561,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 561,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 561,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [17770, 17773], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [17770, 17773], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "no-nested-ternary",
        "severity": 2,
        "message": "Do not nest ternary expressions.",
        "line": 562,
        "column": 17,
        "nodeType": "ConditionalExpression",
        "messageId": "noNestedTernary",
        "endLine": 562,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 604,
        "column": 56,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 627,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 607,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 607,
        "endColumn": 35
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'tag_ids' is not in camel case.",
        "line": 618,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 618,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 619,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 619,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 630,
        "column": 65,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 644,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 647,
        "column": 54,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 658,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 661,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 669,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 672,
        "column": 53,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 680,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 26,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @module routes/tasks\n * @description RESTful API routes for task management.\n *\n * This module provides comprehensive task operations including CRUD operations,\n * dependency management, subtask handling, notes, and tags. All routes require\n * authentication and appropriate permissions.\n *\n * Base path: `/api/v1/tasks`\n *\n * @example\n * ```typescript\n * // Client usage example\n * const response = await fetch('/api/v1/tasks', {\n *   method: 'GET',\n *   headers: {\n *     'X-API-Key': 'your-api-key',\n *     'Content-Type': 'application/json'\n *   }\n * });\n * ```\n */\n\nimport { Router } from 'express';\nimport { TaskService, type CreateTaskRequest } from '@/services/TaskService';\nimport { NoteService } from '@/services/NoteService';\nimport { TagService } from '@/services/TagService';\nimport { dbConnection } from '@/database/connection';\nimport { requirePermission } from '@/middleware/auth';\nimport { TaskValidation, NoteValidation, validateInput } from '@/utils/validation';\nimport type { Task } from '@/types';\nimport { NotFoundError, ValidationError } from '@/utils/errors';\n\n/**\n * Create and configure task routes.\n *\n * @returns Express router with all task endpoints configured\n */\nexport async function taskRoutes(): Promise<Router> {\n  const router = Router();\n\n  const taskService = new TaskService(dbConnection);\n  const noteService = new NoteService(dbConnection);\n  const tagService = new TagService(dbConnection);\n\n  /**\n   * List tasks with filtering, sorting, and pagination.\n   *\n   * @route GET /api/v1/tasks\n   * @auth Required - Read permission\n   *\n   * @queryparam {number} limit - Maximum tasks to return (default: 50)\n   * @queryparam {number} offset - Pagination offset (default: 0)\n   * @queryparam {string} sortBy - Field to sort by: updated_at, created_at, priority, due_date (default: updated_at)\n   * @queryparam {string} sortOrder - Sort direction: asc or desc (default: desc)\n   * @queryparam {string} board_id - Filter by board ID\n   * @queryparam {string} column_id - Filter by column ID\n   * @queryparam {string} status - Filter by status: todo, in_progress, done, blocked, archived\n   * @queryparam {string} assignee - Filter by assignee\n   * @queryparam {string} parent_task_id - Filter by parent task (for subtasks)\n   * @queryparam {string} search - Search in title and description\n   * @queryparam {number} priority_min - Minimum priority (inclusive)\n   * @queryparam {number} priority_max - Maximum priority (inclusive)\n   * @queryparam {boolean} overdue - Filter overdue tasks (true/false)\n   *\n   * @response 200 - Success\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": [\n   *     {\n   *       \"id\": \"task123\",\n   *       \"title\": \"Implement feature\",\n   *       \"status\": \"in_progress\",\n   *       \"priority\": 8,\n   *       \"created_at\": \"2024-01-20T10:00:00Z\"\n   *     }\n   *   ],\n   *   \"pagination\": {\n   *     \"page\": 1,\n   *     \"limit\": 50,\n   *     \"total\": 123,\n   *     \"totalPages\": 3\n   *   }\n   * }\n   * ```\n   *\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   */\n  // GET /api/v1/tasks - List tasks with filters\n  router.get('/', requirePermission('read'), async (req, res, next) => {\n    try {\n      const {\n        limit = 50,\n        offset = 0,\n        sortBy = 'updated_at',\n        sortOrder = 'desc',\n        board_id,\n        column_id,\n        status,\n        assignee,\n        parent_task_id,\n        search,\n        priority_min,\n        priority_max,\n        overdue,\n      } = req.query;\n\n      interface TaskListOptions {\n        limit: number;\n        offset: number;\n        sortBy: string;\n        sortOrder: 'asc' | 'desc';\n        overdue: boolean;\n        board_id?: string;\n        column_id?: string;\n        status?: Task['status'];\n        assignee?: string;\n        parent_task_id?: string;\n        search?: string;\n        priority_min?: number;\n        priority_max?: number;\n      }\n\n      const options: TaskListOptions = {\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n        sortBy: sortBy as string,\n        sortOrder: sortOrder as 'asc' | 'desc',\n        overdue: overdue === 'true',\n      };\n\n      // Add optional properties only if they have values\n      if (board_id) options.board_id = board_id as string;\n      if (column_id) options.column_id = column_id as string;\n      if (\n        status &&\n        typeof status === 'string' &&\n        ['todo', 'in_progress', 'done', 'blocked', 'archived'].includes(status)\n      ) {\n        options.status = status as Task['status'];\n      }\n      if (assignee) options.assignee = assignee as string;\n      if (parent_task_id) options.parent_task_id = parent_task_id as string;\n      if (search) options.search = search as string;\n      if (priority_min) options.priority_min = parseInt(priority_min as string, 10);\n      if (priority_max) options.priority_max = parseInt(priority_max as string, 10);\n\n      const tasks = await taskService.getTasks(options);\n\n      // Get total count for pagination\n      const { limit: _, offset: __, ...countOptions } = options;\n      const totalTasks = await taskService.getTasks(countOptions);\n      const total = totalTasks.length;\n\n      return res.apiPagination(\n        tasks,\n        Math.floor(options.offset / options.limit) + 1,\n        options.limit,\n        total\n      );\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Create a new task.\n   *\n   * @route POST /api/v1/tasks\n   * @auth Required - Write permission\n   *\n   * @bodyparam {string} title - Task title (required)\n   * @bodyparam {string} [description] - Task description\n   * @bodyparam {string} board_id - Board ID (required)\n   * @bodyparam {string} [column_id] - Column ID\n   * @bodyparam {string} [status] - Initial status: todo, in_progress, done, blocked\n   * @bodyparam {number} [priority] - Priority 1-10 (default: 5)\n   * @bodyparam {string} [assignee] - Assignee identifier\n   * @bodyparam {string} [due_date] - Due date in ISO format\n   * @bodyparam {string[]} [tags] - Array of tag IDs\n   * @bodyparam {string} [parent_task_id] - Parent task ID for subtasks\n   * @bodyparam {number} [position] - Position in column\n   *\n   * @response 201 - Task created successfully\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"task456\",\n   *     \"title\": \"New task\",\n   *     \"board_id\": \"board123\",\n   *     \"status\": \"todo\",\n   *     \"priority\": 5,\n   *     \"created_at\": \"2024-01-20T10:00:00Z\"\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid input data\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   */\n  // POST /api/v1/tasks - Create task\n  router.post('/', requirePermission('write'), async (req, res, next) => {\n    try {\n      const rawTaskData = validateInput(TaskValidation.create, req.body);\n      // Filter out undefined values to comply with exactOptionalPropertyTypes\n      const taskData = Object.fromEntries(\n        Object.entries(rawTaskData).filter(([, value]) => value !== undefined)\n      ) as unknown as CreateTaskRequest;\n      const task = await taskService.createTask(taskData);\n      return res.status(201).apiSuccess(task);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Get detailed information about a specific task.\n   *\n   * @route GET /api/v1/tasks/:id\n   * @auth Required - Read permission\n   *\n   * @param {string} id - Task ID\n   * @queryparam {string} [include] - Include related data: 'subtasks' or 'dependencies'\n   *\n   * @response 200 - Success\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"task123\",\n   *     \"title\": \"Task title\",\n   *     \"description\": \"Detailed description\",\n   *     \"status\": \"in_progress\",\n   *     \"priority\": 8,\n   *     \"assignee\": \"user123\",\n   *     \"due_date\": \"2024-12-31T00:00:00Z\",\n   *     \"tags\": [\"bug\", \"urgent\"],\n   *     \"created_at\": \"2024-01-20T10:00:00Z\",\n   *     \"updated_at\": \"2024-01-21T14:30:00Z\",\n   *     \"subtasks\": [],  // If include=subtasks\n   *     \"dependencies\": [],  // If include=dependencies\n   *     \"dependents\": []  // If include=dependencies\n   *   }\n   * }\n   * ```\n   *\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Task not found\n   */\n  // GET /api/v1/tasks/:id - Get task details\n  router.get('/:id', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Task', 'ID is required');\n      }\n      const { include } = req.query;\n\n      let task;\n      if (include === 'subtasks') {\n        task = await taskService.getTaskWithSubtasks(id);\n      } else if (include === 'dependencies') {\n        task = await taskService.getTaskWithDependencies(id);\n      } else {\n        task = await taskService.getTaskById(id);\n      }\n\n      if (!task) {\n        throw new NotFoundError('Task', id);\n      }\n\n      return res.apiSuccess(task);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Update task properties.\n   *\n   * @route PATCH /api/v1/tasks/:id\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Task ID\n   * @bodyparam {string} [title] - New title\n   * @bodyparam {string} [description] - New description\n   * @bodyparam {string} [status] - New status: todo, in_progress, done, blocked, archived\n   * @bodyparam {number} [priority] - New priority 1-10\n   * @bodyparam {string} [assignee] - New assignee\n   * @bodyparam {string} [due_date] - New due date in ISO format\n   * @bodyparam {number} [position] - New position in column\n   *\n   * @response 200 - Task updated successfully\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"task123\",\n   *     \"title\": \"Updated title\",\n   *     \"status\": \"completed\",\n   *     \"updated_at\": \"2024-01-21T15:00:00Z\"\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid input data\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Task not found\n   */\n  // PATCH /api/v1/tasks/:id - Update task\n  router.patch('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Task', 'ID is required');\n      }\n      const updateData = validateInput(TaskValidation.update, req.body);\n      const task = await taskService.updateTask(id, updateData);\n      return res.apiSuccess(task);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Delete a task permanently.\n   *\n   * @route DELETE /api/v1/tasks/:id\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Task ID to delete\n   *\n   * @response 204 - Task deleted successfully (no content)\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Task not found\n   *\n   * @warning This permanently deletes the task and all associated data\n   * (subtasks, notes, tags, dependencies). This action cannot be undone.\n   */\n  // DELETE /api/v1/tasks/:id - Delete task\n  router.delete('/:id', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Task', 'ID is required');\n      }\n      await taskService.deleteTask(id);\n      return res.status(204).send();\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Add a dependency relationship between tasks.\n   *\n   * @route POST /api/v1/tasks/:id/dependencies\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Task ID that depends on another task\n   * @bodyparam {string} depends_on_task_id - Task ID that this task depends on\n   * @bodyparam {string} [dependency_type] - Type: blocks, required, related (default: blocks)\n   *\n   * @response 201 - Dependency created\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"task_id\": \"task123\",\n   *     \"depends_on_task_id\": \"task456\",\n   *     \"dependency_type\": \"blocks\",\n   *     \"created_at\": \"2024-01-20T10:00:00Z\"\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid dependency (e.g., circular dependency)\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Task not found\n   */\n  // POST /api/v1/tasks/:id/dependencies - Add dependency\n  router.post('/:id/dependencies', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Task', 'ID is required');\n      }\n      const dependencyData = validateInput(TaskValidation.dependency, {\n        task_id: id,\n        ...req.body,\n      });\n\n      const dependency = await taskService.addDependency(\n        dependencyData.task_id,\n        dependencyData.depends_on_task_id,\n        dependencyData.dependency_type\n      );\n\n      return res.status(201).apiSuccess(dependency);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // DELETE /api/v1/tasks/:id/dependencies/:dependsOnId - Remove dependency\n  router.delete(\n    '/:id/dependencies/:dependsOnId',\n    requirePermission('write'),\n    async (req, res, next) => {\n      try {\n        const { id, dependsOnId } = req.params;\n        if (!id) {\n          throw new NotFoundError('Task', 'ID is required');\n        }\n        if (!dependsOnId) {\n          throw new NotFoundError('Dependency', 'Dependency ID is required');\n        }\n        await taskService.removeDependency(id, dependsOnId);\n        return res.status(204).send();\n      } catch (error) {\n        return next(error);\n      }\n    }\n  );\n\n  // GET /api/v1/tasks/:id/dependencies - Get task dependencies\n  router.get('/:id/dependencies', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Task', 'ID is required');\n      }\n      const taskWithDeps = await taskService.getTaskWithDependencies(id);\n\n      if (!taskWithDeps) {\n        throw new NotFoundError('Task', id);\n      }\n\n      return res.apiSuccess({\n        dependencies: taskWithDeps.dependencies,\n        dependents: taskWithDeps.dependents,\n      });\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // POST /api/v1/tasks/:id/subtasks - Create subtask\n  router.post('/:id/subtasks', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new NotFoundError('Task', 'ID is required');\n      }\n      const rawSubtaskData = validateInput(TaskValidation.create, {\n        ...req.body,\n        parent_task_id: id,\n      });\n\n      // Filter out undefined values to comply with exactOptionalPropertyTypes\n      const subtaskData = Object.fromEntries(\n        Object.entries(rawSubtaskData).filter(([, value]) => value !== undefined)\n      );\n\n      const subtask = await taskService.createTask(subtaskData as any);\n      return res.status(201).apiSuccess(subtask);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tasks/:id/subtasks - List subtasks\n  router.get('/:id/subtasks', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new ValidationError('Task ID is required');\n      }\n      const taskWithSubtasks = await taskService.getTaskWithSubtasks(id);\n\n      if (!taskWithSubtasks) {\n        throw new NotFoundError('Task', id);\n      }\n\n      return res.apiSuccess(taskWithSubtasks.subtasks);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Add a note to a task.\n   *\n   * @route POST /api/v1/tasks/:id/notes\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Task ID\n   * @bodyparam {string} content - Note content (required)\n   * @bodyparam {string} [category] - Note category: comment, update, reminder, technical\n   * @bodyparam {boolean} [pinned] - Pin note to top (default: false)\n   *\n   * @response 201 - Note created\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": {\n   *     \"id\": \"note123\",\n   *     \"task_id\": \"task456\",\n   *     \"content\": \"Implementation note\",\n   *     \"category\": \"technical\",\n   *     \"pinned\": false,\n   *     \"created_at\": \"2024-01-20T10:00:00Z\"\n   *   }\n   * }\n   * ```\n   *\n   * @response 400 - Invalid input data\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Task not found\n   */\n  // POST /api/v1/tasks/:id/notes - Add note to task\n  router.post('/:id/notes', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new ValidationError('Task ID is required');\n      }\n      const validatedBody = validateInput(NoteValidation.create, req.body);\n      const noteData = {\n        task_id: id,\n        content: validatedBody.content,\n        ...(validatedBody.category ? { category: validatedBody.category } : {}),\n        ...(validatedBody.pinned !== undefined ? { pinned: validatedBody.pinned } : {}),\n      };\n\n      const note = await noteService.createNote(noteData);\n      return res.status(201).apiSuccess(note);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tasks/:id/notes - Get task notes\n  router.get('/:id/notes', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const { limit = 50, offset = 0, category, pinned } = req.query;\n\n      const options = {\n        limit: parseInt(limit as string, 10),\n        offset: parseInt(offset as string, 10),\n        category: category as any,\n        pinned: pinned === 'true' ? true : pinned === 'false' ? false : undefined,\n      };\n\n      if (!id) {\n        throw new ValidationError('Task ID is required');\n      }\n      const notes = await noteService.getTaskNotes(id, options);\n      return res.apiSuccess(notes);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  /**\n   * Add tags to a task.\n   *\n   * @route POST /api/v1/tasks/:id/tags\n   * @auth Required - Write permission\n   *\n   * @param {string} id - Task ID\n   * @bodyparam {string[]} tag_ids - Array of tag IDs to add\n   *\n   * @response 201 - Tags added successfully\n   * ```json\n   * {\n   *   \"success\": true,\n   *   \"data\": [\n   *     {\n   *       \"task_id\": \"task123\",\n   *       \"tag_id\": \"tag456\",\n   *       \"created_at\": \"2024-01-20T10:00:00Z\"\n   *     }\n   *   ]\n   * }\n   * ```\n   *\n   * @response 400 - Invalid input (not an array)\n   * @response 401 - Missing or invalid API key\n   * @response 403 - Insufficient permissions\n   * @response 404 - Task or tag not found\n   */\n  // POST /api/v1/tasks/:id/tags - Add tags to task\n  router.post('/:id/tags', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      const { tag_ids } = req.body;\n\n      if (!Array.isArray(tag_ids)) {\n        return res.status(400).apiError('INVALID_INPUT', 'tag_ids must be an array');\n      }\n\n      if (!id) {\n        throw new ValidationError('Task ID is required');\n      }\n      const assignedTags = [];\n      await Promise.all(\n        tag_ids.map(async tagId => {\n          await tagService.addTagToTask(id, tagId);\n        })\n      );\n\n      return res.status(201).apiSuccess(assignedTags);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // DELETE /api/v1/tasks/:id/tags/:tagId - Remove tag from task\n  router.delete('/:id/tags/:tagId', requirePermission('write'), async (req, res, next) => {\n    try {\n      const { id, tagId } = req.params;\n      if (!id) {\n        throw new NotFoundError('Task', 'ID is required');\n      }\n      if (!tagId) {\n        throw new NotFoundError('Tag', 'Tag ID is required');\n      }\n      await tagService.removeTagFromTask(id, tagId);\n      return res.status(204).send();\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tasks/:id/tags - Get task tags\n  router.get('/:id/tags', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { id } = req.params;\n      if (!id) {\n        throw new ValidationError('Task ID is required');\n      }\n      const tags = await tagService.getTaskTags(id);\n      return res.apiSuccess(tags);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tasks/blocked - Get blocked tasks\n  router.get('/blocked', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { board_id } = req.query;\n      const blockedTasks = await taskService.getBlockedTasks(board_id as string);\n      return res.apiSuccess(blockedTasks);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  // GET /api/v1/tasks/overdue - Get overdue tasks\n  router.get('/overdue', requirePermission('read'), async (req, res, next) => {\n    try {\n      const { board_id } = req.query;\n      const overdueTasks = await taskService.getOverdueTasks(board_id as string);\n      return res.apiSuccess(overdueTasks);\n    } catch (error) {\n      return next(error);\n    }\n  });\n\n  return router;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/server.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 74,
        "column": 29,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 74,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2128, 2130], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 110,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 110,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `JsonObject | null | undefined`.",
        "line": 115,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 115,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 124,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 124,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3431, 3434], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3431, 3434], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .headers on an `any` value.",
        "line": 126,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 126,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .headers on an `any` value.",
        "line": 126,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 126,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 127,
        "column": 21,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 127,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .headers on an `any` value.",
        "line": 127,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 127,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .headers on an `any` value.",
        "line": 127,
        "column": 62,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 127,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .headers on an `any` value.",
        "line": 129,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 129,
        "endColumn": 28
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 132,
        "column": 13,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 132,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 148,
        "column": 22,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 166,
        "endColumn": 4
      },
      {
        "ruleId": "consistent-return",
        "severity": 2,
        "message": "Expected to return a value at the end of async function 'startServer'.",
        "line": 232,
        "column": 23,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturn",
        "endLine": 232,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 234,
        "column": 11,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 234,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6671, 6674], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6671, 6674], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 235,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 235,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6696, 6699], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6696, 6699], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-misused-promises",
        "severity": 2,
        "message": "Promise returned in function argument where a void return was expected.",
        "line": 269,
        "column": 20,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "voidReturnArgument",
        "endLine": 286,
        "endColumn": 8
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 12,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import express from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport compression from 'compression';\nimport rateLimit from 'express-rate-limit';\nimport swaggerUi from 'swagger-ui-express';\nimport YAML from 'yamljs';\nimport path from 'path';\nimport { config } from '@/config';\nimport { logger } from '@/utils/logger';\nimport { dbConnection } from '@/database/connection';\nimport { globalErrorHandler } from '@/utils/errors';\nimport { createApiMiddleware } from '@/middleware';\nimport { webSocketManager } from '@/websocket';\n\nexport async function createServer(): Promise<express.Application> {\n  const app = express();\n\n  // Trust proxy for rate limiting and IP detection\n  app.set('trust proxy', 1);\n\n  // Security middleware\n  app.use(\n    helmet({\n      contentSecurityPolicy: {\n        directives: {\n          defaultSrc: [\"'self'\"],\n          styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n          scriptSrc: [\"'self'\"],\n          imgSrc: [\"'self'\", 'data:', 'https:'],\n        },\n      },\n      hsts: {\n        maxAge: 31536000,\n        includeSubDomains: true,\n        preload: true,\n      },\n    })\n  );\n\n  // CORS configuration\n  app.use(\n    cors({\n      origin: config.api.corsOrigin,\n      credentials: config.api.corsCredentials,\n      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],\n      allowedHeaders: [\n        'Content-Type',\n        'Authorization',\n        'X-API-Key',\n        'X-Request-ID',\n        'X-Forwarded-For',\n      ],\n      exposedHeaders: ['X-Request-ID', 'X-Rate-Limit-Remaining'],\n    })\n  );\n\n  // Rate limiting\n  const limiter = rateLimit({\n    windowMs: config.rateLimit.windowMs,\n    max: config.rateLimit.maxRequests,\n    message: {\n      error: 'Too many requests',\n      code: 'RATE_LIMIT_EXCEEDED',\n      retryAfter: Math.ceil(config.rateLimit.windowMs / 1000),\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n    skip: req =>\n      // Skip rate limiting for health checks\n      req.path === '/health' || req.path === '/api/health',\n    keyGenerator: req =>\n      // Use API key if available, otherwise use IP\n      (req.get('X-API-Key') || req.ip) ?? 'unknown',\n  });\n\n  app.use('/api', limiter);\n\n  // Compression\n  app.use(\n    compression({\n      filter: (req: express.Request, res: express.Response) => {\n        if (req.headers['x-no-compression']) {\n          return false;\n        }\n        return compression.filter(req, res);\n      },\n      threshold: 1024, // Only compress responses larger than 1KB\n    })\n  );\n\n  // Body parsing middleware\n  app.use(\n    express.json({\n      limit: config.performance.maxRequestSize,\n      strict: true,\n    })\n  );\n\n  app.use(\n    express.urlencoded({\n      extended: true,\n      limit: config.performance.maxRequestSize,\n    })\n  );\n\n  // Interactive API Explorer (Swagger UI) - Must be before API middleware to avoid auth\n  try {\n    const openApiSpecPath = path.join(__dirname, '../docs/api/openapi.yaml');\n    const openApiSpec = YAML.load(openApiSpecPath);\n\n    app.use(\n      '/api/docs',\n      swaggerUi.serve,\n      swaggerUi.setup(openApiSpec, {\n        customCss: '.swagger-ui .topbar { display: none }',\n        customSiteTitle: 'MCP Kanban API Explorer',\n        customfavIcon: '/favicon.ico',\n        swaggerOptions: {\n          docExpansion: 'list',\n          filter: true,\n          showRequestHeaders: true,\n          tryItOutEnabled: true,\n          requestInterceptor: (req: any) => {\n            // Add authentication header if available\n            if (req.headers && !req.headers.Authorization) {\n              const apiKey = req.headers['x-api-key'] || req.headers.authorization;\n              if (apiKey) {\n                req.headers.Authorization = `Bearer ${apiKey}`;\n              }\n            }\n            return req;\n          },\n        },\n      })\n    );\n\n    logger.info('Interactive API Explorer available at /api/docs');\n  } catch (error) {\n    logger.warn('Failed to load OpenAPI specification for interactive explorer', { error });\n  }\n\n  // API middleware\n  const apiMiddleware = await createApiMiddleware();\n  app.use('/api', apiMiddleware);\n\n  // Health check endpoint\n  app.get('/health', async (_req, res) => {\n    const health = await dbConnection.healthCheck();\n\n    const status = health.connected && health.responsive ? 'healthy' : 'unhealthy';\n    const statusCode = status === 'healthy' ? 200 : 503;\n\n    res.status(statusCode).json({\n      status,\n      timestamp: new Date().toISOString(),\n      version: config.mcp.serverVersion,\n      database: {\n        connected: health.connected,\n        responsive: health.responsive,\n        responseTime: health.stats?.responseTime,\n      },\n      uptime: process.uptime(),\n      memory: process.memoryUsage(),\n    });\n  });\n\n  // Root endpoint\n  app.get('/', (_req, res) => {\n    res.json({\n      name: config.mcp.serverName,\n      version: config.mcp.serverVersion,\n      description: 'MCP Kanban Task Management Server',\n      documentation: '/api/docs',\n      health: '/health',\n      endpoints: {\n        api: '/api/v1',\n        websocket: `ws://localhost:${String(String(config.websocket.port))}${String(String(config.websocket.path))}`,\n        interactiveExplorer: '/api/docs',\n      },\n    });\n  });\n\n  // 404 handler\n  app.use('*', (req, res) => {\n    res.status(404).json({\n      error: 'Not Found',\n      code: 'NOT_FOUND',\n      message: `The requested resource ${String(String(req.originalUrl))} was not found`,\n      timestamp: new Date().toISOString(),\n    });\n  });\n\n  // Global error handler\n  app.use(\n    (error: Error, req: express.Request, res: express.Response, _next: express.NextFunction) => {\n      const serviceError = globalErrorHandler.handleError(error, {\n        service: 'ExpressServer',\n        method: req.method,\n        metadata: {\n          url: req.originalUrl,\n          userAgent: req.get('User-Agent'),\n          ip: req.ip,\n        },\n      });\n\n      logger.error('HTTP request error', {\n        requestId: req.get('X-Request-ID'),\n        method: req.method,\n        url: req.originalUrl,\n        statusCode: serviceError.statusCode,\n        error: serviceError.message,\n        stack: serviceError.stack,\n      });\n\n      res.status(serviceError.statusCode).json({\n        error: serviceError.message,\n        code: serviceError.code,\n        timestamp: new Date().toISOString(),\n        requestId: req.get('X-Request-ID'),\n        ...(config.server.nodeEnv === 'development' && {\n          details: serviceError.details,\n          stack: serviceError.stack,\n        }),\n      });\n    }\n  );\n\n  return app;\n}\n\nexport async function startServer(): Promise<{\n  app: express.Application;\n  server: any;\n  webSocketManager: any;\n}> {\n  try {\n    // Initialize database\n    logger.info('Initializing database connection...');\n    await dbConnection.initialize();\n\n    // Create Express app\n    logger.info('Creating Express server...');\n    const app = await createServer();\n\n    // Start WebSocket server\n    logger.info('Starting WebSocket server...');\n    await webSocketManager.start();\n\n    // Start server\n    const server = app.listen(config.server.port, config.server.host, () => {\n      logger.info('Server started successfully', {\n        host: config.server.host,\n        port: config.server.port,\n        nodeEnv: config.server.nodeEnv,\n        version: config.mcp.serverVersion,\n        websocket: {\n          host: config.websocket.host,\n          port: config.websocket.port,\n          path: config.websocket.path,\n        },\n      });\n    });\n\n    // Graceful shutdown\n    const gracefulShutdown = (signal: string): void => {\n      logger.info(`Received ${String(signal)}, starting graceful shutdown...`);\n\n      server.close(async () => {\n        logger.info('HTTP server closed');\n\n        try {\n          // Stop WebSocket server\n          await webSocketManager.stop();\n          logger.info('WebSocket server closed');\n\n          await dbConnection.close();\n          logger.info('Database connection closed');\n\n          logger.info('Graceful shutdown completed');\n          process.exit(0);\n        } catch (error) {\n          logger.error('Error during shutdown', { error });\n          process.exit(1);\n        }\n      });\n\n      // Force shutdown after timeout\n      setTimeout(() => {\n        logger.error('Forceful shutdown due to timeout');\n        process.exit(1);\n      }, 10000);\n    };\n\n    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n    process.on('SIGINT', () => gracefulShutdown('SIGINT'));\n\n    // Handle unhandled promise rejections\n    process.on('unhandledRejection', (reason, promise) => {\n      logger.error('Unhandled Promise Rejection', {\n        reason: reason instanceof Error ? reason.message : reason,\n        stack: reason instanceof Error ? reason.stack : undefined,\n        promise,\n      });\n    });\n\n    // Handle uncaught exceptions\n    process.on('uncaughtException', error => {\n      logger.error('Uncaught Exception', {\n        error: error.message,\n        stack: error.stack,\n      });\n      process.exit(1);\n    });\n\n    return { app, server, webSocketManager };\n  } catch (error) {\n    logger.error('Failed to start server', { error });\n    process.exit(1);\n  }\n}\n\n// Start server if this file is run directly\nif (require.main === module) {\n  startServer().catch(error => {\n    logger.error('Failed to start server:', error);\n    process.exit(1);\n  });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/BackupService.ts",
    "messages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'groupStatementsByTable'.",
        "line": 443,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 443,
        "endColumn": 33
      },
      {
        "ruleId": "prefer-destructuring",
        "severity": 2,
        "message": "Use array destructuring.",
        "line": 456,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "preferDestructuring",
        "endLine": 456,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any[]` assigned to a parameter of type `QueryParameters`.",
        "line": 562,
        "column": 45,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 562,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 562,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 562,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16871, 16874], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16871, 16874], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/unbound-method",
        "severity": 2,
        "message": "Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.",
        "line": 563,
        "column": 21,
        "nodeType": "MemberExpression",
        "messageId": "unboundWithoutThisAnnotation",
        "endLine": 563,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 612,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 612,
        "endColumn": 97
      },
      {
        "ruleId": "no-restricted-globals",
        "severity": 2,
        "message": "Unexpected use of 'isNaN'. Use Number.isNaN instead https://github.com/airbnb/javascript#standard-library--isnan",
        "line": 734,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "customMessage",
        "endLine": 734,
        "endColumn": 18
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class async method 'validateRestoreTarget'.",
        "line": 837,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 837,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'stats' is assigned a value but never used.",
        "line": 862,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 862,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 989,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 989,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 990,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 990,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .integrity_check on an `any` value.",
        "line": 990,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 990,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 994,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 994,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1016,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1018,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1021,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1023,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1026,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1028,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1030,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1033,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1031,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1031,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1032,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1032,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1033,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1033,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1041,
        "column": 72,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1041,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1041,
        "column": 111,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1041,
        "endColumn": 116
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1041,
        "column": 158,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1041,
        "endColumn": 163
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1064,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1066,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1067,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1067,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1067,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1067,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1068,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1068,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1072,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1074,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1075,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1075,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1075,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1075,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1076,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1076,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1080,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1082,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1083,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1083,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1083,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1083,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1084,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1084,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 1117,
        "column": 45,
        "nodeType": "MemberExpression",
        "messageId": "unsafeReturn",
        "endLine": 1117,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 1117,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1117,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1160,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1162,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1163,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1163,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1163,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1163,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1164,
        "column": 47,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1164,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1168,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1170,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1171,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1171,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1171,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1171,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1172,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1172,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1199,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1213,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 1215,
        "column": 7,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 1215,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .count on an `any` value.",
        "line": 1215,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1215,
        "endColumn": 27
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'extractTableDefinitions'.",
        "line": 1225,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 1225,
        "endColumn": 34
      },
      {
        "ruleId": "no-cond-assign",
        "severity": 2,
        "message": "Unexpected assignment within a 'while' statement.",
        "line": 1230,
        "column": 13,
        "nodeType": "AssignmentExpression",
        "messageId": "unexpected",
        "endLine": 1230,
        "endColumn": 54
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'extractSchemaVersion'.",
        "line": 1242,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 1242,
        "endColumn": 31
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'isSchemaVersionCompatible'.",
        "line": 1251,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 1251,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'version' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 1251,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 1251,
        "endColumn": 52
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'extractTableInfo'.",
        "line": 1260,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 1260,
        "endColumn": 27
      },
      {
        "ruleId": "no-cond-assign",
        "severity": 2,
        "message": "Unexpected assignment within a 'while' statement.",
        "line": 1270,
        "column": 13,
        "nodeType": "AssignmentExpression",
        "messageId": "unexpected",
        "endLine": 1270,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 1272,
        "column": 62,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 1272,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [39065, 39067], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{}`.",
        "line": 1328,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 1328,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1330,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1330,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [col] on an `any` value.",
        "line": 1330,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1330,
        "endColumn": 32
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 1347,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 1347,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [41240, 41246], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 1504,
        "column": 60,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 1504,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [45819, 45821], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 1507,
        "column": 30,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 1507,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [45929, 45931], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1524,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 1526,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1531,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1531,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .id on an `any` value.",
        "line": 1531,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1531,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1532,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1532,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .total_steps on an `any` value.",
        "line": 1532,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1532,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1533,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1533,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .current_step on an `any` value.",
        "line": 1533,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1533,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1534,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1534,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .progress on an `any` value.",
        "line": 1534,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1534,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1535,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1535,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .message on an `any` value.",
        "line": 1535,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1535,
        "endColumn": 29
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1536,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1536,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .updated_at on an `any` value.",
        "line": 1536,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 1536,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'content' is assigned a value but never used.",
        "line": 1609,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 1609,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 14,
    "fatalErrorCount": 0,
    "warningCount": 62,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Backup Service - Handles database backup and restore operations\n *\n * @module services/BackupService\n * @description Provides comprehensive backup and restore functionality including\n * full/incremental backups, point-in-time recovery, and integrity validation.\n *\n * @example\n * ```typescript\n * import { BackupService } from '@/services/BackupService';\n * import { dbConnection } from '@/database/connection';\n *\n * const backupService = new BackupService(dbConnection);\n *\n * // Create a full backup\n * const backup = await backupService.createFullBackup({\n *   name: 'daily-backup',\n *   description: 'Daily backup of all data',\n *   compress: true\n * });\n * ```\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection } from '@/database/connection';\nimport { BaseServiceError } from '@/utils/errors';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport { gunzip, gzip } from 'zlib';\nimport { promisify } from 'util';\n\nconst gzipAsync = promisify(gzip);\nconst gunzipAsync = promisify(gunzip);\n\nexport interface BackupMetadata {\n  id: string;\n  name: string;\n  description?: string | undefined;\n  type: 'full' | 'incremental';\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'corrupted';\n  size: number;\n  compressed: boolean;\n  verified: boolean;\n  checksum: string;\n  filePath: string;\n  createdAt: string;\n  completedAt?: string | undefined;\n  parentBackupId?: string | undefined; // For incremental backups\n  retentionPolicy?: string | undefined;\n  error?: string | undefined;\n}\n\nexport interface CreateBackupOptions {\n  name?: string;\n  description?: string;\n  type?: 'full' | 'incremental';\n  compress?: boolean;\n  verify?: boolean;\n  parentBackupId?: string; // Required for incremental backups\n}\n\nexport interface RestoreOptions {\n  verify?: boolean;\n  targetFile?: string;\n  pointInTime?: string; // ISO timestamp\n  preserveExisting?: boolean;\n}\n\nexport interface RestoreValidationResult {\n  isValid: boolean;\n  tableChecks: Array<{\n    tableName: string;\n    rowCount: number;\n    isValid: boolean;\n    message: string;\n  }>;\n  errors: string[];\n}\n\nexport interface IntegrityCheckResult {\n  isPassed: boolean;\n  checks: Array<{\n    name: string;\n    passed: boolean;\n    message: string;\n  }>;\n}\n\nexport interface PartialRestoreOptions extends RestoreOptions {\n  tables: string[];\n  includeSchema?: boolean;\n  preserveExisting?: boolean;\n  validateAfter?: boolean;\n}\n\nexport interface RestoreProgress {\n  id: string;\n  totalSteps: number;\n  currentStep: number;\n  progress: number;\n  message: string;\n  updatedAt: string;\n}\n\nexport class BackupService {\n  private readonly backupDir: string;\n\n  constructor(private readonly db: DatabaseConnection) {\n    this.backupDir = path.join(process.cwd(), 'backups');\n  }\n\n  /**\n   * Create a full backup of the database\n   */\n  async createFullBackup(options: CreateBackupOptions = {}): Promise<BackupMetadata> {\n    const backupId = uuidv4();\n    const timestamp = new Date().toISOString();\n    const name = options.name ?? `full-backup-${timestamp}`;\n\n    logger.info('Starting full backup', { backupId, name });\n\n    const metadata: BackupMetadata = {\n      id: backupId,\n      name,\n      description: options.description,\n      type: 'full',\n      status: 'pending',\n      size: 0,\n      compressed: options.compress ?? false,\n      verified: false,\n      checksum: '',\n      filePath: '',\n      createdAt: timestamp,\n    };\n\n    try {\n      // Ensure backup directory exists\n      await this.ensureBackupDirectory();\n\n      // Update status to in_progress\n      metadata.status = 'in_progress';\n      await this.storeBackupMetadata(metadata);\n\n      // Export database to SQL\n      const sqlContent = await this.exportDatabaseToSQL();\n\n      // Compress if requested\n      let content: Buffer;\n      if (options.compress) {\n        content = await gzipAsync(Buffer.from(sqlContent, 'utf8'));\n      } else {\n        content = Buffer.from(sqlContent, 'utf8');\n      }\n\n      // Generate file path\n      const extension = options.compress ? '.sql.gz' : '.sql';\n      const filename = `${backupId}${extension}`;\n      const filePath = path.join(this.backupDir, filename);\n\n      // Write backup file\n      await fs.writeFile(filePath, content);\n\n      // Calculate checksum\n      const checksum = crypto.createHash('sha256').update(content).digest('hex');\n\n      // Update metadata\n      metadata.status = 'completed';\n      metadata.size = content.length;\n      metadata.filePath = filePath;\n      metadata.checksum = checksum;\n      metadata.completedAt = new Date().toISOString();\n\n      // Verify if requested\n      if (options.verify) {\n        const isValid = await this.verifyBackup(backupId);\n        metadata.verified = isValid;\n      }\n\n      await this.updateBackupMetadata(metadata);\n\n      logger.info('Full backup completed', { backupId, size: metadata.size });\n      return metadata;\n    } catch (error) {\n      metadata.status = 'failed';\n      metadata.error = error instanceof Error ? error.message : String(error);\n      await this.updateBackupMetadata(metadata);\n\n      logger.error('Full backup failed', { backupId, error });\n      throw new BaseServiceError('BACKUP_FAILED', 'Failed to create full backup');\n    }\n  }\n\n  /**\n   * Create an incremental backup based on a previous backup\n   */\n  async createIncrementalBackup(options: CreateBackupOptions): Promise<BackupMetadata> {\n    if (!options.parentBackupId) {\n      throw new BaseServiceError(\n        'INVALID_OPTIONS',\n        'parentBackupId is required for incremental backups'\n      );\n    }\n\n    const backupId = uuidv4();\n    const timestamp = new Date().toISOString();\n    const name = options.name ?? `incremental-backup-${timestamp}`;\n\n    logger.info('Starting incremental backup', {\n      backupId,\n      name,\n      parentBackupId: options.parentBackupId,\n    });\n\n    const metadata: BackupMetadata = {\n      id: backupId,\n      name,\n      description: options.description,\n      type: 'incremental',\n      status: 'pending',\n      size: 0,\n      compressed: options.compress ?? false,\n      verified: false,\n      checksum: '',\n      filePath: '',\n      createdAt: timestamp,\n      parentBackupId: options.parentBackupId,\n    };\n\n    try {\n      // Verify parent backup exists\n      const parentBackup = await this.getBackupMetadata(options.parentBackupId);\n      if (!parentBackup) {\n        throw new BaseServiceError('PARENT_NOT_FOUND', 'Parent backup not found');\n      }\n\n      // Ensure backup directory exists\n      await this.ensureBackupDirectory();\n\n      // Update status to in_progress\n      metadata.status = 'in_progress';\n      await this.storeBackupMetadata(metadata);\n\n      // Export only changes since parent backup\n      const sqlContent = await this.exportIncrementalSQL(options.parentBackupId);\n\n      // Compress if requested\n      let content: Buffer;\n      if (options.compress) {\n        content = await gzipAsync(Buffer.from(sqlContent, 'utf8'));\n      } else {\n        content = Buffer.from(sqlContent, 'utf8');\n      }\n\n      // Generate file path\n      const extension = options.compress ? '.sql.gz' : '.sql';\n      const filename = `${backupId}${extension}`;\n      const filePath = path.join(this.backupDir, filename);\n\n      // Write backup file\n      await fs.writeFile(filePath, content);\n\n      // Calculate checksum\n      const checksum = crypto.createHash('sha256').update(content).digest('hex');\n\n      // Update metadata\n      metadata.status = 'completed';\n      metadata.size = content.length;\n      metadata.filePath = filePath;\n      metadata.checksum = checksum;\n      metadata.completedAt = new Date().toISOString();\n\n      // Verify if requested\n      if (options.verify) {\n        const isValid = await this.verifyBackup(backupId);\n        metadata.verified = isValid;\n      }\n\n      await this.updateBackupMetadata(metadata);\n\n      logger.info('Incremental backup completed', { backupId, size: metadata.size });\n      return metadata;\n    } catch (error) {\n      metadata.status = 'failed';\n      metadata.error = error instanceof Error ? error.message : String(error);\n      await this.updateBackupMetadata(metadata);\n\n      logger.error('Incremental backup failed', { backupId, error });\n      throw new BaseServiceError('BACKUP_FAILED', 'Failed to create incremental backup');\n    }\n  }\n\n  /**\n   * Restore database from a backup\n   */\n  async restoreFromBackup(backupId: string, options: RestoreOptions = {}): Promise<void> {\n    logger.info('Starting restore from backup', { backupId, options });\n\n    const metadata = await this.getBackupMetadata(backupId);\n    if (!metadata) {\n      throw new BaseServiceError('BACKUP_NOT_FOUND', 'Backup not found');\n    }\n\n    if (metadata.status !== 'completed') {\n      throw new BaseServiceError('INVALID_BACKUP', 'Cannot restore from incomplete backup');\n    }\n\n    // Verify backup if requested\n    if (options.verify) {\n      const isValid = await this.verifyBackup(backupId);\n      if (!isValid) {\n        throw new BaseServiceError('VERIFICATION_FAILED', 'Backup verification failed');\n      }\n    }\n\n    try {\n      await this.applyBackupContent(metadata, !options.preserveExisting);\n      logger.info('Restore completed successfully', { backupId });\n    } catch (error) {\n      logger.error('Restore failed', { backupId, error });\n      throw new BaseServiceError('RESTORE_FAILED', 'Failed to restore from backup');\n    }\n  }\n\n  /**\n   * Restore specific tables from a backup\n   */\n  async restorePartialData(backupId: string, options: PartialRestoreOptions): Promise<void> {\n    logger.info('Starting partial restore', { backupId, tables: options.tables });\n\n    const metadata = await this.getBackupMetadata(backupId);\n    if (!metadata) {\n      throw new BaseServiceError('BACKUP_NOT_FOUND', 'Backup not found');\n    }\n\n    if (metadata.status !== 'completed') {\n      throw new BaseServiceError('INVALID_BACKUP', 'Cannot restore from incomplete backup');\n    }\n\n    // Validate restore options\n    const validation = await this.validateRestoreOptions(backupId, options);\n    if (!validation.isValid) {\n      throw new BaseServiceError(\n        'VALIDATION_FAILED',\n        `Restore validation failed: ${validation.errors.join(', ')}`\n      );\n    }\n\n    try {\n      // Read backup content\n      let content: Buffer;\n      if (metadata.compressed) {\n        const compressedData = await fs.readFile(metadata.filePath);\n        content = await gunzipAsync(compressedData);\n      } else {\n        content = await fs.readFile(metadata.filePath);\n      }\n\n      const sqlContent = content.toString();\n\n      // Extract and apply specific table data\n      await this.applyPartialBackupContent(sqlContent, options);\n\n      // Validate after restore if requested\n      if (options.validateAfter) {\n        const integrityCheck = await this.performDataIntegrityCheck();\n        if (!integrityCheck.isPassed) {\n          logger.warn('Data integrity issues detected after partial restore', integrityCheck);\n        }\n      }\n\n      logger.info('Partial restore completed successfully', { backupId, tables: options.tables });\n    } catch (error) {\n      logger.error('Partial restore failed', { backupId, error });\n      throw new BaseServiceError('RESTORE_FAILED', 'Failed to perform partial restore');\n    }\n  }\n\n  /**\n   * Apply partial backup content to database\n   */\n  private async applyPartialBackupContent(\n    sqlContent: string,\n    options: PartialRestoreOptions\n  ): Promise<void> {\n    const statements = sqlContent.split(';').filter(stmt => stmt.trim());\n\n    // Group statements by table\n    const tableStatements = this.groupStatementsByTable(statements);\n\n    // Process each requested table\n    for (const tableName of options.tables) {\n      if (!tableStatements.has(tableName)) {\n        logger.warn(`Table ${tableName} not found in backup`);\n        continue;\n      }\n\n      const tableData = tableStatements.get(tableName);\n      if (!tableData) continue;\n\n      logger.info(`Restoring table: ${tableName}`, {\n        schemaStatements: tableData.schema.length,\n        dataStatements: tableData.data.length,\n      });\n\n      try {\n        // Clear existing data if not preserving\n        if (!options.preserveExisting) {\n          await this.db.execute(`DELETE FROM ${tableName}`);\n        }\n\n        // Apply schema if requested\n        if (options.includeSchema) {\n          for (const schemaStmt of tableData.schema) {\n            if (schemaStmt.trim()) {\n              await this.db.execute(schemaStmt);\n            }\n          }\n        }\n\n        // Apply data\n        for (const dataStmt of tableData.data) {\n          if (dataStmt.trim()) {\n            await this.db.execute(dataStmt);\n          }\n        }\n\n        logger.info(`Successfully restored table: ${tableName}`);\n      } catch (error) {\n        logger.error(`Failed to restore table: ${tableName}`, error);\n        throw new BaseServiceError(\n          'TABLE_RESTORE_FAILED',\n          `Failed to restore table ${tableName}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Group SQL statements by table\n   */\n  private groupStatementsByTable(\n    statements: string[]\n  ): Map<string, { schema: string[]; data: string[] }> {\n    const tableStatements = new Map<string, { schema: string[]; data: string[] }>();\n    let currentTable = '';\n\n    statements.forEach(statement => {\n      const trimmed = statement.trim();\n      if (!trimmed) return;\n\n      // Check if this is a CREATE TABLE statement\n      const createMatch = trimmed.match(/CREATE TABLE\\s+(\\w+)/i);\n      if (createMatch) {\n        currentTable = createMatch[1];\n        if (!tableStatements.has(currentTable)) {\n          tableStatements.set(currentTable, { schema: [], data: [] });\n        }\n        tableStatements.get(currentTable)?.schema.push(trimmed);\n        return;\n      }\n\n      // Check if this is an INSERT statement\n      const insertMatch = trimmed.match(/INSERT INTO\\s+(\\w+)/i);\n      if (insertMatch) {\n        const tableName = insertMatch[1];\n        if (!tableStatements.has(tableName)) {\n          tableStatements.set(tableName, { schema: [], data: [] });\n        }\n        tableStatements.get(tableName)?.data.push(trimmed);\n        return;\n      }\n\n      // Other statements (indexes, etc.) go to the current table\n      if (currentTable && tableStatements.has(currentTable)) {\n        tableStatements.get(currentTable)?.schema.push(trimmed);\n      }\n    });\n\n    return tableStatements;\n  }\n\n  /**\n   * Extract specific table data from backup\n   */\n  async extractTableData(backupId: string, tableName: string): Promise<string> {\n    const metadata = await this.getBackupMetadata(backupId);\n    if (!metadata) {\n      throw new BaseServiceError('BACKUP_NOT_FOUND', 'Backup not found');\n    }\n\n    try {\n      // Read backup content\n      let content: Buffer;\n      if (metadata.compressed) {\n        const compressedData = await fs.readFile(metadata.filePath);\n        content = await gunzipAsync(compressedData);\n      } else {\n        content = await fs.readFile(metadata.filePath);\n      }\n\n      const sqlContent = content.toString();\n      const statements = sqlContent.split(';').filter(stmt => stmt.trim());\n      const tableStatements = this.groupStatementsByTable(statements);\n\n      const tableData = tableStatements.get(tableName);\n      if (!tableData) {\n        throw new BaseServiceError('TABLE_NOT_FOUND', `Table ${tableName} not found in backup`);\n      }\n\n      // Combine schema and data statements\n      const allStatements = [...tableData.schema, ...tableData.data];\n      return `${allStatements.join(';\\n')};`;\n    } catch (error) {\n      logger.error(`Failed to extract table data for ${tableName}`, error);\n      throw new BaseServiceError(\n        'EXTRACTION_FAILED',\n        `Failed to extract table data: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * List available backups\n   */\n  async listBackups(\n    options: {\n      limit?: number;\n      offset?: number;\n      type?: 'full' | 'incremental';\n      status?: string;\n    } = {}\n  ): Promise<BackupMetadata[]> {\n    await this.ensureMetadataTable();\n\n    let query = 'SELECT * FROM backup_metadata WHERE 1=1';\n    const params: unknown[] = [];\n\n    if (options.type) {\n      query += ' AND type = ?';\n      params.push(options.type);\n    }\n\n    if (options.status) {\n      query += ' AND status = ?';\n      params.push(options.status);\n    }\n\n    query += ' ORDER BY created_at DESC';\n\n    if (options.limit) {\n      query += ' LIMIT ?';\n      params.push(options.limit);\n    }\n\n    if (options.offset) {\n      query += ' OFFSET ?';\n      params.push(options.offset);\n    }\n\n    const rows = await this.db.query(query, params as any[]);\n    return rows.map(BackupService.deserializeBackupMetadata);\n  }\n\n  /**\n   * Clean up old backups based on retention days\n   */\n  async cleanupOldBackups(retentionDays: number): Promise<void> {\n    logger.info('Starting cleanup of old backups', { retentionDays });\n\n    try {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n      const oldBackups = await this.listBackups({ limit: 1000 });\n      const backupsToDelete = oldBackups.filter(backup => {\n        const backupDate = new Date(backup.createdAt);\n        return backupDate < cutoffDate;\n      });\n\n      await Promise.all(\n        backupsToDelete.map(async backup => {\n          try {\n            await this.deleteBackup(backup.id);\n            logger.info(`Deleted old backup: ${backup.name}`, { backupId: backup.id });\n          } catch (error) {\n            logger.error(`Failed to delete old backup: ${backup.name}`, {\n              backupId: backup.id,\n              error,\n            });\n          }\n        })\n      );\n\n      logger.info('Cleanup completed', {\n        totalBackups: oldBackups.length,\n        deletedBackups: backupsToDelete.length,\n      });\n    } catch (error) {\n      logger.error('Failed to cleanup old backups', error);\n      throw new BaseServiceError('CLEANUP_FAILED', 'Failed to cleanup old backups');\n    }\n  }\n\n  /**\n   * Get backup metadata by ID\n   */\n  async getBackupMetadata(backupId: string): Promise<BackupMetadata | null> {\n    await this.ensureMetadataTable();\n\n    const row = await this.db.queryOne('SELECT * FROM backup_metadata WHERE id = ?', [backupId]);\n    return row\n      ? BackupService.deserializeBackupMetadata(\n          row as {\n            id: string;\n            name: string;\n            description?: string;\n            type: string;\n            status: string;\n            size: number;\n            compressed: number;\n            verified: number;\n            checksum: string;\n            file_path: string;\n            created_at: string;\n            completed_at?: string;\n            parent_backup_id?: string;\n            retention_policy?: string;\n            error?: string;\n          }\n        )\n      : null;\n  }\n\n  /**\n   * Delete a backup\n   */\n  async deleteBackup(backupId: string): Promise<void> {\n    logger.info('Deleting backup', { backupId });\n\n    const metadata = await this.getBackupMetadata(backupId);\n    if (!metadata) {\n      throw new BaseServiceError('BACKUP_NOT_FOUND', 'Backup not found');\n    }\n\n    try {\n      // Delete backup file\n      if (\n        metadata.filePath &&\n        (await fs\n          .access(metadata.filePath)\n          .then(() => true)\n          .catch(() => false))\n      ) {\n        await fs.unlink(metadata.filePath);\n      }\n\n      // Delete metadata\n      await this.db.execute('DELETE FROM backup_metadata WHERE id = ?', [backupId]);\n\n      logger.info('Backup deleted successfully', { backupId });\n    } catch (error) {\n      logger.error('Failed to delete backup', { backupId, error });\n      throw new BaseServiceError('DELETE_FAILED', 'Failed to delete backup');\n    }\n  }\n\n  /**\n   * Verify backup integrity\n   */\n  async verifyBackup(backupId: string): Promise<boolean> {\n    const metadata = await this.getBackupMetadata(backupId);\n    if (!metadata) {\n      return false;\n    }\n\n    try {\n      // Check if file exists\n      if (\n        !(await fs\n          .access(metadata.filePath)\n          .then(() => true)\n          .catch(() => false))\n      ) {\n        return false;\n      }\n\n      // Read file and verify checksum\n      const content = await fs.readFile(metadata.filePath);\n      const calculatedChecksum = crypto.createHash('sha256').update(content).digest('hex');\n\n      return calculatedChecksum === metadata.checksum;\n    } catch (error) {\n      logger.error('Backup verification failed', { backupId, error });\n      return false;\n    }\n  }\n\n  /**\n   * Validate restore options and backup compatibility\n   */\n  async validateRestoreOptions(\n    backupId: string,\n    options: RestoreOptions = {}\n  ): Promise<RestoreValidationResult> {\n    const result: RestoreValidationResult = {\n      isValid: true,\n      tableChecks: [],\n      errors: [],\n    };\n\n    try {\n      // Check if backup exists\n      const metadata = await this.getBackupMetadata(backupId);\n      if (!metadata) {\n        result.isValid = false;\n        result.errors.push('Backup not found');\n        return result;\n      }\n\n      // Check backup status\n      if (metadata.status !== 'completed') {\n        result.isValid = false;\n        result.errors.push('Cannot restore from incomplete backup');\n        return result;\n      }\n\n      // Validate point-in-time if specified\n      if (options.pointInTime) {\n        const pointInTime = new Date(options.pointInTime);\n        const backupTime = new Date(metadata.createdAt);\n\n        if (isNaN(pointInTime.getTime())) {\n          result.isValid = false;\n          result.errors.push('Invalid point-in-time format');\n        } else if (pointInTime > backupTime) {\n          result.isValid = false;\n          result.errors.push('Point-in-time cannot be after backup creation time');\n        }\n      }\n\n      // Validate target file if specified\n      if (options.targetFile) {\n        const targetValidation = await this.validateRestoreTarget(options.targetFile);\n        if (!targetValidation.isValid) {\n          result.isValid = false;\n          result.errors.push(...targetValidation.errors);\n        }\n      }\n\n      // Check backup compatibility\n      const compatibilityCheck = await this.validateBackupCompatibility(metadata);\n      if (!compatibilityCheck.isValid) {\n        result.isValid = false;\n        result.errors.push(...compatibilityCheck.errors);\n      }\n\n      // Validate backup content structure\n      const contentValidation = await this.validateBackupContent(metadata);\n      result.tableChecks = contentValidation.tableChecks;\n      if (!contentValidation.isValid) {\n        result.isValid = false;\n        result.errors.push(...contentValidation.errors);\n      }\n    } catch (error) {\n      result.isValid = false;\n      result.errors.push(\n        `Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Validate backup compatibility with current system\n   */\n  private async validateBackupCompatibility(\n    metadata: BackupMetadata\n  ): Promise<{ isValid: boolean; errors: string[] }> {\n    const result = { isValid: true, errors: [] };\n\n    try {\n      // Read backup content to check schema compatibility\n      let content: Buffer;\n      if (metadata.compressed) {\n        const compressedData = await fs.readFile(metadata.filePath);\n        content = await gunzipAsync(compressedData);\n      } else {\n        content = await fs.readFile(metadata.filePath);\n      }\n\n      const sqlContent = content.toString();\n\n      // Extract table definitions from backup\n      const tableDefinitions = this.extractTableDefinitions(sqlContent);\n\n      // Check if required tables exist\n      const requiredTables = [\n        'boards',\n        'tasks',\n        'columns',\n        'tags',\n        'notes',\n        'task_tags',\n        'task_dependencies',\n      ];\n      requiredTables.forEach(table => {\n        if (!tableDefinitions.has(table)) {\n          result.errors.push(`Required table '${table}' not found in backup`);\n        }\n      });\n\n      // Check schema version compatibility (if schema versioning is implemented)\n      const schemaVersion = this.extractSchemaVersion(sqlContent);\n      if (schemaVersion && !this.isSchemaVersionCompatible(schemaVersion)) {\n        result.errors.push(`Schema version ${schemaVersion} is not compatible with current system`);\n      }\n\n      if (result.errors.length > 0) {\n        result.isValid = false;\n      }\n    } catch (error) {\n      result.isValid = false;\n      result.errors.push(\n        `Compatibility check failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Validate restore target (file system, permissions, etc.)\n   */\n  private async validateRestoreTarget(\n    targetPath?: string\n  ): Promise<{ isValid: boolean; errors: string[] }> {\n    const result = { isValid: true, errors: [] };\n\n    if (!targetPath) {\n      return result; // No target specified, use default\n    }\n\n    try {\n      // Check if target directory exists and is writable\n      const targetDir = path.dirname(targetPath);\n      await fs.access(targetDir, fs.constants.W_OK);\n\n      // Check if target file exists and is writable (or can be created)\n      try {\n        await fs.access(targetPath, fs.constants.W_OK);\n      } catch {\n        // File doesn't exist, check if we can create it\n        const testFile = path.join(targetDir, '.test-write');\n        await fs.writeFile(testFile, 'test');\n        await fs.unlink(testFile);\n      }\n\n      // Check available disk space (basic check)\n      const stats = await fs.stat(targetDir);\n      // Note: This is a simplified check. In production, you'd want more sophisticated space checking\n    } catch (error) {\n      result.isValid = false;\n      result.errors.push(\n        `Target validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Validate backup content structure and integrity\n   */\n  private async validateBackupContent(metadata: BackupMetadata): Promise<{\n    isValid: boolean;\n    tableChecks: Array<{ tableName: string; rowCount: number; isValid: boolean; message: string }>;\n    errors: string[];\n  }> {\n    const result = {\n      isValid: true,\n      tableChecks: [],\n      errors: [],\n    };\n\n    try {\n      // Read backup content\n      let content: Buffer;\n      if (metadata.compressed) {\n        const compressedData = await fs.readFile(metadata.filePath);\n        content = await gunzipAsync(compressedData);\n      } else {\n        content = await fs.readFile(metadata.filePath);\n      }\n\n      const sqlContent = content.toString();\n\n      // Extract table information\n      const tableInfo = this.extractTableInfo(sqlContent);\n\n      tableInfo.forEach((info, tableName) => {\n        const check = {\n          tableName,\n          rowCount: info.rowCount,\n          isValid: info.isValid,\n          message: info.message,\n        };\n\n        result.tableChecks.push(check);\n\n        if (!info.isValid) {\n          result.isValid = false;\n          result.errors.push(`Table ${tableName}: ${info.message}`);\n        }\n      });\n    } catch (error) {\n      result.isValid = false;\n      result.errors.push(\n        `Content validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Perform comprehensive data integrity checks\n   */\n  async performDataIntegrityCheck(): Promise<IntegrityCheckResult> {\n    const result: IntegrityCheckResult = {\n      isPassed: true,\n      checks: [],\n    };\n\n    try {\n      logger.info('Starting data integrity check');\n\n      // Check database integrity\n      const dbIntegrity = await this.checkDatabaseIntegrity();\n      result.checks.push(dbIntegrity);\n\n      // Check foreign key relationships\n      const fkIntegrity = await this.checkForeignKeyIntegrity();\n      result.checks.push(fkIntegrity);\n\n      // Check data consistency\n      const dataConsistency = await this.checkDataConsistency();\n      result.checks.push(dataConsistency);\n\n      // Check index integrity\n      const indexIntegrity = await this.checkIndexIntegrity();\n      result.checks.push(indexIntegrity);\n\n      // Check for orphaned records\n      const orphanedRecords = await this.checkOrphanedRecords();\n      result.checks.push(orphanedRecords);\n\n      // Determine overall result\n      result.isPassed = result.checks.every(check => check.passed);\n\n      logger.info('Data integrity check completed', {\n        passed: result.isPassed,\n        totalChecks: result.checks.length,\n      });\n    } catch (error) {\n      logger.error('Data integrity check failed', error);\n      result.isPassed = false;\n      result.checks.push({\n        name: 'System Error',\n        passed: false,\n        message: `Integrity check failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Check database integrity using SQLite's integrity_check\n   */\n  private async checkDatabaseIntegrity(): Promise<{\n    name: string;\n    passed: boolean;\n    message: string;\n  }> {\n    try {\n      const result = await this.db.queryOne('PRAGMA integrity_check');\n      const isPassed = result && result.integrity_check === 'ok';\n\n      return {\n        name: 'Database Integrity',\n        passed: isPassed,\n        message: isPassed ? 'Database integrity check passed' : 'Database integrity check failed',\n      };\n    } catch (error) {\n      return {\n        name: 'Database Integrity',\n        passed: false,\n        message: `Database integrity check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      };\n    }\n  }\n\n  /**\n   * Check foreign key integrity\n   */\n  private async checkForeignKeyIntegrity(): Promise<{\n    name: string;\n    passed: boolean;\n    message: string;\n  }> {\n    try {\n      // Check for orphaned tasks (no valid board)\n      const orphanedTasks = await this.db.queryOne(\n        'SELECT COUNT(*) as count FROM tasks t LEFT JOIN boards b ON t.board_id = b.id WHERE b.id IS NULL'\n      );\n\n      // Check for orphaned task_tags (no valid task or tag)\n      const orphanedTaskTags = await this.db.queryOne(\n        'SELECT COUNT(*) as count FROM task_tags tt LEFT JOIN tasks t ON tt.task_id = t.id LEFT JOIN tags tag ON tt.tag_id = tag.id WHERE t.id IS NULL OR tag.id IS NULL'\n      );\n\n      // Check for orphaned task_dependencies (no valid task)\n      const orphanedDependencies = await this.db.queryOne(\n        'SELECT COUNT(*) as count FROM task_dependencies td LEFT JOIN tasks t1 ON td.task_id = t1.id LEFT JOIN tasks t2 ON td.depends_on_id = t2.id WHERE t1.id IS NULL OR t2.id IS NULL'\n      );\n\n      const totalOrphaned =\n        (orphanedTasks?.count || 0) +\n        (orphanedTaskTags?.count || 0) +\n        (orphanedDependencies?.count || 0);\n      const isPassed = totalOrphaned === 0;\n\n      return {\n        name: 'Foreign Key Integrity',\n        passed: isPassed,\n        message: isPassed\n          ? 'All foreign key relationships are valid'\n          : `Found ${totalOrphaned} orphaned records (${orphanedTasks?.count || 0} tasks, ${orphanedTaskTags?.count || 0} task_tags, ${orphanedDependencies?.count || 0} dependencies)`,\n      };\n    } catch (error) {\n      return {\n        name: 'Foreign Key Integrity',\n        passed: false,\n        message: `Foreign key check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      };\n    }\n  }\n\n  /**\n   * Check data consistency\n   */\n  private async checkDataConsistency(): Promise<{\n    name: string;\n    passed: boolean;\n    message: string;\n  }> {\n    try {\n      const issues: string[] = [];\n\n      // Check for tasks with invalid status values\n      const invalidStatus = await this.db.queryOne(\n        \"SELECT COUNT(*) as count FROM tasks WHERE status NOT IN ('todo', 'in_progress', 'done', 'blocked', 'archived')\"\n      );\n      if (invalidStatus?.count && invalidStatus.count > 0) {\n        issues.push(`${invalidStatus.count} tasks with invalid status`);\n      }\n\n      // Check for tasks with invalid priority values\n      const invalidPriority = await this.db.queryOne(\n        'SELECT COUNT(*) as count FROM tasks WHERE priority < 1 OR priority > 5'\n      );\n      if (invalidPriority?.count && invalidPriority.count > 0) {\n        issues.push(`${invalidPriority.count} tasks with invalid priority`);\n      }\n\n      // Check for tasks with negative position values\n      const negativePosition = await this.db.queryOne(\n        'SELECT COUNT(*) as count FROM tasks WHERE position < 0'\n      );\n      if (negativePosition?.count && negativePosition.count > 0) {\n        issues.push(`${negativePosition.count} tasks with negative position`);\n      }\n\n      // Check for circular dependencies\n      const circularDeps = await this.checkCircularDependencies();\n      if (circularDeps > 0) {\n        issues.push(`${circularDeps} circular dependencies detected`);\n      }\n\n      const isPassed = issues.length === 0;\n      return {\n        name: 'Data Consistency',\n        passed: isPassed,\n        message: isPassed\n          ? 'All data consistency checks passed'\n          : `Issues found: ${issues.join(', ')}`,\n      };\n    } catch (error) {\n      return {\n        name: 'Data Consistency',\n        passed: false,\n        message: `Data consistency check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      };\n    }\n  }\n\n  /**\n   * Check index integrity\n   */\n  private async checkIndexIntegrity(): Promise<{ name: string; passed: boolean; message: string }> {\n    try {\n      // Check if required indexes exist\n      const indexes = await this.db.query(\"SELECT name FROM sqlite_master WHERE type='index'\");\n      const indexNames = indexes.map(idx => idx.name);\n\n      const requiredIndexes = [\n        'idx_tasks_board_id',\n        'idx_tasks_status',\n        'idx_tasks_priority',\n        'idx_task_tags_task_id',\n        'idx_task_tags_tag_id',\n        'idx_task_dependencies_task_id',\n        'idx_task_dependencies_depends_on_id',\n      ];\n\n      const missingIndexes = requiredIndexes.filter(idx => !indexNames.includes(idx));\n      const isPassed = missingIndexes.length === 0;\n\n      return {\n        name: 'Index Integrity',\n        passed: isPassed,\n        message: isPassed\n          ? 'All required indexes are present'\n          : `Missing indexes: ${missingIndexes.join(', ')}`,\n      };\n    } catch (error) {\n      return {\n        name: 'Index Integrity',\n        passed: false,\n        message: `Index check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      };\n    }\n  }\n\n  /**\n   * Check for orphaned records\n   */\n  private async checkOrphanedRecords(): Promise<{\n    name: string;\n    passed: boolean;\n    message: string;\n  }> {\n    try {\n      const orphanedRecords: string[] = [];\n\n      // Check for notes without tasks\n      const orphanedNotes = await this.db.queryOne(\n        'SELECT COUNT(*) as count FROM notes n LEFT JOIN tasks t ON n.task_id = t.id WHERE t.id IS NULL'\n      );\n      if (orphanedNotes?.count && orphanedNotes.count > 0) {\n        orphanedRecords.push(`${orphanedNotes.count} notes`);\n      }\n\n      // Check for columns without boards\n      const orphanedColumns = await this.db.queryOne(\n        'SELECT COUNT(*) as count FROM columns c LEFT JOIN boards b ON c.board_id = b.id WHERE b.id IS NULL'\n      );\n      if (orphanedColumns?.count && orphanedColumns.count > 0) {\n        orphanedRecords.push(`${orphanedColumns.count} columns`);\n      }\n\n      const isPassed = orphanedRecords.length === 0;\n      return {\n        name: 'Orphaned Records',\n        passed: isPassed,\n        message: isPassed\n          ? 'No orphaned records found'\n          : `Found orphaned records: ${orphanedRecords.join(', ')}`,\n      };\n    } catch (error) {\n      return {\n        name: 'Orphaned Records',\n        passed: false,\n        message: `Orphaned records check error: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      };\n    }\n  }\n\n  /**\n   * Check for circular dependencies in tasks\n   */\n  private async checkCircularDependencies(): Promise<number> {\n    try {\n      // This is a simplified check. In a real implementation, you'd use a more sophisticated algorithm\n      // to detect cycles in the dependency graph\n      const result = await this.db.queryOne(`\n        WITH RECURSIVE deps AS (\n          SELECT task_id, depends_on_id, 1 as depth\n          FROM task_dependencies\n          UNION ALL\n          SELECT td.task_id, td.depends_on_id, d.depth + 1\n          FROM task_dependencies td\n          JOIN deps d ON td['task_id'] = d.depends_on_id\n          WHERE d.depth < 10  -- Prevent infinite recursion\n        )\n        SELECT COUNT(*) as count\n        FROM deps d1\n        JOIN deps d2 ON d1.task_id = d2.depends_on_id AND d1.depends_on_id = d2.task_id\n        WHERE d1.task_id != d1.depends_on_id\n      `);\n\n      return result?.count || 0;\n    } catch (error) {\n      logger.error('Circular dependency check failed', error);\n      return 0; // Assume no circular dependencies if check fails\n    }\n  }\n\n  /**\n   * Extract table definitions from SQL content\n   */\n  private extractTableDefinitions(sqlContent: string): Map<string, string> {\n    const tableDefinitions = new Map<string, string>();\n    const createTableRegex = /CREATE TABLE\\s+(\\w+)\\s*\\(([\\s\\S]*?)\\);/gi;\n\n    let match;\n    while ((match = createTableRegex.exec(sqlContent)) !== null) {\n      const tableName = match[1];\n      const definition = match[2];\n      tableDefinitions.set(tableName, definition);\n    }\n\n    return tableDefinitions;\n  }\n\n  /**\n   * Extract schema version from SQL content\n   */\n  private extractSchemaVersion(sqlContent: string): string | null {\n    const versionRegex = /-- Schema Version:\\s*(\\d+\\.\\d+\\.\\d+)/i;\n    const match = sqlContent.match(versionRegex);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Check if schema version is compatible\n   */\n  private isSchemaVersionCompatible(version: string): boolean {\n    // For now, assume all versions are compatible\n    // In a real implementation, you'd have version compatibility rules\n    return true;\n  }\n\n  /**\n   * Extract table information from SQL content\n   */\n  private extractTableInfo(\n    sqlContent: string\n  ): Map<string, { rowCount: number; isValid: boolean; message: string }> {\n    const tableInfo = new Map<string, { rowCount: number; isValid: boolean; message: string }>();\n\n    // Extract table names and count INSERT statements\n    const tableRegex = /INSERT INTO\\s+(\\w+)\\s*\\(/gi;\n    const tableCounts = new Map<string, number>();\n\n    let match;\n    while ((match = tableRegex.exec(sqlContent)) !== null) {\n      const tableName = match[1];\n      tableCounts.set(tableName, (tableCounts.get(tableName) || 0) + 1);\n    }\n\n    // Validate each table\n    tableCounts.forEach((rowCount, tableName) => {\n      const isValid = rowCount >= 0; // Basic validation\n      const message = isValid ? 'OK' : 'Invalid row count';\n\n      tableInfo.set(tableName, {\n        rowCount,\n        isValid,\n        message,\n      });\n    });\n\n    return tableInfo;\n  }\n\n  // Private helper methods\n\n  private async ensureBackupDirectory(): Promise<void> {\n    try {\n      await fs.access(this.backupDir);\n    } catch {\n      await fs.mkdir(this.backupDir, { recursive: true });\n    }\n  }\n\n  private async exportDatabaseToSQL(): Promise<string> {\n    const tables = await this.db.query<{ name: string }>(\n      \"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'\"\n    );\n\n    let sql = '-- Database Export\\n';\n    sql += `-- Generated: ${new Date().toISOString()}\\n\\n`;\n\n    const tableExports = await Promise.all(\n      tables.map(async table => {\n        // Get table schema\n        const schema = await this.db.queryOne<{ sql: string }>(\n          \"SELECT sql FROM sqlite_master WHERE type='table' AND name = ?\",\n          [table.name]\n        );\n\n        // Get table data\n        const data = await this.db.query(`SELECT * FROM ${table.name}`);\n\n        return { table, schema, data };\n      })\n    );\n\n    for (const { table, schema, data } of tableExports) {\n      if (schema?.sql) {\n        sql += `${schema.sql};\\n\\n`;\n      }\n      for (const row of data) {\n        const columns = Object.keys(row);\n        const values = columns.map(col => {\n          const value = row[col];\n          if (value === null || value === undefined) return 'NULL';\n          if (typeof value === 'string') return `'${value.replace(/'/g, \"''\")}'`;\n          return String(value);\n        });\n\n        sql += `INSERT INTO ${table.name} (${columns.join(', ')}) VALUES (${values.join(', ')});\\n`;\n      }\n      sql += '\\n';\n    }\n\n    return sql;\n  }\n\n  private async exportIncrementalSQL(_parentBackupId: string): Promise<string> {\n    // For simplicity, export all data since parent backup\n    // In a real implementation, this would track changes since the parent backup\n    return await this.exportDatabaseToSQL();\n  }\n\n  private async applyBackupContent(\n    backup: BackupMetadata,\n    clearFirst: boolean = false\n  ): Promise<void> {\n    // Read backup content\n    let content: Buffer;\n    if (backup.compressed) {\n      const compressedData = await fs.readFile(backup.filePath);\n      content = await gunzipAsync(compressedData);\n    } else {\n      content = await fs.readFile(backup.filePath);\n    }\n\n    const sqlContent = content.toString();\n\n    // Clear existing data if requested\n    if (clearFirst) {\n      await this.clearDatabase();\n    }\n\n    // Execute SQL statements\n    const statements = sqlContent.split(';').filter(stmt => stmt.trim());\n\n    // eslint-disable-next-line no-await-in-loop\n    for (const statement of statements) {\n      const trimmed = statement.trim();\n      if (trimmed) {\n        // eslint-disable-next-line no-await-in-loop\n        await this.db.execute(trimmed);\n      }\n    }\n  }\n\n  private async clearDatabase(): Promise<void> {\n    const tables = await this.db.query<{ name: string }>(\n      \"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'\"\n    );\n\n    await Promise.all(tables.map(table => this.db.execute(`DELETE FROM ${table.name}`)));\n  }\n\n  private async storeBackupMetadata(metadata: BackupMetadata): Promise<void> {\n    await this.ensureMetadataTable();\n\n    await this.db.execute(\n      `INSERT INTO backup_metadata (\n        id, name, description, type, status, size, compressed, verified, checksum, \n        file_path, created_at, completed_at, parent_backup_id, retention_policy, error\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n      [\n        metadata.id,\n        metadata.name,\n        metadata.description,\n        metadata.type,\n        metadata.status,\n        metadata.size,\n        metadata.compressed ? 1 : 0,\n        metadata.verified ? 1 : 0,\n        metadata.checksum,\n        metadata.filePath,\n        metadata.createdAt,\n        metadata.completedAt,\n        metadata.parentBackupId,\n        metadata.retentionPolicy,\n        metadata.error,\n      ]\n    );\n  }\n\n  private async updateBackupMetadata(metadata: BackupMetadata): Promise<void> {\n    await this.ensureMetadataTable();\n\n    await this.db.execute(\n      `UPDATE backup_metadata SET \n        name = ?, description = ?, type = ?, status = ?, size = ?, compressed = ?, \n        verified = ?, checksum = ?, file_path = ?, completed_at = ?, parent_backup_id = ?, \n        retention_policy = ?, error = ?\n      WHERE id = ?`,\n      [\n        metadata.name,\n        metadata.description,\n        metadata.type,\n        metadata.status,\n        metadata.size,\n        metadata.compressed ? 1 : 0,\n        metadata.verified ? 1 : 0,\n        metadata.checksum,\n        metadata.filePath,\n        metadata.completedAt,\n        metadata.parentBackupId,\n        metadata.retentionPolicy,\n        metadata.error,\n        metadata.id,\n      ]\n    );\n  }\n\n  private async ensureMetadataTable(): Promise<void> {\n    await this.db.execute(`\n      CREATE TABLE IF NOT EXISTS backup_metadata (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        description TEXT,\n        type TEXT NOT NULL,\n        status TEXT NOT NULL,\n        size INTEGER NOT NULL,\n        compressed INTEGER NOT NULL,\n        verified INTEGER NOT NULL,\n        checksum TEXT NOT NULL,\n        file_path TEXT NOT NULL,\n        created_at TEXT NOT NULL,\n        completed_at TEXT,\n        parent_backup_id TEXT,\n        retention_policy TEXT,\n        error TEXT\n      )\n    `);\n  }\n\n  /**\n   * Track restoration progress\n   */\n  private async trackRestoreProgress(progressId: string, progress: RestoreProgress): Promise<void> {\n    try {\n      await this.ensureProgressTable();\n\n      await this.db.execute(\n        `INSERT OR REPLACE INTO restore_progress \n         (id, total_steps, current_step, progress, message, updated_at) \n         VALUES (?, ?, ?, ?, ?, ?)`,\n        [\n          progress.id,\n          progress.totalSteps,\n          progress.currentStep,\n          progress.progress,\n          progress.message,\n          progress.updatedAt,\n        ]\n      );\n    } catch (error) {\n      logger.error('Failed to track restore progress', { progressId, error });\n      // Don't throw - progress tracking failure shouldn't stop the restore\n    }\n  }\n\n  /**\n   * Update restoration progress\n   */\n  private async updateRestoreProgress(\n    progressId: string,\n    currentStep: number,\n    message: string,\n    totalSteps?: number\n  ): Promise<void> {\n    const progress = Math.round((currentStep / (totalSteps || 1)) * 100);\n    const progressData: RestoreProgress = {\n      id: progressId,\n      totalSteps: totalSteps || 1,\n      currentStep,\n      progress,\n      message,\n      updatedAt: new Date().toISOString(),\n    };\n\n    await this.trackRestoreProgress(progressId, progressData);\n  }\n\n  /**\n   * Get restoration progress\n   */\n  async getRestoreProgress(progressId: string): Promise<RestoreProgress | null> {\n    try {\n      await this.ensureProgressTable();\n\n      const row = await this.db.queryOne('SELECT * FROM restore_progress WHERE id = ?', [\n        progressId,\n      ]);\n\n      if (!row) return null;\n\n      return {\n        id: row.id,\n        totalSteps: row.total_steps,\n        currentStep: row.current_step,\n        progress: row.progress,\n        message: row.message,\n        updatedAt: row.updated_at,\n      };\n    } catch (error) {\n      logger.error('Failed to get restore progress', { progressId, error });\n      return null;\n    }\n  }\n\n  /**\n   * Clear restoration progress\n   */\n  async clearRestoreProgress(progressId: string): Promise<void> {\n    try {\n      await this.ensureProgressTable();\n      await this.db.execute('DELETE FROM restore_progress WHERE id = ?', [progressId]);\n    } catch (error) {\n      logger.error('Failed to clear restore progress', { progressId, error });\n    }\n  }\n\n  /**\n   * Ensure progress tracking table exists\n   */\n  private async ensureProgressTable(): Promise<void> {\n    await this.db.execute(`\n      CREATE TABLE IF NOT EXISTS restore_progress (\n        id TEXT PRIMARY KEY,\n        total_steps INTEGER NOT NULL,\n        current_step INTEGER NOT NULL,\n        progress INTEGER NOT NULL,\n        message TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      )\n    `);\n  }\n\n  /**\n   * Enhanced restore with progress tracking\n   */\n  async restoreFromBackupWithProgress(\n    backupId: string,\n    options: RestoreOptions = {}\n  ): Promise<string> {\n    const progressId = uuidv4();\n    const totalSteps = 5; // Validation, backup read, clear, apply, verify\n\n    logger.info('Starting restore with progress tracking', { backupId, progressId });\n\n    try {\n      // Step 1: Validate restore options\n      await this.updateRestoreProgress(progressId, 1, 'Validating restore options...', totalSteps);\n      const validation = await this.validateRestoreOptions(backupId, options);\n      if (!validation.isValid) {\n        await this.updateRestoreProgress(progressId, totalSteps, 'Validation failed', totalSteps);\n        throw new BaseServiceError(\n          'VALIDATION_FAILED',\n          `Restore validation failed: ${validation.errors.join(', ')}`\n        );\n      }\n\n      // Step 2: Read backup content\n      await this.updateRestoreProgress(progressId, 2, 'Reading backup content...', totalSteps);\n      const metadata = await this.getBackupMetadata(backupId);\n      if (!metadata) {\n        await this.updateRestoreProgress(progressId, totalSteps, 'Backup not found', totalSteps);\n        throw new BaseServiceError('BACKUP_NOT_FOUND', 'Backup not found');\n      }\n\n      let content: Buffer;\n      if (metadata.compressed) {\n        const compressedData = await fs.readFile(metadata.filePath);\n        content = await gunzipAsync(compressedData);\n      } else {\n        content = await fs.readFile(metadata.filePath);\n      }\n\n      // Step 3: Clear existing data if needed\n      if (!options.preserveExisting) {\n        await this.updateRestoreProgress(progressId, 3, 'Clearing existing data...', totalSteps);\n        await this.clearDatabase();\n      }\n\n      // Step 4: Apply backup content\n      await this.updateRestoreProgress(progressId, 4, 'Applying backup content...', totalSteps);\n      await this.applyBackupContent(metadata, !options.preserveExisting);\n\n      // Step 5: Verify if requested\n      if (options.verify) {\n        await this.updateRestoreProgress(progressId, 5, 'Verifying restore...', totalSteps);\n        const isValid = await this.verifyBackup(backupId);\n        if (!isValid) {\n          await this.updateRestoreProgress(\n            progressId,\n            totalSteps,\n            'Verification failed',\n            totalSteps\n          );\n          throw new BaseServiceError(\n            'VERIFICATION_FAILED',\n            'Backup verification failed after restore'\n          );\n        }\n      }\n\n      await this.updateRestoreProgress(\n        progressId,\n        totalSteps,\n        'Restore completed successfully',\n        totalSteps\n      );\n      logger.info('Restore with progress tracking completed', { backupId, progressId });\n\n      return progressId;\n    } catch (error) {\n      await this.updateRestoreProgress(\n        progressId,\n        totalSteps,\n        `Restore failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        totalSteps\n      );\n      logger.error('Restore with progress tracking failed', { backupId, progressId, error });\n      throw error;\n    }\n  }\n\n  private static deserializeBackupMetadata(row: {\n    id: string;\n    name: string;\n    description?: string;\n    type: string;\n    status: string;\n    size: number;\n    compressed: number;\n    verified: number;\n    checksum: string;\n    file_path: string;\n    created_at: string;\n    completed_at?: string;\n    parent_backup_id?: string;\n    retention_policy?: string;\n    error?: string;\n  }): BackupMetadata {\n    return {\n      id: row.id,\n      name: row.name,\n      description: row.description,\n      type: row.type as 'full' | 'incremental',\n      status: row.status as BackupMetadata['status'],\n      size: row.size,\n      compressed: Boolean(row.compressed),\n      verified: Boolean(row.verified),\n      checksum: row.checksum,\n      filePath: row.file_path,\n      createdAt: row.created_at,\n      completedAt: row.completed_at,\n      parentBackupId: row.parent_backup_id,\n      retentionPolicy: row.retention_policy,\n      error: row.error,\n    };\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/BoardService.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 72,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 74,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Board Service - Core business logic for board management\n *\n * @module services/BoardService\n * @description Provides comprehensive board management functionality including CRUD operations,\n * board statistics, archiving, duplication, and column management. Handles board lifecycle\n * and maintains referential integrity with associated tasks and columns.\n *\n * @example\n * ```typescript\n * import { BoardService } from '@/services/BoardService';\n * import { dbConnection } from '@/database/connection';\n *\n * const boardService = new BoardService(dbConnection);\n *\n * // Create a new board with default columns\n * const board = await boardService.createBoard({\n *   name: 'Sprint Planning',\n *   description: 'Q4 feature development',\n *   color: '#2196F3'\n * });\n *\n * // Get board with statistics\n * const stats = await boardService.getBoardWithStats(board.id);\n * logger.log(`Tasks: ${String(String(stats.taskCount))}, Completion: ${String(String(stats.completedTasks))}/${String(String(stats.taskCount))}`);\n * ```\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection, QueryParameters } from '@/database/connection';\nimport type {\n  Board,\n  Column,\n  CreateBoardRequest,\n  UpdateBoardRequest,\n  BoardWithColumns,\n  BoardWithStats,\n  ServiceError,\n  PaginationOptions,\n  FilterOptions,\n} from '@/types';\n\n/**\n * Board Service - Manages kanban board operations and lifecycle\n *\n * @class BoardService\n * @description Provides comprehensive board management including creation, retrieval,\n * updates, archiving, and deletion. Automatically creates default columns (Todo, In Progress, Done)\n * for new boards and maintains referential integrity across related entities.\n *\n * @example\n * ```typescript\n * const boardService = new BoardService(dbConnection);\n *\n * // Create board with automatic column setup\n * const board = await boardService.createBoard({\n *   name: 'Project Alpha',\n *   description: 'Main project board'\n * });\n *\n * // Get comprehensive board data\n * const boardWithColumns = await boardService.getBoardWithColumns(board.id);\n * ```\n */\nexport class BoardService {\n  /**\n   * Initialize BoardService with database connection\n   *\n   * @param {DatabaseConnection} db - Database connection instance\n   */\n  constructor(private readonly db: DatabaseConnection) {\n    // Constructor intentionally empty - dependency injection only\n  }\n\n  /**\n   * Create a new board with default columns\n   *\n   * @param {CreateBoardRequest} data - Board creation data\n   * @param {string} data.name - Board name (required)\n   * @param {string} [data.description] - Board description\n   * @param {string} [data['color'] = '#2196F3'] - Board color in hex format\n   * @returns {Promise<Board>} Created board with generated ID and timestamps\n   * @throws {ServiceError} If board creation fails\n   *\n   * @example\n   * ```typescript\n   * const board = await boardService.createBoard({\n   *   name: 'Development Sprint',\n   *   description: 'Sprint 1 planning board',\n   *   color: '#4CAF50'\n   * });\n   * logger.log(`Created board: ${String(String(board.name))} with ID: ${String(String(board.id))}`);\n   * ```\n   */\n  async createBoard(data: CreateBoardRequest): Promise<Board> {\n    // Validate required fields\n    if (!data.name || data.name.trim().length === 0) {\n      throw BoardService.createError('INVALID_NAME', 'Board name is required and cannot be empty');\n    }\n\n    const id = uuidv4();\n    const now = new Date();\n\n    const board: Board = {\n      id,\n      name: data.name,\n      description: data.description,\n      color: data.color ?? '#2196F3',\n      created_at: now,\n      updated_at: now,\n      archived: false,\n    };\n\n    try {\n      await this.db.transaction(async db => {\n        await db.run(\n          `\n          INSERT INTO boards (id, name, description, color, created_at, updated_at, archived)\n          VALUES (?, ?, ?, ?, ?, ?, ?)\n        `,\n          [\n            board.id,\n            board.name,\n            board.description,\n            board.color,\n            board.created_at,\n            board.updated_at,\n            board.archived,\n          ]\n        );\n\n        const defaultColumns = [\n          { name: 'Todo', position: 0 },\n          { name: 'In Progress', position: 1 },\n          { name: 'Done', position: 2 },\n        ];\n\n        await Promise.all(\n          defaultColumns.map(async col => {\n            const columnId = uuidv4();\n            await db.run(\n              `\n            INSERT INTO columns (id, board_id, name, position, created_at, updated_at)\n            VALUES (?, ?, ?, ?, ?, ?)\n          `,\n              [columnId, board.id, col.name, col.position, now, now]\n            );\n          })\n        );\n      });\n\n      logger.info('Board created successfully', { boardId: board.id, name: board.name });\n      return board;\n    } catch (error) {\n      logger.error('Failed to create board', { error, data });\n      throw BoardService.createError('BOARD_CREATE_FAILED', 'Failed to create board', error);\n    }\n  }\n\n  /**\n   * Get a board by its ID\n   *\n   * @param {string} id - Board ID (UUID)\n   * @returns {Promise<Board | null>} Board object or null if not found\n   * @throws {ServiceError} If database query fails\n   *\n   * @example\n   * ```typescript\n   * const board = await boardService.getBoardById('board-123');\n   * if (board) {\n   *   logger.log(`Found board: ${String(String(board.name))}`);\n   * } else {\n   *   logger.log('Board not found');\n   * }\n   * ```\n   */\n  async getBoardById(id: string): Promise<Board | null> {\n    try {\n      const board = await this.db.queryOne<Board>(\n        `\n        SELECT * FROM boards WHERE id = ? AND archived = FALSE\n      `,\n        [id]\n      );\n\n      if (board) {\n        const boardData = { ...board };\n        boardData.created_at = new Date(boardData.created_at);\n        boardData.updated_at = new Date(boardData.updated_at);\n        Object.assign(board, boardData);\n      }\n\n      return board ?? null;\n    } catch (error) {\n      logger.error('Failed to get board by ID', { error, id });\n      throw BoardService.createError('BOARD_FETCH_FAILED', 'Failed to fetch board', error);\n    }\n  }\n\n  /**\n   * Get a board with its associated columns\n   *\n   * @param {string} id - Board ID (UUID)\n   * @returns {Promise<BoardWithColumns | null>} Board with columns array or null if not found\n   * @throws {ServiceError} If database query fails\n   *\n   * @example\n   * ```typescript\n   * const boardWithColumns = await boardService.getBoardWithColumns('board-123');\n   * if (boardWithColumns) {\n   *   logger.log(`Board has ${String(String(boardWithColumns.columns.length))} columns`);\n   *   boardWithColumns.columns.forEach(col => {\n   *     logger.log(`Column: ${String(String(col.name))} (position: ${String(String(col.position))})`);\n   *   });\n   * }\n   * ```\n   */\n  async getBoardWithColumns(id: string): Promise<BoardWithColumns | null> {\n    try {\n      const board = await this.getBoardById(id);\n      if (!board) return null;\n\n      const columns = await this.db.query<Column>(\n        `\n        SELECT * FROM columns \n        WHERE board_id = ? \n        ORDER BY position ASC\n      `,\n        [id]\n      );\n\n      columns.forEach(col => {\n        const column = { ...col };\n        column.created_at = new Date(column.created_at);\n        column.updated_at = new Date(column.updated_at);\n        Object.assign(col, column);\n      });\n\n      return {\n        ...board,\n        columns,\n      };\n    } catch (error) {\n      logger.error('Failed to get board with columns', { error, id });\n      throw BoardService.createError(\n        'BOARD_FETCH_FAILED',\n        'Failed to fetch board with columns',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get a board with comprehensive statistics\n   *\n   * @param {string} id - Board ID (UUID)\n   * @returns {Promise<BoardWithStats | null>} Board with task statistics or null if not found\n   * @throws {ServiceError} If database query fails\n   *\n   * @example\n   * ```typescript\n   * const stats = await boardService.getBoardWithStats('board-123');\n   * if (stats) {\n   *   logger.log(`Board: ${String(String(stats.name))}`);\n   *   logger.log(`Total tasks: ${String(String(stats.taskCount))}`);\n   *   logger.log(`Completed: ${String(String(stats.completedTasks))}`);\n   *   logger.log(`In progress: ${String(String(stats.inProgressTasks))}`);\n   *   logger.log(`Todo: ${String(String(stats.todoTasks))}`);\n   *   logger.log(`Columns: ${String(String(stats.columnCount))}`);\n   * }\n   * ```\n   */\n  async getBoardWithStats(id: string): Promise<BoardWithStats | null> {\n    try {\n      const board = await this.getBoardById(id);\n      if (!board) return null;\n\n      const [taskStats, columnCount] = await Promise.all([\n        this.db.queryOne<{\n          total: number;\n          completed: number;\n          in_progress: number;\n          todo: number;\n        }>(\n          `\n          SELECT \n            COUNT(*) as total,\n            SUM(CASE WHEN status = 'done' THEN 1 ELSE 0 END) as completed,\n            SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,\n            SUM(CASE WHEN status = 'todo' THEN 1 ELSE 0 END) as todo\n          FROM tasks \n          WHERE board_id = ? AND archived = FALSE\n        `,\n          [id]\n        ),\n        this.db.queryOne<{ count: number }>(\n          `\n          SELECT COUNT(*) as count FROM columns WHERE board_id = ?\n        `,\n          [id]\n        ),\n      ]);\n\n      return {\n        ...board,\n        taskCount: taskStats?.total ?? 0,\n        completedTasks: taskStats?.completed ?? 0,\n        inProgressTasks: taskStats?.in_progress ?? 0,\n        todoTasks: taskStats?.todo ?? 0,\n        columnCount: columnCount?.count ?? 0,\n      };\n    } catch (error) {\n      logger.error('Failed to get board with stats', { error, id });\n      throw BoardService.createError('BOARD_FETCH_FAILED', 'Failed to fetch board stats', error);\n    }\n  }\n\n  /**\n   * Get multiple boards with filtering and pagination\n   *\n   * @param {PaginationOptions & FilterOptions} [options={}] - Query options\n   * @param {number} [options['limit'] = 50] - Maximum number of boards to return\n   * @param {number} [options.offset=0] - Number of boards to skip\n   * @param {string} [options.sortBy='updated_at'] - Field to sort by\n   * @param {'asc'|'desc'} [options.sortOrder='desc'] - Sort direction\n   * @param {boolean} [options.archived=false] - Include archived boards\n   * @param {string} [options.search] - Search term for name/description\n   * @returns {Promise<Board[]>} Array of boards matching criteria\n   * @throws {ServiceError} If database query fails\n   *\n   * @example\n   * ```typescript\n   * // Get recent active boards\n   * const boards = await boardService.getBoards({\n   *   limit: 10,\n   *   sortBy: 'updated_at',\n   *   sortOrder: 'desc'\n   * });\n   *\n   * // Search boards\n   * const searchResults = await boardService.getBoards({\n   *   search: 'development',\n   *   limit: 5\n   * });\n   * ```\n   */\n  async getBoards(options: PaginationOptions & FilterOptions = {}): Promise<Board[]> {\n    const {\n      limit = 50,\n      offset = 0,\n      sortBy = 'updated_at',\n      sortOrder = 'desc',\n      archived = false,\n      search,\n    } = options;\n\n    try {\n      let query = 'SELECT * FROM boards WHERE archived = ?';\n      const params: QueryParameters = [archived];\n\n      if (search) {\n        query += ' AND (name LIKE ? OR description LIKE ?)';\n        params.push(`%${String(search)}%`, `%${String(search)}%`);\n      }\n\n      query += ` ORDER BY ${String(sortBy)} ${String(String(sortOrder.toUpperCase()))} LIMIT ? OFFSET ?`;\n      params.push(limit, offset);\n\n      const boards = await this.db.query<Board>(query, params);\n\n      boards.forEach(board => {\n        const boardData = { ...board };\n        boardData.created_at = new Date(boardData.created_at);\n        boardData.updated_at = new Date(boardData.updated_at);\n        Object.assign(board, boardData);\n      });\n\n      return boards;\n    } catch (error) {\n      logger.error('Failed to get boards', { error, options });\n      throw BoardService.createError('BOARDS_FETCH_FAILED', 'Failed to fetch boards', error);\n    }\n  }\n\n  /**\n   * Update an existing board\n   *\n   * @param {string} id - Board ID (UUID)\n   * @param {UpdateBoardRequest} data - Update data\n   * @param {string} [data.name] - New board name\n   * @param {string} [data.description] - New board description\n   * @param {string} [data.color] - New board color\n   * @param {boolean} [data.archived] - Archive status\n   * @returns {Promise<Board>} Updated board\n   * @throws {ServiceError} If board not found or update fails\n   *\n   * @example\n   * ```typescript\n   * const updatedBoard = await boardService.updateBoard('board-123', {\n   *   name: 'Updated Sprint Board',\n   *   description: 'Updated description',\n   *   color: '#FF5722'\n   * });\n   * logger.log(`Updated board: ${String(String(updatedBoard.name))}`);\n   * ```\n   */\n  async updateBoard(id: string, data: UpdateBoardRequest): Promise<Board> {\n    try {\n      const existingBoard = await this.getBoardById(id);\n      if (!existingBoard) {\n        throw BoardService.createError('BOARD_NOT_FOUND', 'Board not found', { id });\n      }\n\n      const updates: string[] = [];\n      const params: QueryParameters = [];\n\n      if (data.name !== undefined) {\n        updates.push('name = ?');\n        params.push(data.name);\n      }\n      if (data.description !== undefined) {\n        updates.push('description = ?');\n        params.push(data.description);\n      }\n      if (data.color !== undefined) {\n        updates.push('color = ?');\n        params.push(data.color);\n      }\n      if (data.archived !== undefined) {\n        updates.push('archived = ?');\n        params.push(data.archived);\n      }\n\n      if (updates.length === 0) {\n        return existingBoard;\n      }\n\n      updates.push('updated_at = ?');\n      params.push(new Date());\n\n      params.push(id);\n\n      await this.db.execute(\n        `\n        UPDATE boards \n        SET ${String(String(updates.join(', ')))}\n        WHERE id = ?\n      `,\n        params\n      );\n\n      const updatedBoard = await this.getBoardById(id);\n      if (!updatedBoard) {\n        throw BoardService.createError('BOARD_UPDATE_FAILED', 'Board disappeared after update');\n      }\n\n      logger.info('Board updated successfully', { boardId: id });\n      return updatedBoard;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('BOARD_')) {\n        throw error;\n      }\n      logger.error('Failed to update board', { error, id, data });\n      throw BoardService.createError('BOARD_UPDATE_FAILED', 'Failed to update board', error);\n    }\n  }\n\n  /**\n   * Permanently delete a board and all associated data\n   *\n   * @param {string} id - Board ID (UUID)\n   * @returns {Promise<void>}\n   * @throws {ServiceError} If board not found or deletion fails\n   *\n   * @example\n   * ```typescript\n   * // WARNING: This permanently deletes the board and all its data\n   * await boardService.deleteBoard('board-123');\n   * logger.log('Board and all associated data deleted');\n   * ```\n   */\n  async deleteBoard(id: string): Promise<void> {\n    try {\n      const board = await this.getBoardById(id);\n      if (!board) {\n        throw BoardService.createError('BOARD_NOT_FOUND', 'Board not found', { id });\n      }\n\n      await this.db.transaction(async db => {\n        await db.run(\n          'DELETE FROM task_dependencies WHERE task_id IN (SELECT id FROM tasks WHERE board_id = ?)',\n          [id]\n        );\n        await db.run(\n          'DELETE FROM notes WHERE task_id IN (SELECT id FROM tasks WHERE board_id = ?)',\n          [id]\n        );\n        await db.run(\n          'DELETE FROM task_tags WHERE task_id IN (SELECT id FROM tasks WHERE board_id = ?)',\n          [id]\n        );\n        await db.run('DELETE FROM tasks WHERE board_id = ?', [id]);\n        await db.run('DELETE FROM columns WHERE board_id = ?', [id]);\n        await db.run('DELETE FROM boards WHERE id = ?', [id]);\n      });\n\n      logger.info('Board deleted successfully', { boardId: id });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('BOARD_')) {\n        throw error;\n      }\n      logger.error('Failed to delete board', { error, id });\n      throw BoardService.createError('BOARD_DELETE_FAILED', 'Failed to delete board', error);\n    }\n  }\n\n  /**\n   * Archive a board (soft delete)\n   *\n   * @param {string} id - Board ID (UUID)\n   * @returns {Promise<Board>} Archived board\n   * @throws {ServiceError} If board not found or archiving fails\n   *\n   * @example\n   * ```typescript\n   * const archivedBoard = await boardService.archiveBoard('board-123');\n   * logger.log(`Archived board: ${String(String(archivedBoard.name))}`);\n   * ```\n   */\n  async archiveBoard(id: string): Promise<Board> {\n    return this.updateBoard(id, { archived: true });\n  }\n\n  /**\n   * Unarchive a board (restore from soft delete)\n   *\n   * @param {string} id - Board ID (UUID)\n   * @returns {Promise<Board>} Unarchived board\n   * @throws {ServiceError} If board not found or unarchiving fails\n   *\n   * @example\n   * ```typescript\n   * const restoredBoard = await boardService.unarchiveBoard('board-123');\n   * logger.log(`Restored board: ${String(String(restoredBoard.name))}`);\n   * ```\n   */\n  async unarchiveBoard(id: string): Promise<Board> {\n    return this.updateBoard(id, { archived: false });\n  }\n\n  /**\n   * Create a duplicate of an existing board with its columns\n   *\n   * @param {string} id - Source board ID (UUID)\n   * @param {string} [newName] - Name for the duplicated board (defaults to \"Original Name (Copy)\")\n   * @returns {Promise<Board>} Newly created duplicate board\n   * @throws {ServiceError} If source board not found or duplication fails\n   *\n   * @example\n   * ```typescript\n   * // Duplicate with auto-generated name\n   * const duplicate = await boardService.duplicateBoard('board-123');\n   * logger.log(`Created duplicate: ${String(String(duplicate.name))}`);\n   *\n   * // Duplicate with custom name\n   * const namedDuplicate = await boardService.duplicateBoard('board-123', 'Sprint 2 Board');\n   * ```\n   */\n  async duplicateBoard(id: string, newName?: string): Promise<Board> {\n    try {\n      const originalBoard = await this.getBoardWithColumns(id);\n      if (!originalBoard) {\n        throw BoardService.createError('BOARD_NOT_FOUND', 'Board not found', { id });\n      }\n\n      const duplicatedBoard = await this.createBoard({\n        name: newName ?? `${String(String(originalBoard.name))} (Copy)`,\n        description: originalBoard.description,\n        color: originalBoard.color,\n      });\n\n      await this.db.transaction(async db => {\n        await db.run('DELETE FROM columns WHERE board_id = ?', [duplicatedBoard.id]);\n\n        await Promise.all(\n          originalBoard.columns.map(async column => {\n            const newColumnId = uuidv4();\n            await db.run(\n              `\n              INSERT INTO columns (id, board_id, name, position, wip_limit, created_at, updated_at)\n              VALUES (?, ?, ?, ?, ?, ?, ?)\n            `,\n              [\n                newColumnId,\n                duplicatedBoard.id,\n                column.name,\n                column.position,\n                column.wip_limit,\n                new Date(),\n                new Date(),\n              ]\n            );\n          })\n        );\n      });\n\n      logger.info('Board duplicated successfully', { originalId: id, newId: duplicatedBoard.id });\n      return duplicatedBoard;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('BOARD_')) {\n        throw error;\n      }\n      logger.error('Failed to duplicate board', { error, id });\n      throw BoardService.createError('BOARD_DUPLICATE_FAILED', 'Failed to duplicate board', error);\n    }\n  }\n\n  /**\n   * Create a standardized service error\n   *\n   * @private\n   * @param {string} code - Error code for categorization\n   * @param {string} message - Human-readable error message\n   * @param {any} [originalError] - Original error object for debugging\n   * @returns {ServiceError} Formatted service error with status code\n   */\n  private static createError(code: string, message: string, originalError?: unknown): ServiceError {\n    const error = new Error(message) as ServiceError;\n    error.code = code;\n    error.statusCode = BoardService.getStatusCodeForError(code);\n    error.details = originalError as ServiceError['details'];\n    return error;\n  }\n\n  /**\n   * Map error codes to appropriate HTTP status codes\n   *\n   * @private\n   * @param {string} code - Error code\n   * @returns {number} HTTP status code\n   */\n  private static getStatusCodeForError(code: string): number {\n    switch (code) {\n      case 'BOARD_NOT_FOUND':\n        return 404;\n      case 'INVALID_NAME':\n        return 400;\n      case 'BOARD_CREATE_FAILED':\n      case 'BOARD_UPDATE_FAILED':\n      case 'BOARD_DELETE_FAILED':\n      case 'BOARD_DUPLICATE_FAILED':\n        return 500;\n      case 'BOARD_FETCH_FAILED':\n      case 'BOARDS_FETCH_FAILED':\n        return 500;\n      default:\n        return 500;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/ContextService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'QueryParameters' is defined but never used.",
        "line": 34,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 34,
        "endColumn": 50
      },
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 233,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 239,
        "endColumn": 7
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 239,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 239,
        "endColumn": 7
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'include_metrics' is not in camel case.",
        "line": 287,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 287,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async method 'detectCircularRisks' has no 'await' expression.",
        "line": 1060,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 1060,
        "endColumn": 36
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class async method 'detectCircularRisks'.",
        "line": 1060,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 1060,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Context Service - Intelligent context generation for project and task analysis\n *\n * @module services/ContextService\n * @description Provides comprehensive context generation for AI-powered project management.\n * Analyzes project data to generate intelligent summaries, priority insights, blocker detection,\n * and actionable recommendations. Supports multiple context levels and customizable analysis depth.\n *\n * @example\n * ```typescript\n * import { ContextService } from '@/services/ContextService';\n * import { dbConnection } from '@/database/connection';\n *\n * const contextService = new ContextService(db, boardService, taskService, noteService, tagService);\n *\n * // Get comprehensive project overview\n * const projectContext = await contextService.getProjectContext({\n *   days_back: 30,\n *   detail_level: 'comprehensive'\n * });\n *\n * // Get focused task analysis\n * const taskContext = await contextService.getTaskContext('task-123', {\n *   detail_level: 'detailed'\n * });\n *\n * // Get current work recommendations\n * const workContext = await contextService.getCurrentWorkContext();\n * logger.log('Next actions:', workContext.next_actions);\n * ```\n */\n\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection, QueryParameters } from '@/database/connection';\nimport type { Task, Note, Tag, Board, ServiceError } from '@/types';\nimport type { BoardService } from './BoardService';\nimport type { TaskService } from './TaskService';\nimport type { NoteService } from './NoteService';\nimport type { TagService } from './TagService';\n\n/**\n * Comprehensive project context with analytics and insights\n *\n * @interface ProjectContext\n * @description Contains project-wide analysis including board status, recent activities,\n * priority analysis, blocker detection, and key performance metrics\n */\nexport interface ProjectContext {\n  summary: string;\n  boards: BoardContextInfo[];\n  recent_activities: ActivityItem[];\n  priorities: PriorityInfo[];\n  blockers: BlockerInfo[];\n  overdue_tasks: Task[];\n  key_metrics: ProjectMetrics;\n  generated_at: Date;\n}\n\n/**\n * Detailed task context with relationships and analysis\n *\n * @interface TaskContext\n * @description Contains comprehensive task analysis including related tasks,\n * dependencies, notes, tags, history, and AI-generated recommendations\n */\nexport interface TaskContext {\n  task: Task;\n  board: Board;\n  related_tasks: RelatedTaskInfo[];\n  dependencies: DependencyInfo;\n  notes: Note[];\n  tags: Tag[];\n  history: ActivityItem[];\n  context_summary: string;\n  recommendations: string[];\n  generated_at: Date;\n}\n\n/**\n * Board information with contextual metrics\n *\n * @interface BoardContextInfo\n * @description Board data enriched with task counts, completion rates,\n * recent activity metrics, and calculated priority scores\n */\nexport interface BoardContextInfo {\n  board: Board;\n  task_count: number;\n  completion_rate: number;\n  recent_activity: number;\n  priority_score: number;\n}\n\n/**\n * Project activity item for timeline tracking\n *\n * @interface ActivityItem\n * @description Represents a significant project event with type classification,\n * entity references, and descriptive information for activity feeds\n */\nexport interface ActivityItem {\n  type: 'task_created' | 'task_updated' | 'task_completed' | 'note_added' | 'dependency_added';\n  entity_id: string;\n  entity_title: string;\n  board_name: string;\n  timestamp: Date;\n  description: string;\n}\n\n/**\n * Task priority analysis with scoring and reasoning\n *\n * @interface PriorityInfo\n * @description Comprehensive priority assessment including calculated scores,\n * reasoning explanations, blocking impact, and urgency classification\n */\nexport interface PriorityInfo {\n  task: Task;\n  score: number;\n  reasoning: string[];\n  blocking_count: number;\n  urgency_level: 'low' | 'medium' | 'high' | 'critical';\n}\n\n/**\n * Task blocker analysis with impact assessment\n *\n * @interface BlockerInfo\n * @description Information about task dependencies that are causing blocks,\n * including duration metrics and impact level classification\n */\nexport interface BlockerInfo {\n  blocked_task: Task;\n  blocking_task: Task;\n  days_blocked: number;\n  impact_level: 'low' | 'medium' | 'high';\n}\n\n/**\n * Related task information with relationship classification\n *\n * @interface RelatedTaskInfo\n * @description Task relationships with type classification and relevance scoring\n * for contextual task analysis and recommendations\n */\nexport interface RelatedTaskInfo {\n  task: Task;\n  relationship: 'parent' | 'child' | 'dependency' | 'similar';\n  relevance_score: number;\n}\n\n/**\n * Task dependency analysis and risk assessment\n *\n * @interface DependencyInfo\n * @description Comprehensive dependency mapping including upstream/downstream tasks,\n * circular dependency risks, and critical path analysis\n */\nexport interface DependencyInfo {\n  depends_on: Task[];\n  blocks: Task[];\n  circular_risks: string[];\n  critical_path: boolean;\n}\n\n/**\n * Comprehensive project performance metrics\n *\n * @interface ProjectMetrics\n * @description Key performance indicators including task counts, completion rates,\n * velocity trends, and predictive analytics for project health assessment\n */\nexport interface ProjectMetrics {\n  total_tasks: number;\n  completed_tasks: number;\n  completion_rate: number;\n  average_task_age_days: number;\n  overdue_count: number;\n  blocked_count: number;\n  velocity_trend: 'increasing' | 'decreasing' | 'stable';\n  estimated_completion_date?: Date;\n}\n\n/**\n * Configuration options for context generation\n *\n * @interface ContextOptions\n * @description Customizable options for controlling context generation scope,\n * depth, and inclusion criteria for different analysis needs\n */\nexport interface ContextOptions {\n  include_completed?: boolean;\n  days_back?: number;\n  max_items?: number;\n  include_metrics?: boolean;\n  detail_level?: 'summary' | 'detailed' | 'comprehensive';\n}\n\n/**\n * Context Service - AI-powered project analysis and insight generation\n *\n * @class ContextService\n * @description Provides intelligent context generation for project management workflows.\n * Analyzes project data to generate summaries, identify priorities, detect blockers,\n * and provide actionable recommendations. Integrates with all service layers to provide\n * comprehensive project insights for AI-powered task management.\n *\n * @example\n * ```typescript\n * const contextService = new ContextService(db, boardService, taskService, noteService, tagService);\n *\n * // Generate project overview\n * const context = await contextService.getProjectContext({\n *   days_back: 14,\n *   detail_level: 'comprehensive'\n * });\n *\n * logger.log(context.summary);\n * logger.log(`Priority tasks: ${String(String(context.priorities.length))}`);\n * logger.log(`Active blockers: ${String(String(context.blockers.length))}`);\n * ```\n */\nexport class ContextService {\n  /**\n   * Initialize ContextService with all required service dependencies\n   *\n   * @param {DatabaseConnection} db - Database connection instance\n   * @param {BoardService} boardService - Board management service\n   * @param {TaskService} taskService - Task management service\n   * @param {NoteService} noteService - Note management service\n   * @param {TagService} tagService - Tag management service\n   */\n  constructor(\n    private readonly db: DatabaseConnection,\n    private readonly boardService: BoardService,\n    private readonly taskService: TaskService,\n    private readonly noteService: NoteService,\n    private readonly tagService: TagService\n  ) {}\n\n  /**\n   * Generate comprehensive project context with analytics and insights\n   *\n   * @param {ContextOptions} [options={}] - Context generation options\n   * @param {boolean} [options['include_completed'] = false] - Include completed tasks in analysis\n   * @param {number} [options.days_back=30] - Number of days to look back for activities\n   * @param {number} [options.max_items=50] - Maximum items to include in each category\n   * @param {boolean} [options.include_metrics=true] - Include performance metrics\n   * @param {'summary'|'detailed'|'comprehensive'} [options.detail_level='detailed'] - Analysis depth\n   * @returns {Promise<ProjectContext>} Comprehensive project analysis\n   * @throws {ServiceError} If context generation fails\n   *\n   * @example\n   * ```typescript\n   * // Get detailed project overview\n   * const context = await contextService.getProjectContext({\n   *   days_back: 14,\n   *   detail_level: 'comprehensive',\n   *   max_items: 25\n   * });\n   *\n   * logger.log(`Project Summary: ${String(String(context.summary))}`);\n   * logger.log(`Active Boards: ${String(String(context.boards.length))}`);\n   * logger.log(`High Priority Tasks: ${String(String(context.priorities.filter(p => p['urgency_level'] = == 'high').length))}`);\n   * logger.log(`Critical Blockers: ${String(String(context.blockers.filter(b => b['impact_level'] = == 'high').length))}`);\n   * ```\n   */\n  async getProjectContext(options: ContextOptions = {}): Promise<ProjectContext> {\n    const {\n      include_completed = false,\n      days_back = 30,\n      max_items = 50,\n      include_metrics = true,\n      detail_level = 'detailed',\n    } = options;\n\n    try {\n      logger.info('Generating project context', { options });\n\n      const [boards, recentActivities, priorities, blockers, overdueTasks, metrics] =\n        await Promise.all([\n          this.getBoardsContext(include_completed),\n          this.getRecentActivities(days_back, max_items),\n          this.getPriorityAnalysis(max_items),\n          this.getBlockerAnalysis(),\n          this.taskService.getOverdueTasks(),\n          include_metrics\n            ? this.calculateProjectMetrics()\n            : Promise.resolve(ContextService.getEmptyMetrics()),\n        ]);\n\n      const summary = ContextService.generateProjectSummary(\n        boards,\n        priorities,\n        blockers,\n        metrics,\n        detail_level\n      );\n\n      const context: ProjectContext = {\n        summary,\n        boards,\n        recent_activities: recentActivities,\n        priorities: priorities.slice(0, max_items),\n        blockers,\n        overdue_tasks: overdueTasks.slice(0, max_items),\n        key_metrics: metrics,\n        generated_at: new Date(),\n      };\n\n      logger.info('Project context generated successfully', {\n        boardCount: boards.length,\n        activitiesCount: recentActivities.length,\n        prioritiesCount: priorities.length,\n        blockersCount: blockers.length,\n      });\n\n      return context;\n    } catch (error) {\n      logger.error('Failed to generate project context', { error });\n      throw ContextService.createError(\n        'CONTEXT_GENERATION_FAILED',\n        'Failed to generate project context',\n        error\n      );\n    }\n  }\n\n  /**\n   * Generate detailed context analysis for a specific task\n   *\n   * @param {string} taskId - Task ID (UUID) to analyze\n   * @param {ContextOptions} [options={}] - Context generation options\n   * @param {number} [options['days_back'] = 14] - Days to look back for task history\n   * @param {number} [options.max_items=20] - Maximum related items to include\n   * @param {'summary'|'detailed'|'comprehensive'} [options.detail_level='comprehensive'] - Analysis depth\n   * @returns {Promise<TaskContext>} Detailed task analysis with recommendations\n   * @throws {ServiceError} If task not found or context generation fails\n   *\n   * @example\n   * ```typescript\n   * const taskContext = await contextService.getTaskContext('task-123', {\n   *   detail_level: 'comprehensive',\n   *   days_back: 7\n   * });\n   *\n   * logger.log(`Task: ${String(String(taskContext.task.title))}`);\n   * logger.log(`Board: ${String(String(taskContext.board.name))}`);\n   * logger.log(`Related Tasks: ${String(String(taskContext.related_tasks.length))}`);\n   * logger.log(`Dependencies: ${String(String(taskContext.dependencies.depends_on.length))}`);\n   * logger.log(`Blocks: ${String(String(taskContext.dependencies.blocks.length))}`);\n   * logger.log(`Notes: ${String(String(taskContext.notes.length))}`);\n   * logger.log(`Recommendations: ${String(String(taskContext.recommendations.join(', ')))}`);\n   * ```\n   */\n  async getTaskContext(taskId: string, options: ContextOptions = {}): Promise<TaskContext> {\n    const { days_back = 14, max_items = 20, detail_level = 'comprehensive' } = options;\n\n    try {\n      logger.info('Generating task context', { taskId, options });\n\n      const task = await this.taskService.getTaskById(taskId);\n      if (!task) {\n        throw ContextService.createError('TASK_NOT_FOUND', 'Task not found', { taskId });\n      }\n\n      const [board, relatedTasks, dependencies, notes, tags, history] = await Promise.all([\n        this.boardService.getBoardById(task.board_id),\n        this.getRelatedTasks(taskId, max_items),\n        this.getDependencyContext(taskId),\n        this.noteService.getTaskNotes(taskId),\n        this.tagService.getTaskTags(taskId),\n        this.getTaskHistory(taskId, days_back),\n      ]);\n\n      if (!board) {\n        throw ContextService.createError('BOARD_NOT_FOUND', 'Task board not found');\n      }\n\n      const contextSummary = ContextService.generateTaskContextSummary(\n        task,\n        relatedTasks,\n        dependencies,\n        notes,\n        detail_level\n      );\n      const recommendations = ContextService.generateTaskRecommendations(\n        task,\n        dependencies,\n        notes,\n        tags\n      );\n\n      const context: TaskContext = {\n        task,\n        board,\n        related_tasks: relatedTasks,\n        dependencies,\n        notes,\n        tags,\n        history,\n        context_summary: contextSummary,\n        recommendations,\n        generated_at: new Date(),\n      };\n\n      logger.info('Task context generated successfully', { taskId });\n      return context;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('_NOT_FOUND')) {\n        throw error;\n      }\n      logger.error('Failed to generate task context', { error, taskId });\n      throw ContextService.createError(\n        'TASK_CONTEXT_FAILED',\n        'Failed to generate task context',\n        error\n      );\n    }\n  }\n\n  /**\n   * Get current work context with actionable recommendations\n   *\n   * @param {ContextOptions} [options={}] - Context generation options\n   * @param {number} [options['max_items'] = 10] - Maximum items per category\n   * @returns {Promise<Object>} Current work context with recommendations\n   * @returns {Task[]} returns.active_tasks - Currently in-progress tasks\n   * @returns {PriorityInfo[]} returns.next_actions - Top priority tasks ready to start\n   * @returns {BlockerInfo[]} returns.blockers - Active blockers requiring attention\n   * @returns {string[]} returns.focus_recommendations - AI-generated focus suggestions\n   * @returns {number} returns.estimated_work_hours - Estimated remaining work hours\n   * @throws {ServiceError} If work context generation fails\n   *\n   * @example\n   * ```typescript\n   * const workContext = await contextService.getCurrentWorkContext({\n   *   max_items: 5\n   * });\n   *\n   * logger.log(`Active Tasks: ${String(String(workContext.active_tasks.length))}`);\n   * logger.log(`Next Actions: ${String(String(workContext.next_actions.length))}`);\n   * logger.log(`Blockers: ${String(String(workContext.blockers.length))}`);\n   * logger.log(`Estimated Hours: ${String(String(workContext.estimated_work_hours))}`);\n   *\n   * workContext.focus_recommendations.forEach(rec => {\n   *   logger.log(`Recommendation: ${String(rec)}`);\n   * });\n   * ```\n   */\n  async getCurrentWorkContext(options: ContextOptions = {}): Promise<{\n    active_tasks: Task[];\n    next_actions: PriorityInfo[];\n    blockers: BlockerInfo[];\n    focus_recommendations: string[];\n    estimated_work_hours: number;\n  }> {\n    try {\n      const activeTasks = await this.taskService.getTasks({\n        status: 'in_progress',\n        limit: options.max_items ?? 10,\n        sortBy: 'priority',\n        sortOrder: 'desc',\n      });\n\n      const [nextActions, blockers] = await Promise.all([\n        this.getPriorityAnalysis(10),\n        this.getBlockerAnalysis(),\n      ]);\n\n      const focusRecommendations = ContextService.generateFocusRecommendations(\n        activeTasks,\n        nextActions,\n        blockers\n      );\n      const estimatedHours = ContextService.calculateEstimatedWorkHours(activeTasks);\n\n      return {\n        active_tasks: activeTasks,\n        next_actions: nextActions.slice(0, 5),\n        blockers: blockers.filter(b => b.impact_level !== 'low'),\n        focus_recommendations: focusRecommendations,\n        estimated_work_hours: estimatedHours,\n      };\n    } catch (error) {\n      logger.error('Failed to get current work context', { error });\n      throw ContextService.createError(\n        'WORK_CONTEXT_FAILED',\n        'Failed to generate work context',\n        error\n      );\n    }\n  }\n\n  private async getBoardsContext(_includeCompleted: boolean): Promise<BoardContextInfo[]> {\n    const boards = await this.boardService.getBoards({ archived: false });\n    const boardContexts: BoardContextInfo[] = [];\n\n    await Promise.all(\n      boards.map(async board => {\n        await this.boardService.getBoardWithStats(board.id);\n      })\n    );\n\n    return boardContexts.sort((a, b) => b.priority_score - a.priority_score);\n  }\n\n  private async getRecentActivities(daysBack: number, maxItems: number): Promise<ActivityItem[]> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysBack);\n\n    const activities = await this.db.query<{\n      type: string;\n      entity_id: string;\n      entity_title: string;\n      board_name: string;\n      timestamp: string;\n      description: string;\n    }>(\n      `\n      SELECT \n        'task_created' as type,\n        t.id as entity_id,\n        t.title as entity_title,\n        b.name as board_name,\n        t.created_at as timestamp,\n        'Task created: ' || t.title as description\n      FROM tasks t\n      INNER JOIN boards b ON t['board_id'] = b.id\n      WHERE t.created_at >= ?\n      \n      UNION ALL\n      \n      SELECT \n        'task_completed' as type,\n        t.id as entity_id,\n        t.title as entity_title,\n        b.name as board_name,\n        t.completed_at as timestamp,\n        'Task completed: ' || t.title as description\n      FROM tasks t\n      INNER JOIN boards b ON t.board_id = b.id\n      WHERE t.completed_at >= ? AND t.completed_at IS NOT NULL\n      \n      UNION ALL\n      \n      SELECT \n        'note_added' as type,\n        n.id as entity_id,\n        t.title as entity_title,\n        b.name as board_name,\n        n.created_at as timestamp,\n        'Note added to: ' || t.title as description\n      FROM notes n\n      INNER JOIN tasks t ON n.task_id = t.id\n      INNER JOIN boards b ON t.board_id = b.id\n      WHERE n.created_at >= ?\n      \n      ORDER BY timestamp DESC\n      LIMIT ?\n    `,\n      [cutoffDate, cutoffDate, cutoffDate, maxItems]\n    );\n\n    return activities.map(activity => ({\n      type: activity.type as ActivityItem['type'],\n      entity_id: activity.entity_id,\n      entity_title: activity.entity_title,\n      board_name: activity.board_name,\n      timestamp: new Date(activity.timestamp),\n      description: activity.description,\n    }));\n  }\n\n  private async getPriorityAnalysis(maxItems: number): Promise<PriorityInfo[]> {\n    const tasks = await this.taskService.getTasks({\n      status: 'todo',\n      limit: maxItems * 2, // Get more to analyze and filter\n      sortBy: 'priority',\n      sortOrder: 'desc',\n    });\n\n    const priorityInfos: PriorityInfo[] = [];\n\n    await Promise.all(\n      tasks.map(async task => {\n        await Promise.all([this.getBlockingTaskCount(task.id), this.calculateUrgencyFactors(task)]);\n      })\n    );\n\n    return priorityInfos.sort((a, b) => b.score - a.score).slice(0, maxItems);\n  }\n\n  private async getBlockerAnalysis(): Promise<BlockerInfo[]> {\n    const blockedTasks = await this.taskService.getBlockedTasks();\n    const blockers: BlockerInfo[] = [];\n\n    await Promise.all(\n      blockedTasks.map(async blockedTask => {\n        await this.db.query<{ depends_on_task_id: string }>(\n          `\n          SELECT depends_on_task_id FROM task_dependencies \n          WHERE task_id = ? AND dependency_type = 'blocks'\n        `,\n          [blockedTask.id]\n        );\n      })\n    );\n\n    return blockers.sort((a, b) => b.days_blocked - a.days_blocked);\n  }\n\n  private async getRelatedTasks(taskId: string, maxItems: number): Promise<RelatedTaskInfo[]> {\n    const task = await this.taskService.getTaskById(taskId);\n    if (!task) return [];\n\n    const related: RelatedTaskInfo[] = [];\n\n    // Get parent/child tasks\n    if (task.parent_task_id) {\n      const parentTask = await this.taskService.getTaskById(task.parent_task_id);\n      if (parentTask) {\n        related.push({\n          task: parentTask,\n          relationship: 'parent',\n          relevance_score: 10,\n        });\n      }\n    }\n\n    const subtasks = await this.db.query<Task>(\n      `\n      SELECT * FROM tasks WHERE parent_task_id = ? LIMIT ?\n    `,\n      [taskId, maxItems]\n    );\n\n    subtasks.forEach(subtask => {\n      related.push({\n        task: subtask,\n        relationship: 'child',\n        relevance_score: 9,\n      });\n    });\n\n    // Get dependency tasks\n    const dependencies = await this.db.query<Task>(\n      `\n      SELECT t.* FROM tasks t\n      INNER JOIN task_dependencies td ON t['id'] = td.depends_on_task_id\n      WHERE td.task_id = ?\n      LIMIT ?\n    `,\n      [taskId, maxItems]\n    );\n\n    dependencies.forEach(depTask => {\n      related.push({\n        task: depTask,\n        relationship: 'dependency',\n        relevance_score: 8,\n      });\n    });\n\n    return related.sort((a, b) => b.relevance_score - a.relevance_score).slice(0, maxItems);\n  }\n\n  private async getDependencyContext(taskId: string): Promise<DependencyInfo> {\n    const taskWithDeps = await this.taskService.getTaskWithDependencies(taskId);\n    if (!taskWithDeps) {\n      return {\n        depends_on: [],\n        blocks: [],\n        circular_risks: [],\n        critical_path: false,\n      };\n    }\n\n    const [dependsOnResults, blocksResults] = await Promise.all([\n      Promise.all(\n        taskWithDeps.dependencies.map(dep => this.taskService.getTaskById(dep.depends_on_task_id))\n      ),\n      Promise.all(taskWithDeps.dependents.map(dep => this.taskService.getTaskById(dep.task_id))),\n    ]);\n\n    const dependsOn = dependsOnResults.filter((task): task is Task => task !== null);\n    const blocks = blocksResults.filter((task): task is Task => task !== null);\n\n    const circularRisks = await this.detectCircularRisks(taskId);\n    const criticalPath = await this.isOnCriticalPath(taskId);\n\n    return {\n      depends_on: dependsOn,\n      blocks,\n      circular_risks: circularRisks,\n      critical_path: criticalPath,\n    };\n  }\n\n  private async getTaskHistory(taskId: string, daysBack: number): Promise<ActivityItem[]> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - daysBack);\n\n    return this.getRecentActivities(daysBack, 50).then(activities =>\n      activities.filter(activity => activity.entity_id === taskId)\n    );\n  }\n\n  private static generateProjectSummary(\n    boards: BoardContextInfo[],\n    priorities: PriorityInfo[],\n    blockers: BlockerInfo[],\n    metrics: ProjectMetrics,\n    detailLevel: string\n  ): string {\n    const activeBoardCount = boards.length;\n    const highPriorityCount = priorities.filter(\n      p => p.urgency_level === 'high' || p.urgency_level === 'critical'\n    ).length;\n    const criticalBlockerCount = blockers.filter(b => b.impact_level === 'high').length;\n\n    let summary = `Project Status: ${String(activeBoardCount)} active boards, ${String(String(metrics.completion_rate.toFixed(1)))}% completion rate. `;\n\n    if (highPriorityCount > 0) {\n      summary += `${String(highPriorityCount)} high-priority tasks need attention. `;\n    }\n\n    if (criticalBlockerCount > 0) {\n      summary += `${String(criticalBlockerCount)} critical blockers identified. `;\n    }\n\n    if (metrics.overdue_count > 0) {\n      summary += `${String(String(metrics.overdue_count))} tasks are overdue. `;\n    }\n\n    summary += `Current velocity trend: ${String(String(metrics.velocity_trend))}.`;\n\n    if (detailLevel === 'comprehensive' && metrics.estimated_completion_date) {\n      summary += ` Estimated completion: ${String(String(metrics.estimated_completion_date.toLocaleDateString()))}.`;\n    }\n\n    return summary;\n  }\n\n  private static generateTaskContextSummary(\n    task: Task,\n    _relatedTasks: RelatedTaskInfo[],\n    dependencies: DependencyInfo,\n    notes: Note[],\n    _detailLevel: string\n  ): string {\n    let summary = `Task \"${String(String(task.title))}\" (${String(String(task.status))}, Priority: ${String(String(task.priority))}). `;\n\n    if (dependencies.depends_on.length > 0) {\n      summary += `Depends on ${String(String(dependencies.depends_on.length))} task(s). `;\n    }\n\n    if (dependencies.blocks.length > 0) {\n      summary += `Blocks ${String(String(dependencies.blocks.length))} task(s). `;\n    }\n\n    if (notes.length > 0) {\n      const recentNotes = notes.filter(\n        n => Date.now() - n.created_at.getTime() < 7 * 24 * 60 * 60 * 1000 // 7 days\n      ).length;\n      summary += `${String(String(notes.length))} notes (${String(recentNotes)} recent). `;\n    }\n\n    if (task.due_date && task.due_date < new Date()) {\n      const daysOverdue = Math.floor(\n        (Date.now() - task.due_date.getTime()) / (1000 * 60 * 60 * 24)\n      );\n      summary += `Overdue by ${String(daysOverdue)} days. `;\n    }\n\n    return summary.trim();\n  }\n\n  private static generateTaskRecommendations(\n    task: Task,\n    dependencies: DependencyInfo,\n    notes: Note[],\n    _tags: Tag[]\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (task.status === 'todo' && dependencies.depends_on.some(dep => dep.status !== 'done')) {\n      recommendations.push('Resolve blocking dependencies before starting this task');\n    }\n\n    if (task.due_date && task.due_date < new Date()) {\n      recommendations.push('This task is overdue and should be prioritized');\n    }\n\n    if (dependencies.blocks.length > 3) {\n      recommendations.push('This task blocks multiple others - consider breaking it down');\n    }\n\n    if (notes.length === 0 && task.status === 'in_progress') {\n      recommendations.push('Consider adding progress notes to track development');\n    }\n\n    if (dependencies.circular_risks.length > 0) {\n      recommendations.push('Review dependency structure to prevent circular dependencies');\n    }\n\n    if (\n      task.estimated_hours &&\n      task.actual_hours &&\n      task.actual_hours > task.estimated_hours * 1.5\n    ) {\n      recommendations.push('Task is taking longer than estimated - review scope or approach');\n    }\n\n    return recommendations;\n  }\n\n  private static generateFocusRecommendations(\n    activeTasks: Task[],\n    nextActions: PriorityInfo[],\n    blockers: BlockerInfo[]\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (activeTasks.length > 3) {\n      recommendations.push(\n        'Consider reducing work in progress - focus on completing current tasks'\n      );\n    }\n\n    if (blockers.length > 0) {\n      recommendations.push('Address blocking tasks to improve team velocity');\n    }\n\n    const highPriorityNext = nextActions.filter(\n      a => a.urgency_level === 'high' || a.urgency_level === 'critical'\n    );\n    if (highPriorityNext.length > 0) {\n      recommendations.push(\n        `${String(String(highPriorityNext.length))} high-priority tasks ready to start`\n      );\n    }\n\n    return recommendations;\n  }\n\n  private async calculateProjectMetrics(): Promise<ProjectMetrics> {\n    const [taskStats, overdueCount, blockedCount, avgAge, velocityTrend] = await Promise.all([\n      this.db.queryOne<{ total: number; completed: number }>(`\n        SELECT \n          COUNT(*) as total,\n          SUM(CASE WHEN status = 'done' THEN 1 ELSE 0 END) as completed\n        FROM tasks WHERE archived = FALSE\n      `),\n      this.db.queryOne<{ count: number }>(\n        `\n        SELECT COUNT(*) as count FROM tasks \n        WHERE due_date < ? AND status != 'done' AND archived = FALSE\n      `,\n        [new Date()]\n      ),\n      this.db.queryOne<{ count: number }>(`\n        SELECT COUNT(DISTINCT t.id) as count FROM tasks t\n        INNER JOIN task_dependencies td ON t['id'] = td.task_id\n        INNER JOIN tasks blocking ON td.depends_on_task_id = blocking.id\n        WHERE blocking.status != 'done' AND t.archived = FALSE\n      `),\n      this.db.queryOne<{ avg_days: number }>(`\n        SELECT AVG(julianday('now') - julianday(created_at)) as avg_days\n        FROM tasks WHERE status != 'done' AND archived = FALSE\n      `),\n      this.calculateVelocityTrend(),\n    ]);\n\n    const total = taskStats?.total ?? 0;\n    const completed = taskStats?.completed ?? 0;\n    const completionRate = total > 0 ? (completed / total) * 100 : 0;\n\n    return {\n      total_tasks: total,\n      completed_tasks: completed,\n      completion_rate: completionRate,\n      average_task_age_days: Math.round(avgAge?.avg_days ?? 0),\n      overdue_count: overdueCount?.count ?? 0,\n      blocked_count: blockedCount?.count ?? 0,\n      velocity_trend: velocityTrend,\n    };\n  }\n\n  private async calculateVelocityTrend(): Promise<'increasing' | 'decreasing' | 'stable'> {\n    const thirtyDaysAgo = new Date();\n    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n    const fifteenDaysAgo = new Date();\n    fifteenDaysAgo.setDate(fifteenDaysAgo.getDate() - 15);\n\n    const [recentVelocity, olderVelocity] = await Promise.all([\n      this.db.queryOne<{ count: number }>(\n        `\n        SELECT COUNT(*) as count FROM tasks \n        WHERE completed_at >= ? AND completed_at IS NOT NULL\n      `,\n        [fifteenDaysAgo]\n      ),\n      this.db.queryOne<{ count: number }>(\n        `\n        SELECT COUNT(*) as count FROM tasks \n        WHERE completed_at >= ? AND completed_at < ? AND completed_at IS NOT NULL\n      `,\n        [thirtyDaysAgo, fifteenDaysAgo]\n      ),\n    ]);\n\n    const recent = recentVelocity?.count ?? 0;\n    const older = olderVelocity?.count ?? 0;\n\n    if (recent > older * 1.1) return 'increasing';\n    if (recent < older * 0.9) return 'decreasing';\n    return 'stable';\n  }\n\n  private static getEmptyMetrics(): ProjectMetrics {\n    return {\n      total_tasks: 0,\n      completed_tasks: 0,\n      completion_rate: 0,\n      average_task_age_days: 0,\n      overdue_count: 0,\n      blocked_count: 0,\n      velocity_trend: 'stable',\n    };\n  }\n\n  private async getRecentActivityCount(boardId: string, days: number): Promise<number> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n\n    const result = await this.db.queryOne<{ count: number }>(\n      `\n      SELECT COUNT(*) as count FROM tasks \n      WHERE board_id = ? AND (created_at >= ? OR updated_at >= ?)\n    `,\n      [boardId, cutoffDate, cutoffDate]\n    );\n\n    return result?.count ?? 0;\n  }\n\n  private static calculateBoardPriorityScore(\n    board: BoardContextInfo,\n    recentActivity: number\n  ): number {\n    let score = 0;\n\n    // Task count factor\n    score += Math.min(board.task_count * 2, 20);\n\n    // Completion rate factor (inverse - lower completion means higher priority)\n    score += (100 - board.completion_rate) * 0.3;\n\n    // Recent activity factor\n    score += recentActivity * 5;\n\n    return Math.round(score);\n  }\n\n  private async getBlockingTaskCount(taskId: string): Promise<number> {\n    const result = await this.db.queryOne<{ count: number }>(\n      `\n      SELECT COUNT(*) as count FROM task_dependencies \n      WHERE depends_on_task_id = ?\n    `,\n      [taskId]\n    );\n\n    return result?.count ?? 0;\n  }\n\n  private async calculateUrgencyFactors(task: Task): Promise<{\n    has_due_date: boolean;\n    overdue: boolean;\n    blocks_others: boolean;\n    high_priority: boolean;\n  }> {\n    const now = new Date();\n    const blockingCount = await this.getBlockingTaskCount(task.id);\n\n    return {\n      has_due_date: !!task.due_date,\n      overdue: !!(task.due_date && task.due_date < now),\n      blocks_others: blockingCount > 0,\n      high_priority: task.priority >= 7,\n    };\n  }\n\n  private static calculatePriorityScore(\n    task: Task,\n    blockingCount: number,\n    urgencyFactors: {\n      has_due_date: boolean;\n      overdue: boolean;\n      blocks_others: boolean;\n      high_priority: boolean;\n    }\n  ): number {\n    let score = task.priority * 10; // Base priority\n\n    if (urgencyFactors.overdue) score += 50;\n    if (urgencyFactors.has_due_date) score += 20;\n    if (urgencyFactors.blocks_others) score += blockingCount * 15;\n    if (urgencyFactors.high_priority) score += 25;\n\n    return Math.round(score);\n  }\n\n  private static generatePriorityReasoning(\n    _task: Task,\n    blockingCount: number,\n    urgencyFactors: {\n      has_due_date: boolean;\n      overdue: boolean;\n      blocks_others: boolean;\n      high_priority: boolean;\n    }\n  ): string[] {\n    const reasons: string[] = [];\n\n    if (urgencyFactors.overdue) reasons.push('Task is overdue');\n    if (urgencyFactors.blocks_others) reasons.push(`Blocks ${String(blockingCount)} other task(s)`);\n    if (urgencyFactors.high_priority) reasons.push('High priority level set');\n    if (urgencyFactors.has_due_date) reasons.push('Has due date');\n\n    return reasons;\n  }\n\n  private static determineUrgencyLevel(\n    score: number,\n    urgencyFactors: {\n      has_due_date: boolean;\n      overdue: boolean;\n      blocks_others: boolean;\n      high_priority: boolean;\n    }\n  ): 'low' | 'medium' | 'high' | 'critical' {\n    if (urgencyFactors.overdue ?? score >= 100) return 'critical';\n    if (score >= 70) return 'high';\n    if (score >= 40) return 'medium';\n    return 'low';\n  }\n\n  private static determineBlockerImpact(\n    daysBlocked: number,\n    priority: number\n  ): 'low' | 'medium' | 'high' {\n    if (daysBlocked > 7 || priority >= 8) return 'high';\n    if (daysBlocked > 3 || priority >= 5) return 'medium';\n    return 'low';\n  }\n\n  private async detectCircularRisks(_taskId: string): Promise<string[]> {\n    // Simplified circular dependency detection\n    return []; // Implementation would check for potential circular paths\n  }\n\n  private async isOnCriticalPath(taskId: string): Promise<boolean> {\n    // Simplified critical path detection\n    const blockingCount = await this.getBlockingTaskCount(taskId);\n    return blockingCount > 2; // Simple heuristic\n  }\n\n  private static calculateEstimatedWorkHours(tasks: Task[]): number {\n    return tasks.reduce((total, task) => {\n      const remaining = (task.estimated_hours ?? 0) - (task.actual_hours ?? 0);\n      return total + Math.max(0, remaining);\n    }, 0);\n  }\n\n  /**\n   * Create a standardized service error\n   *\n   * @private\n   * @param {string} code - Error code for categorization\n   * @param {string} message - Human-readable error message\n   * @param {any} [originalError] - Original error object for debugging\n   * @returns {ServiceError} Formatted service error with status code\n   */\n  private static createError(code: string, message: string, originalError?: unknown): ServiceError {\n    const error = new Error(message) as ServiceError;\n    error.code = code;\n    error.statusCode = ContextService.getStatusCodeForError(code);\n    error.details = originalError as ServiceError['details'];\n    return error;\n  }\n\n  /**\n   * Maps error codes to appropriate HTTP status codes\n   *\n   * @private\n   * @param code Error code identifier\n   * @returns HTTP status code\n   */\n  private static getStatusCodeForError(code: string): number {\n    switch (code) {\n      case 'CONTEXT_GENERATION_FAILED':\n      case 'PROJECT_CONTEXT_FAILED':\n      case 'TASK_CONTEXT_FAILED':\n      case 'WORK_CONTEXT_FAILED':\n        return 500;\n      default:\n        return 500;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/ExportService.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 101,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 101,
        "endColumn": 58
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 101,
        "column": 56,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 101,
        "endColumn": 58
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 398,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 398,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [11664, 11670], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 407,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 407,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [11966, 11972], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 436,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 436,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [12874, 12880], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 440,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 440,
        "endColumn": 83,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [12999, 13005], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 446,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 448,
        "endColumn": 6,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [13204, 13210], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "no-return-await",
        "severity": 2,
        "message": "Redundant use of `await` on a return value.",
        "line": 464,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "redundantUseOfAwait",
        "endLine": 464,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "removeAwait",
            "fix": { "range": [13764, 13770], "text": "" },
            "desc": "Remove redundant `await`."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class async method 'writeToFile'.",
        "line": 712,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 712,
        "endColumn": 28
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'anonymizeText'.",
        "line": 731,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 731,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 10,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Export Service - Handles data export and import operations\n *\n * @module services/ExportService\n * @description Provides comprehensive export/import functionality for boards, tasks, tags, and notes.\n * Supports JSON and CSV formats with optional anonymization and filtering capabilities.\n *\n * @example\n * ```typescript\n * import { ExportService } from '@/services/ExportService';\n * import { dbConnection } from '@/database/connection';\n *\n * const exportService = new ExportService(dbConnection);\n *\n * // Export all data to JSON\n * const result = await exportService.exportToJSON({\n *   format: 'json',\n *   includeBoards: true,\n *   includeTasks: true,\n *   includeTags: true,\n *   includeNotes: true\n * });\n * ```\n */\n\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection } from '@/database/connection';\nimport type { Board, Task, Tag, Note, Column } from '@/types';\nimport { BaseServiceError } from '@/utils/errors';\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\nexport interface AnonymizationOptions {\n  anonymizeUserData?: boolean;\n  anonymizeTaskTitles?: boolean;\n  anonymizeDescriptions?: boolean;\n  anonymizeNotes?: boolean;\n  preserveStructure?: boolean;\n  hashSeed?: string;\n}\n\nexport interface ExportOptions {\n  format: 'json' | 'csv';\n  includeBoards?: boolean;\n  includeTasks?: boolean;\n  includeTags?: boolean;\n  includeNotes?: boolean;\n  boardIds?: string[];\n  taskStatuses?: string[];\n  dateFrom?: Date;\n  dateTo?: Date;\n  outputPath?: string;\n  anonymize?: boolean;\n  anonymizationOptions?: AnonymizationOptions;\n}\n\nexport interface ExportResult {\n  format: string;\n  itemCount: number;\n  filePath?: string | undefined;\n  data?: ExportData | undefined;\n}\n\nexport interface ExportData {\n  boards?: Board[];\n  tasks?: Task[];\n  tags?: Tag[];\n  notes?: Note[];\n  columns?: Column[];\n  taskTags?: Array<{ task_id: string; tag_id: string }>;\n  metadata?: {\n    exportDate: string;\n    version: string;\n    totalItems: number;\n  };\n}\n\nexport interface ExportFileFormat {\n  version: string;\n  exportDate?: string;\n  data: ExportData;\n}\n\nexport interface ImportOptions {\n  format: 'json' | 'csv';\n  merge?: boolean;\n  overwrite?: boolean;\n  validateOnly?: boolean;\n  conflictResolution?: 'skip' | 'overwrite' | 'rename';\n}\n\nexport interface ImportResult {\n  imported: number;\n  skipped: number;\n  errors: string[];\n  conflicts: string[];\n}\n\nexport class ExportService {\n  constructor(private readonly db: DatabaseConnection) {}\n\n  /**\n   * Export data to JSON format\n   */\n  async exportToJSON(options: ExportOptions): Promise<ExportResult> {\n    logger.info('Starting JSON export', { options });\n\n    try {\n      const data: ExportFileFormat = {\n        version: '1.0',\n        exportDate: new Date().toISOString(),\n        data: {},\n      };\n\n      let itemCount = 0;\n\n      // Export boards\n      if (options.includeBoards !== false) {\n        let boards = await this.getBoards(options);\n        if (options.anonymize) {\n          boards = this.anonymizeBoards(boards, options.anonymizationOptions);\n        }\n        data.data.boards = boards;\n        itemCount += boards.length;\n      }\n\n      // Export columns for included boards\n      if (options.includeBoards !== false && data.data.boards) {\n        const boardIds = data.data.boards.map(b => b.id);\n        const columns = await this.getColumns(boardIds);\n        data.data.columns = columns;\n        itemCount += columns.length;\n      }\n\n      // Export tasks\n      if (options.includeTasks !== false) {\n        let tasks = await this.getTasks(options);\n        if (options.anonymize) {\n          tasks = this.anonymizeTasks(tasks, options.anonymizationOptions);\n        }\n        data.data.tasks = tasks;\n        itemCount += tasks.length;\n      }\n\n      // Export tags\n      if (options.includeTags !== false) {\n        let tags = await this.getTags(options);\n        if (options.anonymize) {\n          tags = this.anonymizeTags(tags, options.anonymizationOptions);\n        }\n        data.data.tags = tags;\n        itemCount += tags.length;\n      }\n\n      // Export task-tag relationships\n      if (options.includeTasks !== false && options.includeTags !== false) {\n        const taskTags = await this.getTaskTags(options);\n        data.data.taskTags = taskTags;\n        itemCount += taskTags.length;\n      }\n\n      // Export notes\n      if (options.includeNotes !== false) {\n        let notes = await this.getNotes(options);\n        if (options.anonymize) {\n          notes = this.anonymizeNotes(notes, options.anonymizationOptions);\n        }\n        data.data.notes = notes;\n        itemCount += notes.length;\n      }\n\n      // Add metadata\n      data.data.metadata = {\n        exportDate: new Date().toISOString(),\n        version: '1.0',\n        totalItems: itemCount,\n      };\n\n      // Write to file if outputPath is specified\n      let filePath: string | undefined;\n      if (options.outputPath) {\n        filePath = await this.writeToFile(data, options.outputPath, 'json');\n      }\n\n      logger.info('JSON export completed', { itemCount, filePath });\n\n      return {\n        format: 'json',\n        itemCount,\n        filePath,\n        data: data.data,\n      };\n    } catch (error) {\n      logger.error('JSON export failed:', error);\n      throw new BaseServiceError('EXPORT_FAILED', 'Failed to export data to JSON');\n    }\n  }\n\n  /**\n   * Export data to CSV format\n   */\n  async exportToCSV(options: ExportOptions): Promise<ExportResult> {\n    logger.info('Starting CSV export', { options });\n\n    try {\n      let itemCount = 0;\n      const csvData: string[] = [];\n\n      // Export boards\n      if (options.includeBoards !== false) {\n        let boards = await this.getBoards(options);\n        if (options.anonymize) {\n          boards = this.anonymizeBoards(boards, options.anonymizationOptions);\n        }\n        const boardCsv = ExportService.convertArrayToCSV(boards, [\n          'id',\n          'name',\n          'description',\n          'is_active',\n          'created_at',\n          'updated_at',\n        ]);\n        csvData.push(`=== BOARDS ===\\n${boardCsv}`);\n        itemCount += boards.length;\n      }\n\n      // Export tasks\n      if (options.includeTasks !== false) {\n        let tasks = await this.getTasks(options);\n        if (options.anonymize) {\n          tasks = this.anonymizeTasks(tasks, options.anonymizationOptions);\n        }\n        const taskCsv = ExportService.convertArrayToCSV(tasks, [\n          'id',\n          'title',\n          'description',\n          'board_id',\n          'column_id',\n          'position',\n          'priority',\n          'status',\n          'assignee',\n          'due_date',\n          'created_at',\n          'updated_at',\n        ]);\n        csvData.push(`=== TASKS ===\\n${taskCsv}`);\n        itemCount += tasks.length;\n      }\n\n      // Export tags\n      if (options.includeTags !== false) {\n        let tags = await this.getTags(options);\n        if (options.anonymize) {\n          tags = this.anonymizeTags(tags, options.anonymizationOptions);\n        }\n        const tagCsv = ExportService.convertArrayToCSV(tags, [\n          'id',\n          'name',\n          'color',\n          'description',\n          'parent_tag_id',\n          'created_at',\n        ]);\n        csvData.push(`=== TAGS ===\\n${tagCsv}`);\n        itemCount += tags.length;\n      }\n\n      // Export notes\n      if (options.includeNotes !== false) {\n        let notes = await this.getNotes(options);\n        if (options.anonymize) {\n          notes = this.anonymizeNotes(notes, options.anonymizationOptions);\n        }\n        const noteCsv = ExportService.convertArrayToCSV(notes, [\n          'id',\n          'content',\n          'category',\n          'task_id',\n          'pinned',\n          'created_at',\n          'updated_at',\n        ]);\n        csvData.push(`=== NOTES ===\\n${noteCsv}`);\n        itemCount += notes.length;\n      }\n\n      const csvContent = csvData.join('\\n\\n');\n\n      // Write to file if outputPath is specified\n      let filePath: string | undefined;\n      if (options.outputPath) {\n        filePath = await this.writeToFile(csvContent, options.outputPath, 'csv');\n      }\n\n      logger.info('CSV export completed', { itemCount, filePath });\n\n      return {\n        format: 'csv',\n        itemCount,\n        filePath,\n      };\n    } catch (error) {\n      logger.error('CSV export failed:', error);\n      throw new BaseServiceError('EXPORT_FAILED', 'Failed to export data to CSV');\n    }\n  }\n\n  /**\n   * Import data from JSON format\n   */\n  async importFromJSON(\n    data: ExportData | ExportFileFormat,\n    options: ImportOptions\n  ): Promise<ImportResult> {\n    logger.info('Starting JSON import', { options });\n\n    try {\n      const importData = 'data' in data ? data.data : data;\n      const result: ImportResult = { imported: 0, skipped: 0, errors: [], conflicts: [] };\n\n      // Import boards\n      if (importData.boards) {\n        const boardResult = await this.importBoards(importData.boards, options);\n        result.imported += boardResult.imported;\n        result.skipped += boardResult.skipped;\n        result.errors.push(...boardResult.errors);\n        result.conflicts.push(...boardResult.conflicts);\n      }\n\n      // Import columns\n      if (importData.columns) {\n        const columnResult = await this.importColumns(importData.columns, options);\n        result.imported += columnResult.imported;\n        result.skipped += columnResult.skipped;\n        result.errors.push(...columnResult.errors);\n        result.conflicts.push(...columnResult.conflicts);\n      }\n\n      // Import tasks\n      if (importData.tasks) {\n        const taskResult = await this.importTasks(importData.tasks, options);\n        result.imported += taskResult.imported;\n        result.skipped += taskResult.skipped;\n        result.errors.push(...taskResult.errors);\n        result.conflicts.push(...taskResult.conflicts);\n      }\n\n      // Import tags\n      if (importData.tags) {\n        const tagResult = await this.importTags(importData.tags, options);\n        result.imported += tagResult.imported;\n        result.skipped += tagResult.skipped;\n        result.errors.push(...tagResult.errors);\n        result.conflicts.push(...tagResult.conflicts);\n      }\n\n      // Import task-tag relationships\n      if (importData.taskTags) {\n        const taskTagResult = await this.importTaskTags(importData.taskTags, options);\n        result.imported += taskTagResult.imported;\n        result.skipped += taskTagResult.skipped;\n        result.errors.push(...taskTagResult.errors);\n        result.conflicts.push(...taskTagResult.conflicts);\n      }\n\n      // Import notes\n      if (importData.notes) {\n        const noteResult = await this.importNotes(importData.notes, options);\n        result.imported += noteResult.imported;\n        result.skipped += noteResult.skipped;\n        result.errors.push(...noteResult.errors);\n        result.conflicts.push(...noteResult.conflicts);\n      }\n\n      logger.info('JSON import completed', result);\n      return result;\n    } catch (error) {\n      logger.error('JSON import failed:', error);\n      throw new BaseServiceError('IMPORT_FAILED', 'Failed to import data from JSON');\n    }\n  }\n\n  // Private helper methods\n\n  private async getBoards(options: ExportOptions): Promise<Board[]> {\n    let query = 'SELECT * FROM boards WHERE deleted_at IS NULL';\n    const params: unknown[] = [];\n\n    if (options.boardIds && options.boardIds.length > 0) {\n      query += ` AND id IN (${options.boardIds.map(() => '?').join(',')})`;\n      params.push(...options.boardIds);\n    }\n\n    query += ' ORDER BY created_at DESC';\n\n    return await this.db.query<Board>(query, params);\n  }\n\n  private async getColumns(boardIds: string[]): Promise<Column[]> {\n    if (boardIds.length === 0) return [];\n\n    const query = `SELECT * FROM columns WHERE board_id IN (${boardIds\n      .map(() => '?')\n      .join(',')}) ORDER BY position`;\n    return await this.db.query<Column>(query, boardIds);\n  }\n\n  private async getTasks(options: ExportOptions): Promise<Task[]> {\n    let query = 'SELECT * FROM tasks WHERE deleted_at IS NULL';\n    const params: unknown[] = [];\n\n    if (options.boardIds && options.boardIds.length > 0) {\n      query += ` AND board_id IN (${options.boardIds.map(() => '?').join(',')})`;\n      params.push(...options.boardIds);\n    }\n\n    if (options.taskStatuses && options.taskStatuses.length > 0) {\n      query += ` AND status IN (${options.taskStatuses.map(() => '?').join(',')})`;\n      params.push(...options.taskStatuses);\n    }\n\n    if (options.dateFrom) {\n      query += ' AND created_at >= ?';\n      params.push(options.dateFrom.toISOString());\n    }\n\n    if (options.dateTo) {\n      query += ' AND created_at <= ?';\n      params.push(options.dateTo.toISOString());\n    }\n\n    query += ' ORDER BY created_at DESC';\n\n    return await this.db.query<Task>(query, params);\n  }\n\n  private async getTags(_options: ExportOptions): Promise<Tag[]> {\n    return await this.db.query<Tag>('SELECT * FROM tags ORDER BY created_at DESC');\n  }\n\n  private async getTaskTags(\n    _options: ExportOptions\n  ): Promise<Array<{ task_id: string; tag_id: string }>> {\n    return await this.db.query<{ task_id: string; tag_id: string }>(\n      'SELECT task_id, tag_id FROM task_tags'\n    );\n  }\n\n  private async getNotes(options: ExportOptions): Promise<Note[]> {\n    let query = 'SELECT * FROM notes';\n    const params: unknown[] = [];\n\n    if (options.boardIds && options.boardIds.length > 0) {\n      query += ` WHERE task_id IN (SELECT id FROM tasks WHERE board_id IN (${options.boardIds\n        .map(() => '?')\n        .join(',')}))`;\n      params.push(...options.boardIds);\n    }\n\n    query += ' ORDER BY created_at DESC';\n\n    return await this.db.query<Note>(query, params);\n  }\n\n  private static convertArrayToCSV(data: unknown[], columns: string[]): string {\n    if (data.length === 0) return columns.join(',');\n\n    const header = columns.join(',');\n    const rows = data.map(item =>\n      columns\n        .map(col => {\n          const value = (item as Record<string, unknown>)[col];\n          if (value === null || value === undefined) return '';\n          return String(value).includes(',') ? `\"${String(value)}\"` : String(value);\n        })\n        .join(',')\n    );\n\n    return `${header}\\n${rows.join('\\n')}`;\n  }\n\n  private async importBoards(boards: Board[], options: ImportOptions): Promise<ImportResult> {\n    const result: ImportResult = { imported: 0, skipped: 0, errors: [], conflicts: [] };\n\n    for (const board of boards) {\n      try {\n        // Check if board already exists\n        // eslint-disable-next-line no-await-in-loop\n        const existingBoard = await this.db.queryOne<Board>('SELECT * FROM boards WHERE id = ?', [\n          board.id,\n        ]);\n\n        if (existingBoard) {\n          if (options.conflictResolution === 'skip') {\n            result.skipped += 1;\n            continue;\n          } else if (options.conflictResolution === 'rename') {\n            board.name = `${board.name} (imported ${new Date().toISOString()})`;\n          }\n        }\n\n        // eslint-disable-next-line no-await-in-loop\n        await this.db.execute(\n          'INSERT OR REPLACE INTO boards (id, name, description, is_active, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?)',\n          [\n            board.id,\n            board.name,\n            board.description,\n            (board as Board & { is_active?: boolean }).is_active ?? true,\n            board.created_at,\n            board.updated_at,\n          ]\n        );\n        result.imported += 1;\n      } catch (error: unknown) {\n        result.errors.push(\n          `Failed to import board ${board.name}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async importColumns(columns: Column[], _options: ImportOptions): Promise<ImportResult> {\n    const result: ImportResult = { imported: 0, skipped: 0, errors: [], conflicts: [] };\n\n    for (const column of columns) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        await this.db.execute(\n          'INSERT OR REPLACE INTO columns (id, board_id, name, position, wip_limit, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)',\n          [\n            column.id,\n            column.board_id,\n            column.name,\n            column.position,\n            column.wip_limit,\n            column.created_at,\n            column.updated_at,\n          ]\n        );\n        result.imported += 1;\n      } catch (error: unknown) {\n        result.errors.push(\n          `Failed to import column ${column.name}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async importTasks(tasks: Task[], options: ImportOptions): Promise<ImportResult> {\n    const result: ImportResult = { imported: 0, skipped: 0, errors: [], conflicts: [] };\n\n    // Sort tasks to import parents before children\n    const sortedTasks = [...tasks].sort((a, b) => {\n      if (!a.parent_task_id && b.parent_task_id) return -1;\n      if (a.parent_task_id && !b.parent_task_id) return 1;\n      return 0;\n    });\n\n    for (const task of sortedTasks) {\n      try {\n        // Check if task already exists\n        // eslint-disable-next-line no-await-in-loop\n        const existingTask = await this.db.queryOne<Task>('SELECT * FROM tasks WHERE id = ?', [\n          task.id,\n        ]);\n\n        if (existingTask) {\n          if (options.conflictResolution === 'skip') {\n            result.skipped++;\n            continue;\n          }\n        }\n\n        // eslint-disable-next-line no-await-in-loop\n        await this.db.execute(\n          `INSERT OR REPLACE INTO tasks (\n            id, title, description, board_id, column_id, position, priority,\n            status, assignee, due_date, estimated_hours, actual_hours,\n            parent_task_id, metadata, created_at, updated_at\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n          [\n            task.id,\n            task.title,\n            task.description,\n            task.board_id,\n            task.column_id,\n            task.position,\n            task.priority,\n            task.status,\n            task.assignee,\n            task.due_date,\n            task.estimated_hours,\n            task.actual_hours,\n            task.parent_task_id,\n            task.metadata,\n            task.created_at,\n            task.updated_at,\n          ]\n        );\n        result.imported++;\n      } catch (error: unknown) {\n        result.errors.push(\n          `Failed to import task ${task.title}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async importTags(tags: Tag[], options: ImportOptions): Promise<ImportResult> {\n    const result: ImportResult = { imported: 0, skipped: 0, errors: [], conflicts: [] };\n\n    // Sort tags to import parents before children\n    const sortedTags = [...tags].sort((a, b) => {\n      if (!a.parent_tag_id && b.parent_tag_id) return -1;\n      if (a.parent_tag_id && !b.parent_tag_id) return 1;\n      return 0;\n    });\n\n    for (const tag of sortedTags) {\n      try {\n        // Check if tag already exists\n        // eslint-disable-next-line no-await-in-loop\n        const existingTag = await this.db.queryOne<Tag>('SELECT * FROM tags WHERE name = ?', [\n          tag.name,\n        ]);\n\n        if (existingTag) {\n          if (options.conflictResolution === 'skip') {\n            result.skipped++;\n            continue;\n          }\n        }\n\n        // eslint-disable-next-line no-await-in-loop\n        await this.db.execute(\n          'INSERT OR REPLACE INTO tags (id, name, color, description, parent_tag_id, created_at) VALUES (?, ?, ?, ?, ?, ?)',\n          [tag.id, tag.name, tag.color, tag.description, tag.parent_tag_id, tag.created_at]\n        );\n        result.imported++;\n      } catch (error: unknown) {\n        result.errors.push(\n          `Failed to import tag ${tag.name}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async importNotes(notes: Note[], _options: ImportOptions): Promise<ImportResult> {\n    const result: ImportResult = { imported: 0, skipped: 0, errors: [], conflicts: [] };\n\n    for (const note of notes) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        await this.db.execute(\n          'INSERT OR REPLACE INTO notes (id, content, category, task_id, pinned, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)',\n          [\n            note.id,\n            note.content,\n            note.category,\n            note.task_id,\n            note.pinned,\n            note.created_at,\n            note.updated_at,\n          ]\n        );\n        result.imported++;\n      } catch (error: unknown) {\n        result.errors.push(\n          `Failed to import note: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async importTaskTags(\n    taskTags: Array<{ task_id: string; tag_id: string }>,\n    _options: ImportOptions\n  ): Promise<ImportResult> {\n    const result: ImportResult = { imported: 0, skipped: 0, errors: [], conflicts: [] };\n\n    for (const mapping of taskTags) {\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        await this.db.execute(\n          'INSERT OR IGNORE INTO task_tags (task_id, tag_id, created_at) VALUES (?, ?, ?)',\n          [mapping.task_id, mapping.tag_id, new Date().toISOString()]\n        );\n        result.imported++;\n      } catch (error: unknown) {\n        result.errors.push(\n          `Failed to import task-tag mapping: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return result;\n  }\n\n  private async writeToFile(content: unknown, outputPath: string, format: string): Promise<string> {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const filename = `export-${timestamp}.${format}`;\n    const fullPath = path.join(outputPath, filename);\n\n    await fs.mkdir(path.dirname(fullPath), { recursive: true });\n    await fs.writeFile(\n      fullPath,\n      typeof content === 'string' ? content : JSON.stringify(content, null, 2)\n    );\n\n    return fullPath;\n  }\n\n  // Anonymization methods\n\n  /**\n   * Generate deterministic anonymous text based on input\n   */\n  private anonymizeText(text: string, prefix: string, hashSeed?: string): string {\n    const seed = hashSeed ?? 'default-seed';\n    const hash = crypto\n      .createHash('sha256')\n      .update(seed + text)\n      .digest('hex');\n    return `${prefix}_${hash.substring(0, 8)}`;\n  }\n\n  /**\n   * Anonymize board data\n   */\n  private anonymizeBoards(boards: Board[], options?: AnonymizationOptions): Board[] {\n    return boards.map(board => ({\n      ...board,\n      name: options?.preserveStructure\n        ? board.name\n        : this.anonymizeText(board.name, 'Board', options?.hashSeed),\n      description:\n        board.description && options?.anonymizeDescriptions\n          ? this.anonymizeText(board.description, 'BoardDesc', options?.hashSeed)\n          : board.description,\n    }));\n  }\n\n  /**\n   * Anonymize column data\n   */\n  private anonymizeColumns(columns: Column[], options?: AnonymizationOptions): Column[] {\n    return columns.map(column => ({\n      ...column,\n      name: options?.preserveStructure\n        ? column.name\n        : this.anonymizeText(column.name, 'Column', options?.hashSeed),\n    }));\n  }\n\n  /**\n   * Anonymize task data\n   */\n  private anonymizeTasks(tasks: Task[], options?: AnonymizationOptions): Task[] {\n    return tasks.map(task => ({\n      ...task,\n      title: options?.anonymizeTaskTitles\n        ? this.anonymizeText(task.title, 'Task', options?.hashSeed)\n        : task.title,\n      description:\n        task.description && options?.anonymizeDescriptions\n          ? this.anonymizeText(task.description, 'TaskDesc', options?.hashSeed)\n          : task.description,\n      assignee: options?.anonymizeUserData\n        ? this.anonymizeText(task.assignee ?? 'unknown', 'User', options?.hashSeed)\n        : task.assignee,\n    }));\n  }\n\n  /**\n   * Anonymize tag data\n   */\n  private anonymizeTags(tags: Tag[], options?: AnonymizationOptions): Tag[] {\n    return tags.map(tag => ({\n      ...tag,\n      name: options?.preserveStructure\n        ? tag.name\n        : this.anonymizeText(tag.name, 'Tag', options?.hashSeed),\n      description:\n        tag.description && options?.anonymizeDescriptions\n          ? this.anonymizeText(tag.description, 'TagDesc', options?.hashSeed)\n          : tag.description,\n    }));\n  }\n\n  /**\n   * Anonymize note data\n   */\n  private anonymizeNotes(notes: Note[], options?: AnonymizationOptions): Note[] {\n    return notes.map(note => ({\n      ...note,\n      content: options?.anonymizeNotes\n        ? this.anonymizeText(note.content, 'Note', options?.hashSeed)\n        : note.content,\n    }));\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/NoteService.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 126,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 126,
        "endColumn": 58
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 126,
        "column": 56,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 126,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 165,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 165,
        "endColumn": 93
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'pinned_only' is not in camel case.",
        "line": 572,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 572,
        "endColumn": 22
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'result'.",
        "line": 601,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 601,
        "endColumn": 17
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'date_from' is not in camel case.",
        "line": 638,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 638,
        "endColumn": 20
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'date_from' is not in camel case.",
        "line": 639,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 639,
        "endColumn": 14
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'date_from' is not in camel case.",
        "line": 639,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 639,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 825,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 825,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [23360, 23363], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [23360, 23363], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any[]` assigned to a parameter of type `QueryParameters`.",
        "line": 845,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 845,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any[]` assigned to a parameter of type `QueryParameters`.",
        "line": 853,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 853,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any[]` assigned to a parameter of type `QueryParameters`.",
        "line": 860,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 860,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any[]` assigned to a parameter of type `QueryParameters`.",
        "line": 867,
        "column": 11,
        "nodeType": "ArrayExpression",
        "messageId": "unsafeArgument",
        "endLine": 867,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe spread of an `any` value in an array.",
        "line": 867,
        "column": 12,
        "nodeType": "SpreadElement",
        "messageId": "unsafeArraySpread",
        "endLine": 867,
        "endColumn": 21
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'by_category' is not in camel case.",
        "line": 871,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 871,
        "endColumn": 58
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'by_category' is not in camel case.",
        "line": 880,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 880,
        "endColumn": 20
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'note'.",
        "line": 998,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 998,
        "endColumn": 9
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'note'.",
        "line": 999,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 999,
        "endColumn": 9
      }
    ],
    "suppressedMessages": [],
    "errorCount": 12,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Note Service - Core business logic for note management\n *\n * @module services/NoteService\n * @description Provides comprehensive note management functionality including CRUD operations,\n * search capabilities, categorization, pinning, and note statistics. Supports task-associated\n * notes with categories for progress tracking, blockers, decisions, and questions.\n *\n * @example\n * ```typescript\n * import { NoteService } from '@/services/NoteService';\n * import { dbConnection } from '@/database/connection';\n *\n * const noteService = new NoteService(dbConnection);\n *\n * // Create a blocker note\n * const note = await noteService.createNote({\n *   task_id: 'task-123',\n *   content: 'Waiting for API credentials from client',\n *   category: 'blocker',\n *   pinned: true\n * });\n *\n * // Search notes across boards\n * const results = await noteService.searchNotes({\n *   query: 'API',\n *   board_id: 'board-123',\n *   highlight: true\n * });\n * ```\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection, QueryParameters } from '@/database/connection';\nimport type { Note, ServiceError, PaginationOptions, FilterOptions } from '@/types';\n\n/**\n * Request interface for creating new notes\n *\n * @interface CreateNoteRequest\n * @description Defines the structure for note creation requests with required task association\n */\nexport interface CreateNoteRequest {\n  task_id: string;\n  content: string;\n  category?: Note['category'];\n  pinned?: boolean;\n}\n\n/**\n * Request interface for updating existing notes\n *\n * @interface UpdateNoteRequest\n * @description All fields are optional to support partial updates\n */\nexport interface UpdateNoteRequest {\n  content?: string;\n  category?: Note['category'];\n  pinned?: boolean;\n}\n\n/**\n * Advanced filtering options for note queries\n *\n * @interface NoteFilters\n * @extends FilterOptions\n * @description Provides comprehensive filtering capabilities including task/board scope,\n * category filtering, pinned status, content search, and date ranges\n */\nexport interface NoteFilters extends FilterOptions {\n  task_id?: string;\n  category?: Note['category'];\n  pinned?: boolean;\n  content_search?: string;\n  board_id?: string;\n  date_from?: Date;\n  date_to?: Date;\n}\n\n/**\n * Options for note search functionality\n *\n * @interface NoteSearchOptions\n * @extends PaginationOptions\n * @description Defines search parameters including query text, scope filters,\n * and highlighting options\n */\nexport interface NoteSearchOptions extends PaginationOptions {\n  query: string;\n  task_id?: string;\n  board_id?: string;\n  category?: Note['category'];\n  pinned_only?: boolean;\n  highlight?: boolean;\n}\n\n/**\n * Note search result with additional context\n *\n * @interface NoteSearchResult\n * @extends Note\n * @description Includes task/board context and search relevance information\n */\nexport interface NoteSearchResult extends Note {\n  task_title?: string;\n  board_name?: string;\n  relevance_score?: number;\n  highlighted_content?: string;\n}\n\n/**\n * Note Service - Manages all note-related operations\n *\n * @class NoteService\n * @description Core service class providing comprehensive note management functionality.\n * Handles note CRUD operations, search, categorization, and statistics with proper\n * transaction handling and task association validation.\n */\nexport class NoteService {\n  /**\n   * Creates a new NoteService instance\n   *\n   * @param db Database connection instance for note operations\n   */\n  constructor(private readonly db: DatabaseConnection) {}\n\n  /**\n   * Creates a new note associated with a task\n   *\n   * @param data Note creation data including task association and content\n   * @returns Promise resolving to the created note with generated ID and timestamps\n   *\n   * @throws {ServiceError} NOTE_CREATE_FAILED - When note creation fails\n   * @throws {Error} Task not found - When specified task_id doesn't exist\n   *\n   * @example\n   * ```typescript\n   * const note = await noteService.createNote({\n   *   task_id: 'task-123',\n   *   content: 'Implementation completed, ready for review',\n   *   category: 'progress',\n   *   pinned: false\n   * });\n   * ```\n   *\n   * @since 1.0.0\n   */\n  async createNote(data: CreateNoteRequest): Promise<Note> {\n    const id = uuidv4();\n    const now = new Date();\n\n    const note: Note = {\n      id,\n      task_id: data.task_id,\n      content: data.content,\n      category: data.category ?? 'general',\n      pinned: data.pinned ?? false,\n      created_at: now,\n      updated_at: now,\n    };\n\n    try {\n      await this.db.transaction(async db => {\n        const taskExists = await db.get('SELECT id FROM tasks WHERE id = ?', [data.task_id]);\n        if (!taskExists) {\n          throw new Error('Task not found');\n        }\n\n        await db.run(\n          `\n          INSERT INTO notes (id, task_id, content, category, pinned, created_at, updated_at)\n          VALUES (?, ?, ?, ?, ?, ?, ?)\n        `,\n          [\n            note.id,\n            note.task_id,\n            note.content,\n            note.category,\n            note.pinned,\n            note.created_at,\n            note.updated_at,\n          ]\n        );\n      });\n\n      logger.info('Note created successfully', { noteId: note.id, taskId: data.task_id });\n      return note;\n    } catch (error) {\n      logger.error('Failed to create note', { error, data });\n      throw NoteService.createError('NOTE_CREATE_FAILED', 'Failed to create note', error);\n    }\n  }\n\n  /**\n   * Retrieves a single note by its ID\n   *\n   * @param id Unique note identifier\n   * @returns Promise resolving to the note if found, null otherwise\n   *\n   * @throws {ServiceError} NOTE_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const note = await noteService.getNoteById('note-123');\n   * if (note) {\n   *   logger.log(`Note: ${String(String(note.content))}`);\n   * }\n   * ```\n   */\n  async getNoteById(id: string): Promise<Note | null> {\n    try {\n      const note = await this.db.queryOne<Note>(\n        `\n        SELECT * FROM notes WHERE id = ?\n      `,\n        [id]\n      );\n\n      if (note) {\n        NoteService.convertNoteDates(note);\n      }\n\n      return note ?? null;\n    } catch (error) {\n      logger.error('Failed to get note by ID', { error, id });\n      throw NoteService.createError('NOTE_FETCH_FAILED', 'Failed to fetch note', error);\n    }\n  }\n\n  /**\n   * Retrieves notes with advanced filtering, pagination, and sorting\n   *\n   * @param options Comprehensive options for filtering, pagination, and sorting\n   * @returns Promise resolving to array of notes matching the criteria\n   *\n   * @throws {ServiceError} NOTES_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * // Get recent blocker notes for a board\n   * const blockers = await noteService.getNotes({\n   *   board_id: 'board-123',\n   *   category: 'blocker',\n   *   sortBy: 'created_at',\n   *   sortOrder: 'desc',\n   *   limit: 20\n   * });\n   *\n   * // Search notes by content\n   * const searchResults = await noteService.getNotes({\n   *   content_search: 'deployment',\n   *   date_from: new Date('2025-01-01')\n   * });\n   * ```\n   */\n  async getNotes(options: PaginationOptions & NoteFilters = {}): Promise<Note[]> {\n    const {\n      limit = 50,\n      offset = 0,\n      sortBy = 'updated_at',\n      sortOrder = 'desc',\n      task_id: taskId,\n      category,\n      pinned,\n      content_search: contentSearch,\n      board_id: boardId,\n      date_from: dateFrom,\n      date_to: dateTo,\n    } = options;\n\n    try {\n      let query = 'SELECT n.* FROM notes n';\n      const params: QueryParameters = [];\n      const conditions: string[] = [];\n\n      if (boardId) {\n        query += ' INNER JOIN tasks t ON n.task_id = t.id';\n        conditions.push('t.board_id = ?');\n        params.push(boardId);\n      }\n\n      if (taskId) {\n        conditions.push('n.task_id = ?');\n        params.push(taskId);\n      }\n\n      if (category) {\n        conditions.push('n.category = ?');\n        params.push(category);\n      }\n\n      if (pinned !== undefined) {\n        conditions.push('n.pinned = ?');\n        params.push(pinned);\n      }\n\n      if (contentSearch) {\n        conditions.push('n.content LIKE ?');\n        params.push(`%${String(contentSearch)}%`);\n      }\n\n      if (dateFrom) {\n        conditions.push('n.created_at >= ?');\n        params.push(dateFrom);\n      }\n\n      if (dateTo) {\n        conditions.push('n.created_at <= ?');\n        params.push(dateTo);\n      }\n\n      if (conditions.length > 0) {\n        query += ` WHERE ${String(String(conditions.join(' AND ')))}`;\n      }\n\n      query += ` ORDER BY n.${String(sortBy)} ${String(String(sortOrder.toUpperCase()))} LIMIT ? OFFSET ?`;\n      params.push(limit, offset);\n\n      const notes = await this.db.query<Note>(query, params);\n      notes.forEach(note => NoteService.convertNoteDates(note));\n\n      return notes;\n    } catch (error) {\n      logger.error('Failed to get notes', { error, options });\n      throw NoteService.createError('NOTES_FETCH_FAILED', 'Failed to fetch notes', error);\n    }\n  }\n\n  /**\n   * Retrieves all notes for a specific task\n   *\n   * @param taskId ID of the task\n   * @param options Pagination options\n   * @returns Promise resolving to array of task notes\n   *\n   * @throws {ServiceError} NOTES_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * const taskNotes = await noteService.getTaskNotes('task-123', {\n   *   sortBy: 'created_at',\n   *   sortOrder: 'asc'\n   * });\n   * ```\n   */\n  async getTaskNotes(taskId: string, options: PaginationOptions = {}): Promise<Note[]> {\n    return this.getNotes({\n      ...options,\n      task_id: taskId,\n    });\n  }\n\n  /**\n   * Retrieves all pinned notes with optional scope filtering\n   *\n   * @param options Filtering and pagination options\n   * @returns Promise resolving to array of pinned notes\n   *\n   * @throws {ServiceError} NOTES_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * // Get pinned notes for a board\n   * const pinnedNotes = await noteService.getPinnedNotes({\n   *   board_id: 'board-123'\n   * });\n   * ```\n   */\n  async getPinnedNotes(\n    options: PaginationOptions & { task_id?: string; board_id?: string } = {}\n  ): Promise<Note[]> {\n    return this.getNotes({\n      ...options,\n      pinned: true,\n    });\n  }\n\n  /**\n   * Updates an existing note\n   *\n   * @param id Unique note identifier\n   * @param data Partial note data to update (only provided fields will be changed)\n   * @returns Promise resolving to the updated note\n   *\n   * @throws {ServiceError} NOTE_NOT_FOUND - When note doesn't exist\n   * @throws {ServiceError} NOTE_UPDATE_FAILED - When update operation fails\n   *\n   * @example\n   * ```typescript\n   * const updated = await noteService.updateNote('note-123', {\n   *   content: 'Updated: Implementation completed and tested',\n   *   category: 'progress',\n   *   pinned: true\n   * });\n   * ```\n   */\n  async updateNote(id: string, data: UpdateNoteRequest): Promise<Note> {\n    try {\n      const existingNote = await this.getNoteById(id);\n      if (!existingNote) {\n        throw NoteService.createError('NOTE_NOT_FOUND', 'Note not found', { id });\n      }\n\n      const updates: string[] = [];\n      const params: QueryParameters = [];\n\n      if (data.content !== undefined) {\n        updates.push('content = ?');\n        params.push(data.content);\n      }\n      if (data.category !== undefined) {\n        updates.push('category = ?');\n        params.push(data.category);\n      }\n      if (data.pinned !== undefined) {\n        updates.push('pinned = ?');\n        params.push(data.pinned);\n      }\n\n      if (updates.length === 0) {\n        return existingNote;\n      }\n\n      updates.push('updated_at = ?');\n      params.push(new Date());\n      params.push(id);\n\n      await this.db.execute(\n        `\n        UPDATE notes \n        SET ${String(String(updates.join(', ')))}\n        WHERE id = ?\n      `,\n        params\n      );\n\n      const updatedNote = await this.getNoteById(id);\n      if (!updatedNote) {\n        throw NoteService.createError('NOTE_UPDATE_FAILED', 'Note disappeared after update');\n      }\n\n      logger.info('Note updated successfully', { noteId: id });\n      return updatedNote;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('NOTE_')) {\n        throw error;\n      }\n      logger.error('Failed to update note', { error, id, data });\n      throw NoteService.createError('NOTE_UPDATE_FAILED', 'Failed to update note', error);\n    }\n  }\n\n  /**\n   * Permanently deletes a note\n   *\n   * @param id Unique note identifier\n   * @returns Promise that resolves when deletion is complete\n   *\n   * @throws {ServiceError} NOTE_NOT_FOUND - When note doesn't exist\n   * @throws {ServiceError} NOTE_DELETE_FAILED - When deletion fails\n   *\n   * @example\n   * ```typescript\n   * await noteService.deleteNote('note-123');\n   * ```\n   */\n  async deleteNote(id: string): Promise<void> {\n    try {\n      const note = await this.getNoteById(id);\n      if (!note) {\n        throw NoteService.createError('NOTE_NOT_FOUND', 'Note not found', { id });\n      }\n\n      const result = await this.db.execute('DELETE FROM notes WHERE id = ?', [id]);\n\n      if (result.changes === 0) {\n        throw NoteService.createError('NOTE_DELETE_FAILED', 'Failed to delete note');\n      }\n\n      logger.info('Note deleted successfully', { noteId: id });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('NOTE_')) {\n        throw error;\n      }\n      logger.error('Failed to delete note', { error, id });\n      throw NoteService.createError('NOTE_DELETE_FAILED', 'Failed to delete note', error);\n    }\n  }\n\n  /**\n   * Searches notes with relevance scoring and optional highlighting\n   *\n   * @param options Search parameters including query and filters\n   * @returns Promise resolving to array of search results with context\n   *\n   * @throws {ServiceError} NOTE_SEARCH_FAILED - When search fails\n   *\n   * @description Performs full-text search across note content with:\n   * - Relevance scoring based on match quality\n   * - Optional content highlighting\n   * - Task and board context inclusion\n   *\n   * @example\n   * ```typescript\n   * const results = await noteService.searchNotes({\n   *   query: 'authentication',\n   *   board_id: 'board-123',\n   *   category: 'decision',\n   *   highlight: true,\n   *   limit: 10\n   * });\n   *\n   * results.forEach(result => {\n   *   logger.log(`${String(String(result.task_title))}: ${String(String(result.highlighted_content))}`);\n   * });\n   * ```\n   */\n  async searchNotes(options: NoteSearchOptions): Promise<NoteSearchResult[]> {\n    const {\n      query,\n      limit = 50,\n      offset = 0,\n      sortBy = 'relevance',\n      sortOrder = 'desc',\n      task_id,\n      board_id,\n      category,\n      pinned_only,\n      highlight = true,\n    } = options;\n\n    try {\n      let sql = `\n        SELECT \n          n.*,\n          t.title as task_title,\n          b.name as board_name,\n          CASE \n            WHEN n.content LIKE ? THEN 10\n            WHEN n.content LIKE ? THEN 5\n            ELSE 1 \n          END as relevance_score\n        FROM notes n\n        INNER JOIN tasks t ON n['task_id'] = t.id\n        INNER JOIN boards b ON t.board_id = b.id\n        WHERE n.content LIKE ?\n      `;\n\n      const searchTerm = `%${String(query)}%`;\n      const exactMatch = `%${String(query)}%`;\n      const wordBoundary = `% ${String(query)} %`;\n\n      const params: QueryParameters = [exactMatch, wordBoundary, searchTerm];\n      const conditions: string[] = [];\n\n      if (task_id) {\n        conditions.push('n.task_id = ?');\n        params.push(task_id);\n      }\n\n      if (board_id) {\n        conditions.push('b.id = ?');\n        params.push(board_id);\n      }\n\n      if (category) {\n        conditions.push('n.category = ?');\n        params.push(category);\n      }\n\n      if (pinned_only) {\n        conditions.push('n.pinned = TRUE');\n      }\n\n      if (conditions.length > 0) {\n        sql += ` AND ${String(String(conditions.join(' AND ')))}`;\n      }\n\n      if (sortBy === 'relevance') {\n        sql += ' ORDER BY relevance_score DESC, n.updated_at DESC';\n      } else {\n        sql += ` ORDER BY n.${String(sortBy)} ${String(String(sortOrder.toUpperCase()))}`;\n      }\n\n      sql += ` LIMIT ? OFFSET ?`;\n      params.push(limit, offset);\n\n      const results = await this.db.query<\n        NoteSearchResult & {\n          task_title: string;\n          board_name: string;\n          relevance_score: number;\n        }\n      >(sql, params);\n\n      return results.map(result => {\n        NoteService.convertNoteDates(result);\n\n        if (highlight) {\n          result.highlighted_content = NoteService.highlightSearchTerm(result.content, query);\n        }\n\n        return {\n          ...result,\n          task_title: result.task_title,\n          board_name: result.board_name,\n          relevance_score: result.relevance_score,\n        };\n      });\n    } catch (error) {\n      logger.error('Failed to search notes', { error, options });\n      throw NoteService.createError('NOTE_SEARCH_FAILED', 'Failed to search notes', error);\n    }\n  }\n\n  /**\n   * Retrieves notes created within a recent time period\n   *\n   * @param options Options including time period and board filter\n   * @returns Promise resolving to array of recent notes\n   *\n   * @throws {ServiceError} NOTES_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * // Get notes from last 3 days\n   * const recentNotes = await noteService.getRecentNotes({\n   *   days: 3,\n   *   board_id: 'board-123'\n   * });\n   * ```\n   */\n  async getRecentNotes(\n    options: PaginationOptions & { days?: number; board_id?: string } = {}\n  ): Promise<Note[]> {\n    const { days = 7, board_id, ...paginationOptions } = options;\n    const date_from = new Date();\n    date_from.setDate(date_from.getDate() - days);\n\n    return this.getNotes({\n      ...paginationOptions,\n      ...(board_id ? { board_id } : {}),\n      date_from,\n      sortBy: 'created_at',\n      sortOrder: 'desc',\n    });\n  }\n\n  /**\n   * Retrieves all notes of a specific category\n   *\n   * @param category Note category to filter by\n   * @param options Additional filtering and pagination options\n   * @returns Promise resolving to array of notes in the category\n   *\n   * @throws {ServiceError} NOTES_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * // Get all blocker notes\n   * const blockers = await noteService.getNotesByCategory('blocker', {\n   *   board_id: 'board-123',\n   *   sortBy: 'created_at',\n   *   sortOrder: 'desc'\n   * });\n   * ```\n   */\n  async getNotesByCategory(\n    category: Note['category'],\n    options: PaginationOptions & { board_id?: string } = {}\n  ): Promise<Note[]> {\n    return this.getNotes({\n      ...options,\n      category,\n    });\n  }\n\n  /**\n   * Retrieves all notes for a specific board\n   *\n   * @param boardId ID of the board\n   * @param options Additional filtering and pagination options\n   * @returns Promise resolving to array of board notes\n   *\n   * @throws {ServiceError} NOTES_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * const boardNotes = await noteService.getNotesForBoard('board-123', {\n   *   category: 'decision',\n   *   pinned: true\n   * });\n   * ```\n   */\n  async getNotesForBoard(\n    boardId: string,\n    options: PaginationOptions & NoteFilters = {}\n  ): Promise<Note[]> {\n    return this.getNotes({\n      ...options,\n      board_id: boardId,\n    });\n  }\n\n  /**\n   * Pins a note for priority visibility\n   *\n   * @param id Unique note identifier\n   * @returns Promise resolving to the updated note\n   *\n   * @throws {ServiceError} NOTE_NOT_FOUND - When note doesn't exist\n   * @throws {ServiceError} NOTE_UPDATE_FAILED - When update fails\n   *\n   * @example\n   * ```typescript\n   * const pinnedNote = await noteService.pinNote('note-123');\n   * ```\n   */\n  async pinNote(id: string): Promise<Note> {\n    return this.updateNote(id, { pinned: true });\n  }\n\n  /**\n   * Unpins a previously pinned note\n   *\n   * @param id Unique note identifier\n   * @returns Promise resolving to the updated note\n   *\n   * @throws {ServiceError} NOTE_NOT_FOUND - When note doesn't exist\n   * @throws {ServiceError} NOTE_UPDATE_FAILED - When update fails\n   *\n   * @example\n   * ```typescript\n   * const unpinnedNote = await noteService.unpinNote('note-123');\n   * ```\n   */\n  async unpinNote(id: string): Promise<Note> {\n    return this.updateNote(id, { pinned: false });\n  }\n\n  /**\n   * Creates a duplicate of an existing note\n   *\n   * @param id ID of the note to duplicate\n   * @param newTaskId Optional different task ID for the duplicate\n   * @returns Promise resolving to the duplicated note\n   *\n   * @throws {ServiceError} NOTE_NOT_FOUND - When original note doesn't exist\n   * @throws {ServiceError} NOTE_DUPLICATE_FAILED - When duplication fails\n   *\n   * @description Creates a copy of the note with:\n   * - Same content and category\n   * - Reset pinned status to false\n   * - New timestamps\n   * - Optional different task association\n   *\n   * @example\n   * ```typescript\n   * // Duplicate to same task\n   * const duplicate = await noteService.duplicateNote('note-123');\n   *\n   * // Duplicate to different task\n   * const crossTaskDuplicate = await noteService.duplicateNote('note-123', 'task-456');\n   * ```\n   */\n  async duplicateNote(id: string, newTaskId?: string): Promise<Note> {\n    try {\n      const originalNote = await this.getNoteById(id);\n      if (!originalNote) {\n        throw NoteService.createError('NOTE_NOT_FOUND', 'Note not found', { id });\n      }\n\n      const duplicatedNote = await this.createNote({\n        task_id: newTaskId ?? originalNote.task_id,\n        content: originalNote.content,\n        category: originalNote.category,\n        pinned: false, // Don't duplicate pin status\n      });\n\n      logger.info('Note duplicated successfully', { originalId: id, newId: duplicatedNote.id });\n      return duplicatedNote;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('NOTE_')) {\n        throw error;\n      }\n      logger.error('Failed to duplicate note', { error, id });\n      throw NoteService.createError('NOTE_DUPLICATE_FAILED', 'Failed to duplicate note', error);\n    }\n  }\n\n  /**\n   * Retrieves comprehensive note statistics\n   *\n   * @param options Scope filters for statistics calculation\n   * @returns Promise resolving to note statistics object\n   *\n   * @throws {ServiceError} NOTE_STATS_FAILED - When statistics calculation fails\n   *\n   * @example\n   * ```typescript\n   * // Get board-wide note statistics\n   * const stats = await noteService.getNoteStats({\n   *   board_id: 'board-123',\n   *   days: 30\n   * });\n   *\n   * logger.log(`Total notes: ${String(String(stats.total))}`);\n   * logger.log(`Blockers: ${String(String(stats.by_category.blocker))}`);\n   * logger.log(`Recent notes (30 days): ${String(String(stats.recent))}`);\n   * ```\n   */\n  async getNoteStats(\n    options: { board_id?: string; task_id?: string; days?: number } = {}\n  ): Promise<{\n    total: number;\n    by_category: Record<Note['category'], number>;\n    pinned: number;\n    recent: number;\n  }> {\n    const { board_id, task_id, days = 7 } = options;\n\n    try {\n      let baseQuery = 'FROM notes n';\n      const params: any[] = [];\n      const conditions: string[] = [];\n\n      if (board_id) {\n        baseQuery += ' INNER JOIN tasks t ON n.task_id = t.id';\n        conditions.push('t.board_id = ?');\n        params.push(board_id);\n      }\n\n      if (task_id) {\n        conditions.push('n.task_id = ?');\n        params.push(task_id);\n      }\n\n      const whereClause =\n        conditions.length > 0 ? ` WHERE ${String(String(conditions.join(' AND ')))}` : '';\n\n      const [totalResult, categoryStats, pinnedResult, recentResult] = await Promise.all([\n        this.db.queryOne<{ count: number }>(\n          `SELECT COUNT(*) as count ${String(baseQuery)}${String(whereClause)}`,\n          params\n        ),\n        this.db.query<{ category: Note['category']; count: number }>(\n          `\n          SELECT category, COUNT(*) as count \n          ${String(baseQuery)}${String(whereClause)}\n          GROUP BY category\n        `,\n          params\n        ),\n        this.db.queryOne<{ count: number }>(\n          `\n          SELECT COUNT(*) as count \n          ${String(baseQuery)}${String(whereClause)}${String(String(conditions.length > 0 ? ' AND' : ' WHERE'))} n['pinned'] = TRUE\n        `,\n          params\n        ),\n        this.db.queryOne<{ count: number }>(\n          `\n          SELECT COUNT(*) as count \n          ${String(baseQuery)}${String(whereClause)}${String(String(conditions.length > 0 ? ' AND' : ' WHERE'))} n.created_at >= ?\n        `,\n          [...params, new Date(Date.now() - days * 24 * 60 * 60 * 1000)]\n        ),\n      ]);\n\n      const by_category: Record<Note['category'], number> = {\n        general: 0,\n        progress: 0,\n        blocker: 0,\n        decision: 0,\n        question: 0,\n      };\n\n      categoryStats.forEach(stat => {\n        by_category[stat.category] = stat.count;\n      });\n\n      return {\n        total: totalResult?.count ?? 0,\n        by_category,\n        pinned: pinnedResult?.count ?? 0,\n        recent: recentResult?.count ?? 0,\n      };\n    } catch (error) {\n      logger.error('Failed to get note stats', { error, options });\n      throw NoteService.createError('NOTE_STATS_FAILED', 'Failed to get note statistics', error);\n    }\n  }\n\n  /**\n   * Retrieves note category distribution with percentages\n   *\n   * @param filters Scope filters for category analysis\n   * @returns Promise resolving to array of category statistics\n   *\n   * @throws {ServiceError} NOTE_CATEGORIES_FAILED - When category analysis fails\n   *\n   * @example\n   * ```typescript\n   * const categories = await noteService.getNoteCategories({\n   *   board_id: 'board-123'\n   * });\n   *\n   * categories.forEach(cat => {\n   *   logger.log(`${String(String(cat.category))}: ${String(String(cat.count))} notes (${String(String(cat.percentage.toFixed(1)))}%)`);\n   * });\n   * ```\n   */\n  async getNoteCategories(filters: { task_id?: string; board_id?: string } = {}): Promise<\n    {\n      category: Note['category'];\n      count: number;\n      percentage: number;\n    }[]\n  > {\n    const { task_id, board_id } = filters;\n\n    try {\n      let baseQuery = 'FROM notes n';\n      const params: QueryParameters = [];\n      const conditions: string[] = [];\n\n      if (board_id) {\n        baseQuery += ' INNER JOIN tasks t ON n.task_id = t.id';\n        conditions.push('t.board_id = ?');\n        params.push(board_id);\n      }\n\n      if (task_id) {\n        conditions.push('n.task_id = ?');\n        params.push(task_id);\n      }\n\n      const whereClause =\n        conditions.length > 0 ? ` WHERE ${String(String(conditions.join(' AND ')))}` : '';\n\n      const [totalResult, categoryStats] = await Promise.all([\n        this.db.queryOne<{ count: number }>(\n          `SELECT COUNT(*) as count ${String(baseQuery)}${String(whereClause)}`,\n          params\n        ),\n        this.db.query<{ category: Note['category']; count: number }>(\n          `\n          SELECT category, COUNT(*) as count \n          ${String(baseQuery)}${String(whereClause)}\n          GROUP BY category\n          ORDER BY count DESC\n        `,\n          params\n        ),\n      ]);\n\n      const total = totalResult?.count ?? 0;\n\n      return categoryStats.map(stat => ({\n        category: stat.category,\n        count: stat.count,\n        percentage: total > 0 ? (stat.count / total) * 100 : 0,\n      }));\n    } catch (error) {\n      logger.error('Failed to get note categories', { error, filters });\n      throw NoteService.createError(\n        'NOTE_CATEGORIES_FAILED',\n        'Failed to get note categories',\n        error\n      );\n    }\n  }\n\n  /**\n   * Highlights search terms in content using HTML markup\n   *\n   * @private\n   * @param content Original content\n   * @param searchTerm Term to highlight\n   * @returns Content with search terms wrapped in <mark> tags\n   */\n  private static highlightSearchTerm(content: string, searchTerm: string): string {\n    if (!searchTerm.trim()) return content;\n\n    const escapedSearchTerm = searchTerm.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');\n    return content.replace(regex, '<mark>$1</mark>');\n  }\n\n  /**\n   * Converts string date fields to Date objects\n   *\n   * @private\n   * @param note Note object with potentially string-based dates\n   */\n  private static convertNoteDates(note: Note): void {\n    note.created_at = new Date(note.created_at);\n    note.updated_at = new Date(note.updated_at);\n  }\n\n  /**\n   * Creates a standardized service error\n   *\n   * @private\n   * @param code Error code identifier\n   * @param message Human-readable error message\n   * @param originalError Optional original error for debugging\n   * @returns Standardized ServiceError with status code\n   */\n  private static createError(code: string, message: string, originalError?: unknown): ServiceError {\n    const error = new Error(message) as ServiceError;\n    error.code = code;\n    error.statusCode = NoteService.getStatusCodeForError(code);\n    error.details = originalError as ServiceError['details'];\n    return error;\n  }\n\n  /**\n   * Maps error codes to HTTP status codes\n   *\n   * @private\n   * @param code Error code\n   * @returns HTTP status code\n   */\n  private static getStatusCodeForError(code: string): number {\n    switch (code) {\n      case 'NOTE_NOT_FOUND':\n        return 404;\n      case 'NOTE_CREATE_FAILED':\n      case 'NOTE_UPDATE_FAILED':\n      case 'NOTE_DELETE_FAILED':\n      case 'NOTE_DUPLICATE_FAILED':\n      case 'NOTE_SEARCH_FAILED':\n      case 'NOTE_STATS_FAILED':\n        return 500;\n      case 'NOTE_FETCH_FAILED':\n      case 'NOTES_FETCH_FAILED':\n        return 500;\n      default:\n        return 500;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/SchedulingService.ts",
    "messages": [
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 107,
        "column": 5,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 107,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 174,
        "column": 19,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 174,
        "endColumn": 22,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4909, 4912], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4909, 4912], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any[]` assigned to a parameter of type `QueryParameters`.",
        "line": 193,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 193,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{ id: string; name: string; description?: string; cron_expression: string; backup_type: string; enabled: number; last_run_at?: string; next_run_at?: string; run_count: number; failure_count: number; ... 4 more ...; updated_at: string; }`.",
        "line": 194,
        "column": 66,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 194,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 204,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 204,
        "endColumn": 92
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{ id: string; name: string; description?: string; cron_expression: string; backup_type: string; enabled: number; last_run_at?: string; next_run_at?: string; run_count: number; failure_count: number; ... 4 more ...; updated_at: string; }`.",
        "line": 205,
        "column": 56,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 205,
        "endColumn": 59
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 292,
        "column": 5,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 292,
        "endColumn": 38
      },
      {
        "ruleId": "no-void",
        "severity": 2,
        "message": "Expected 'undefined' and instead saw 'void'.",
        "line": 624,
        "column": 7,
        "nodeType": "UnaryExpression",
        "messageId": "noVoid",
        "endLine": 624,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Scheduling Service - Manages automated backup scheduling and execution\n *\n * @module services/SchedulingService\n * @description Provides cron-based scheduling for automated backups, manages backup schedules,\n * and handles retention policies. Integrates with BackupService to execute scheduled operations.\n *\n * @example\n * ```typescript\n * import { SchedulingService } from '@/services/SchedulingService';\n * import { BackupService } from '@/services/BackupService';\n * import { dbConnection } from '@/database/connection';\n *\n * const backupService = new BackupService(dbConnection);\n * const schedulingService = new SchedulingService(dbConnection, backupService);\n *\n * // Schedule daily backups at 2 AM\n * await schedulingService.createSchedule({\n *   name: 'daily-backup',\n *   cronExpression: '0 2 * * *',\n *   backupType: 'full',\n *   enabled: true\n * });\n *\n * // Start the scheduler\n * schedulingService.start();\n * ```\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport * as cron from 'node-cron';\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection } from '@/database/connection';\nimport type { BackupService } from './BackupService';\n\n/**\n * Backup schedule configuration\n */\nexport interface BackupSchedule {\n  id: string;\n  name: string;\n  description?: string;\n  cronExpression: string;\n  backupType: 'full' | 'incremental';\n  enabled: boolean;\n  lastRunAt?: string;\n  nextRunAt?: string;\n  runCount: number;\n  failureCount: number;\n  retentionDays?: number;\n  compressionEnabled: boolean;\n  verificationEnabled: boolean;\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * Schedule creation options\n */\nexport interface CreateScheduleOptions {\n  name: string;\n  description?: string;\n  cronExpression: string;\n  backupType: 'full' | 'incremental';\n  enabled?: boolean;\n  retentionDays?: number;\n  compressionEnabled?: boolean;\n  verificationEnabled?: boolean;\n}\n\n/**\n * Schedule update options\n */\nexport interface UpdateScheduleOptions {\n  name?: string;\n  description?: string;\n  cronExpression?: string;\n  backupType?: 'full' | 'incremental';\n  enabled?: boolean;\n  retentionDays?: number;\n  compressionEnabled?: boolean;\n  verificationEnabled?: boolean;\n}\n\n/**\n * Scheduling Service - Manages automated backup operations\n *\n * @class SchedulingService\n * @description Provides comprehensive scheduling functionality for automated backups\n * including cron-based scheduling, retention policies, and failure handling.\n */\nexport class SchedulingService {\n  private static readonly activeJobs = new Map<string, cron.ScheduledTask>();\n\n  private readonly isRunning = false;\n\n  /**\n   * Initialize SchedulingService\n   *\n   * @param {DatabaseConnection} db - Database connection instance\n   * @param {BackupService} backupService - Backup service instance\n   */\n  constructor(\n    private readonly db: DatabaseConnection,\n    private readonly backupService: BackupService\n  ) {\n    void this.ensureScheduleTable();\n  }\n\n  /**\n   * Create a new backup schedule\n   *\n   * @param {CreateScheduleOptions} options - Schedule creation options\n   * @returns {Promise<BackupSchedule>} Created schedule\n   */\n  async createSchedule(options: CreateScheduleOptions): Promise<BackupSchedule> {\n    // Validate cron expression\n    if (!cron.validate(options.cronExpression)) {\n      throw new Error(`Invalid cron expression: ${options.cronExpression}`);\n    }\n\n    const id = uuidv4();\n    const now = new Date().toISOString();\n\n    const schedule: BackupSchedule = {\n      id,\n      name: options.name,\n      cronExpression: options.cronExpression,\n      backupType: options.backupType,\n      enabled: options.enabled ?? true,\n      nextRunAt: SchedulingService.calculateNextRun(options.cronExpression),\n      runCount: 0,\n      failureCount: 0,\n      retentionDays: options.retentionDays ?? 30,\n      compressionEnabled: options.compressionEnabled ?? true,\n      verificationEnabled: options.verificationEnabled ?? true,\n      createdAt: now,\n      updatedAt: now,\n    };\n    if (options.description) {\n      schedule.description = options.description;\n    }\n\n    try {\n      await this.storeSchedule(schedule);\n\n      // Start the job if scheduler is running and schedule is enabled\n      if (this.isRunning && schedule.enabled) {\n        this.startJob(schedule);\n      }\n\n      logger.info(`Backup schedule created: ${schedule.name}`, { scheduleId: id });\n      return schedule;\n    } catch (error) {\n      logger.error('Failed to create backup schedule', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all backup schedules\n   *\n   * @param {Object} options - Query options\n   * @returns {Promise<BackupSchedule[]>} Array of schedules\n   */\n  async getSchedules(\n    options: {\n      enabled?: boolean;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<BackupSchedule[]> {\n    let query = 'SELECT * FROM backup_schedules WHERE 1=1';\n    const params: any[] = [];\n\n    if (options.enabled !== undefined) {\n      query += ' AND enabled = ?';\n      params.push(options.enabled ? 1 : 0);\n    }\n\n    query += ' ORDER BY created_at DESC';\n\n    if (options.limit) {\n      query += ' LIMIT ?';\n      params.push(options.limit);\n\n      if (options.offset) {\n        query += ' OFFSET ?';\n        params.push(options.offset);\n      }\n    }\n\n    const rows = await this.db.query(query, params);\n    return rows.map(row => SchedulingService.deserializeSchedule(row));\n  }\n\n  /**\n   * Get schedule by ID\n   *\n   * @param {string} id - Schedule ID\n   * @returns {Promise<BackupSchedule | null>} Schedule or null if not found\n   */\n  async getScheduleById(id: string): Promise<BackupSchedule | null> {\n    const row = await this.db.queryOne('SELECT * FROM backup_schedules WHERE id = ?', [id]);\n    return row ? SchedulingService.deserializeSchedule(row) : null;\n  }\n\n  /**\n   * Update a backup schedule\n   *\n   * @param {string} id - Schedule ID\n   * @param {UpdateScheduleOptions} options - Update options\n   * @returns {Promise<BackupSchedule>} Updated schedule\n   */\n  async updateSchedule(id: string, options: UpdateScheduleOptions): Promise<BackupSchedule> {\n    const existingSchedule = await this.getScheduleById(id);\n    if (!existingSchedule) {\n      throw new Error(`Schedule not found: ${id}`);\n    }\n\n    // Validate cron expression if provided\n    if (options.cronExpression && !cron.validate(options.cronExpression)) {\n      throw new Error(`Invalid cron expression: ${options.cronExpression}`);\n    }\n\n    // Update fields\n    const updatedSchedule: BackupSchedule = {\n      ...existingSchedule,\n      ...options,\n      updatedAt: new Date().toISOString(),\n    };\n\n    // Recalculate next run if cron expression changed\n    if (options.cronExpression) {\n      updatedSchedule.nextRunAt = SchedulingService.calculateNextRun(options.cronExpression);\n    }\n\n    try {\n      await this.storeSchedule(updatedSchedule);\n\n      // Restart job if scheduler is running\n      if (this.isRunning) {\n        SchedulingService.stopJob(id);\n        if (updatedSchedule.enabled) {\n          this.startJob(updatedSchedule);\n        }\n      }\n\n      logger.info(`Backup schedule updated: ${updatedSchedule.name}`, { scheduleId: id });\n      return updatedSchedule;\n    } catch (error) {\n      logger.error('Failed to update backup schedule', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a backup schedule\n   *\n   * @param {string} id - Schedule ID\n   */\n  async deleteSchedule(id: string): Promise<void> {\n    const existingSchedule = await this.getScheduleById(id);\n    if (!existingSchedule) {\n      throw new Error(`Schedule not found: ${id}`);\n    }\n\n    try {\n      // Stop the job if running\n      SchedulingService.stopJob(id);\n\n      // Delete from database\n      await this.db.execute('DELETE FROM backup_schedules WHERE id = ?', [id]);\n\n      logger.info(`Backup schedule deleted: ${existingSchedule.name}`, { scheduleId: id });\n    } catch (error) {\n      logger.error('Failed to delete backup schedule', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Start the scheduler\n   */\n  start(): void {\n    if (this.isRunning) {\n      logger.warn('Scheduler is already running');\n      return;\n    }\n\n    this.isRunning = true;\n    void this.loadAndStartSchedules();\n    logger.info('Backup scheduler started');\n  }\n\n  /**\n   * Stop the scheduler\n   */\n  stop(): void {\n    if (!this.isRunning) {\n      logger.warn('Scheduler is not running');\n      return;\n    }\n\n    this.isRunning = false;\n\n    // Stop all active jobs\n    for (const [scheduleId, task] of SchedulingService.activeJobs) {\n      task.stop();\n      SchedulingService.activeJobs.delete(scheduleId);\n    }\n\n    logger.info('Backup scheduler stopped');\n  }\n\n  /**\n   * Manually execute a schedule\n   *\n   * @param {string} id - Schedule ID\n   */\n  async executeSchedule(id: string): Promise<void> {\n    const schedule = await this.getScheduleById(id);\n    if (!schedule) {\n      throw new Error(`Schedule not found: ${id}`);\n    }\n\n    if (!schedule.enabled) {\n      throw new Error(`Schedule is disabled: ${id}`);\n    }\n\n    await this.executeBackup(schedule);\n  }\n\n  /**\n   * Clean up old backups based on retention policies\n   */\n  async cleanupOldBackups(): Promise<void> {\n    const schedules = await this.getSchedules({ enabled: true });\n\n    await Promise.all(\n      schedules\n        .filter(schedule => schedule.retentionDays)\n        .map(async schedule => {\n          try {\n            await this.backupService.cleanupOldBackups(schedule.retentionDays!);\n            logger.info(`Cleaned up old backups for schedule: ${schedule.name}`);\n          } catch (error) {\n            logger.error(`Failed to cleanup backups for schedule: ${schedule.name}`, error);\n          }\n        })\n    );\n  }\n\n  /**\n   * Load and start all enabled schedules\n   */\n  private async loadAndStartSchedules(): Promise<void> {\n    try {\n      const schedules = await this.getSchedules({ enabled: true });\n\n      await Promise.all(schedules.map(schedule => this.executeBackup(schedule)));\n    } catch (error) {\n      logger.error('Failed to load and start schedules:', error);\n    }\n  }\n\n  /**\n   * Stop a scheduled job\n   *\n   * @param {string} scheduleId - Schedule ID\n   */\n  private static stopJob(scheduleId: string): void {\n    const task = SchedulingService.activeJobs.get(scheduleId);\n    if (task) {\n      task.stop();\n      SchedulingService.activeJobs.delete(scheduleId);\n      logger.info(`Stopped backup job for schedule: ${scheduleId}`);\n    }\n  }\n\n  /**\n   * Execute a backup for a schedule\n   *\n   * @param {BackupSchedule} schedule - Schedule configuration\n   */\n  private async executeBackup(schedule: BackupSchedule): Promise<void> {\n    const startTime = Date.now();\n\n    try {\n      logger.info(`Executing scheduled backup: ${schedule.name}`, {\n        scheduleId: schedule.id,\n      });\n\n      // Create backup name with timestamp\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      const backupName = `${schedule.name}-${timestamp}`;\n\n      // Execute backup based on type\n      let backup;\n      if (schedule.backupType === 'incremental') {\n        // Find the latest full backup for this schedule\n        const recentBackups = await this.backupService.listBackups({\n          limit: 10,\n          type: 'full',\n        });\n\n        const parentBackup = recentBackups.find(\n          b => b.name.includes(schedule.name) && b.status === 'completed'\n        );\n\n        if (parentBackup) {\n          backup = await this.backupService.createIncrementalBackup({\n            name: backupName,\n            description: `Scheduled incremental backup from ${schedule.name}`,\n            compress: schedule.compressionEnabled,\n            verify: schedule.verificationEnabled,\n            parentBackupId: parentBackup.id,\n          });\n        } else {\n          // Fall back to full backup if no parent found\n          logger.warn(\n            `No parent backup found for incremental backup, creating full backup instead`\n          );\n          backup = await this.backupService.createFullBackup({\n            name: backupName,\n            description: `Scheduled full backup from ${schedule.name} (fallback)`,\n            compress: schedule.compressionEnabled,\n            verify: schedule.verificationEnabled,\n          });\n        }\n      } else {\n        backup = await this.backupService.createFullBackup({\n          name: backupName,\n          description: `Scheduled full backup from ${schedule.name}`,\n          compress: schedule.compressionEnabled,\n          verify: schedule.verificationEnabled,\n        });\n      }\n\n      // Update schedule statistics\n      await this.updateScheduleStats(schedule.id, true);\n\n      const duration = Date.now() - startTime;\n      logger.info(`Scheduled backup completed: ${schedule.name}`, {\n        scheduleId: schedule.id,\n        backupId: backup.id,\n        duration: `${duration}ms`,\n        size: backup.size,\n      });\n    } catch (error) {\n      // Update failure statistics\n      await this.updateScheduleStats(schedule.id, false);\n\n      const duration = Date.now() - startTime;\n      logger.error(`Scheduled backup failed: ${schedule.name}`, {\n        scheduleId: schedule.id,\n        duration: `${duration}ms`,\n        error,\n      });\n    }\n  }\n\n  /**\n   * Update schedule execution statistics\n   *\n   * @param {string} scheduleId - Schedule ID\n   * @param {boolean} success - Whether the execution was successful\n   */\n  private async updateScheduleStats(scheduleId: string, success: boolean): Promise<void> {\n    const now = new Date().toISOString();\n    const schedule = await this.getScheduleById(scheduleId);\n\n    if (!schedule) return;\n\n    const nextRun = SchedulingService.calculateNextRun(schedule.cronExpression);\n\n    await this.db.execute(\n      `\n      UPDATE backup_schedules \n      SET \n        last_run_at = ?,\n        next_run_at = ?,\n        run_count = run_count + 1,\n        failure_count = failure_count + ?,\n        updated_at = ?\n      WHERE id = ?\n    `,\n      [now, nextRun, success ? 0 : 1, now, scheduleId]\n    );\n  }\n\n  /**\n   * Calculate next run time for a cron expression\n   *\n   * @param {string} cronExpression - Cron expression\n   * @returns {string} Next run time in ISO format\n   */\n  private static calculateNextRun(_cronExpression: string): string {\n    try {\n      // Use a simple approximation - in production you'd want a proper cron parser\n      return new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(); // 24 hours from now\n    } catch {\n      return new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n    }\n  }\n\n  /**\n   * Ensure schedule table exists\n   */\n  private async ensureScheduleTable(): Promise<void> {\n    const query = `\n      CREATE TABLE IF NOT EXISTS backup_schedules (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL UNIQUE,\n        description TEXT,\n        cron_expression TEXT NOT NULL,\n        backup_type TEXT NOT NULL CHECK (backup_type IN ('full', 'incremental')),\n        enabled INTEGER DEFAULT 1,\n        last_run_at TEXT,\n        next_run_at TEXT,\n        run_count INTEGER DEFAULT 0,\n        failure_count INTEGER DEFAULT 0,\n        retention_days INTEGER DEFAULT 30,\n        compression_enabled INTEGER DEFAULT 1,\n        verification_enabled INTEGER DEFAULT 1,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      )\n    `;\n\n    await this.db.execute(query);\n  }\n\n  /**\n   * Store schedule in database\n   *\n   * @param {BackupSchedule} schedule - Schedule to store\n   */\n  private async storeSchedule(schedule: BackupSchedule): Promise<void> {\n    await this.ensureScheduleTable();\n\n    const query = `\n      INSERT INTO backup_schedules (\n        id, name, description, cron_expression, backup_type, enabled,\n        last_run_at, next_run_at, run_count, failure_count, retention_days,\n        compression_enabled, verification_enabled, created_at, updated_at\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `;\n\n    await this.db.execute(query, [\n      schedule.id,\n      schedule.name,\n      schedule.description,\n      schedule.cronExpression,\n      schedule.backupType,\n      schedule.enabled ? 1 : 0,\n      schedule.lastRunAt,\n      schedule.nextRunAt,\n      schedule.runCount,\n      schedule.failureCount,\n      schedule.retentionDays,\n      schedule.compressionEnabled ? 1 : 0,\n      schedule.verificationEnabled ? 1 : 0,\n      schedule.createdAt,\n      schedule.updatedAt,\n    ]);\n  }\n\n  /**\n   * Deserialize schedule from database row\n   *\n   * @param {any} row - Database row\n   * @returns {BackupSchedule} Deserialized schedule\n   */\n  private static deserializeSchedule(row: {\n    id: string;\n    name: string;\n    description?: string;\n    cron_expression: string;\n    backup_type: string;\n    enabled: number;\n    last_run_at?: string;\n    next_run_at?: string;\n    run_count: number;\n    failure_count: number;\n    retention_days: number;\n    compression_enabled: number;\n    verification_enabled: number;\n    created_at: string;\n    updated_at: string;\n  }): BackupSchedule {\n    const schedule: BackupSchedule = {\n      id: row.id,\n      name: row.name,\n      cronExpression: row.cron_expression,\n      backupType: row.backup_type as 'full' | 'incremental',\n      enabled: Boolean(row.enabled),\n      runCount: row.run_count ?? 0,\n      failureCount: row.failure_count ?? 0,\n      retentionDays: row.retention_days,\n      compressionEnabled: Boolean(row.compression_enabled),\n      verificationEnabled: Boolean(row.verification_enabled),\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n    };\n\n    // Add optional properties only if they exist\n    if (row.description) schedule.description = row.description;\n    if (row.last_run_at) schedule.lastRunAt = row.last_run_at;\n    if (row.next_run_at) schedule.nextRunAt = row.next_run_at;\n\n    return schedule;\n  }\n\n  /**\n   * Start a job for a schedule\n   */\n  private startJob(schedule: BackupSchedule): void {\n    // Stop existing job if any\n    SchedulingService.stopJob(schedule.id);\n\n    // Create new cron job\n    const task = cron.schedule(schedule.cronExpression, () => {\n      void this.executeBackup(schedule);\n    });\n\n    SchedulingService.activeJobs.set(schedule.id, task);\n    logger.info(`Started backup job for schedule: ${schedule.name}`, { scheduleId: schedule.id });\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/TagService.kysely-poc.ts",
    "messages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class getter 'db'.",
        "line": 43,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 43,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 109,
        "column": 18,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 109,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [2750, 2752], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 178,
        "column": 19,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 178,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 294,
        "column": 67,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 294,
        "endColumn": 72
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 294,
        "column": 74,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 294,
        "endColumn": 82
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * TagService Kysely Proof of Concept\n *\n * This demonstrates how the TagService would look with Kysely for type-safe queries.\n * Compare this with the existing TagService.ts to evaluate the benefits.\n */\n\nimport { logger } from '@/utils/logger';\nimport { kyselyDb } from '@/database/kyselyConnection';\nimport type {\n  Tag,\n  NewTag,\n  TagUpdate,\n  TagWithUsage,\n  Database as DatabaseSchema,\n} from '@/database/kyselySchema';\nimport { BaseServiceError, NotFoundError, ValidationError } from '@/utils/errors';\nimport { v4 as uuidv4 } from 'uuid';\nimport type { Kysely } from 'kysely';\n\nexport interface CreateTagRequest {\n  name: string;\n  color?: string;\n  description?: string;\n  parent_id?: string;\n}\n\nexport interface UpdateTagRequest {\n  name?: string;\n  color?: string;\n  description?: string;\n  parent_id?: string;\n}\n\nexport interface TagFilters {\n  parent_id?: string;\n  name_search?: string;\n  limit?: number;\n  offset?: number;\n}\n\nexport class TagServiceKysely {\n  private get db(): Kysely<DatabaseSchema> {\n    return kyselyDb.db;\n  }\n\n  /**\n   * Create a new tag with type safety\n   */\n  async createTag(data: CreateTagRequest): Promise<Tag> {\n    try {\n      const tagId = uuidv4();\n\n      // Validate parent tag exists if provided\n      if (data.parent_id) {\n        const parentExists = await this.db\n          .selectFrom('tags')\n          .select(['id'])\n          .where('id', '=', data.parent_id)\n          .executeTakeFirst();\n\n        if (!parentExists) {\n          throw new NotFoundError('tag', data.parent_id);\n        }\n      }\n\n      // Kysely ensures type safety - can't pass wrong fields or types\n      const newTag: NewTag = {\n        id: tagId,\n        name: data.name,\n        color: data.color ?? null,\n        description: data.description ?? null,\n        parent_id: data.parent_id ?? null,\n      };\n\n      // Insert and return the created tag\n      await this.db.insertInto('tags').values(newTag).execute();\n\n      // Fetch the created tag with full type safety\n      const createdTag = await this.db\n        .selectFrom('tags')\n        .selectAll()\n        .where('id', '=', tagId)\n        .executeTakeFirst();\n\n      if (!createdTag) {\n        throw new BaseServiceError('TAG_CREATE_FAILED', 'Failed to create tag');\n      }\n\n      logger.info('Tag created successfully', { tagId, name: data.name });\n      return createdTag;\n    } catch (error) {\n      logger.error('Failed to create tag', { error, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Get tag by ID with type safety\n   */\n  async getTagById(id: string): Promise<Tag | null> {\n    try {\n      const tag = await this.db\n        .selectFrom('tags')\n        .selectAll()\n        .where('id', '=', id)\n        .executeTakeFirst();\n\n      return tag || null;\n    } catch (error) {\n      logger.error('Failed to get tag by ID', { error, id });\n      throw new BaseServiceError('TAG_FETCH_FAILED', 'Failed to fetch tag', error);\n    }\n  }\n\n  /**\n   * Get tags with advanced filtering and type safety\n   */\n  async getTags(filters: TagFilters = {}): Promise<Tag[]> {\n    try {\n      let query = this.db.selectFrom('tags').selectAll();\n\n      // Type-safe filtering\n      if (filters.parent_id !== undefined) {\n        query = query.where(\n          'parent_id',\n          filters.parent_id === null ? 'is' : '=',\n          filters.parent_id\n        );\n      }\n\n      if (filters.name_search) {\n        query = query.where('name', 'like', `%${String(filters.name_search)}%`);\n      }\n\n      // Pagination with type safety\n      if (filters.limit) {\n        query = query.limit(filters.limit);\n      }\n\n      if (filters.offset) {\n        query = query.offset(filters.offset);\n      }\n\n      const tags = await query.orderBy('name', 'asc').execute();\n\n      return tags;\n    } catch (error) {\n      logger.error('Failed to get tags', { error, filters });\n      throw new BaseServiceError('TAG_FETCH_FAILED', 'Failed to fetch tags', error);\n    }\n  }\n\n  /**\n   * Update tag with type safety\n   */\n  async updateTag(id: string, data: UpdateTagRequest): Promise<Tag> {\n    try {\n      // Check if tag exists\n      const existingTag = await this.getTagById(id);\n      if (!existingTag) {\n        throw new NotFoundError('tag', id);\n      }\n\n      // Validate parent tag if changing parent\n      if (data.parent_id) {\n        const parentExists = await this.db\n          .selectFrom('tags')\n          .select(['id'])\n          .where('id', '=', data.parent_id)\n          .executeTakeFirst();\n\n        if (!parentExists) {\n          throw new NotFoundError('parent_tag', data.parent_id);\n        }\n\n        // Prevent circular references\n        if (await this.wouldCreateCircularReference(id, data.parent_id)) {\n          throw new ValidationError('Cannot create circular tag hierarchy');\n        }\n      }\n\n      // Type-safe update\n      const updateData: TagUpdate = {\n        ...data,\n        updated_at: new Date().toISOString(),\n      };\n\n      await this.db.updateTable('tags').set(updateData).where('id', '=', id).execute();\n\n      // Return updated tag\n      const updatedTag = await this.getTagById(id);\n      if (!updatedTag) {\n        throw new BaseServiceError('TAG_UPDATE_FAILED', 'Tag disappeared after update');\n      }\n\n      logger.info('Tag updated successfully', { id, changes: data });\n      return updatedTag;\n    } catch (error) {\n      logger.error('Failed to update tag', { error, id, data });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete tag with proper cleanup\n   */\n  async deleteTag(id: string): Promise<void> {\n    try {\n      const tag = await this.getTagById(id);\n      if (!tag) {\n        throw new NotFoundError('tag', id);\n      }\n\n      // Use transaction for atomic operation\n      await kyselyDb.transaction(async trx => {\n        // Remove tag from all tasks\n        await trx.deleteFrom('task_tags').where('tag_id', '=', id).execute();\n\n        // Update child tags to have no parent\n        await trx\n          .updateTable('tags')\n          .set({ parent_id: null })\n          .where('parent_id', '=', id)\n          .execute();\n\n        // Delete the tag\n        await trx.deleteFrom('tags').where('id', '=', id).execute();\n      });\n\n      logger.info('Tag deleted successfully', { id, name: tag.name });\n    } catch (error) {\n      logger.error('Failed to delete tag', { error, id });\n      throw error;\n    }\n  }\n\n  /**\n   * Get tags with usage statistics (demonstrates complex queries)\n   */\n  async getTagsWithUsage(): Promise<TagWithUsage[]> {\n    try {\n      const tagsWithUsage = await this.db\n        .selectFrom('tags')\n        .leftJoin('task_tags', 'tags.id', 'task_tags.tag_id')\n        .select([\n          'tags.id',\n          'tags.name',\n          'tags.color',\n          'tags.description',\n          'tags.parent_id',\n          'tags.created_at',\n          'tags.updated_at',\n          // Type-safe aggregation\n          this.db.fn.count('task_tags.task_id').as('usage_count'),\n          this.db.fn.max('task_tags.created_at').as('recent_usage'),\n        ])\n        .groupBy(['tags.id'])\n        .orderBy('usage_count', 'desc')\n        .execute();\n\n      return tagsWithUsage.map(tag => ({\n        ...tag,\n        usage_count: Number(tag.usage_count),\n      })) as TagWithUsage[];\n    } catch (error) {\n      logger.error('Failed to get tags with usage', { error });\n      throw new BaseServiceError('TAG_USAGE_FETCH_FAILED', 'Failed to fetch tag usage', error);\n    }\n  }\n\n  /**\n   * Get hierarchical tag tree (demonstrates recursive queries)\n   */\n  async getTagHierarchy(): Promise<Array<Tag & { children?: Tag[] }>> {\n    try {\n      // Get all tags\n      const allTags = await this.db.selectFrom('tags').selectAll().orderBy('name', 'asc').execute();\n\n      // Build hierarchy\n\n      await Promise.all(\n        allTags.map(async _tag => {\n          await this.db\n            .selectFrom('tags')\n            .select(['parent_id'])\n            .where('id', '=', currentParentId)\n            .executeTakeFirst();\n        })\n      );\n\n      return false;\n    } catch (error) {\n      logger.error('Failed to check circular reference', { error, tagId, parentId });\n      // Conservative approach: assume circular reference to prevent data corruption\n      return true;\n    }\n  }\n\n  /**\n   * Search tags with full-text search capabilities\n   */\n  async searchTags(query: string, limit = 20): Promise<Tag[]> {\n    try {\n      const tags = await this.db\n        .selectFrom('tags')\n        .selectAll()\n        .where(eb =>\n          eb.or([\n            eb('name', 'like', `%${String(query)}%`),\n            eb('description', 'like', `%${String(query)}%`),\n          ])\n        )\n        .orderBy('name', 'asc')\n        .limit(limit)\n        .execute();\n\n      return tags;\n    } catch (error) {\n      logger.error('Failed to search tags', { error, query });\n      throw new BaseServiceError('TAG_SEARCH_FAILED', 'Failed to search tags', error);\n    }\n  }\n}\n\n/*\n * COMPARISON ANALYSIS:\n *\n * Benefits demonstrated in this POC:\n *\n * 1. **Compile-time Type Safety**\n *    - Can't misspell column names\n *    - Can't use wrong data types\n *    - Autocomplete for all table columns\n *    - Type errors caught at build time\n *\n * 2. **Complex Query Support**\n *    - Type-safe joins and aggregations\n *    - Proper handling of nullable fields\n *    - Complex where conditions with type checking\n *\n * 3. **Transaction Safety**\n *    - Type-safe transaction callbacks\n *    - Automatic rollback on errors\n *    - Proper resource cleanup\n *\n * 4. **Developer Experience**\n *    - Better IDE support and autocomplete\n *    - Clearer error messages\n *    - Self-documenting query structure\n *\n * 5. **Maintainability**\n *    - Schema changes caught at compile time\n *    - Refactoring is safer\n *    - Less runtime type errors\n *\n * Performance Impact: Minimal overhead compared to raw SQL\n * Migration Effort: Can be done incrementally, service by service\n * Learning Curve: Moderate, but pays off quickly with better safety\n */\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/TagService.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 138,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 138,
        "endColumn": 58
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 138,
        "column": 56,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 138,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 177,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 177,
        "endColumn": 92
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 183,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 185,
        "endColumn": 13
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'parent_tag_id' is not in camel case.",
        "line": 326,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 326,
        "endColumn": 24
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'parent_tag_id' is not in camel case.",
        "line": 327,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 327,
        "endColumn": 26
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'parent_tag_id' is not in camel case.",
        "line": 327,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 327,
        "endColumn": 52
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'has_parent' is not in camel case.",
        "line": 335,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 335,
        "endColumn": 21
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'has_parent' is not in camel case.",
        "line": 336,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 336,
        "endColumn": 23
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'name_pattern' is not in camel case.",
        "line": 348,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 348,
        "endColumn": 23
      },
      {
        "ruleId": "no-return-assign",
        "severity": 2,
        "message": "Arrow function should not return assignment.",
        "line": 366,
        "column": 20,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "arrowAssignment",
        "endLine": 366,
        "endColumn": 70
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'tag'.",
        "line": 366,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 366,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe array destructuring of a tuple element with an `any` value.",
        "line": 706,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeArrayPatternFromTuple",
        "endLine": 706,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe array destructuring of a tuple element with an `any` value.",
        "line": 706,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeArrayPatternFromTuple",
        "endLine": 706,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe array destructuring of a tuple element with an `any` value.",
        "line": 706,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeArrayPatternFromTuple",
        "endLine": 706,
        "endColumn": 55
      },
      {
        "ruleId": "no-return-assign",
        "severity": 2,
        "message": "Arrow function should not return assignment.",
        "line": 813,
        "column": 20,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "arrowAssignment",
        "endLine": 813,
        "endColumn": 70
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'tag'.",
        "line": 813,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 813,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 1029,
        "column": 60,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 1029,
        "endColumn": 62
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'node'.",
        "line": 1031,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 1031,
        "endColumn": 17
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'most_used' is not in camel case.",
        "line": 1220,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 1220,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 11,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Tag Service - Core business logic for tag management\n *\n * @module services/TagService\n * @description Provides comprehensive tag management functionality including CRUD operations,\n * hierarchical tag structures, tag assignment to tasks, usage statistics, and tag merging.\n * Supports nested tag hierarchies with circular dependency prevention and efficient querying.\n *\n * @example\n * ```typescript\n * import { TagService } from '@/services/TagService';\n * import { dbConnection } from '@/database/connection';\n *\n * const tagService = new TagService(dbConnection);\n *\n * // Create a hierarchical tag structure\n * const parentTag = await tagService.createTag({\n *   name: 'Feature',\n *   color: '#4CAF50',\n *   description: 'Feature-related tags'\n * });\n *\n * const childTag = await tagService.createTag({\n *   name: 'Authentication',\n *   parent_tag_id: parentTag.id,\n *   color: '#2196F3'\n * });\n *\n * // Assign tag to task\n * await tagService.addTagToTask('task-123', childTag.id);\n * ```\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection, QueryParameters } from '@/database/connection';\nimport type { Tag, TaskTag, ServiceError, PaginationOptions, FilterOptions } from '@/types';\n\n/**\n * Request interface for creating new tags\n *\n * @interface CreateTagRequest\n * @description Defines the structure for tag creation requests with required name and optional metadata\n */\nexport interface CreateTagRequest {\n  name: string;\n  color?: string | undefined;\n  description?: string | undefined;\n  parent_tag_id?: string | undefined;\n}\n\n/**\n * Request interface for updating existing tags\n *\n * @interface UpdateTagRequest\n * @description All fields are optional to support partial updates. Parent tag changes\n * are validated to prevent circular hierarchies.\n */\nexport interface UpdateTagRequest {\n  name?: string | undefined;\n  color?: string | undefined;\n  description?: string | undefined;\n  parent_tag_id?: string | undefined;\n}\n\n/**\n * Advanced filtering options for tag queries\n *\n * @interface TagFilters\n * @extends FilterOptions\n * @description Provides comprehensive filtering capabilities for tag searches including\n * hierarchy filtering, color matching, and pattern-based name searching.\n */\nexport interface TagFilters extends FilterOptions {\n  parent_tag_id?: string;\n  has_parent?: boolean;\n  color?: string;\n  name_pattern?: string;\n}\n\n/**\n * Tag with hierarchical structure information\n *\n * @interface TagHierarchy\n * @extends Tag\n * @description Represents a tag with its complete subtree, depth level, and usage count\n */\nexport interface TagHierarchy extends Tag {\n  children: TagHierarchy[];\n  depth: number;\n  task_count: number;\n}\n\n/**\n * Tag with comprehensive usage statistics\n *\n * @interface TagWithStats\n * @extends Tag\n * @description Includes usage metrics, task associations, and child tag count\n */\nexport interface TagWithStats extends Tag {\n  task_count: number;\n  usage_count: number;\n  last_used?: Date;\n  child_count: number;\n}\n\n/**\n * Tag usage statistics with trend analysis\n *\n * @interface TagUsageStats\n * @description Provides detailed usage metrics and trend information for tags\n */\nexport interface TagUsageStats {\n  tag_id: string;\n  tag_name: string;\n  usage_count: number;\n  unique_tasks: number;\n  first_used: Date;\n  last_used: Date;\n  trend: 'increasing' | 'decreasing' | 'stable';\n}\n\n/**\n * Tag Service - Manages all tag-related operations\n *\n * @class TagService\n * @description Core service class providing comprehensive tag management functionality.\n * Handles tag CRUD operations, hierarchical structures, task associations, and usage analytics\n * with proper transaction handling and circular dependency prevention.\n */\nexport class TagService {\n  /**\n   * Creates a new TagService instance\n   *\n   * @param db Database connection instance for tag operations\n   */\n  constructor(private readonly db: DatabaseConnection) {}\n\n  /**\n   * Creates a new tag with optional parent relationship\n   *\n   * @param data Tag creation data including name, color, and optional parent\n   * @returns Promise resolving to the created tag with generated ID\n   *\n   * @throws {ServiceError} TAG_CREATE_FAILED - When tag creation fails\n   * @throws {Error} Tag with this name already exists - When name is not unique\n   * @throws {Error} Parent tag not found - When specified parent_tag_id doesn't exist\n   * @throws {Error} Would create circular hierarchy - When parent relationship creates a cycle\n   *\n   * @example\n   * ```typescript\n   * const tag = await tagService.createTag({\n   *   name: 'High Priority',\n   *   color: '#FF5722',\n   *   description: 'Tasks requiring immediate attention'\n   * });\n   * ```\n   *\n   * @since 1.0.0\n   */\n  async createTag(data: CreateTagRequest): Promise<Tag> {\n    const id = uuidv4();\n    const now = new Date();\n\n    const tag: Tag = {\n      id,\n      name: data.name,\n      color: data.color ?? '#9E9E9E',\n      description: data.description,\n      parent_tag_id: data.parent_tag_id,\n      created_at: now,\n    };\n\n    try {\n      await this.db.transaction(async db => {\n        const existingTag = await db.get('SELECT id FROM tags WHERE name = ?', [data.name]);\n        if (existingTag) {\n          throw new Error('Tag with this name already exists');\n        }\n\n        if (data.parent_tag_id) {\n          const parentExists = await db.get('SELECT id FROM tags WHERE id = ?', [\n            data.parent_tag_id,\n          ]);\n          if (!parentExists) {\n            throw new Error('Parent tag not found');\n          }\n\n          if (await this.wouldCreateCircularHierarchy(data.parent_tag_id, id)) {\n            throw new Error('Would create circular hierarchy');\n          }\n        }\n\n        await db.run(\n          `\n          INSERT INTO tags (id, name, color, description, parent_tag_id, created_at)\n          VALUES (?, ?, ?, ?, ?, ?)\n        `,\n          [tag.id, tag.name, tag.color, tag.description, tag.parent_tag_id, tag.created_at]\n        );\n      });\n\n      logger.info('Tag created successfully', { tagId: tag.id, name: tag.name });\n      return tag;\n    } catch (error) {\n      logger.error('Failed to create tag', { error, data });\n      throw TagService.createError('TAG_CREATE_FAILED', 'Failed to create tag', error);\n    }\n  }\n\n  /**\n   * Retrieves a single tag by its ID\n   *\n   * @param id Unique tag identifier\n   * @returns Promise resolving to the tag if found, null otherwise\n   *\n   * @throws {ServiceError} TAG_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const tag = await tagService.getTagById('tag-123');\n   * if (tag) {\n   *   logger.log(`Tag: ${String(String(tag.name))}`);\n   * }\n   * ```\n   */\n  async getTagById(id: string): Promise<Tag | null> {\n    try {\n      const tag = await this.db.queryOne<Tag>(\n        `\n        SELECT * FROM tags WHERE id = ?\n      `,\n        [id]\n      );\n\n      if (tag) {\n        tag.created_at = new Date(tag.created_at);\n      }\n\n      return tag ?? null;\n    } catch (error) {\n      logger.error('Failed to get tag by ID', { error, id });\n      throw TagService.createError('TAG_FETCH_FAILED', 'Failed to fetch tag', error);\n    }\n  }\n\n  /**\n   * Retrieves a tag by its unique name\n   *\n   * @param name Tag name to search for (case-sensitive)\n   * @returns Promise resolving to the tag if found, null otherwise\n   *\n   * @throws {ServiceError} TAG_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const tag = await tagService.getTagByName('Bug');\n   * if (tag) {\n   *   logger.log(`Found tag with ID: ${String(String(tag.id))}`);\n   * }\n   * ```\n   */\n  async getTagByName(name: string): Promise<Tag | null> {\n    try {\n      const tag = await this.db.queryOne<Tag>(\n        `\n        SELECT * FROM tags WHERE name = ?\n      `,\n        [name]\n      );\n\n      if (tag) {\n        tag.created_at = new Date(tag.created_at);\n      }\n\n      return tag ?? null;\n    } catch (error) {\n      logger.error('Failed to get tag by name', { error, name });\n      throw TagService.createError('TAG_FETCH_FAILED', 'Failed to fetch tag by name', error);\n    }\n  }\n\n  /**\n   * Retrieves tags with advanced filtering, pagination, and sorting\n   *\n   * @param options Comprehensive options for filtering, pagination, and sorting\n   * @returns Promise resolving to array of tags matching the criteria\n   *\n   * @throws {ServiceError} TAGS_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * // Get root tags (no parent)\n   * const rootTags = await tagService.getTags({\n   *   has_parent: false,\n   *   sortBy: 'name',\n   *   sortOrder: 'asc'\n   * });\n   *\n   * // Search tags by pattern\n   * const bugTags = await tagService.getTags({\n   *   name_pattern: 'bug',\n   *   limit: 10\n   * });\n   * ```\n   */\n  async getTags(options: PaginationOptions & TagFilters = {}): Promise<Tag[]> {\n    const {\n      limit = 50,\n      offset = 0,\n      sortBy = 'name',\n      sortOrder = 'asc',\n      parent_tag_id,\n      has_parent,\n      color,\n      name_pattern,\n      search,\n    } = options;\n\n    try {\n      let query = 'SELECT * FROM tags';\n      const params: QueryParameters = [];\n      const conditions: string[] = [];\n\n      if (parent_tag_id !== undefined) {\n        if (parent_tag_id === null || parent_tag_id === undefined) {\n          conditions.push('parent_tag_id IS NULL');\n        } else {\n          conditions.push('parent_tag_id = ?');\n          params.push(parent_tag_id);\n        }\n      }\n\n      if (has_parent !== undefined) {\n        if (has_parent) {\n          conditions.push('parent_tag_id IS NOT NULL');\n        } else {\n          conditions.push('parent_tag_id IS NULL');\n        }\n      }\n\n      if (color) {\n        conditions.push('color = ?');\n        params.push(color);\n      }\n\n      if (name_pattern) {\n        conditions.push('name LIKE ?');\n        params.push(`%${String(name_pattern)}%`);\n      }\n\n      if (search) {\n        conditions.push('(name LIKE ? OR description LIKE ?)');\n        params.push(`%${String(search)}%`, `%${String(search)}%`);\n      }\n\n      if (conditions.length > 0) {\n        query += ` WHERE ${String(String(conditions.join(' AND ')))}`;\n      }\n\n      query += ` ORDER BY ${String(sortBy)} ${String(String(sortOrder.toUpperCase()))} LIMIT ? OFFSET ?`;\n      params.push(limit, offset);\n\n      const tags = await this.db.query<Tag>(query, params);\n      tags.forEach(tag => (tag.created_at = new Date(tag.created_at)));\n\n      return tags;\n    } catch (error) {\n      logger.error('Failed to get tags', { error, options });\n      throw TagService.createError('TAGS_FETCH_FAILED', 'Failed to fetch tags', error);\n    }\n  }\n\n  /**\n   * Retrieves all root tags (tags without parents)\n   *\n   * @returns Promise resolving to array of root tags\n   *\n   * @throws {ServiceError} TAGS_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const rootTags = await tagService.getRootTags();\n   * logger.log(`Found ${String(String(rootTags.length))} root tags`);\n   * ```\n   */\n  async getRootTags(): Promise<Tag[]> {\n    return this.getTags({ has_parent: false });\n  }\n\n  /**\n   * Retrieves all direct child tags of a parent tag\n   *\n   * @param parentId ID of the parent tag\n   * @returns Promise resolving to array of child tags\n   *\n   * @throws {ServiceError} TAGS_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const children = await tagService.getChildTags('parent-tag-123');\n   * children.forEach(child => {\n   *   logger.log(`Child tag: ${String(String(child.name))}`);\n   * });\n   * ```\n   */\n  async getChildTags(parentId: string): Promise<Tag[]> {\n    return this.getTags({ parent_tag_id: parentId });\n  }\n\n  /**\n   * Builds complete tag hierarchy tree structure\n   *\n   * @param rootTagId Optional specific root tag ID to start from\n   * @returns Promise resolving to array of tag hierarchies with nested children\n   *\n   * @throws {ServiceError} TAG_HIERARCHY_FAILED - When hierarchy building fails\n   *\n   * @example\n   * ```typescript\n   * // Get entire tag hierarchy\n   * const hierarchy = await tagService.getTagHierarchy();\n   *\n   * // Get hierarchy for specific root\n   * const featureHierarchy = await tagService.getTagHierarchy('feature-tag-id');\n   * ```\n   */\n  async getTagHierarchy(rootTagId?: string): Promise<TagHierarchy[]> {\n    try {\n      const rootTags = rootTagId\n        ? ([await this.getTagById(rootTagId)].filter(Boolean) as Tag[])\n        : await this.getRootTags();\n\n      const hierarchies: TagHierarchy[] = [];\n\n      await Promise.all(\n        rootTags.map(async rootTag => {\n          const hierarchy = await this.buildTagHierarchy(rootTag, 0);\n          hierarchies.push(hierarchy);\n        })\n      );\n\n      return hierarchies;\n    } catch (error) {\n      logger.error('Failed to get tag hierarchy', { error, rootTagId });\n      throw TagService.createError('TAG_HIERARCHY_FAILED', 'Failed to build tag hierarchy', error);\n    }\n  }\n\n  /**\n   * Retrieves a tag with comprehensive usage statistics\n   *\n   * @param id Unique tag identifier\n   * @returns Promise resolving to tag with statistics or null if not found\n   *\n   * @throws {ServiceError} TAG_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const tagStats = await tagService.getTagWithStats('tag-123');\n   * if (tagStats) {\n   *   logger.log(`Tag \"${String(String(tagStats.name))}\" is used by ${String(String(tagStats.task_count))} tasks`);\n   *   logger.log(`Last used: ${String(String(tagStats.last_used))}`);\n   * }\n   * ```\n   */\n  async getTagWithStats(id: string): Promise<TagWithStats | null> {\n    try {\n      const tag = await this.getTagById(id);\n      if (!tag) return null;\n\n      const [taskCount, childCount, usageStats] = await Promise.all([\n        this.db.queryOne<{ count: number }>(\n          `\n          SELECT COUNT(DISTINCT task_id) as count \n          FROM task_tags \n          WHERE tag_id = ?\n        `,\n          [id]\n        ),\n        this.db.queryOne<{ count: number }>(\n          `\n          SELECT COUNT(*) as count \n          FROM tags \n          WHERE parent_tag_id = ?\n        `,\n          [id]\n        ),\n        this.db.queryOne<{ count: number; last_used: string }>(\n          `\n          SELECT \n            COUNT(*) as count,\n            MAX(tt.created_at) as last_used\n          FROM task_tags tt\n          WHERE tt['tag_id'] = ?\n        `,\n          [id]\n        ),\n      ]);\n\n      const tagWithStats: TagWithStats = {\n        ...tag,\n        task_count: taskCount?.count ?? 0,\n        usage_count: usageStats?.count ?? 0,\n        child_count: childCount?.count ?? 0,\n        ...(usageStats?.last_used ? { last_used: new Date(usageStats.last_used) } : {}),\n      };\n\n      return tagWithStats;\n    } catch (error) {\n      logger.error('Failed to get tag with stats', { error, id });\n      throw TagService.createError('TAG_FETCH_FAILED', 'Failed to fetch tag with stats', error);\n    }\n  }\n\n  /**\n   * Updates an existing tag with validation\n   *\n   * @param id Unique tag identifier\n   * @param data Partial tag data to update (only provided fields will be changed)\n   * @returns Promise resolving to the updated tag\n   *\n   * @throws {ServiceError} TAG_NOT_FOUND - When tag doesn't exist\n   * @throws {ServiceError} TAG_NAME_EXISTS - When new name already exists\n   * @throws {ServiceError} PARENT_TAG_NOT_FOUND - When new parent doesn't exist\n   * @throws {ServiceError} CIRCULAR_HIERARCHY - When update would create circular dependency\n   * @throws {ServiceError} TAG_UPDATE_FAILED - When update operation fails\n   *\n   * @example\n   * ```typescript\n   * const updated = await tagService.updateTag('tag-123', {\n   *   name: 'Critical Bug',\n   *   color: '#F44336'\n   * });\n   * ```\n   */\n  async updateTag(id: string, data: UpdateTagRequest): Promise<Tag> {\n    try {\n      const existingTag = await this.getTagById(id);\n      if (!existingTag) {\n        throw TagService.createError('TAG_NOT_FOUND', 'Tag not found', { id });\n      }\n\n      const updates: string[] = [];\n      const params: QueryParameters = [];\n\n      if (data.name !== undefined) {\n        if (data.name !== existingTag.name) {\n          const existingWithName = await this.getTagByName(data.name);\n          if (existingWithName && existingWithName.id !== id) {\n            throw TagService.createError('TAG_NAME_EXISTS', 'Tag with this name already exists');\n          }\n        }\n        updates.push('name = ?');\n        params.push(data.name);\n      }\n\n      if (data.color !== undefined) {\n        updates.push('color = ?');\n        params.push(data.color);\n      }\n\n      if (data.description !== undefined) {\n        updates.push('description = ?');\n        params.push(data.description);\n      }\n\n      if (data.parent_tag_id !== undefined) {\n        if (data.parent_tag_id && data.parent_tag_id !== existingTag.parent_tag_id) {\n          const parentExists = await this.getTagById(data.parent_tag_id);\n          if (!parentExists) {\n            throw TagService.createError('PARENT_TAG_NOT_FOUND', 'Parent tag not found');\n          }\n\n          if (await this.wouldCreateCircularHierarchy(data.parent_tag_id, id)) {\n            throw TagService.createError('CIRCULAR_HIERARCHY', 'Would create circular hierarchy');\n          }\n        }\n        updates.push('parent_tag_id = ?');\n        params.push(data.parent_tag_id);\n      }\n\n      if (updates.length === 0) {\n        return existingTag;\n      }\n\n      params.push(id);\n\n      await this.db.execute(\n        `\n        UPDATE tags \n        SET ${String(String(updates.join(', ')))}\n        WHERE id = ?\n      `,\n        params\n      );\n\n      const updatedTag = await this.getTagById(id);\n      if (!updatedTag) {\n        throw TagService.createError('TAG_UPDATE_FAILED', 'Tag disappeared after update');\n      }\n\n      logger.info('Tag updated successfully', { tagId: id });\n      return updatedTag;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('TAG_')) {\n        throw error;\n      }\n      logger.error('Failed to update tag', { error, id, data });\n      throw TagService.createError('TAG_UPDATE_FAILED', 'Failed to update tag', error);\n    }\n  }\n\n  /**\n   * Deletes a tag with configurable child handling\n   *\n   * @param id Unique tag identifier\n   * @param reassignToParent If true, reassigns children to deleted tag's parent; if false, deletes children recursively\n   * @returns Promise that resolves when deletion is complete\n   *\n   * @throws {ServiceError} TAG_NOT_FOUND - When tag doesn't exist\n   * @throws {ServiceError} TAG_DELETE_FAILED - When deletion fails\n   *\n   * @description This method:\n   * - Removes all task associations\n   * - Handles child tags based on reassignToParent parameter\n   * - Maintains hierarchy integrity\n   *\n   * @example\n   * ```typescript\n   * // Delete tag and reassign children to parent\n   * await tagService.deleteTag('tag-123', true);\n   *\n   * // Delete tag and all its children\n   * await tagService.deleteTag('tag-123', false);\n   * ```\n   */\n  async deleteTag(id: string, reassignToParent: boolean = true): Promise<void> {\n    try {\n      const tag = await this.getTagById(id);\n      if (!tag) {\n        throw TagService.createError('TAG_NOT_FOUND', 'Tag not found', { id });\n      }\n\n      if (!reassignToParent) {\n        // Delete children recursively first\n        const childTags = await this.getChildTags(id);\n        await Promise.all(\n          childTags.map(async child => {\n            await this.deleteTag(child.id, false);\n          })\n        );\n      }\n\n      await this.db.transaction(async db => {\n        if (reassignToParent) {\n          await db.run(\n            `\n            UPDATE tags \n            SET parent_tag_id = ? \n            WHERE parent_tag_id = ?\n          `,\n            [tag.parent_tag_id, id]\n          );\n        }\n\n        await db.run('DELETE FROM task_tags WHERE tag_id = ?', [id]);\n        await db.run('DELETE FROM tags WHERE id = ?', [id]);\n      });\n\n      logger.info('Tag deleted successfully', { tagId: id, reassignToParent });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('TAG_')) {\n        throw error;\n      }\n      logger.error('Failed to delete tag', { error, id });\n      throw TagService.createError('TAG_DELETE_FAILED', 'Failed to delete tag', error);\n    }\n  }\n\n  /**\n   * Associates a tag with a task\n   *\n   * @param taskId ID of the task to tag\n   * @param tagId ID of the tag to apply\n   * @returns Promise resolving to the created association\n   *\n   * @throws {ServiceError} TAG_ASSIGN_FAILED - When assignment fails\n   * @throws {Error} Task not found - When task doesn't exist\n   * @throws {Error} Tag not found - When tag doesn't exist\n   * @throws {Error} Tag already assigned to task - When association already exists\n   *\n   * @example\n   * ```typescript\n   * const association = await tagService.addTagToTask('task-123', 'bug-tag-id');\n   * logger.log('Tag applied successfully');\n   * ```\n   */\n  async addTagToTask(taskId: string, tagId: string): Promise<TaskTag> {\n    const id = uuidv4();\n    const now = new Date();\n\n    try {\n      await this.db.transaction(async db => {\n        const [taskExists, tagExists, existingRelation] = await Promise.all([\n          db.get('SELECT id FROM tasks WHERE id = ?', [taskId]),\n          db.get('SELECT id FROM tags WHERE id = ?', [tagId]),\n          db.get('SELECT task_id FROM task_tags WHERE task_id = ? AND tag_id = ?', [taskId, tagId]),\n        ]);\n\n        if (!taskExists) {\n          throw new Error('Task not found');\n        }\n        if (!tagExists) {\n          throw new Error('Tag not found');\n        }\n        if (existingRelation) {\n          throw new Error('Tag already assigned to task');\n        }\n\n        await db.run(\n          `\n          INSERT INTO task_tags (task_id, tag_id, created_at)\n          VALUES (?, ?, ?)\n        `,\n          [taskId, tagId, now]\n        );\n      });\n\n      const taskTag: TaskTag = {\n        id, // Generate ID for interface compatibility\n        task_id: taskId,\n        tag_id: tagId,\n        created_at: now,\n      };\n\n      logger.info('Tag added to task successfully', { taskId, tagId });\n      return taskTag;\n    } catch (error) {\n      logger.error('Failed to add tag to task', { error, taskId, tagId });\n      throw TagService.createError('TAG_ASSIGN_FAILED', 'Failed to assign tag to task', error);\n    }\n  }\n\n  /**\n   * Removes a tag association from a task\n   *\n   * @param taskId ID of the task\n   * @param tagId ID of the tag to remove\n   * @returns Promise that resolves when association is removed\n   *\n   * @throws {ServiceError} TAG_ASSIGNMENT_NOT_FOUND - When association doesn't exist\n   * @throws {ServiceError} TAG_REMOVE_FAILED - When removal fails\n   *\n   * @example\n   * ```typescript\n   * await tagService.removeTagFromTask('task-123', 'bug-tag-id');\n   * ```\n   */\n  async removeTagFromTask(taskId: string, tagId: string): Promise<void> {\n    try {\n      const result = await this.db.execute(\n        `\n        DELETE FROM task_tags \n        WHERE task_id = ? AND tag_id = ?\n      `,\n        [taskId, tagId]\n      );\n\n      if (result.changes === 0) {\n        throw TagService.createError('TAG_ASSIGNMENT_NOT_FOUND', 'Tag assignment not found');\n      }\n\n      logger.info('Tag removed from task successfully', { taskId, tagId });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('TAG_')) {\n        throw error;\n      }\n      logger.error('Failed to remove tag from task', { error, taskId, tagId });\n      throw TagService.createError('TAG_REMOVE_FAILED', 'Failed to remove tag from task', error);\n    }\n  }\n\n  /**\n   * Retrieves all tags associated with a task\n   *\n   * @param taskId ID of the task\n   * @returns Promise resolving to array of tags\n   *\n   * @throws {ServiceError} TAGS_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * const tags = await tagService.getTaskTags('task-123');\n   * tags.forEach(tag => {\n   *   logger.log(`Task has tag: ${String(String(tag.name))}`);\n   * });\n   * ```\n   */\n  async getTaskTags(taskId: string): Promise<Tag[]> {\n    try {\n      const tags = await this.db.query<Tag>(\n        `\n        SELECT t.* FROM tags t\n        INNER JOIN task_tags tt ON t['id'] = tt.tag_id\n        WHERE tt.task_id = ?\n        ORDER BY t.name ASC\n      `,\n        [taskId]\n      );\n\n      tags.forEach(tag => (tag.created_at = new Date(tag.created_at)));\n      return tags;\n    } catch (error) {\n      logger.error('Failed to get task tags', { error, taskId });\n      throw TagService.createError('TAGS_FETCH_FAILED', 'Failed to fetch task tags', error);\n    }\n  }\n\n  /**\n   * Retrieves all tasks tagged with a specific tag\n   *\n   * @param tagId ID of the tag\n   * @param includeChildren Whether to include tasks tagged with child tags\n   * @returns Promise resolving to array of task IDs\n   *\n   * @throws {ServiceError} TAGGED_TASKS_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * // Get tasks with specific tag only\n   * const taskIds = await tagService.getTaggedTasks('bug-tag-id');\n   *\n   * // Include tasks with child tags\n   * const allBugTasks = await tagService.getTaggedTasks('bug-tag-id', true);\n   * ```\n   */\n  async getTaggedTasks(tagId: string, includeChildren: boolean = false): Promise<string[]> {\n    try {\n      let tagIds = [tagId];\n\n      if (includeChildren) {\n        const childTagIds = await this.getAllChildTagIds(tagId);\n        tagIds = tagIds.concat(childTagIds);\n      }\n\n      const placeholders = tagIds.map(() => '?').join(',');\n      const taskIds = await this.db.query<{ task_id: string }>(\n        `\n        SELECT DISTINCT task_id FROM task_tags \n        WHERE tag_id IN (${String(placeholders)})\n      `,\n        tagIds\n      );\n\n      return taskIds.map(row => row.task_id);\n    } catch (error) {\n      logger.error('Failed to get tagged tasks', { error, tagId, includeChildren });\n      throw TagService.createError(\n        'TAGGED_TASKS_FETCH_FAILED',\n        'Failed to fetch tagged tasks',\n        error\n      );\n    }\n  }\n\n  /**\n   * Retrieves tag usage statistics over a time period\n   *\n   * @param options Statistics options including time period and result limit\n   * @returns Promise resolving to array of usage statistics with trends\n   *\n   * @throws {ServiceError} TAG_STATS_FAILED - When statistics calculation fails\n   *\n   * @example\n   * ```typescript\n   * // Get top 20 tags used in last 30 days\n   * const stats = await tagService.getTagUsageStats({\n   *   days: 30,\n   *   limit: 20\n   * });\n   *\n   * stats.forEach(stat => {\n   *   logger.log(`${String(String(stat.tag_name))}: ${String(String(stat.usage_count))} uses (${String(String(stat.trend))})`);\n   * });\n   * ```\n   */\n  async getTagUsageStats(\n    options: { days?: number; limit?: number } = {}\n  ): Promise<TagUsageStats[]> {\n    const { days = 30, limit = 50 } = options;\n\n    try {\n      const dateThreshold = new Date();\n      dateThreshold.setDate(dateThreshold.getDate() - days);\n\n      const stats = await this.db.query<{\n        tag_id: string;\n        tag_name: string;\n        usage_count: number;\n        unique_tasks: number;\n        first_used: string;\n        last_used: string;\n      }>(\n        `\n        SELECT \n          t.id as tag_id,\n          t.name as tag_name,\n          COUNT(tt.task_id) as usage_count,\n          COUNT(DISTINCT tt.task_id) as unique_tasks,\n          MIN(tt.created_at) as first_used,\n          MAX(tt.created_at) as last_used\n        FROM tags t\n        LEFT JOIN task_tags tt ON t['id'] = tt.tag_id\n        WHERE tt.created_at >= ? OR tt.created_at IS NULL\n        GROUP BY t.id, t.name\n        ORDER BY usage_count DESC\n        LIMIT ?\n      `,\n        [dateThreshold, limit]\n      );\n\n      return stats.map(stat => ({\n        tag_id: stat.tag_id,\n        tag_name: stat.tag_name,\n        usage_count: stat.usage_count,\n        unique_tasks: stat.unique_tasks,\n        first_used: stat.first_used ? new Date(stat.first_used) : new Date(),\n        last_used: stat.last_used ? new Date(stat.last_used) : new Date(),\n        trend: TagService.calculateTrend(stat.usage_count, days), // Simplified trend calculation\n      }));\n    } catch (error) {\n      logger.error('Failed to get tag usage stats', { error, options });\n      throw TagService.createError('TAG_STATS_FAILED', 'Failed to get tag usage statistics', error);\n    }\n  }\n\n  /**\n   * Retrieves a tag with its complete child hierarchy\n   *\n   * @param id Unique tag identifier\n   * @returns Promise resolving to tag hierarchy or null if not found\n   *\n   * @throws {ServiceError} TAG_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * const hierarchy = await tagService.getTagWithChildren('parent-tag-id');\n   * if (hierarchy) {\n   *   logger.log(`Tag \"${String(String(hierarchy.name))}\" has ${String(String(hierarchy.children.length))} children`);\n   * }\n   * ```\n   */\n  async getTagWithChildren(id: string): Promise<TagHierarchy | null> {\n    try {\n      const tag = await this.getTagById(id);\n      if (!tag) return null;\n\n      return await this.buildTagHierarchy(tag, 0);\n    } catch (error) {\n      logger.error('Failed to get tag with children', { error, id });\n      throw TagService.createError('TAG_FETCH_FAILED', 'Failed to fetch tag with children', error);\n    }\n  }\n\n  /**\n   * Retrieves the complete path from root to specified tag\n   *\n   * @param id Unique tag identifier\n   * @returns Promise resolving to array of tags from root to target\n   *\n   * @throws {ServiceError} TAG_PATH_FAILED - When path retrieval fails\n   *\n   * @example\n   * ```typescript\n   * const path = await tagService.getTagPath('child-tag-id');\n   * logger.log('Tag path: ' + path.map(t => t.name).join(' > '));\n   * // Output: \"Feature > Authentication > OAuth\"\n   * ```\n   */\n  async getTagPath(id: string): Promise<Tag[]> {\n    try {\n      const path: Tag[] = [];\n      let currentId: string | null | undefined = id;\n\n      // eslint-disable-next-line no-await-in-loop\n      while (currentId) {\n        // eslint-disable-next-line no-await-in-loop\n        const tag = await this.getTagById(currentId);\n        if (!tag) break;\n\n        path.unshift(tag); // Add to beginning for root-to-leaf order\n        currentId = tag.parent_tag_id;\n      }\n\n      return path;\n    } catch (error) {\n      logger.error('Failed to get tag path', { error, id });\n      throw TagService.createError('TAG_PATH_FAILED', 'Failed to get tag path', error);\n    }\n  }\n\n  /**\n   * Retrieves the complete tag tree with optional usage counts\n   *\n   * @param includeUsageCount Whether to include task count for each tag\n   * @returns Promise resolving to array of root tag hierarchies\n   *\n   * @throws {ServiceError} TAG_TREE_FAILED - When tree building fails\n   *\n   * @example\n   * ```typescript\n   * // Get tag tree with usage counts\n   * const tree = await tagService.getTagTree(true);\n   * tree.forEach(root => {\n   *   logger.log(`${String(String(root.name))} (${String(String(root.task_count))} tasks)`);\n   * });\n   * ```\n   */\n  async getTagTree(includeUsageCount: boolean = false): Promise<TagHierarchy[]> {\n    try {\n      const rootTags = await this.getRootTags();\n\n      const hierarchyPromises = rootTags.map(async rootTag => {\n        const hierarchy = await this.buildTagHierarchy(rootTag, 0);\n\n        if (includeUsageCount) {\n          const addUsageCount = async (node: TagHierarchy) => {\n            const usageStats = await this.getTagUsageStats({ limit: 1 });\n            node.task_count =\n              usageStats.length > 0 && usageStats[0] ? usageStats[0].usage_count : 0;\n\n            await Promise.all(node.children.map(child => addUsageCount(child)));\n          };\n\n          await addUsageCount(hierarchy);\n        }\n\n        return hierarchy;\n      });\n\n      const hierarchies = await Promise.all(hierarchyPromises);\n\n      return hierarchies;\n    } catch (error) {\n      logger.error('Failed to get tag tree', { error });\n      throw TagService.createError('TAG_TREE_FAILED', 'Failed to get tag tree', error);\n    }\n  }\n\n  /**\n   * Retrieves the most popular tags by usage\n   *\n   * @param options Filtering options including board scope and time period\n   * @returns Promise resolving to array of tags with statistics sorted by usage\n   *\n   * @throws {ServiceError} POPULAR_TAGS_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * // Get top 10 tags for a specific board in last week\n   * const popular = await tagService.getPopularTags({\n   *   board_id: 'board-123',\n   *   days: 7,\n   *   limit: 10\n   * });\n   * ```\n   */\n  async getPopularTags(\n    options: { limit?: number; board_id?: string; days?: number } = {}\n  ): Promise<TagWithStats[]> {\n    const { limit = 20, board_id, days = 30 } = options;\n\n    try {\n      const dateThreshold = new Date();\n      dateThreshold.setDate(dateThreshold.getDate() - days);\n\n      let query = `\n        SELECT \n          t.*,\n          COUNT(DISTINCT tt.task_id) as task_count,\n          COUNT(tt.task_id) as usage_count,\n          MAX(tt.created_at) as last_used,\n          (SELECT COUNT(*) FROM tags WHERE parent_tag_id = t.id) as child_count\n        FROM tags t\n        LEFT JOIN task_tags tt ON t['id'] = tt.tag_id\n      `;\n\n      const params: QueryParameters = [];\n      const conditions: string[] = [];\n\n      if (board_id) {\n        query += ' LEFT JOIN tasks task ON tt.task_id = task.id';\n        conditions.push('task.board_id = ?');\n        params.push(board_id);\n      }\n\n      conditions.push('(tt.created_at >= ? OR tt.created_at IS NULL)');\n      params.push(dateThreshold);\n\n      if (conditions.length > 0) {\n        query += ` WHERE ${String(String(conditions.join(' AND ')))}`;\n      }\n\n      query += `\n        GROUP BY t.id\n        ORDER BY usage_count DESC\n        LIMIT ?\n      `;\n      params.push(limit);\n\n      const popularTags = await this.db.query<TagWithStats & { last_used: string | null }>(\n        query,\n        params\n      );\n\n      return popularTags.map(tag => {\n        const result: TagWithStats = {\n          ...tag,\n          created_at: new Date(tag.created_at),\n        };\n        if (tag.last_used) {\n          result.last_used = new Date(tag.last_used);\n        }\n        return result;\n      });\n    } catch (error) {\n      logger.error('Failed to get popular tags', { error, options });\n      throw TagService.createError('POPULAR_TAGS_FAILED', 'Failed to get popular tags', error);\n    }\n  }\n\n  /**\n   * Retrieves comprehensive tag system statistics\n   *\n   * @param boardId Optional board ID to scope statistics\n   * @returns Promise resolving to tag system statistics\n   *\n   * @throws {ServiceError} TAG_STATS_FAILED - When statistics calculation fails\n   *\n   * @example\n   * ```typescript\n   * const stats = await tagService.getTagStats();\n   * logger.log(`Total tags: ${String(String(stats.total))}`);\n   * logger.log(`Root tags: ${String(String(stats.root_tags))}`);\n   * logger.log(`Max hierarchy depth: ${String(String(stats.max_depth))}`);\n   * logger.log(`Average tasks per tag: ${String(String(stats.avg_tasks_per_tag))}`);\n   * ```\n   */\n  async getTagStats(boardId?: string): Promise<{\n    total: number;\n    root_tags: number;\n    leaf_tags: number;\n    max_depth: number;\n    avg_tasks_per_tag: number;\n    most_used: TagWithStats[];\n  }> {\n    try {\n      let baseQuery = '';\n      const params: QueryParameters = [];\n\n      if (boardId) {\n        baseQuery = `\n          FROM tags t\n          WHERE EXISTS (\n            SELECT 1 FROM task_tags tt\n            JOIN tasks task ON tt.task_id = task.id\n            WHERE tt.tag_id = t.id AND task.board_id = ?\n          )\n        `;\n        params.push(boardId);\n      } else {\n        baseQuery = 'FROM tags t';\n      }\n\n      const [totalResult, rootResult, leafResult, depthResult, avgTasksResult] = await Promise.all([\n        this.db.queryOne<{ count: number }>(\n          `SELECT COUNT(*) as count ${String(baseQuery)}`,\n          params\n        ),\n        this.db.queryOne<{ count: number }>(\n          `SELECT COUNT(*) as count ${String(baseQuery)} WHERE parent_tag_id IS NULL`,\n          params\n        ),\n        this.db.queryOne<{ count: number }>(\n          `\n          SELECT COUNT(*) as count ${String(baseQuery)} \n          WHERE NOT EXISTS (SELECT 1 FROM tags child WHERE child.parent_tag_id = t.id)\n        `,\n          params\n        ),\n        this.db.queryOne<{ max_depth: number }>(\n          `\n          WITH RECURSIVE tag_depth AS (\n            SELECT id, parent_tag_id, 0 as depth FROM tags WHERE parent_tag_id IS NULL\n            UNION ALL\n            SELECT t.id, t.parent_tag_id, td.depth + 1\n            FROM tags t\n            JOIN tag_depth td ON t.parent_tag_id = td.id\n          )\n          SELECT MAX(depth) as max_depth FROM tag_depth\n        `,\n          []\n        ),\n        this.db.queryOne<{ avg_tasks: number }>(\n          `\n          SELECT AVG(task_count) as avg_tasks FROM (\n            SELECT COUNT(DISTINCT tt.task_id) as task_count\n            ${String(baseQuery)}\n            LEFT JOIN task_tags tt ON t.id = tt.tag_id\n            GROUP BY t.id\n          )\n        `,\n          params\n        ),\n      ]);\n\n      const mostUsedOptions = boardId ? { board_id: boardId, limit: 5 } : { limit: 5 };\n      const most_used = await this.getPopularTags(mostUsedOptions);\n\n      return {\n        total: totalResult?.count ?? 0,\n        root_tags: rootResult?.count ?? 0,\n        leaf_tags: leafResult?.count ?? 0,\n        max_depth: depthResult?.max_depth ?? 0,\n        avg_tasks_per_tag: avgTasksResult?.avg_tasks ?? 0,\n        most_used,\n      };\n    } catch (error) {\n      logger.error('Failed to get tag stats', { error, boardId });\n      throw TagService.createError('TAG_STATS_FAILED', 'Failed to get tag statistics', error);\n    }\n  }\n\n  /**\n   * Merges one tag into another, transferring all associations\n   *\n   * @param sourceTagId ID of the tag to be merged (will be deleted)\n   * @param targetTagId ID of the tag to merge into\n   * @returns Promise that resolves when merge is complete\n   *\n   * @throws {ServiceError} SOURCE_TAG_NOT_FOUND - When source tag doesn't exist\n   * @throws {ServiceError} TARGET_TAG_NOT_FOUND - When target tag doesn't exist\n   * @throws {ServiceError} TAG_MERGE_FAILED - When merge operation fails\n   *\n   * @description This method:\n   * - Transfers all task associations from source to target\n   * - Updates child tags to point to target\n   * - Deletes the source tag\n   * - Prevents duplicate associations\n   *\n   * @example\n   * ```typescript\n   * // Merge \"bug-critical\" into \"critical\"\n   * await tagService.mergeTags('bug-critical-id', 'critical-id');\n   * ```\n   */\n  async mergeTags(sourceTagId: string, targetTagId: string): Promise<void> {\n    try {\n      const [sourceTag, targetTag] = await Promise.all([\n        this.getTagById(sourceTagId),\n        this.getTagById(targetTagId),\n      ]);\n\n      if (!sourceTag) {\n        throw TagService.createError('SOURCE_TAG_NOT_FOUND', 'Source tag not found');\n      }\n      if (!targetTag) {\n        throw TagService.createError('TARGET_TAG_NOT_FOUND', 'Target tag not found');\n      }\n\n      await this.db.transaction(async db => {\n        await db.run(\n          `\n          UPDATE OR IGNORE task_tags \n          SET tag_id = ? \n          WHERE tag_id = ?\n        `,\n          [targetTagId, sourceTagId]\n        );\n\n        await db.run(\n          `\n          DELETE FROM task_tags \n          WHERE tag_id = ?\n        `,\n          [sourceTagId]\n        );\n\n        await db.run(\n          `\n          UPDATE tags \n          SET parent_tag_id = ? \n          WHERE parent_tag_id = ?\n        `,\n          [targetTagId, sourceTagId]\n        );\n\n        await db.run('DELETE FROM tags WHERE id = ?', [sourceTagId]);\n      });\n\n      logger.info('Tags merged successfully', { sourceTagId, targetTagId });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('TAG_')) {\n        throw error;\n      }\n      logger.error('Failed to merge tags', { error, sourceTagId, targetTagId });\n      throw TagService.createError('TAG_MERGE_FAILED', 'Failed to merge tags', error);\n    }\n  }\n\n  /**\n   * Recursively builds tag hierarchy structure\n   *\n   * @private\n   * @param tag Root tag to build from\n   * @param depth Current depth level\n   * @returns Promise resolving to tag hierarchy with children\n   */\n  private async buildTagHierarchy(tag: Tag, depth: number): Promise<TagHierarchy> {\n    const childTags = await this.getChildTags(tag.id);\n    const taskCount = await this.getTaskCount(tag.id);\n\n    const children: TagHierarchy[] = [];\n    await Promise.all(\n      childTags.map(async child => {\n        const childHierarchy = await this.buildTagHierarchy(child, depth + 1);\n        children.push(childHierarchy);\n      })\n    );\n\n    return {\n      ...tag,\n      children,\n      depth,\n      task_count: taskCount,\n    };\n  }\n\n  /**\n   * Gets the count of tasks associated with a tag\n   *\n   * @private\n   * @param tagId Tag identifier\n   * @returns Promise resolving to task count\n   */\n  private async getTaskCount(tagId: string): Promise<number> {\n    const result = await this.db.queryOne<{ count: number }>(\n      `\n      SELECT COUNT(DISTINCT task_id) as count \n      FROM task_tags \n      WHERE tag_id = ?\n    `,\n      [tagId]\n    );\n\n    return result?.count ?? 0;\n  }\n\n  /**\n   * Recursively retrieves all descendant tag IDs\n   *\n   * @private\n   * @param tagId Parent tag identifier\n   * @returns Promise resolving to array of all descendant tag IDs\n   */\n  private async getAllChildTagIds(tagId: string): Promise<string[]> {\n    const childIds: string[] = [];\n    const directChildren = await this.getChildTags(tagId);\n\n    // Add direct children\n    for (const child of directChildren) {\n      childIds.push(child.id);\n\n      // Recursively get all descendants\n      const descendantIds = await this.getAllChildTagIds(child.id);\n      childIds.push(...descendantIds);\n    }\n\n    return childIds;\n  }\n\n  /**\n   * Checks if setting a parent would create a circular dependency\n   *\n   * @private\n   * @param parentId Proposed parent tag ID\n   * @param childId Tag that would become a child\n   * @returns Promise resolving to true if circular dependency would be created\n   *\n   * @description Uses depth-first search to detect cycles in the tag hierarchy.\n   * This prevents infinite loops and ensures hierarchy integrity.\n   */\n  private async wouldCreateCircularHierarchy(parentId: string, childId: string): Promise<boolean> {\n    const visited = new Set<string>();\n    const stack = [parentId];\n\n    while (stack.length > 0) {\n      const currentId = stack.pop()!;\n\n      if (currentId === childId) {\n        return true;\n      }\n\n      if (visited.has(currentId)) {\n        continue;\n      }\n\n      visited.add(currentId);\n\n      // eslint-disable-next-line no-await-in-loop\n      const parent = await this.getTagById(currentId);\n      if (parent?.parent_tag_id) {\n        stack.push(parent.parent_tag_id);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculates usage trend based on count and time period\n   *\n   * @private\n   * @param usageCount Total usage count\n   * @param days Number of days in the period\n   * @returns Trend classification\n   *\n   * @description Simplified trend calculation based on average daily usage.\n   * In production, this would compare with historical data.\n   */\n  private static calculateTrend(\n    usageCount: number,\n    days: number\n  ): 'increasing' | 'decreasing' | 'stable' {\n    // Simplified trend calculation - in reality, you'd compare with previous periods\n    const avgUsagePerDay = usageCount / days;\n    if (avgUsagePerDay > 1) return 'increasing';\n    if (avgUsagePerDay < 0.5) return 'decreasing';\n    return 'stable';\n  }\n\n  /**\n   * Creates a standardized service error with proper error codes and status codes\n   *\n   * @private\n   * @param code Error code identifier for categorization\n   * @param message Human-readable error message\n   * @param originalError Optional original error for debugging context\n   * @returns Standardized ServiceError with status code and details\n   */\n  private static createError(code: string, message: string, originalError?: unknown): ServiceError {\n    const error = new Error(message) as ServiceError;\n    error.code = code;\n    error.statusCode = this.getStatusCodeForError(code);\n    error.details = originalError as ServiceError['details'];\n    return error;\n  }\n\n  /**\n   * Maps error codes to appropriate HTTP status codes\n   *\n   * @private\n   * @param code Error code\n   * @returns HTTP status code (404 for not found, 400 for validation, 500 for server errors)\n   */\n  private static getStatusCodeForError(code: string): number {\n    switch (code) {\n      case 'TAG_NOT_FOUND':\n      case 'PARENT_TAG_NOT_FOUND':\n      case 'SOURCE_TAG_NOT_FOUND':\n      case 'TARGET_TAG_NOT_FOUND':\n      case 'TAG_ASSIGNMENT_NOT_FOUND':\n        return 404;\n      case 'TAG_NAME_EXISTS':\n      case 'CIRCULAR_HIERARCHY':\n        return 400;\n      case 'TAG_CREATE_FAILED':\n      case 'TAG_UPDATE_FAILED':\n      case 'TAG_DELETE_FAILED':\n      case 'TAG_ASSIGN_FAILED':\n      case 'TAG_REMOVE_FAILED':\n      case 'TAG_MERGE_FAILED':\n      case 'TAG_STATS_FAILED':\n        return 500;\n      case 'TAG_FETCH_FAILED':\n      case 'TAGS_FETCH_FAILED':\n      case 'TAG_HIERARCHY_FAILED':\n      case 'TAGGED_TASKS_FETCH_FAILED':\n        return 500;\n      default:\n        return 500;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/services/TaskService.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 140,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 140,
        "endColumn": 58
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 140,
        "column": 56,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 140,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 171,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 173,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 181,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 183,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.",
        "line": 194,
        "column": 7,
        "nodeType": "ConditionalExpression",
        "messageId": "preferNullishOverTernary",
        "endLine": 194,
        "endColumn": 95,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": {
              "range": [5922, 6010],
              "text": "data.position ?? await this.getNextPosition(data.column_id)"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 220,
        "column": 17,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 222,
        "endColumn": 13
      },
      {
        "ruleId": "no-return-assign",
        "severity": 2,
        "message": "Arrow function should not return assignment.",
        "line": 388,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "arrowAssignment",
        "endLine": 388,
        "endColumn": 78
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'dep'.",
        "line": 388,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 388,
        "endColumn": 39
      },
      {
        "ruleId": "no-return-assign",
        "severity": 2,
        "message": "Arrow function should not return assignment.",
        "line": 389,
        "column": 26,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "arrowAssignment",
        "endLine": 389,
        "endColumn": 76
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'dep'.",
        "line": 389,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 389,
        "endColumn": 37
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'has_dependencies' is not in camel case.",
        "line": 491,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 491,
        "endColumn": 27
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'has_dependencies' is not in camel case.",
        "line": 492,
        "column": 13,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 492,
        "endColumn": 29
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'priority_min' is not in camel case.",
        "line": 506,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 506,
        "endColumn": 23
      },
      {
        "ruleId": "camelcase",
        "severity": 2,
        "message": "Identifier 'priority_max' is not in camel case.",
        "line": 511,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "notCamelCase",
        "endLine": 511,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.",
        "line": 621,
        "column": 13,
        "nodeType": "ConditionalExpression",
        "messageId": "preferNullishOverTernary",
        "endLine": 623,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": {
              "range": [18541, 18657],
              "text": "data.position ?? await this.getNextPosition(data.column_id)"
            },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe array destructuring of a tuple element with an `any` value.",
        "line": 757,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeArrayPatternFromTuple",
        "endLine": 757,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe array destructuring of a tuple element with an `any` value.",
        "line": 757,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unsafeArrayPatternFromTuple",
        "endLine": 757,
        "endColumn": 35
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'dep'.",
        "line": 1264,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 1264,
        "endColumn": 12
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'task'.",
        "line": 1352,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 1352,
        "endColumn": 9
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'task'.",
        "line": 1353,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 1353,
        "endColumn": 9
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'task'.",
        "line": 1355,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 1355,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 8,
    "fatalErrorCount": 0,
    "warningCount": 13,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Task Service - Core business logic for task management\n *\n * @module services/TaskService\n * @description Provides comprehensive task management functionality including CRUD operations,\n * dependencies, priorities, and advanced querying. Handles task positioning, subtask relationships,\n * and dependency validation to maintain data integrity.\n *\n * @example\n * ```typescript\n * import { TaskService } from '@/services/TaskService';\n * import { dbConnection } from '@/database/connection';\n *\n * const taskService = new TaskService(dbConnection);\n *\n * // Create a new task\n * const task = await taskService.createTask({\n *   title: 'Implement user authentication',\n *   description: 'Add JWT-based authentication system',\n *   board_id: 'board-123',\n *   column_id: 'todo',\n *   priority: 5\n * });\n *\n * // Get tasks with filtering\n * const tasks = await taskService.getTasks({\n *   board_id: 'board-123',\n *   status: 'in_progress',\n *   limit: 10\n * });\n * ```\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection, QueryParameters } from '@/database/connection';\nimport type { Task, TaskDependency, ServiceError, PaginationOptions, FilterOptions } from '@/types';\n\n/**\n * Request interface for creating new tasks\n *\n * @interface CreateTaskRequest\n * @description Defines the structure for task creation requests with all optional and required fields\n */\nexport interface CreateTaskRequest {\n  title: string;\n  description?: string;\n  board_id: string;\n  column_id: string;\n  position?: number;\n  priority?: number;\n  status?: Task['status'];\n  assignee?: string;\n  due_date?: Date;\n  estimated_hours?: number;\n  parent_task_id?: string;\n  metadata?: string;\n}\n\n/**\n * Request interface for updating existing tasks\n *\n * @interface UpdateTaskRequest\n * @description All fields are optional to support partial updates. Position and column changes\n * are handled automatically with proper repositioning logic.\n */\nexport interface UpdateTaskRequest {\n  title?: string | undefined;\n  description?: string | undefined;\n  column_id?: string | undefined;\n  position?: number | undefined;\n  priority?: number | undefined;\n  status?: Task['status'] | undefined;\n  assignee?: string | undefined;\n  due_date?: Date | undefined;\n  estimated_hours?: number | undefined;\n  actual_hours?: number | undefined;\n  parent_task_id?: string | undefined;\n  metadata?: string | undefined;\n}\n\n/**\n * Advanced filtering options for task queries\n *\n * @interface TaskFilters\n * @extends FilterOptions\n * @description Provides comprehensive filtering capabilities for task searches including\n * board/column filtering, status filtering, dependency checks, and date-based filtering.\n */\nexport interface TaskFilters extends FilterOptions {\n  board_id?: string;\n  column_id?: string;\n  status?: Task['status'];\n  assignee?: string;\n  parent_task_id?: string;\n  has_dependencies?: boolean;\n  overdue?: boolean;\n  priority_min?: number;\n  priority_max?: number;\n}\n\n/**\n * Task with loaded subtask relationships\n *\n * @interface TaskWithSubtasks\n * @extends Task\n * @description Represents a task with all its subtasks loaded and sorted by position\n */\nexport interface TaskWithSubtasks extends Task {\n  subtasks: Task[];\n}\n\n/**\n * Task with loaded dependency relationships\n *\n * @interface TaskWithDependencies\n * @extends Task\n * @description Represents a task with both its dependencies (tasks it depends on)\n * and dependents (tasks that depend on it) loaded\n */\nexport interface TaskWithDependencies extends Task {\n  dependencies: TaskDependency[];\n  dependents: TaskDependency[];\n}\n\n/**\n * Task Service - Manages all task-related operations\n *\n * @class TaskService\n * @description Core service class providing comprehensive task management functionality.\n * Handles task CRUD operations, dependency management, positioning, and advanced querying\n * with proper transaction handling and error recovery.\n */\nexport class TaskService {\n  /**\n   * Creates a new TaskService instance\n   *\n   * @param db Database connection instance for task operations\n   */\n  constructor(private readonly db: DatabaseConnection) {}\n\n  /**\n   * Creates a new task with proper positioning and validation\n   *\n   * @param data Task creation data including title, board, column, and optional metadata\n   * @returns Promise resolving to the created task with generated ID and timestamps\n   *\n   * @throws {ServiceError} TASK_CREATE_FAILED - When task creation fails due to database errors\n   * @throws {Error} Parent task not found - When specified parent_task_id doesn't exist\n   *\n   * @example\n   * ```typescript\n   * const task = await taskService.createTask({\n   *   title: 'Fix login bug',\n   *   description: 'Users cannot login with special characters in password',\n   *   board_id: 'board-123',\n   *   column_id: 'backlog',\n   *   priority: 8,\n   *   assignee: 'dev@example.com',\n   *   due_date: new Date('2024-01-15')\n   * });\n   * ```\n   */\n  async createTask(data: CreateTaskRequest): Promise<Task> {\n    // Validate required fields\n    if (!data.title || data.title.trim().length === 0) {\n      throw TaskService.createError('INVALID_TITLE', 'Task title is required and cannot be empty');\n    }\n\n    // Validate board_id exists\n    const boardExists = await this.db.queryOne('SELECT id FROM boards WHERE id = ?', [\n      data.board_id,\n    ]);\n    if (!boardExists) {\n      throw TaskService.createError('INVALID_BOARD_ID', 'Board not found', {\n        board_id: data.board_id,\n      });\n    }\n\n    // Validate column_id exists\n    const columnExists = await this.db.queryOne('SELECT id FROM columns WHERE id = ?', [\n      data.column_id,\n    ]);\n    if (!columnExists) {\n      throw TaskService.createError('INVALID_COLUMN_ID', 'Column not found', {\n        column_id: data.column_id,\n      });\n    }\n\n    const id = uuidv4();\n    const now = new Date();\n\n    const position =\n      data.position !== undefined ? data.position : await this.getNextPosition(data.column_id);\n\n    const task: Task = {\n      id,\n      title: data.title,\n      description: data.description,\n      board_id: data.board_id,\n      column_id: data.column_id,\n      position,\n      priority: data.priority ?? 1,\n      status: data.status ?? 'todo',\n      assignee: data.assignee,\n      due_date: data.due_date,\n      estimated_hours: data.estimated_hours,\n      actual_hours: undefined,\n      parent_task_id: data.parent_task_id,\n      created_at: now,\n      updated_at: now,\n      completed_at: undefined,\n      archived: false,\n      metadata: data.metadata,\n    };\n\n    try {\n      await this.db.transaction(async db => {\n        if (data.parent_task_id) {\n          const parentExists = await db.get('SELECT id FROM tasks WHERE id = ?', [\n            data.parent_task_id,\n          ]);\n          if (!parentExists) {\n            throw new Error('Parent task not found');\n          }\n        }\n\n        await this.adjustPositionsForInsertion(data.column_id, position);\n\n        await db.run(\n          `\n          INSERT INTO tasks (\n            id, title, description, board_id, column_id, position, priority, status, \n            assignee, due_date, estimated_hours, actual_hours, parent_task_id, \n            created_at, updated_at, completed_at, archived, metadata\n          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `,\n          [\n            task.id,\n            task.title,\n            task.description,\n            task.board_id,\n            task.column_id,\n            task.position,\n            task.priority,\n            task.status,\n            task.assignee,\n            task.due_date,\n            task.estimated_hours,\n            task.actual_hours,\n            task.parent_task_id,\n            task.created_at,\n            task.updated_at,\n            task.completed_at,\n            task.archived,\n            task.metadata,\n          ]\n        );\n      });\n\n      logger.info('Task created successfully', { taskId: task.id, title: task.title });\n      return task;\n    } catch (error) {\n      logger.error('Failed to create task', { error, data });\n      throw TaskService.createError('TASK_CREATE_FAILED', 'Failed to create task', error);\n    }\n  }\n\n  /**\n   * Retrieves a single task by its ID\n   *\n   * @param id Unique task identifier\n   * @returns Promise resolving to the task if found, null if not found or archived\n   *\n   * @throws {ServiceError} TASK_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const task = await taskService.getTaskById('task-123');\n   * if (task) {\n   *   logger.log(`Task: ${String(String(task.title))}`);\n   * }\n   * ```\n   */\n  async getTaskById(id: string): Promise<Task | null> {\n    try {\n      const task = await this.db.queryOne<Task>(\n        `\n        SELECT * FROM tasks WHERE id = ? AND archived = FALSE\n      `,\n        [id]\n      );\n\n      if (task) {\n        TaskService.convertTaskDates(task);\n      }\n\n      return task ?? null;\n    } catch (error) {\n      logger.error('Failed to get task by ID', { error, id });\n      throw TaskService.createError('TASK_FETCH_FAILED', 'Failed to fetch task', error);\n    }\n  }\n\n  /**\n   * Retrieves a task with all its subtasks loaded\n   *\n   * @param id Unique task identifier\n   * @returns Promise resolving to task with subtasks array, or null if not found\n   *\n   * @throws {ServiceError} TASK_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const taskWithSubs = await taskService.getTaskWithSubtasks('task-123');\n   * if (taskWithSubs) {\n   *   logger.log(`Task has ${String(String(taskWithSubs.subtasks.length))} subtasks`);\n   * }\n   * ```\n   */\n  async getTaskWithSubtasks(id: string): Promise<TaskWithSubtasks | null> {\n    try {\n      const task = await this.getTaskById(id);\n      if (!task) return null;\n\n      const subtasks = await this.db.query<Task>(\n        `\n        SELECT * FROM tasks \n        WHERE parent_task_id = ? AND archived = FALSE\n        ORDER BY position ASC\n      `,\n        [id]\n      );\n\n      subtasks.forEach(subtask => TaskService.convertTaskDates(subtask));\n\n      return {\n        ...task,\n        subtasks,\n      };\n    } catch (error) {\n      logger.error('Failed to get task with subtasks', { error, id });\n      throw TaskService.createError(\n        'TASK_FETCH_FAILED',\n        'Failed to fetch task with subtasks',\n        error\n      );\n    }\n  }\n\n  /**\n   * Retrieves a task with all its dependency relationships\n   *\n   * @param id Unique task identifier\n   * @returns Promise resolving to task with dependencies and dependents arrays\n   *\n   * @throws {ServiceError} TASK_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * const taskWithDeps = await taskService.getTaskWithDependencies('task-123');\n   * if (taskWithDeps) {\n   *   logger.log(`Depends on ${String(String(taskWithDeps.dependencies.length))} tasks`);\n   *   logger.log(`${String(String(taskWithDeps.dependents.length))} tasks depend on this`);\n   * }\n   * ```\n   */\n  async getTaskWithDependencies(id: string): Promise<TaskWithDependencies | null> {\n    try {\n      const task = await this.getTaskById(id);\n      if (!task) return null;\n\n      const [dependencies, dependents] = await Promise.all([\n        this.db.query<TaskDependency>(\n          `\n          SELECT * FROM task_dependencies WHERE task_id = ?\n        `,\n          [id]\n        ),\n        this.db.query<TaskDependency>(\n          `\n          SELECT * FROM task_dependencies WHERE depends_on_task_id = ?\n        `,\n          [id]\n        ),\n      ]);\n\n      dependencies.forEach(dep => (dep.created_at = new Date(dep.created_at)));\n      dependents.forEach(dep => (dep.created_at = new Date(dep.created_at)));\n\n      return {\n        ...task,\n        dependencies,\n        dependents,\n      };\n    } catch (error) {\n      logger.error('Failed to get task with dependencies', { error, id });\n      throw TaskService.createError(\n        'TASK_FETCH_FAILED',\n        'Failed to fetch task with dependencies',\n        error\n      );\n    }\n  }\n\n  /**\n   * Retrieves tasks with advanced filtering, pagination, and sorting\n   *\n   * @param options Comprehensive options for filtering, pagination, and sorting\n   * @returns Promise resolving to array of tasks matching the criteria\n   *\n   * @throws {ServiceError} TASKS_FETCH_FAILED - When database query fails\n   *\n   * @example\n   * ```typescript\n   * // Get recent high-priority tasks\n   * const tasks = await taskService.getTasks({\n   *   board_id: 'board-123',\n   *   priority_min: 7,\n   *   sortBy: 'updated_at',\n   *   sortOrder: 'desc',\n   *   limit: 20\n   * });\n   *\n   * // Search for overdue tasks\n   * const overdue = await taskService.getTasks({\n   *   overdue: true,\n   *   status: 'in_progress'\n   * });\n   * ```\n   */\n  async getTasks(options: PaginationOptions & TaskFilters = {}): Promise<Task[]> {\n    const {\n      limit = 50,\n      offset = 0,\n      sortBy = 'updated_at',\n      sortOrder = 'desc',\n      archived = false,\n      search,\n      board_id,\n      column_id,\n      status,\n      assignee,\n      parent_task_id,\n      has_dependencies,\n      overdue,\n      priority_min,\n      priority_max,\n    } = options;\n\n    try {\n      let query = 'SELECT DISTINCT t.* FROM tasks t';\n      const params: QueryParameters = [];\n      const conditions: string[] = ['t.archived = ?'];\n      params.push(archived);\n\n      if (search) {\n        conditions.push('(t.title LIKE ? OR t.description LIKE ?)');\n        params.push(`%${String(search)}%`, `%${String(search)}%`);\n      }\n\n      if (board_id) {\n        conditions.push('t.board_id = ?');\n        params.push(board_id);\n      }\n\n      if (column_id) {\n        conditions.push('t.column_id = ?');\n        params.push(column_id);\n      }\n\n      if (status) {\n        conditions.push('t.status = ?');\n        params.push(status);\n      }\n\n      if (assignee) {\n        conditions.push('t.assignee = ?');\n        params.push(assignee);\n      }\n\n      if (parent_task_id !== undefined) {\n        if (parent_task_id === null) {\n          conditions.push('t.parent_task_id IS NULL');\n        } else {\n          conditions.push('t.parent_task_id = ?');\n          params.push(parent_task_id);\n        }\n      }\n\n      if (has_dependencies !== undefined) {\n        if (has_dependencies) {\n          query += ' LEFT JOIN task_dependencies td ON t.id = td.task_id';\n          conditions.push('td.task_id IS NOT NULL');\n        } else {\n          query += ' LEFT JOIN task_dependencies td ON t.id = td.task_id';\n          conditions.push('td.task_id IS NULL');\n        }\n      }\n\n      if (overdue) {\n        conditions.push('t.due_date < ? AND t.status != ?');\n        params.push(new Date(), 'done');\n      }\n\n      if (priority_min !== undefined) {\n        conditions.push('t.priority >= ?');\n        params.push(priority_min);\n      }\n\n      if (priority_max !== undefined) {\n        conditions.push('t.priority <= ?');\n        params.push(priority_max);\n      }\n\n      query += ` WHERE ${conditions.join(' AND ')}`;\n      query += ` ORDER BY t.${sortBy} ${sortOrder.toUpperCase()} LIMIT ? OFFSET ?`;\n      params.push(limit, offset);\n\n      const tasks = await this.db.query<Task>(query, params);\n      tasks.forEach(task => TaskService.convertTaskDates(task));\n\n      return tasks;\n    } catch (error) {\n      logger.error('Failed to get tasks', { error, options });\n      throw TaskService.createError('TASKS_FETCH_FAILED', 'Failed to fetch tasks', error);\n    }\n  }\n\n  /**\n   * Updates an existing task with automatic position handling\n   *\n   * @param id Unique task identifier\n   * @param data Partial task data to update (only provided fields will be changed)\n   * @returns Promise resolving to the updated task\n   *\n   * @throws {ServiceError} TASK_NOT_FOUND - When task doesn't exist\n   * @throws {ServiceError} TASK_UPDATE_FAILED - When update operation fails\n   *\n   * @example\n   * ```typescript\n   * // Update task status and completion\n   * const updated = await taskService.updateTask('task-123', {\n   *   status: 'done',\n   *   actual_hours: 8.5\n   * });\n   *\n   * // Move task to different column\n   * await taskService.updateTask('task-123', {\n   *   column_id: 'in_progress',\n   *   position: 0 // Move to top of column\n   * });\n   * ```\n   */\n  async updateTask(id: string, data: UpdateTaskRequest): Promise<Task> {\n    try {\n      const existingTask = await this.getTaskById(id);\n      if (!existingTask) {\n        throw TaskService.createError('TASK_NOT_FOUND', 'Task not found', { id });\n      }\n\n      const updates: string[] = [];\n      const params: QueryParameters = [];\n\n      if (data.title !== undefined) {\n        updates.push('title = ?');\n        params.push(data.title);\n      }\n      if (data.description !== undefined) {\n        updates.push('description = ?');\n        params.push(data.description);\n      }\n      if (data.priority !== undefined) {\n        updates.push('priority = ?');\n        params.push(data.priority);\n      }\n      if (data.status !== undefined) {\n        updates.push('status = ?');\n        params.push(data.status);\n\n        if (data.status === 'done' && existingTask.status !== 'done') {\n          updates.push('completed_at = ?');\n          params.push(new Date());\n        } else if (data.status !== 'done' && existingTask.status === 'done') {\n          updates.push('completed_at = ?');\n          params.push(null);\n        }\n      }\n      if (data.assignee !== undefined) {\n        updates.push('assignee = ?');\n        params.push(data.assignee);\n      }\n      if (data.due_date !== undefined) {\n        updates.push('due_date = ?');\n        params.push(data.due_date);\n      }\n      if (data.estimated_hours !== undefined) {\n        updates.push('estimated_hours = ?');\n        params.push(data.estimated_hours);\n      }\n      if (data.actual_hours !== undefined) {\n        updates.push('actual_hours = ?');\n        params.push(data.actual_hours);\n      }\n      if (data.parent_task_id !== undefined) {\n        updates.push('parent_task_id = ?');\n        params.push(data.parent_task_id);\n      }\n      if (data.metadata !== undefined) {\n        updates.push('metadata = ?');\n        params.push(data.metadata);\n      }\n\n      if (updates.length === 0 && data.column_id === undefined && data.position === undefined) {\n        return existingTask;\n      }\n\n      await this.db.transaction(async db => {\n        if (data.column_id !== undefined && data.column_id !== existingTask.column_id) {\n          const newPosition =\n            data.position !== undefined\n              ? data.position\n              : await this.getNextPosition(data.column_id);\n\n          await this.adjustPositionsForRemoval(existingTask.column_id, existingTask.position);\n          await this.adjustPositionsForInsertion(data.column_id, newPosition);\n\n          updates.push('column_id = ?', 'position = ?');\n          params.push(data.column_id, newPosition);\n        } else if (data.position !== undefined && data.position !== existingTask.position) {\n          await this.adjustPositionsForMove(\n            existingTask.column_id,\n            existingTask.position,\n            data.position\n          );\n          updates.push('position = ?');\n          params.push(data.position);\n        }\n\n        if (updates.length > 0) {\n          updates.push('updated_at = ?');\n          params.push(new Date());\n          params.push(id);\n\n          await db.run(\n            `\n            UPDATE tasks \n            SET ${String(String(updates.join(', ')))}\n            WHERE id = ?\n          `,\n            params\n          );\n        }\n      });\n\n      const updatedTask = await this.getTaskById(id);\n      if (!updatedTask) {\n        throw TaskService.createError('TASK_UPDATE_FAILED', 'Task disappeared after update');\n      }\n\n      logger.info('Task updated successfully', { taskId: id });\n      return updatedTask;\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('TASK_')) {\n        throw error;\n      }\n      logger.error('Failed to update task', { error, id, data });\n      throw TaskService.createError('TASK_UPDATE_FAILED', 'Failed to update task', error);\n    }\n  }\n\n  /**\n   * Permanently deletes a task and cleans up all related data\n   *\n   * @param id Unique task identifier\n   * @returns Promise that resolves when deletion is complete\n   *\n   * @throws {ServiceError} TASK_NOT_FOUND - When task doesn't exist\n   * @throws {ServiceError} TASK_DELETE_FAILED - When deletion fails\n   *\n   * @description This method:\n   * - Moves subtasks to the deleted task's parent (or makes them top-level)\n   * - Removes all task dependencies\n   * - Deletes all associated notes and tags\n   * - Adjusts positions of remaining tasks in the column\n   *\n   * @example\n   * ```typescript\n   * await taskService.deleteTask('task-123');\n   * ```\n   */\n  async deleteTask(id: string): Promise<void> {\n    try {\n      const task = await this.getTaskById(id);\n      if (!task) {\n        throw TaskService.createError('TASK_NOT_FOUND', 'Task not found', { id });\n      }\n\n      await this.db.transaction(async db => {\n        await db.run('UPDATE tasks SET parent_task_id = ? WHERE parent_task_id = ?', [\n          task.parent_task_id,\n          id,\n        ]);\n        await db.run('DELETE FROM task_dependencies WHERE task_id = ? OR depends_on_task_id = ?', [\n          id,\n          id,\n        ]);\n        await db.run('DELETE FROM notes WHERE task_id = ?', [id]);\n        await db.run('DELETE FROM task_tags WHERE task_id = ?', [id]);\n        await db.run('DELETE FROM tasks WHERE id = ?', [id]);\n\n        await this.adjustPositionsForRemoval(task.column_id, task.position);\n      });\n\n      logger.info('Task deleted successfully', { taskId: id });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('TASK_')) {\n        throw error;\n      }\n      logger.error('Failed to delete task', { error, id });\n      throw TaskService.createError('TASK_DELETE_FAILED', 'Failed to delete task', error);\n    }\n  }\n\n  /**\n   * Adds a dependency relationship between two tasks\n   *\n   * @param taskId ID of the task that depends on another\n   * @param dependsOnTaskId ID of the task that this task depends on\n   * @param dependencyType Type of dependency relationship (default: 'blocks')\n   * @returns Promise resolving to the created dependency relationship\n   *\n   * @throws {ServiceError} DEPENDENCY_ADD_FAILED - When dependency creation fails\n   * @throws {Error} Task not found - When either task doesn't exist\n   * @throws {Error} Would create circular dependency - When dependency would create a cycle\n   *\n   * @example\n   * ```typescript\n   * // Task B blocks task A (A depends on B)\n   * const dependency = await taskService.addDependency(\n   *   'task-a',\n   *   'task-b',\n   *   'blocks'\n   * );\n   * ```\n   */\n  async addDependency(\n    taskId: string,\n    dependsOnTaskId: string,\n    dependencyType: TaskDependency['dependency_type'] = 'blocks'\n  ): Promise<TaskDependency> {\n    const id = uuidv4();\n    const now = new Date();\n\n    try {\n      await this.db.transaction(async db => {\n        const [task, dependentTask] = await Promise.all([\n          db.get('SELECT id FROM tasks WHERE id = ?', [taskId]),\n          db.get('SELECT id FROM tasks WHERE id = ?', [dependsOnTaskId]),\n        ]);\n\n        if (!task) {\n          throw new Error('Task not found');\n        }\n        if (!dependentTask) {\n          throw new Error('Dependent task not found');\n        }\n\n        if (await this.wouldCreateCircularDependency(taskId, dependsOnTaskId)) {\n          throw new Error('Would create circular dependency');\n        }\n\n        await db.run(\n          `\n          INSERT INTO task_dependencies (id, task_id, depends_on_task_id, dependency_type, created_at)\n          VALUES (?, ?, ?, ?, ?)\n        `,\n          [id, taskId, dependsOnTaskId, dependencyType, now]\n        );\n      });\n\n      const dependency: TaskDependency = {\n        id,\n        task_id: taskId,\n        depends_on_task_id: dependsOnTaskId,\n        dependency_type: dependencyType,\n        created_at: now,\n      };\n\n      logger.info('Task dependency added successfully', {\n        taskId,\n        dependsOnTaskId,\n        dependencyType,\n      });\n      return dependency;\n    } catch (error) {\n      logger.error('Failed to add task dependency', { error, taskId, dependsOnTaskId });\n      throw TaskService.createError(\n        'DEPENDENCY_ADD_FAILED',\n        'Failed to add task dependency',\n        error\n      );\n    }\n  }\n\n  /**\n   * Removes a dependency relationship between two tasks\n   *\n   * @param taskId ID of the dependent task\n   * @param dependsOnTaskId ID of the task being depended upon\n   * @returns Promise that resolves when dependency is removed\n   *\n   * @throws {ServiceError} DEPENDENCY_NOT_FOUND - When dependency doesn't exist\n   * @throws {ServiceError} DEPENDENCY_REMOVE_FAILED - When removal fails\n   *\n   * @example\n   * ```typescript\n   * await taskService.removeDependency('task-a', 'task-b');\n   * ```\n   */\n  async removeDependency(taskId: string, dependsOnTaskId: string): Promise<void> {\n    try {\n      const result = await this.db.execute(\n        `\n        DELETE FROM task_dependencies \n        WHERE task_id = ? AND depends_on_task_id = ?\n      `,\n        [taskId, dependsOnTaskId]\n      );\n\n      if (result.changes === 0) {\n        throw TaskService.createError('DEPENDENCY_NOT_FOUND', 'Dependency not found');\n      }\n\n      logger.info('Task dependency removed successfully', { taskId, dependsOnTaskId });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('DEPENDENCY_')) {\n        throw error;\n      }\n      logger.error('Failed to remove task dependency', { error, taskId, dependsOnTaskId });\n      throw TaskService.createError(\n        'DEPENDENCY_REMOVE_FAILED',\n        'Failed to remove task dependency',\n        error\n      );\n    }\n  }\n\n  /**\n   * Retrieves all tasks that are blocked by incomplete dependencies\n   *\n   * @param boardId Optional board ID to filter results to a specific board\n   * @returns Promise resolving to array of blocked tasks sorted by priority\n   *\n   * @throws {ServiceError} TASKS_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * // Get all blocked tasks\n   * const blocked = await taskService.getBlockedTasks();\n   *\n   * // Get blocked tasks for a specific board\n   * const boardBlocked = await taskService.getBlockedTasks('board-123');\n   * ```\n   */\n  async getBlockedTasks(boardId?: string): Promise<Task[]> {\n    try {\n      let query = `\n        SELECT DISTINCT t.* FROM tasks t\n        INNER JOIN task_dependencies td ON t.id = td.task_id\n        INNER JOIN tasks blocking_task ON td.depends_on_task_id = blocking_task.id\n        WHERE blocking_task.status != 'done' AND t.archived = FALSE\n      `;\n      const params: QueryParameters = [];\n\n      if (boardId) {\n        query += ' AND t.board_id = ?';\n        params.push(boardId);\n      }\n\n      query += ' ORDER BY t.priority DESC, t.created_at ASC';\n\n      const tasks = await this.db.query<Task>(query, params);\n      tasks.forEach(task => TaskService.convertTaskDates(task));\n\n      return tasks;\n    } catch (error) {\n      logger.error('Failed to get blocked tasks', { error, boardId });\n      throw TaskService.createError('TASKS_FETCH_FAILED', 'Failed to fetch blocked tasks', error);\n    }\n  }\n\n  /**\n   * Retrieves all tasks that are past their due date and not completed\n   *\n   * @param boardId Optional board ID to filter results to a specific board\n   * @returns Promise resolving to array of overdue tasks sorted by due date\n   *\n   * @throws {ServiceError} TASKS_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * // Get all overdue tasks\n   * const overdue = await taskService.getOverdueTasks();\n   *\n   * // Get overdue tasks for a specific board\n   * const boardOverdue = await taskService.getOverdueTasks('board-123');\n   * ```\n   */\n  async getOverdueTasks(boardId?: string): Promise<Task[]> {\n    try {\n      let query = `\n        SELECT * FROM tasks \n        WHERE due_date < ? AND status != 'done' AND archived = FALSE\n      `;\n      const params: QueryParameters = [new Date()];\n\n      if (boardId) {\n        query += ' AND board_id = ?';\n        params.push(boardId);\n      }\n\n      query += ' ORDER BY due_date ASC, priority DESC';\n\n      const tasks = await this.db.query<Task>(query, params);\n      tasks.forEach(task => TaskService.convertTaskDates(task));\n\n      return tasks;\n    } catch (error) {\n      logger.error('Failed to get overdue tasks', { error, boardId });\n      throw TaskService.createError('TASKS_FETCH_FAILED', 'Failed to fetch overdue tasks', error);\n    }\n  }\n\n  /**\n   * Calculates the next available position in a column\n   *\n   * @private\n   * @param columnId Column identifier\n   * @returns Promise resolving to the next position number (0-based)\n   */\n  private async getNextPosition(columnId: string): Promise<number> {\n    const result = await this.db.queryOne<{ max_position: number }>(\n      `\n      SELECT COALESCE(MAX(position), 0) + 1 as max_position \n      FROM tasks \n      WHERE column_id = ? AND archived = FALSE\n    `,\n      [columnId]\n    );\n\n    return result?.max_position ?? 1;\n  }\n\n  /**\n   * Adjusts positions of existing tasks to make room for insertion at specified position\n   *\n   * @private\n   * @param columnId Column identifier\n   * @param position Position where new task will be inserted\n   */\n  private async adjustPositionsForInsertion(columnId: string, position: number): Promise<void> {\n    await this.db.execute(\n      `\n      UPDATE tasks \n      SET position = position + 1 \n      WHERE column_id = ? AND position >= ? AND archived = FALSE\n    `,\n      [columnId, position]\n    );\n  }\n\n  /**\n   * Adjusts positions of tasks after a task is removed from specified position\n   *\n   * @private\n   * @param columnId Column identifier\n   * @param position Position of the removed task\n   */\n  private async adjustPositionsForRemoval(columnId: string, position: number): Promise<void> {\n    await this.db.execute(\n      `\n      UPDATE tasks \n      SET position = position - 1 \n      WHERE column_id = ? AND position > ? AND archived = FALSE\n    `,\n      [columnId, position]\n    );\n  }\n\n  /**\n   * Adjusts positions when a task is moved within the same column\n   *\n   * @private\n   * @param columnId Column identifier\n   * @param oldPosition Current position of the task\n   * @param newPosition Target position for the task\n   */\n  private async adjustPositionsForMove(\n    columnId: string,\n    oldPosition: number,\n    newPosition: number\n  ): Promise<void> {\n    if (oldPosition === newPosition) return;\n\n    if (oldPosition < newPosition) {\n      // Moving down: shift tasks between old and new position up by 1\n      await this.db.execute(\n        `\n        UPDATE tasks \n        SET position = position - 1 \n        WHERE column_id = ? AND position > ? AND position <= ? AND archived = FALSE\n      `,\n        [columnId, oldPosition, newPosition]\n      );\n    } else {\n      // Moving up: shift tasks between new and old position down by 1\n      await this.db.execute(\n        `\n        UPDATE tasks \n        SET position = position + 1 \n        WHERE column_id = ? AND position >= ? AND position < ? AND archived = FALSE\n      `,\n        [columnId, newPosition, oldPosition]\n      );\n    }\n  }\n\n  /**\n   * Checks if adding a dependency would create a circular dependency chain\n   *\n   * @private\n   * @param taskId ID of the task that would depend on another\n   * @param dependsOnTaskId ID of the task to depend on\n   * @returns Promise resolving to true if circular dependency would be created\n   *\n   * @description Uses depth-first search to detect cycles in the dependency graph.\n   * This prevents infinite loops and ensures dependency integrity.\n   */\n  private async wouldCreateCircularDependency(\n    taskId: string,\n    dependsOnTaskId: string\n  ): Promise<boolean> {\n    const visited = new Set<string>();\n    const stack = [dependsOnTaskId];\n\n    while (stack.length > 0) {\n      const currentTaskId = stack.pop()!;\n\n      if (currentTaskId === taskId) {\n        return true;\n      }\n\n      if (visited.has(currentTaskId)) {\n        continue;\n      }\n\n      visited.add(currentTaskId);\n\n      // eslint-disable-next-line no-await-in-loop\n      const dependencies = await this.db.query<{ depends_on_task_id: string }>(\n        `\n        SELECT depends_on_task_id FROM task_dependencies WHERE task_id = ?\n      `,\n        [currentTaskId]\n      );\n\n      // Add all dependencies to the stack for processing\n      for (const dep of dependencies) {\n        stack.push(dep.depends_on_task_id);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Retrieves all subtasks of a given parent task\n   *\n   * @param parentTaskId ID of the parent task\n   * @returns Promise resolving to array of subtasks\n   *\n   * @throws {ServiceError} TASKS_FETCH_FAILED - When query fails\n   *\n   * @example\n   * ```typescript\n   * const subtasks = await taskService.getSubtasks('parent-task-123');\n   * ```\n   */\n  async getSubtasks(parentTaskId: string): Promise<Task[]> {\n    try {\n      const query = `\n        SELECT t.* FROM tasks t\n        WHERE t.parent_task_id = ? AND t.archived = FALSE\n        ORDER BY t.position ASC, t.created_at ASC\n      `;\n\n      const tasks = await this.db.query<Task>(query, [parentTaskId]);\n      tasks.forEach(task => TaskService.convertTaskDates(task));\n\n      return tasks;\n    } catch (error) {\n      logger.error('Failed to get subtasks', { error, parentTaskId });\n      throw TaskService.createError('TASKS_FETCH_FAILED', 'Failed to fetch subtasks', error);\n    }\n  }\n\n  /**\n   * Adds a dependency relationship between two tasks\n   *\n   * @param taskId ID of the task that depends on another\n   * @param dependsOnTaskId ID of the task to depend on\n   *\n   * @throws {ServiceError} TASK_NOT_FOUND - When either task doesn't exist\n   * @throws {ServiceError} CIRCULAR_DEPENDENCY - When adding would create a cycle\n   * @throws {ServiceError} SELF_DEPENDENCY - When trying to depend on self\n   * @throws {ServiceError} DEPENDENCY_ADD_FAILED - When creation fails\n   *\n   * @example\n   * ```typescript\n   * // Task B depends on Task A\n   * await taskService.addTaskDependency('task-b-id', 'task-a-id');\n   * ```\n   */\n  async addTaskDependency(taskId: string, dependsOnTaskId: string): Promise<void> {\n    try {\n      // Prevent self-dependency\n      if (taskId === dependsOnTaskId) {\n        throw TaskService.createError('SELF_DEPENDENCY', 'A task cannot depend on itself');\n      }\n\n      // Verify both tasks exist\n      const [task, dependsOnTask] = await Promise.all([\n        this.getTaskById(taskId),\n        this.getTaskById(dependsOnTaskId),\n      ]);\n\n      if (!task) {\n        throw TaskService.createError('TASK_NOT_FOUND', 'Task not found', { taskId });\n      }\n\n      if (!dependsOnTask) {\n        throw TaskService.createError('TASK_NOT_FOUND', 'Dependency task not found', {\n          dependsOnTaskId,\n        });\n      }\n\n      // Check for circular dependencies\n      if (await this.wouldCreateCircularDependency(taskId, dependsOnTaskId)) {\n        throw TaskService.createError(\n          'CIRCULAR_DEPENDENCY',\n          'Adding this dependency would create a circular dependency'\n        );\n      }\n\n      // Check if dependency already exists\n      const existing = await this.db.query<{ id: string }>(\n        `\n        SELECT id FROM task_dependencies \n        WHERE task_id = ? AND depends_on_task_id = ?\n      `,\n        [taskId, dependsOnTaskId]\n      );\n\n      if (existing.length > 0) {\n        return; // Dependency already exists, no need to add\n      }\n\n      await this.db.execute(\n        `\n        INSERT INTO task_dependencies (id, task_id, depends_on_task_id, created_at)\n        VALUES (?, ?, ?, ?)\n      `,\n        [uuidv4(), taskId, dependsOnTaskId, new Date()]\n      );\n\n      logger.info('Task dependency added successfully', { taskId, dependsOnTaskId });\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        (error.message.includes('TASK_') ||\n          error.message.includes('CIRCULAR_') ||\n          error.message.includes('SELF_'))\n      ) {\n        throw error;\n      }\n      logger.error('Failed to add task dependency', { error, taskId, dependsOnTaskId });\n      throw TaskService.createError(\n        'DEPENDENCY_ADD_FAILED',\n        'Failed to add task dependency',\n        error\n      );\n    }\n  }\n\n  /**\n   * Removes a dependency relationship between two tasks\n   *\n   * @param taskId ID of the task that currently depends on another\n   * @param dependsOnTaskId ID of the task to remove dependency on\n   *\n   * @throws {ServiceError} DEPENDENCY_REMOVE_FAILED - When removal fails\n   *\n   * @example\n   * ```typescript\n   * // Remove dependency from Task B to Task A\n   * await taskService.removeTaskDependency('task-b-id', 'task-a-id');\n   * ```\n   */\n  async removeTaskDependency(taskId: string, dependsOnTaskId: string): Promise<void> {\n    try {\n      const result = await this.db.execute(\n        `\n        DELETE FROM task_dependencies \n        WHERE task_id = ? AND depends_on_task_id = ?\n      `,\n        [taskId, dependsOnTaskId]\n      );\n\n      logger.info('Task dependency removed', {\n        taskId,\n        dependsOnTaskId,\n        found: result.changes > 0,\n      });\n    } catch (error) {\n      logger.error('Failed to remove task dependency', { error, taskId, dependsOnTaskId });\n      throw TaskService.createError(\n        'DEPENDENCY_REMOVE_FAILED',\n        'Failed to remove task dependency',\n        error\n      );\n    }\n  }\n\n  /**\n   * Gets all dependencies for a specific task\n   *\n   * @param taskId ID of the task to get dependencies for\n   * @returns Promise resolving to array of task dependencies with related task info\n   *\n   * @throws {ServiceError} TASKS_FETCH_FAILED - When fetching dependencies fails\n   *\n   * @example\n   * ```typescript\n   * const dependencies = await taskService.getTaskDependencies('task-123');\n   * logger.log(`Task depends on ${String(String(dependencies.length))} other tasks`);\n   * ```\n   */\n  async getTaskDependencies(taskId: string): Promise<TaskDependency[]> {\n    try {\n      const query = `\n        SELECT \n          td.*,\n          t.title as depends_on_title,\n          t.status as depends_on_status,\n          t.board_id as depends_on_board_id\n        FROM task_dependencies td\n        JOIN tasks t ON td.depends_on_task_id = t.id\n        WHERE td.task_id = ? AND t.archived = FALSE\n        ORDER BY td.created_at ASC\n      `;\n\n      const dependencies = await this.db.query<TaskDependency>(query, [taskId]);\n      dependencies.forEach(dep => {\n        dep.created_at = new Date(dep.created_at);\n      });\n\n      return dependencies;\n    } catch (error) {\n      logger.error('Failed to get task dependencies', { error, taskId });\n      throw TaskService.createError(\n        'TASKS_FETCH_FAILED',\n        'Failed to fetch task dependencies',\n        error\n      );\n    }\n  }\n\n  /**\n   * Searches tasks by title and description using full-text search\n   *\n   * @param query Search query string\n   * @param options Optional filtering and pagination options\n   * @returns Promise resolving to array of matching tasks\n   *\n   * @throws {ServiceError} TASKS_FETCH_FAILED - When search fails\n   *\n   * @example\n   * ```typescript\n   * // Search for authentication-related tasks\n   * const results = await taskService.searchTasks('authentication jwt');\n   *\n   * // Search with additional filters\n   * const results = await taskService.searchTasks('bug fix', {\n   *   board_id: 'board-123',\n   *   status: 'todo'\n   * });\n   * ```\n   */\n  async searchTasks(\n    query: string,\n    options: Partial<TaskFilters & PaginationOptions> = {}\n  ): Promise<Task[]> {\n    try {\n      const { board_id, column_id, status, limit = 50, offset = 0 } = options;\n\n      let sql = `\n        SELECT t.*, \n               ts.rank\n        FROM tasks_fts ts\n        JOIN tasks t ON ts.rowid = t.rowid\n        WHERE ts.tasks_fts MATCH ?\n          AND t.archived = FALSE\n      `;\n\n      const params: QueryParameters = [query];\n\n      if (board_id) {\n        sql += ' AND t.board_id = ?';\n        params.push(board_id);\n      }\n\n      if (column_id) {\n        sql += ' AND t.column_id = ?';\n        params.push(column_id);\n      }\n\n      if (status) {\n        sql += ' AND t.status = ?';\n        params.push(status);\n      }\n\n      sql += ` ORDER BY ts.rank, t.priority DESC, t.created_at DESC LIMIT ? OFFSET ?`;\n      params.push(limit, offset);\n\n      const tasks = await this.db.query<Task>(sql, params);\n      tasks.forEach(task => TaskService.convertTaskDates(task));\n\n      return tasks;\n    } catch (error) {\n      logger.error('Failed to search tasks', { error, query, options });\n      throw TaskService.createError('TASKS_FETCH_FAILED', 'Failed to search tasks', error);\n    }\n  }\n\n  /**\n   * Converts string date fields to Date objects\n   *\n   * @private\n   * @param task Task object with potentially string-based dates\n   */\n  private static convertTaskDates(task: Task): void {\n    task.created_at = new Date(task.created_at);\n    task.updated_at = new Date(task.updated_at);\n    if (task.due_date) {\n      task.due_date = new Date(task.due_date);\n    }\n  }\n\n  /**\n   * Creates a standardized service error\n   *\n   * @private\n   * @param code Error code identifier\n   * @param message Human-readable error message\n   * @param originalError Optional original error for debugging\n   * @returns ServiceError instance\n   */\n  private static createError(code: string, message: string, originalError?: unknown): ServiceError {\n    const error = new Error(message) as ServiceError;\n    error.code = code;\n    error.statusCode = TaskService.getStatusCodeForError(code);\n    error.details = originalError ? { originalError: String(originalError) } : undefined;\n    return error;\n  }\n\n  /**\n   * Maps error codes to appropriate HTTP status codes\n   *\n   * @private\n   * @param code Error code identifier\n   * @returns HTTP status code (404 for not found, 500 for server errors)\n   */\n  private static getStatusCodeForError(code: string): number {\n    switch (code) {\n      case 'TASK_NOT_FOUND':\n      case 'DEPENDENCY_NOT_FOUND':\n        return 404;\n      case 'CIRCULAR_DEPENDENCY':\n      case 'SELF_DEPENDENCY':\n      case 'INVALID_TITLE':\n        return 400;\n      case 'TASK_CREATE_FAILED':\n      case 'TASK_UPDATE_FAILED':\n      case 'TASK_DELETE_FAILED':\n      case 'DEPENDENCY_ADD_FAILED':\n      case 'DEPENDENCY_REMOVE_FAILED':\n        return 500;\n      case 'TASK_FETCH_FAILED':\n      case 'TASKS_FETCH_FAILED':\n        return 500;\n      default:\n        return 500;\n    }\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/types/ambient.d.ts",
    "messages": [
      {
        "ruleId": "max-classes-per-file",
        "severity": 2,
        "message": "File has too many classes (23). Maximum allowed is 1.",
        "line": 8,
        "column": 1,
        "nodeType": "Program",
        "messageId": "maximumExceeded",
        "endLine": 673,
        "endColumn": 1
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-declaration-merging",
        "severity": 2,
        "message": "Unsafe declaration merging between classes and interfaces.",
        "line": 9,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "unsafeMerging",
        "endLine": 9,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 13,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 13,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [466, 469], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [466, 469], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 14,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 14,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [506, 509], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [506, 509], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 28,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 28,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [945, 948], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [945, 948], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-declaration-merging",
        "severity": 2,
        "message": "Unsafe declaration merging between classes and interfaces.",
        "line": 37,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMerging",
        "endLine": 37,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 46,
        "column": 64,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 46,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1330, 1333], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1330, 1333], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 48,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 48,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1371, 1374], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1371, 1374], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 66,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 66,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1749, 1752], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1749, 1752], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 68,
        "column": 11,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 68,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1766, 1769], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1766, 1769], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 73,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 73,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1944, 1947], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1944, 1947], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 74,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 74,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1998, 2001], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1998, 2001], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'version' is already declared in the upper scope on line 79 column 19.",
        "line": 79,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 79,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'usage' is already declared in the upper scope on line 80 column 19.",
        "line": 80,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 80,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-shadow",
        "severity": 2,
        "message": "'name' is already declared in the upper scope on line 81 column 19.",
        "line": 81,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "noShadow",
        "endLine": 81,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 169,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 169,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4340, 4343], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4340, 4343], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 171,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 171,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4398, 4401], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4398, 4401], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 274,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 274,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7188, 7191], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7188, 7191], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 276,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 276,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7240, 7243], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7240, 7243], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 277,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 277,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7315, 7318], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7315, 7318], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 277,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 277,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7323, 7326], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7323, 7326], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 278,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 278,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7349, 7352], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7349, 7352], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 278,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 278,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7357, 7360], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7357, 7360], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 279,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 279,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7392, 7395], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7392, 7395], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 283,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 283,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7483, 7486], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7483, 7486], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 284,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 284,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7502, 7505], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7502, 7505], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 298,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 298,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7794, 7797], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7794, 7797], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 347,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 347,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8943, 8946], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8943, 8946], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 354,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 354,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9108, 9111], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9108, 9111], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 355,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 355,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9138, 9141], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9138, 9141], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 374,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 374,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9528, 9531], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9528, 9531], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 376,
        "column": 43,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 376,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9577, 9580], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9577, 9580], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 378,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 378,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9644, 9647], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9644, 9647], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 425,
        "column": 77,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 425,
        "endColumn": 80,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10832, 10835], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10832, 10835], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 426,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 426,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10878, 10881], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10878, 10881], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 426,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 426,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10892, 10895], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10892, 10895], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 430,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 430,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11185, 11188], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11185, 11188], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 431,
        "column": 75,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 431,
        "endColumn": 78,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11265, 11268], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11265, 11268], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 434,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 434,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11486, 11489], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11486, 11489], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 435,
        "column": 65,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 435,
        "endColumn": 68,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11556, 11559], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11556, 11559], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 436,
        "column": 67,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 436,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11628, 11631], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11628, 11631], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 437,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 437,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11694, 11697], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11694, 11697], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 438,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 438,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11736, 11739], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11736, 11739], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 438,
        "column": 49,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 438,
        "endColumn": 52,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11750, 11753], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11750, 11753], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 538,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 538,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14541, 14544], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14541, 14544], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 538,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 538,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14554, 14557], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14554, 14557], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 538,
        "column": 70,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 538,
        "endColumn": 73,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14572, 14575], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14572, 14575], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 538,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 538,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14580, 14583], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14580, 14583], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 582,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 582,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15655, 15658], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15655, 15658], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 583,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 583,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15725, 15728], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15725, 15728], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 584,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 584,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15783, 15786], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15783, 15786], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 587,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 587,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15905, 15908], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15905, 15908], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 589,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 589,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16038, 16041], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16038, 16041], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 596,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 596,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16235, 16238], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16235, 16238], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 599,
        "column": 11,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 599,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16311, 16314], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16311, 16314], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 600,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 600,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16355, 16358], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16355, 16358], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 658,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 658,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [17144, 17147], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [17144, 17147], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 666,
        "column": 15,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 666,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [17323, 17326], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [17323, 17326], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 666,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 666,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [17337, 17340], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [17337, 17340], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 53,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Ambient type declarations for third-party packages without @types\n * This file provides basic type definitions for packages that don't have\n * official TypeScript definitions available.\n */\n\n// commander - CLI framework\ndeclare module 'commander' {\n  export interface Command {\n    command(name: string): Command;\n    alias(alias: string): Command;\n    description(description: string): Command;\n    option(flags: string, description?: string, defaultValue?: any): Command;\n    action(fn: (...args: any[]) => void | Promise<void>): Command;\n    argument(name: string, description?: string): Command;\n    arguments(names: string[]): Command;\n    parse(argv?: string[]): Command;\n    help(): void;\n    version(version: string, flags?: string): Command;\n    usage(usage: string): Command;\n    name(name: string): Command;\n    program: Command;\n  }\n\n  export interface Option {\n    flags: string;\n    description?: string;\n    defaultValue?: any;\n    required?: boolean;\n    optional?: boolean;\n    variadic?: boolean;\n    short?: string;\n    long?: string;\n    negate?: boolean;\n  }\n\n  export class Command {\n    constructor(name?: string);\n\n    command(name: string): Command;\n\n    alias(alias: string): Command;\n\n    description(description: string): Command;\n\n    option(flags: string, description?: string, defaultValue?: any): Command;\n\n    action(fn: (...args: any[]) => void | Promise<void>): Command;\n\n    argument(name: string, description?: string): Command;\n\n    arguments(names: string[]): Command;\n\n    parse(argv?: string[]): Command;\n\n    help(): void;\n\n    version(version: string, flags?: string): Command;\n\n    usage(usage: string): Command;\n\n    name(name: string): Command;\n\n    program: Command;\n\n    opts(): Record<string, any>;\n\n    args: any[];\n  }\n\n  export function program(): Command;\n  export function command(name?: string): Command;\n  export function option(flags: string, description?: string, defaultValue?: any): Command;\n  export function action(fn: (...args: any[]) => void | Promise<void>): Command;\n  export function argument(name: string, description?: string): Command;\n  export function arguments(names: string[]): Command;\n  export function parse(argv?: string[]): Command;\n  export function help(): void;\n  export function version(version: string, flags?: string): Command;\n  export function usage(usage: string): Command;\n  export function name(name: string): Command;\n}\n\n// blessed-contrib - Terminal UI library\ndeclare module 'blessed-contrib' {\n  import type { Widgets } from 'blessed';\n\n  export interface GridOptions {\n    rows: number;\n    cols: number;\n    screen?: Widgets.Screen;\n    top?: string | number;\n    left?: string | number;\n    width?: string | number;\n    height?: string | number;\n  }\n\n  export interface ChartOptions {\n    style?: {\n      line?: string;\n      text?: string;\n      baseline?: string;\n    };\n    xLabelPadding?: number;\n    xPadding?: number;\n    showLegend?: boolean;\n    legend?: { width: number };\n    wholeNumbersOnly?: boolean;\n    label?: string;\n  }\n\n  export interface LineChartOptions extends ChartOptions {\n    style?: {\n      line?: string;\n      text?: string;\n      baseline?: string;\n    };\n  }\n\n  export interface BarChartOptions extends ChartOptions {\n    barWidth?: number;\n    barSpacing?: number;\n    xOffset?: number;\n    maxHeight?: number;\n  }\n\n  export interface DonutChartOptions extends ChartOptions {\n    radius?: number;\n    arcWidth?: number;\n    yPadding?: number;\n    data?: Array<{ percent: number; label: string; color: string }>;\n  }\n\n  export interface GaugeOptions extends ChartOptions {\n    percent?: number[];\n    stroke?: string;\n    fill?: string;\n    label?: string;\n  }\n\n  export interface MapOptions extends ChartOptions {\n    style?: {\n      bg?: string;\n      fg?: string;\n    };\n  }\n\n  export interface TableOptions extends ChartOptions {\n    keys?: boolean;\n    fg?: string;\n    selectedFg?: string;\n    selectedBg?: string;\n    interactive?: boolean;\n    label?: string;\n    width?: string | number;\n    height?: string | number;\n    border?: Widgets.Types.TBoxOptions['border'];\n    columnSpacing?: number;\n    columnWidth?: number[];\n  }\n\n  export interface Grid {\n    set(\n      row: number,\n      col: number,\n      rowSpan: number,\n      colSpan: number,\n      obj: Widgets.BlessedElement,\n      opts?: any\n    ): Widgets.BlessedElement;\n    applyLayout(nodes: any): void;\n  }\n\n  export interface LineChart extends Widgets.BlessedElement {\n    setData(\n      data: Array<{ title: string; x: string[]; y: number[]; style?: { line: string } }>\n    ): void;\n  }\n\n  export interface BarChart extends Widgets.BlessedElement {\n    setData(\n      data: Array<{ title: string; x: string[]; y: number[]; style?: { line: string } }>\n    ): void;\n  }\n\n  export interface DonutChart extends Widgets.BlessedElement {\n    setData(data: Array<{ percent: number; label: string; color: string }>): void;\n  }\n\n  export interface Gauge extends Widgets.BlessedElement {\n    setPercent(percent: number): void;\n  }\n\n  export interface Map extends Widgets.BlessedElement {\n    setData(data: Array<{ lat: number; lon: number; color: string }>): void;\n  }\n\n  export interface Table extends Widgets.BlessedElement {\n    setData(data: Array<Array<string>>): void;\n  }\n\n  export interface Log extends Widgets.BlessedElement {\n    log(message: string): void;\n  }\n\n  export interface Sparkline extends Widgets.BlessedElement {\n    setData(data: string[], data2: number[]): void;\n  }\n\n  export function grid(options: GridOptions): Grid;\n  export function line(options: LineChartOptions): LineChart;\n  export function bar(options: BarChartOptions): BarChart;\n  export function donut(options: DonutChartOptions): DonutChart;\n  export function gauge(options: GaugeOptions): Gauge;\n  export function map(options: MapOptions): Map;\n  export function table(options: TableOptions): Table;\n  export function log(options: ChartOptions): Log;\n  export function sparkline(options: ChartOptions): Sparkline;\n}\n\n// cli-table3 - CLI table formatting\ndeclare module 'cli-table3' {\n  export interface TableOptions {\n    chars?: {\n      top?: string;\n      'top-mid'?: string;\n      'top-left'?: string;\n      'top-right'?: string;\n      bottom?: string;\n      'bottom-mid'?: string;\n      'bottom-left'?: string;\n      'bottom-right'?: string;\n      left?: string;\n      'left-mid'?: string;\n      mid?: string;\n      'mid-mid'?: string;\n      right?: string;\n      'right-mid'?: string;\n      middle?: string;\n    };\n    truncate?: string;\n    colWidths?: number[];\n    colAligns?: Array<'left' | 'middle' | 'right'>;\n    head?: string[];\n    wordWrap?: boolean;\n    wrapOnWordBoundary?: boolean;\n    style?: {\n      'padding-left'?: number;\n      'padding-right'?: number;\n      head?: string[];\n      border?: string[];\n      compact?: boolean;\n    };\n  }\n\n  export class Table {\n    constructor(options?: TableOptions);\n\n    push(...rows: Array<string | string[]>): this;\n\n    toString(): string;\n\n    length: number;\n  }\n\n  export default Table;\n}\n\n// enquirer - CLI prompts\ndeclare module 'enquirer' {\n  export interface PromptOptions {\n    name?: string;\n    message?: string;\n    initial?: any;\n    required?: boolean;\n    validate?: (value: any) => boolean | string | Promise<boolean | string>;\n    format?: (value: any) => any;\n    result?: (value: any) => any;\n    skip?: boolean | ((state: any) => boolean);\n    limit?: number;\n    delay?: number;\n    show?: boolean;\n    styles?: any;\n    symbols?: any;\n    indicator?: string;\n    separator?: string;\n    prefix?: string;\n    suffix?: string;\n    header?: string;\n    footer?: string;\n    hint?: string;\n    warn?: string;\n    error?: string;\n    cancel?: string;\n    submit?: string;\n    choices?: Array<{\n      name: string;\n      value: any;\n      hint?: string;\n      disabled?: boolean;\n    }>;\n  }\n\n  export interface TextPromptOptions extends PromptOptions {\n    multiline?: boolean;\n    placeholder?: string;\n  }\n\n  export interface SelectPromptOptions extends PromptOptions {\n    multiple?: boolean;\n    maxChoices?: number;\n    sort?: boolean;\n    linebreak?: boolean;\n    scroll?: boolean;\n  }\n\n  export interface MultiSelectPromptOptions extends SelectPromptOptions {\n    limit?: number;\n    hint?: string;\n    warn?: string;\n  }\n\n  export interface ConfirmPromptOptions extends PromptOptions {\n    initial?: boolean;\n  }\n\n  export interface InputPromptOptions extends PromptOptions {\n    multiline?: boolean;\n    placeholder?: string;\n  }\n\n  export interface PasswordPromptOptions extends PromptOptions {\n    mask?: string;\n  }\n\n  export interface NumberPromptOptions extends PromptOptions {\n    float?: boolean;\n    round?: number;\n    increment?: number;\n    min?: number;\n    max?: number;\n  }\n\n  export interface ScalePromptOptions extends PromptOptions {\n    scale?: Array<{ name: string; message: string; initial?: number }>;\n    margin?: number[];\n    format?: (value: any) => string;\n  }\n\n  export interface SnippetPromptOptions extends PromptOptions {\n    fields?: Array<{\n      name: string;\n      message: string;\n      initial?: any;\n      validate?: (value: any) => boolean | string;\n    }>;\n    template?: string;\n  }\n\n  export interface SortPromptOptions extends PromptOptions {\n    hint?: string;\n    drag?: boolean;\n    numbered?: boolean;\n  }\n\n  export interface TogglePromptOptions extends PromptOptions {\n    enabled?: string;\n    disabled?: string;\n  }\n\n  export class Prompt {\n    constructor(options?: PromptOptions);\n\n    run(): Promise<any>;\n\n    on(event: string, listener: (...args: any[]) => void): this;\n\n    off(event: string, listener: (...args: any[]) => void): this;\n  }\n\n  export class TextPrompt extends Prompt {\n    constructor(options?: TextPromptOptions);\n  }\n\n  export class SelectPrompt extends Prompt {\n    constructor(options?: SelectPromptOptions);\n  }\n\n  export class MultiSelectPrompt extends Prompt {\n    constructor(options?: MultiSelectPromptOptions);\n  }\n\n  export class ConfirmPrompt extends Prompt {\n    constructor(options?: ConfirmPromptOptions);\n  }\n\n  export class InputPrompt extends Prompt {\n    constructor(options?: InputPromptOptions);\n  }\n\n  export class PasswordPrompt extends Prompt {\n    constructor(options?: PasswordPromptOptions);\n  }\n\n  export class NumberPrompt extends Prompt {\n    constructor(options?: NumberPromptOptions);\n  }\n\n  export class ScalePrompt extends Prompt {\n    constructor(options?: ScalePromptOptions);\n  }\n\n  export class SnippetPrompt extends Prompt {\n    constructor(options?: SnippetPromptOptions);\n  }\n\n  export class SortPrompt extends Prompt {\n    constructor(options?: SortPromptOptions);\n  }\n\n  export class TogglePrompt extends Prompt {\n    constructor(options?: TogglePromptOptions);\n  }\n\n  export function prompt(options: PromptOptions | PromptOptions[]): Promise<any>;\n  export function autoComplete(options: any): Promise<any>;\n  export function confirm(options: ConfirmPromptOptions): Promise<boolean>;\n  export function input(options: InputPromptOptions): Promise<string>;\n  export function invisible(options: PasswordPromptOptions): Promise<string>;\n  export function list(options: SelectPromptOptions): Promise<any>;\n  export function multiselect(options: MultiSelectPromptOptions): Promise<any[]>;\n  export function numeral(options: NumberPromptOptions): Promise<number>;\n  export function password(options: PasswordPromptOptions): Promise<string>;\n  export function scale(options: ScalePromptOptions): Promise<any>;\n  export function select(options: SelectPromptOptions): Promise<any>;\n  export function snippet(options: SnippetPromptOptions): Promise<any>;\n  export function sort(options: SortPromptOptions): Promise<any[]>;\n  export function survey(options: any): Promise<any>;\n  export function text(options: TextPromptOptions): Promise<string>;\n  export function toggle(options: TogglePromptOptions): Promise<boolean>;\n}\n\n// ink - React for CLI\ndeclare module 'ink' {\n  import type { ReactNode } from 'react';\n  import { Component } from 'react';\n\n  export interface BoxProps {\n    margin?: number | { top?: number; bottom?: number; left?: number; right?: number };\n    marginX?: number;\n    marginY?: number;\n    padding?: number | { top?: number; bottom?: number; left?: number; right?: number };\n    paddingX?: number;\n    paddingY?: number;\n    borderStyle?:\n      | 'single'\n      | 'double'\n      | 'round'\n      | 'bold'\n      | 'singleDouble'\n      | 'doubleSingle'\n      | 'classic';\n    borderColor?: string;\n    borderDimColor?: string;\n    borderBackgroundColor?: string;\n    borderDirection?: 'horizontal' | 'vertical' | 'left' | 'right' | 'top' | 'bottom';\n    children?: ReactNode;\n  }\n\n  export interface TextProps {\n    bold?: boolean;\n    italic?: boolean;\n    underline?: boolean;\n    strikethrough?: boolean;\n    dimColor?: boolean;\n    color?: string;\n    backgroundColor?: string;\n    children?: ReactNode;\n  }\n\n  export interface NewlineProps {\n    count?: number;\n  }\n\n  export interface SpacerProps {\n    direction?: 'horizontal' | 'vertical';\n  }\n\n  export interface StaticProps {\n    items?: ReactNode[];\n    placeholder?: ReactNode;\n  }\n\n  export interface TransformProps {\n    transform: (output: string) => string;\n    children?: ReactNode;\n  }\n\n  export interface UseInputOptions {\n    isActive?: boolean;\n  }\n\n  export interface UseAppOptions {\n    exitOnCtrlC?: boolean;\n  }\n\n  export interface AppProps extends UseAppOptions {\n    children?: ReactNode;\n  }\n\n  export class Box extends Component<BoxProps> {}\n  export class Text extends Component<TextProps> {}\n  export class Newline extends Component<NewlineProps> {}\n  export class Spacer extends Component<SpacerProps> {}\n  export class Static extends Component<StaticProps> {}\n  export class Transform extends Component<TransformProps> {}\n  export class App extends Component<AppProps> {}\n\n  export function render(\n    element: ReactNode,\n    options?: { stdout?: NodeJS.WriteStream; stdin?: NodeJS.ReadStream }\n  ): {\n    waitUntilExit(): Promise<void>;\n    unmount(): void;\n    rerender(element: ReactNode): void;\n  };\n\n  export function useInput(\n    inputHandler: (\n      input: string,\n      key: { name: string; ctrl: boolean; meta: boolean; shift: boolean }\n    ) => void,\n    options?: UseInputOptions\n  ): void;\n  export function useApp(): { exit: (error?: Error) => void };\n  export function measureElement(element: ReactNode): { width: number; height: number };\n  export function renderToString(element: ReactNode): string;\n  export function createElement(type: any, props?: any, ...children: any[]): any;\n\n  export default App;\n}\n\n// ink-testing-library - Testing utilities for Ink\ndeclare module 'ink-testing-library' {\n  import type { ReactElement } from 'react';\n\n  export interface RenderOptions {\n    stdout?: NodeJS.WriteStream;\n    stdin?: NodeJS.ReadStream;\n    debug?: boolean;\n  }\n\n  export interface RenderResult {\n    lastFrame(): string;\n    frames(): string[];\n    unmount(): void;\n    waitUntilExit(): Promise<void>;\n    stdin: {\n      write(data: string): void;\n    };\n    stdout: {\n      write(data: string): void;\n    };\n  }\n\n  export function render(element: ReactElement, options?: RenderOptions): RenderResult;\n  export function cleanup(): void;\n  export function waitFor(\n    condition: () => boolean,\n    options?: { timeout?: number; interval?: number }\n  ): Promise<void>;\n  export function waitForElementToBeRemoved(\n    condition: () => boolean,\n    options?: { timeout?: number; interval?: number }\n  ): Promise<void>;\n}\n\n// listr2 - Task list runner\ndeclare module 'listr2' {\n  export interface TaskOptions {\n    title?: string;\n    task?: (ctx: any, task: Task) => void | Promise<void>;\n    skip?: boolean | ((ctx: any) => boolean | string);\n    enabled?: boolean | ((ctx: any) => boolean);\n    exitOnError?: boolean;\n    retry?: number | { tries: number; delay?: number };\n    rollback?: (ctx: any, task: Task) => void | Promise<void>;\n    renderer?: 'default' | 'verbose' | 'silent' | 'test' | 'simple';\n    rendererOptions?: any;\n  }\n\n  export interface ListrOptions {\n    concurrent?: boolean | number;\n    exitOnError?: boolean;\n    renderer?: 'default' | 'verbose' | 'silent' | 'test' | 'simple';\n    rendererOptions?: any;\n    nonTty?: boolean;\n    registerSignalListeners?: boolean;\n    ctx?: any;\n    silentRendererCondition?: (output: any) => boolean;\n  }\n\n  export class Task {\n    constructor(options: TaskOptions);\n\n    title: string;\n\n    output: string;\n\n    isEnabled(): boolean;\n\n    isSkipped(): boolean;\n\n    isCompleted(): boolean;\n\n    isPending(): boolean;\n\n    isFailed(): boolean;\n\n    isRetrying(): boolean;\n\n    hasFailed(): boolean;\n\n    hasTitle(): boolean;\n\n    hasSubtasks(): boolean;\n\n    isPrompt(): boolean;\n\n    isPaused(): boolean;\n\n    isSettled(): boolean;\n\n    isPending(): boolean;\n\n    isCompleted(): boolean;\n\n    isFailed(): boolean;\n\n    isSkipped(): boolean;\n\n    isEnabled(): boolean;\n\n    isRetrying(): boolean;\n\n    hasFailed(): boolean;\n\n    hasTitle(): boolean;\n\n    hasSubtasks(): boolean;\n\n    isPrompt(): boolean;\n\n    isPaused(): boolean;\n\n    isSettled(): boolean;\n\n    run(ctx?: any): Promise<void>;\n  }\n\n  export class Listr {\n    constructor(tasks: TaskOptions[], options?: ListrOptions);\n\n    add(tasks: TaskOptions | TaskOptions[]): this;\n\n    run(ctx?: any): Promise<any>;\n\n    newListr(tasks: TaskOptions[], options?: ListrOptions): Listr;\n  }\n\n  export default Listr;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/types/branded.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/types/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/databaseValidation.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async function 'validateBatch' has no 'await' expression.",
        "line": 300,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingAwait",
        "endLine": 300,
        "endColumn": 39,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/errors.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.",
        "line": 619,
        "column": 9,
        "nodeType": "Punctuator",
        "messageId": "preferNullishOverOr",
        "endLine": 619,
        "endColumn": 11,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [17279, 17281], "text": "??" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 780,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 780,
        "endColumn": 44
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed async function.",
        "line": 782,
        "column": 24,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 782,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 796,
        "column": 9,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 796,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 796,
        "column": 22,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 796,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .apply on an `any` value.",
        "line": 796,
        "column": 37,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 796,
        "endColumn": 42
      },
      {
        "ruleId": "space-before-function-paren",
        "severity": 2,
        "message": "Unexpected space before function parentheses.",
        "line": 831,
        "column": 45,
        "nodeType": "FunctionDeclaration",
        "messageId": "unexpectedSpace",
        "endLine": 831,
        "endColumn": 46,
        "fix": { "range": [23365, 23366], "text": "" }
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 873,
        "column": 10,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 873,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 873,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 873,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [24594, 24597], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [24594, 24597], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 875,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 875,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [24699, 24702], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [24699, 24702], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe spread of an `any` array type.",
        "line": 876,
        "column": 15,
        "nodeType": "SpreadElement",
        "messageId": "unsafeArraySpread",
        "endLine": 876,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 878,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 878,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [name] on an `any` value.",
        "line": 880,
        "column": 62,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 880,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 990,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 990,
        "endColumn": 27
      },
      {
        "ruleId": "no-loop-func",
        "severity": 2,
        "message": "Function declared in a loop contains unsafe references to variable(s) 'delay'.",
        "line": 1009,
        "column": 25,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "unsafeRefs",
        "endLine": 1009,
        "endColumn": 62
      },
      {
        "ruleId": "no-promise-executor-return",
        "severity": 2,
        "message": "Return values from promise executor functions cannot be read.",
        "line": 1009,
        "column": 36,
        "nodeType": "CallExpression",
        "messageId": "returnsValue",
        "endLine": 1009,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "wrapBraces",
            "fix": { "range": [28929, 28955], "text": "{setTimeout(resolve, delay)}" },
            "desc": "Wrap the expression in `{}`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-use-before-define",
        "severity": 2,
        "message": "'isRetryableError' was used before it was defined.",
        "line": 1083,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "noUseBeforeDefine",
        "endLine": 1083,
        "endColumn": 65
      },
      {
        "ruleId": "no-promise-executor-return",
        "severity": 2,
        "message": "Return values from promise executor functions cannot be read.",
        "line": 1100,
        "column": 36,
        "nodeType": "CallExpression",
        "messageId": "returnsValue",
        "endLine": 1100,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "wrapBraces",
            "fix": { "range": [31478, 31509], "text": "{setTimeout(resolve, finalDelay)}" },
            "desc": "Wrap the expression in `{}`."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 1163,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 1163,
        "endColumn": 37
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed async function.",
        "line": 1175,
        "column": 10,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 1175,
        "endColumn": 28
      },
      {
        "ruleId": "space-before-function-paren",
        "severity": 2,
        "message": "Missing space before function parentheses.",
        "line": 1175,
        "column": 28,
        "nodeType": "FunctionExpression",
        "messageId": "missingSpace",
        "endLine": 1175,
        "endColumn": 29,
        "fix": { "range": [33523, 33523], "text": " " }
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "max-classes-per-file",
        "severity": 2,
        "message": "File has too many classes (15). Maximum allowed is 1.",
        "line": 26,
        "column": 1,
        "nodeType": "Program",
        "messageId": "maximumExceeded",
        "endLine": 1308,
        "endColumn": 1,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "default-param-last",
        "severity": 2,
        "message": "Default parameters should be last.",
        "line": 108,
        "column": 5,
        "nodeType": "AssignmentPattern",
        "messageId": "shouldBeLast",
        "endLine": 108,
        "endColumn": 29,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "default-param-last",
        "severity": 2,
        "message": "Default parameters should be last.",
        "line": 226,
        "column": 5,
        "nodeType": "AssignmentPattern",
        "messageId": "shouldBeLast",
        "endLine": 226,
        "endColumn": 48,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "default-param-last",
        "severity": 2,
        "message": "Default parameters should be last.",
        "line": 249,
        "column": 15,
        "nodeType": "AssignmentPattern",
        "messageId": "shouldBeLast",
        "endLine": 249,
        "endColumn": 44,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "default-param-last",
        "severity": 2,
        "message": "Default parameters should be last.",
        "line": 344,
        "column": 5,
        "nodeType": "AssignmentPattern",
        "messageId": "shouldBeLast",
        "endLine": 344,
        "endColumn": 44,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'descriptor'.",
        "line": 782,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 782,
        "endColumn": 15,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "default-param-last",
        "severity": 2,
        "message": "Default parameters should be last.",
        "line": 1058,
        "column": 3,
        "nodeType": "AssignmentPattern",
        "messageId": "shouldBeLast",
        "endLine": 1058,
        "endColumn": 38,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 2,
    "fixableWarningCount": 0,
    "source": "/**\n * Error management utilities for the MCP Kanban system\n *\n * @module utils/errors\n * @description Provides a comprehensive error handling system with type-safe error classes,\n * global error handlers, retry mechanisms, and circuit breakers. This module ensures consistent\n * error handling across the application with proper logging and context preservation.\n *\n * @example\n * ```typescript\n * // Using specific error classes\n * throw new ValidationError('Invalid task title', { field: 'title', value: '' });\n *\n * // Using error factories\n * throw createNotFoundError('Task', taskId);\n *\n * // Using error decorators\n * @createServiceErrorHandler('TaskService')\n * async updateTask(id: string, data: UpdateTaskData) {\n *   // Method implementation\n * }\n * ```\n */\n\n/* eslint-disable max-classes-per-file, no-param-reassign, default-param-last */\nimport { logger } from '@/utils/logger';\nimport type { ServiceError } from '@/types';\nimport { isError, isRecord, getErrorMessage } from './typeGuards';\n\n/**\n * Structured error details type for providing additional context\n * @typedef {string | number | boolean | null | undefined | Object | Array} ErrorDetails\n */\nexport type ErrorDetails =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | { [key: string]: ErrorDetails }\n  | ErrorDetails[];\n\n/**\n * Context information for error tracking and debugging\n *\n * @interface ErrorContext\n * @property {string} service - The service where the error occurred\n * @property {string} method - The method that threw the error\n * @property {string} [userId] - Optional user ID for user-specific errors\n * @property {string} [requestId] - Optional request ID for tracing\n * @property {Record<string, unknown>} [metadata] - Additional contextual data\n */\nexport interface ErrorContext {\n  service: string;\n  method: string;\n  userId?: string;\n  requestId?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Base error class for all service-level errors in the application\n *\n * @class BaseServiceError\n * @extends Error\n * @implements ServiceError\n *\n * @description Provides a consistent error structure with error codes, HTTP status codes,\n * detailed error information, and context for debugging. All custom errors should extend this class.\n *\n * @example\n * ```typescript\n * class CustomError extends BaseServiceError {\n *   constructor(message: string, details?: ErrorDetails) {\n *     super('CUSTOM_ERROR', message, 400, details);\n *   }\n * }\n * ```\n */\nexport class BaseServiceError extends Error implements ServiceError {\n  /** Unique error code for identifying error types */\n  public readonly code: string;\n\n  /** HTTP status code for API responses */\n  public readonly statusCode: number;\n\n  /** Additional error details for debugging */\n  public readonly details?: ErrorDetails;\n\n  /** Context information about where and when the error occurred */\n  public readonly context?: ErrorContext | undefined;\n\n  /** Timestamp when the error was created */\n  public readonly timestamp: Date;\n\n  /**\n   * Creates a new BaseServiceError instance\n   *\n   * @param {string} code - Unique error code (e.g., 'VALIDATION_ERROR')\n   * @param {string} message - Human-readable error message\n   * @param {number} [statusCode=500] - HTTP status code\n   * @param {ErrorDetails} [details] - Additional error details\n   * @param {ErrorContext} [context] - Error context information\n   */\n  constructor(\n    code: string,\n    message: string,\n    statusCode: number = 500,\n    details?: ErrorDetails,\n    context?: ErrorContext\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.statusCode = statusCode;\n    this.details = details;\n    this.context = context ?? undefined;\n    this.timestamp = new Date();\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * Serializes the error to a JSON-compatible object\n   *\n   * @returns {Record<string, unknown>} JSON representation of the error\n   */\n  toJSON(): Record<string, unknown> {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message,\n      statusCode: this.statusCode,\n      details: this.details,\n      context: this.context,\n      timestamp: this.timestamp,\n      stack: this.stack,\n    };\n  }\n}\n\n/**\n * Error thrown when input validation fails\n *\n * @class ValidationError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new ValidationError('Invalid email format', {\n *   field: 'email',\n *   value: 'not-an-email',\n *   pattern: 'email'\n * });\n * ```\n */\nexport class ValidationError extends BaseServiceError {\n  constructor(message: string, details?: ErrorDetails, context?: ErrorContext) {\n    super('VALIDATION_ERROR', message, 400, details, context);\n  }\n}\n\n/**\n * Error thrown when a requested resource cannot be found\n *\n * @class NotFoundError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new NotFoundError('Task', taskId);\n * // Message: \"Task with identifier 'task-123' not found\"\n * ```\n */\nexport class NotFoundError extends BaseServiceError {\n  /**\n   * Creates a NotFoundError\n   *\n   * @param {string} resource - The type of resource that wasn't found\n   * @param {string | number} [id] - The identifier of the missing resource\n   * @param {ErrorContext} [context] - Additional error context\n   */\n  constructor(resource: string, id?: string | number, context?: ErrorContext) {\n    const identifier = id ?? 'unknown';\n    const message =\n      id !== undefined\n        ? `${String(resource)} with identifier '${String(identifier)}' not found`\n        : `${String(resource)} not found`;\n    super('NOT_FOUND', message, 404, { resource, identifier }, context);\n  }\n}\n\n/**\n * Error thrown when there's a conflict with the current state\n *\n * @class ConflictError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new ConflictError('Task already exists', {\n *   existingId: 'task-123',\n *   attemptedTitle: 'Duplicate Task'\n * });\n * ```\n */\nexport class ConflictError extends BaseServiceError {\n  constructor(message: string, details?: ErrorDetails, context?: ErrorContext) {\n    super('CONFLICT', message, 409, details, context);\n  }\n}\n\n/**\n * Error thrown when authentication is required but not provided\n *\n * @class UnauthorizedError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new UnauthorizedError('Invalid token', { token: 'Bearer ...' });\n * ```\n */\nexport class UnauthorizedError extends BaseServiceError {\n  constructor(\n    message: string = 'Authentication required',\n    details?: ErrorDetails,\n    context?: ErrorContext\n  ) {\n    super('UNAUTHORIZED', message, 401, details, context);\n  }\n}\n\n/**\n * Error thrown when user lacks permission for an action\n *\n * @class ForbiddenError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new ForbiddenError('Insufficient permissions', {\n *   required: 'admin',\n *   actual: 'user'\n * });\n * ```\n */\nexport class ForbiddenError extends BaseServiceError {\n  constructor(message: string = 'Forbidden', details?: ErrorDetails, context?: ErrorContext) {\n    super('FORBIDDEN', message, 403, details, context);\n  }\n}\n\n/**\n * Error thrown for internal server errors\n *\n * @class InternalServerError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new InternalServerError('Database connection failed', {\n *   component: 'database',\n *   error: originalError.message\n * });\n * ```\n */\nexport class InternalServerError extends BaseServiceError {\n  constructor(message: string, details?: ErrorDetails, context?: ErrorContext) {\n    super('INTERNAL_SERVER_ERROR', message, 500, details, context);\n  }\n}\n\n/**\n * Error thrown for database-related failures\n *\n * @class DatabaseError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * try {\n *   await db.query(sql);\n * } catch (error) {\n *   throw new DatabaseError('Query failed', error);\n * }\n * ```\n */\nexport class DatabaseError extends BaseServiceError {\n  /**\n   * Creates a DatabaseError\n   *\n   * @param {string} message - Error description\n   * @param {Error | ErrorDetails} [originalError] - The original database error\n   * @param {ErrorContext} [context] - Additional error context\n   */\n  constructor(message: string, originalError?: Error | ErrorDetails, context?: ErrorContext) {\n    const details =\n      originalError instanceof Error\n        ? { originalError: originalError.message }\n        : (originalError ?? { originalError: undefined });\n    super('DATABASE_ERROR', message, 500, details, context);\n  }\n}\n\n/**\n * Error thrown when task dependencies are invalid\n *\n * @class DependencyError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new DependencyError('Circular dependency detected', {\n *   taskId: 'task-1',\n *   dependsOn: 'task-2',\n *   cycle: ['task-1', 'task-2', 'task-1']\n * });\n * ```\n */\nexport class DependencyError extends BaseServiceError {\n  constructor(message: string, details?: ErrorDetails, context?: ErrorContext) {\n    super('DEPENDENCY_ERROR', message, 400, details, context);\n  }\n}\n\n/**\n * Error thrown when rate limits are exceeded\n *\n * @class RateLimitError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new RateLimitError('Too many requests', {\n *   limit: 100,\n *   window: '1 hour',\n *   retryAfter: 3600\n * });\n * ```\n */\nexport class RateLimitError extends BaseServiceError {\n  constructor(\n    message: string = 'Rate limit exceeded',\n    details?: ErrorDetails,\n    context?: ErrorContext\n  ) {\n    super('RATE_LIMIT_EXCEEDED', message, 429, details, context);\n  }\n}\n\n/**\n * Error thrown when external service calls fail\n *\n * @class ExternalServiceError\n * @extends BaseServiceError\n *\n * @example\n * ```typescript\n * throw new ExternalServiceError('OpenAI', 'API timeout', {\n *   endpoint: '/v1/completions',\n *   timeout: 30000\n * });\n * ```\n */\nexport class ExternalServiceError extends BaseServiceError {\n  /**\n   * Creates an ExternalServiceError\n   *\n   * @param {string} service - Name of the external service\n   * @param {string} message - Error description\n   * @param {ErrorDetails} [details] - Additional error details\n   * @param {ErrorContext} [context] - Error context\n   */\n  constructor(service: string, message: string, details?: ErrorDetails, context?: ErrorContext) {\n    super(\n      'EXTERNAL_SERVICE_ERROR',\n      `${String(service)}: ${String(message)}`,\n      502,\n      details,\n      context\n    );\n  }\n}\n\n/**\n * Type-safe error factory functions for consistent error creation\n * @typedef {Function} ErrorFactory\n */\ntype ErrorFactory<T extends unknown[]> = (...args: T) => BaseServiceError;\n\n/**\n * Creates a validation error with consistent formatting\n *\n * @function createValidationError\n * @param {string} message - Error message\n * @param {ErrorDetails} [details] - Additional details\n * @param {ErrorContext} [context] - Error context\n * @returns {ValidationError} The created validation error\n *\n * @example\n * ```typescript\n * throw createValidationError('Invalid email', { field: 'email' });\n * ```\n */\nexport const createValidationError: ErrorFactory<[string, ErrorDetails?, ErrorContext?]> = (\n  message,\n  details,\n  context\n) => new ValidationError(message, details, context);\n\n/**\n * Creates a not found error with consistent formatting\n *\n * @function createNotFoundError\n * @param {string} resource - Resource type\n * @param {string | number} id - Resource identifier\n * @param {ErrorContext} [context] - Error context\n * @returns {NotFoundError} The created not found error\n *\n * @example\n * ```typescript\n * throw createNotFoundError('Task', taskId);\n * ```\n */\nexport const createNotFoundError: ErrorFactory<[string, string | number, ErrorContext?]> = (\n  resource,\n  id,\n  context\n) => new NotFoundError(resource, id, context);\n\n/**\n * Creates a database error with consistent formatting\n *\n * @function createDatabaseError\n * @param {string} message - Error message\n * @param {ErrorDetails} [details] - Additional details\n * @param {ErrorContext} [context] - Error context\n * @returns {DatabaseError} The created database error\n *\n * @example\n * ```typescript\n * throw createDatabaseError('Connection failed', { host: 'localhost' });\n * ```\n */\nexport const createDatabaseError: ErrorFactory<[string, ErrorDetails?, ErrorContext?]> = (\n  message,\n  details,\n  context\n) => new DatabaseError(message, details, context);\n\n/**\n * Error handler function type\n * @typedef {Function} ErrorHandler\n * @param {Error} error - The error to handle\n * @param {ErrorContext} [context] - Error context\n * @returns {ServiceError} The handled service error\n */\nexport type ErrorHandler = (error: Error, context?: ErrorContext) => ServiceError;\n\n/**\n * Manages custom error handlers for different error types\n *\n * @class ErrorHandlerManager\n *\n * @example\n * ```typescript\n * const errorManager = new ErrorHandlerManager();\n * errorManager.registerHandler('TypeError', (error, context) => {\n *   return new ValidationError('Type error: ' + error.message);\n * });\n * ```\n */\nexport class ErrorHandlerManager {\n  private readonly handlers: Map<string, ErrorHandler> = new Map();\n\n  /**\n   * Registers a custom error handler for a specific error type\n   *\n   * @param {string} errorType - The error constructor name to handle\n   * @param {ErrorHandler} handler - The handler function\n   */\n  registerHandler(errorType: string, handler: ErrorHandler): void {\n    this.handlers.set(errorType, handler);\n  }\n\n  /**\n   * Handles an error using registered handlers or default logic\n   *\n   * @param {Error} error - The error to handle\n   * @param {ErrorContext} [context] - Error context\n   * @returns {ServiceError} The processed service error\n   */\n  handleError(error: Error, context?: ErrorContext): ServiceError {\n    if (error instanceof BaseServiceError) {\n      return error;\n    }\n\n    const errorType = error.constructor.name;\n    const handler = this.handlers.get(errorType);\n\n    if (handler) {\n      return handler(error, context);\n    }\n\n    // Default to generic error handling\n    return ErrorHandlerManager.handleGenericError(error, context);\n  }\n\n  /**\n   * Handles generic errors with pattern matching for common database errors\n   *\n   * @private\n   * @static\n   * @param {Error} error - The error to handle\n   * @param {ErrorContext} [context] - Error context\n   * @returns {ServiceError} The appropriate service error\n   */\n  private static handleGenericError(error: Error, context?: ErrorContext): ServiceError {\n    if (error.message.includes('UNIQUE constraint failed')) {\n      return new ConflictError(\n        'Resource already exists',\n        { originalError: error.message },\n        context\n      );\n    }\n\n    if (error.message.includes('FOREIGN KEY constraint failed')) {\n      return new ValidationError(\n        'Invalid reference to related resource',\n        { originalError: error.message },\n        context\n      );\n    }\n\n    if (error.message.includes('NOT NULL constraint failed')) {\n      return new ValidationError(\n        'Required field is missing',\n        { originalError: error.message },\n        context\n      );\n    }\n\n    if (error.message.includes('CHECK constraint failed')) {\n      return new ValidationError('Invalid field value', { originalError: error.message }, context);\n    }\n\n    if (error.message.includes('database is locked')) {\n      return new BaseServiceError(\n        'DATABASE_BUSY',\n        'Database is temporarily busy',\n        503,\n        { originalError: error.message },\n        context\n      );\n    }\n\n    if (error.message.includes('no such table')) {\n      return new BaseServiceError(\n        'DATABASE_SCHEMA_ERROR',\n        'Database schema error',\n        500,\n        { originalError: error.message },\n        context\n      );\n    }\n\n    return new BaseServiceError(\n      'INTERNAL_ERROR',\n      'An internal error occurred',\n      500,\n      { originalError: error.message },\n      context\n    );\n  }\n}\n\n/**\n * Global error handler for consistent error processing across the application\n *\n * @class GlobalErrorHandler\n *\n * @description Provides centralized error handling with type-specific handlers,\n * automatic error classification, and context preservation. Handles various error\n * types including validation errors, database errors, and external service errors.\n *\n * @example\n * ```typescript\n * try {\n *   await someOperation();\n * } catch (error) {\n *   throw globalErrorHandler.handleError(error, {\n *     service: 'MyService',\n *     method: 'someOperation'\n *   });\n * }\n * ```\n */\nclass GlobalErrorHandler {\n  private readonly errorHandlers = new Map<\n    string,\n    (error: unknown, context: ErrorContext) => BaseServiceError\n  >();\n\n  constructor() {\n    this.registerDefaultHandlers();\n  }\n\n  private registerDefaultHandlers(): void {\n    this.registerHandler('ValidationError', (error: unknown, context: ErrorContext) => {\n      const message = getErrorMessage(error);\n      return new ValidationError(message, undefined, context);\n    });\n\n    this.registerHandler('ZodError', (error: unknown, context: ErrorContext) => {\n      const zodError = error as { errors?: Array<{ path: string[]; message: string }> };\n      const messages = zodError.errors?.map(\n        err => `${String(err.path.join('.'))}: ${String(err.message)}`\n      ) || [getErrorMessage(error)];\n      return new ValidationError(\n        `Validation failed: ${String(messages.join(', '))}`,\n        zodError.errors,\n        context\n      );\n    });\n\n    this.registerHandler('TypeError', (error: unknown, context: ErrorContext) => {\n      const message = getErrorMessage(error);\n      if (message.includes('Cannot read') || message.includes('undefined')) {\n        return new BaseServiceError(\n          'INVALID_INPUT',\n          'Invalid input data structure',\n          400,\n          { originalError: message },\n          context\n        );\n      }\n      return new BaseServiceError(\n        'TYPE_ERROR',\n        'Type error occurred',\n        500,\n        { originalError: message },\n        context\n      );\n    });\n\n    // Add more default handlers...\n  }\n\n  /**\n   * Registers a custom error handler for a specific error type\n   *\n   * @param {string} errorName - The error constructor name\n   * @param {Function} handler - The handler function\n   *\n   * @example\n   * ```typescript\n   * globalErrorHandler.registerHandler('CustomError', (error, context) => {\n   *   return new ValidationError('Custom error: ' + error.message);\n   * });\n   * ```\n   */\n  registerHandler(\n    errorName: string,\n    handler: (error: unknown, context: ErrorContext) => BaseServiceError\n  ): void {\n    this.errorHandlers.set(errorName, handler);\n  }\n\n  /**\n   * Handles any error and converts it to a BaseServiceError\n   *\n   * @param {unknown} error - The error to handle\n   * @param {ErrorContext} context - Error context information\n   * @returns {BaseServiceError} The processed service error\n   *\n   * @example\n   * ```typescript\n   * const serviceError = globalErrorHandler.handleError(error, {\n   *   service: 'TaskService',\n   *   method: 'createTask',\n   *   userId: 'user-123'\n   * });\n   * ```\n   */\n  handleError(error: unknown, context: ErrorContext): BaseServiceError {\n    // If already a BaseServiceError, enhance with context\n    if (error instanceof BaseServiceError) {\n      if (!error.context) {\n        // Create a new instance of the same error type with context\n        if (error instanceof ValidationError) {\n          return new ValidationError(error.message, error.details, context);\n        }\n        if (error instanceof NotFoundError) {\n          return new NotFoundError(\n            ((error.details as Record<string, unknown>)?.resource as string) || 'Resource',\n            ((error.details as Record<string, unknown>)?.identifier as string | number) ||\n              'unknown',\n            context\n          );\n        }\n        if (error instanceof ConflictError) {\n          return new ConflictError(error.message, error.details, context);\n        }\n        if (error instanceof DatabaseError) {\n          return new DatabaseError(error.message, error.details, context);\n        }\n        // For other error types, return as is with context\n        return new BaseServiceError(\n          error.code,\n          error.message,\n          error.statusCode,\n          error.details,\n          context\n        );\n      }\n      return error;\n    }\n\n    // Handle Error instances\n    if (isError(error)) {\n      const handler = this.errorHandlers.get(error.name);\n      if (handler) {\n        return handler(error, context);\n      }\n\n      // Default error handling\n      return new InternalServerError(\n        error.message,\n        {\n          errorName: error.name,\n          stack: error.stack,\n          originalError: error.message,\n        },\n        context\n      );\n    }\n\n    // Handle unknown errors\n    return new InternalServerError(\n      'An unexpected error occurred',\n      { originalError: getErrorMessage(error) },\n      context\n    );\n  }\n}\n\n/**\n * Singleton instance of the global error handler\n * @constant {GlobalErrorHandler}\n */\nexport const globalErrorHandler = new GlobalErrorHandler();\n\n/**\n * Creates a method decorator for automatic error handling\n *\n * @function createServiceErrorHandler\n * @param {string} serviceName - The name of the service\n * @returns {MethodDecorator} The error handler decorator\n *\n * @description Wraps service methods with automatic error handling, logging,\n * and context preservation. Converts all errors to appropriate ServiceError types.\n *\n * @example\n * ```typescript\n * class TaskService {\n *   @createServiceErrorHandler('TaskService')\n *   async createTask(data: CreateTaskData): Promise<Task> {\n *     // Method implementation\n *   }\n * }\n * ```\n */\nexport function createServiceErrorHandler(serviceName: string) {\n  return function handleServiceError<T extends Record<string, unknown>>(\n    _target: T,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ): PropertyDescriptor {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (this: T, ...args: unknown[]): Promise<unknown> {\n      const context: ErrorContext = {\n        service: serviceName,\n        method: propertyKey,\n        metadata: {\n          args: args.map((arg, index) => ({\n            index,\n            type: typeof arg,\n            value: typeof arg === 'object' ? '[object]' : String(arg),\n          })),\n        },\n      };\n\n      try {\n        return await originalMethod.apply(this, args);\n      } catch (error) {\n        const serviceError = globalErrorHandler.handleError(error, context);\n\n        logger.error('Service method error', {\n          service: serviceName,\n          method: propertyKey,\n          error: serviceError.toJSON(),\n        });\n\n        throw serviceError;\n      }\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * Wraps a function with error context for better error tracking\n *\n * @function withErrorContext\n * @template TFn - The function type\n * @param {TFn} fn - The function to wrap\n * @param {Partial<ErrorContext>} context - Error context to attach\n * @returns {TFn} The wrapped function\n *\n * @example\n * ```typescript\n * const wrappedFn = withErrorContext(\n *   async (id: string) => await fetchTask(id),\n *   { service: 'TaskService', method: 'getTask' }\n * );\n * ```\n */\nexport function withErrorContext<TFn extends (...args: unknown[]) => unknown>(\n  fn: TFn,\n  context: Partial<ErrorContext>\n): TFn {\n  return ((...args: unknown[]) => {\n    try {\n      const result = fn(...args);\n\n      if (result instanceof Promise) {\n        return result.catch((error: unknown) => {\n          throw globalErrorHandler.handleError(error, context as ErrorContext);\n        });\n      }\n\n      return result;\n    } catch (error) {\n      throw globalErrorHandler.handleError(error, context as ErrorContext);\n    }\n  }) as TFn;\n}\n\n/**\n * Creates a class decorator that adds error handling to all methods\n *\n * @function createErrorBoundary\n * @param {string} serviceName - The name of the service\n * @returns {ClassDecorator} The error boundary decorator\n *\n * @description Automatically wraps all class methods with error handling,\n * providing consistent error processing and logging across the entire class.\n *\n * @example\n * ```typescript\n * @createErrorBoundary('TaskService')\n * export class TaskService {\n *   async createTask(data: CreateTaskData): Promise<Task> {\n *     // All methods in this class are automatically wrapped\n *   }\n * }\n * ```\n */\nexport function createErrorBoundary(serviceName: string) {\n  return function <T extends new (...args: any[]) => object>(constructor: T): T {\n    return class extends constructor {\n      constructor(...args: any[]) {\n        super(...args);\n\n        const prototype = Object.getPrototypeOf(this);\n        const methodNames = Object.getOwnPropertyNames(prototype).filter(\n          name => name !== 'constructor' && typeof prototype[name] === 'function'\n        );\n\n        methodNames.forEach(methodName => {\n          const originalMethod = (prototype as Record<string, unknown>)[methodName];\n          if (typeof originalMethod === 'function') {\n            (prototype as Record<string, unknown>)[methodName] = withErrorContext(\n              originalMethod.bind(this),\n              {\n                service: serviceName,\n                method: methodName,\n              }\n            );\n          }\n        });\n      }\n    } as T;\n  };\n}\n\n/**\n * Standard error codes used throughout the application\n *\n * @constant {Object} ErrorCodes\n * @property {string} VALIDATION_ERROR - Input validation failed\n * @property {string} NOT_FOUND - Resource not found\n * @property {string} CONFLICT - Resource conflict\n * @property {string} UNAUTHORIZED - Authentication required\n * @property {string} FORBIDDEN - Insufficient permissions\n * @property {string} INTERNAL_SERVER_ERROR - Server error\n * @property {string} DATABASE_ERROR - Database operation failed\n * @property {string} DEPENDENCY_ERROR - Task dependency error\n * @property {string} RATE_LIMIT_EXCEEDED - Too many requests\n */\nexport const ErrorCodes = {\n  // Validation\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n  INVALID_INPUT: 'INVALID_INPUT',\n  MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',\n  INVALID_TYPE: 'INVALID_TYPE',\n\n  // Resources\n  NOT_FOUND: 'NOT_FOUND',\n  ALREADY_EXISTS: 'ALREADY_EXISTS',\n  CONFLICT: 'CONFLICT',\n\n  // Auth\n  UNAUTHORIZED: 'UNAUTHORIZED',\n  FORBIDDEN: 'FORBIDDEN',\n  INVALID_TOKEN: 'INVALID_TOKEN',\n  TOKEN_EXPIRED: 'TOKEN_EXPIRED',\n\n  // System\n  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',\n  INTERNAL_ERROR: 'INTERNAL_ERROR',\n  DATABASE_ERROR: 'DATABASE_ERROR',\n  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',\n  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',\n\n  // Business logic\n  DEPENDENCY_ERROR: 'DEPENDENCY_ERROR',\n  CIRCULAR_DEPENDENCY: 'CIRCULAR_DEPENDENCY',\n  INVALID_STATE_TRANSITION: 'INVALID_STATE_TRANSITION',\n} as const;\n\nexport type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];\n\n/**\n * Retries an operation with exponential backoff\n *\n * @function retryWithBackoff\n * @template T - The return type of the operation\n * @param {Function} operation - The async operation to retry\n * @param {Object} [options] - Retry configuration\n * @param {number} [options.maxRetries=3] - Maximum retry attempts\n * @param {number} [options.initialDelay=100] - Initial delay in milliseconds\n * @param {number} [options.maxDelay=5000] - Maximum delay in milliseconds\n * @param {number} [options.backoffFactor=2] - Exponential backoff factor\n * @param {Function} [options.shouldRetry] - Function to determine if retry is appropriate\n * @returns {Promise<T>} The operation result\n *\n * @throws {Error} The last error if all retries fail\n *\n * @example\n * ```typescript\n * const result = await retryWithBackoff(\n *   async () => await fetchData(),\n *   {\n *     maxRetries: 5,\n *     initialDelay: 1000,\n *     shouldRetry: (error) => error.statusCode >= 500\n *   }\n * );\n * ```\n */\nexport async function retryWithBackoff<T>(\n  operation: () => Promise<T>,\n  options: {\n    maxRetries?: number;\n    initialDelay?: number;\n    maxDelay?: number;\n    backoffFactor?: number;\n    shouldRetry?: (error: unknown) => boolean;\n  } = {}\n): Promise<T> {\n  const {\n    maxRetries = 3,\n    initialDelay = 100,\n    maxDelay = 5000,\n    backoffFactor = 2,\n    shouldRetry = error => !(error instanceof ValidationError || error instanceof NotFoundError),\n  } = options;\n\n  let lastError: unknown;\n  let delay = initialDelay;\n\n  // eslint-disable-next-line no-await-in-loop\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      return await operation();\n    } catch (error) {\n      lastError = error;\n\n      if (attempt === maxRetries || !shouldRetry(error)) {\n        throw error;\n      }\n\n      // eslint-disable-next-line no-await-in-loop\n      await new Promise(resolve => setTimeout(resolve, delay));\n      delay = Math.min(delay * backoffFactor, maxDelay);\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Configuration options for retry operations\n *\n * @interface RetryOptions\n * @property {number} maxAttempts - Maximum number of retry attempts\n * @property {number} baseDelay - Base delay between retries in milliseconds\n * @property {number} maxDelay - Maximum delay between retries in milliseconds\n * @property {number} exponentialBase - Base for exponential backoff calculation\n * @property {boolean} jitter - Whether to add random jitter to delays\n */\nexport interface RetryOptions {\n  maxAttempts: number;\n  baseDelay: number;\n  maxDelay: number;\n  exponentialBase: number;\n  jitter: boolean;\n}\n\n/**\n * Retries an operation with configurable backoff and jitter\n *\n * @function withRetry\n * @template T - The return type of the operation\n * @param {Function} operation - The async operation to retry\n * @param {Partial<RetryOptions>} [options] - Retry configuration\n * @param {ErrorContext} [context] - Error context for logging\n * @returns {Promise<T>} The operation result\n *\n * @throws {BaseServiceError} The last error wrapped in appropriate error type\n *\n * @example\n * ```typescript\n * const result = await withRetry(\n *   async () => await databaseQuery(),\n *   { maxAttempts: 3, jitter: true },\n *   { service: 'Database', method: 'query' }\n * );\n * ```\n */\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  options: Partial<RetryOptions> = {},\n  context?: ErrorContext\n): Promise<T> {\n  const {\n    maxAttempts = 3,\n    baseDelay = 1000,\n    maxDelay = 10000,\n    exponentialBase = 2,\n    jitter = true,\n  } = options;\n\n  let lastError: Error;\n\n  // eslint-disable-next-line no-await-in-loop\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      if (attempt === maxAttempts) {\n        break;\n      }\n\n      if (error instanceof BaseServiceError && !isRetryableError(error)) {\n        break;\n      }\n\n      const delay = Math.min(baseDelay * exponentialBase ** (attempt - 1), maxDelay);\n\n      const finalDelay = jitter ? delay * (0.5 + Math.random() * 0.5) : delay;\n\n      logger.warn('Operation failed, retrying', {\n        attempt,\n        maxAttempts,\n        delay: finalDelay,\n        error: lastError.message,\n        context,\n      });\n\n      // eslint-disable-next-line no-await-in-loop\n      await new Promise(resolve => setTimeout(resolve, finalDelay));\n    }\n  }\n\n  throw globalErrorHandler.handleError(\n    lastError!,\n    context ?? {\n      service: 'retry',\n      method: 'withRetry',\n    }\n  );\n}\n\n/**\n * Determines if an error is retryable based on error code and status\n *\n * @function isRetryableError\n * @param {BaseServiceError} error - The error to check\n * @returns {boolean} True if the error is retryable\n *\n * @private\n */\nfunction isRetryableError(error: BaseServiceError): boolean {\n  const retryableCodes = [\n    'DATABASE_BUSY',\n    'EXTERNAL_SERVICE_TIMEOUT',\n    'EXTERNAL_SERVICE_UNAVAILABLE',\n    'SERVICE_UNAVAILABLE',\n    'TIMEOUT',\n  ];\n\n  return retryableCodes.includes(error.code) || error.statusCode >= 500;\n}\n\n/**\n * Creates a circuit breaker for protecting against cascading failures\n *\n * @function createCircuitBreaker\n * @param {string} name - Circuit breaker name for logging\n * @param {Object} options - Circuit breaker configuration\n * @param {number} options.threshold - Failure threshold before opening\n * @param {number} options.timeout - Timeout for operations in milliseconds\n * @param {number} options.resetTimeout - Time before attempting reset in milliseconds\n * @returns {Function} Circuit breaker wrapper function\n *\n * @description Implements the circuit breaker pattern to prevent cascading failures.\n * The circuit has three states: CLOSED (normal), OPEN (failing), and HALF_OPEN (testing).\n *\n * @example\n * ```typescript\n * const protectedFn = createCircuitBreaker('external-api', {\n *   threshold: 5,\n *   timeout: 5000,\n *   resetTimeout: 60000\n * });\n *\n * try {\n *   const result = await protectedFn(async () => await callExternalAPI());\n * } catch (error) {\n *   // Handle circuit breaker open or operation failure\n * }\n * ```\n */\nexport function createCircuitBreaker(\n  name: string,\n  options: {\n    threshold: number;\n    timeout: number;\n    resetTimeout: number;\n  }\n) {\n  let failures = 0;\n  let lastFailureTime = 0;\n  let state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n\n  return async function <T>(operation: () => Promise<T>): Promise<T> {\n    const now = Date.now();\n\n    if (state === 'OPEN') {\n      if (now - lastFailureTime >= options.resetTimeout) {\n        state = 'HALF_OPEN';\n        logger.info('Circuit breaker half-open', { name });\n      } else {\n        throw new BaseServiceError(\n          'CIRCUIT_BREAKER_OPEN',\n          `Circuit breaker ${String(name)} is open`,\n          503\n        );\n      }\n    }\n\n    try {\n      const result = await operation();\n\n      if (state === 'HALF_OPEN') {\n        state = 'CLOSED';\n        failures = 0;\n        logger.info('Circuit breaker closed', { name });\n      }\n\n      return result;\n    } catch (error) {\n      failures++;\n      lastFailureTime = now;\n\n      if (failures >= options.threshold) {\n        state = 'OPEN';\n        logger.error('Circuit breaker opened', { name, failures, threshold: options.threshold });\n      }\n\n      throw error;\n    }\n  };\n}\n\n/**\n * Error class for aggregating multiple errors into a single error\n *\n * @class AggregateError\n * @extends BaseServiceError\n *\n * @description Useful for batch operations where multiple errors can occur\n * and all need to be reported together.\n *\n * @example\n * ```typescript\n * const errors: BaseServiceError[] = [];\n *\n * for (const task of tasks) {\n *   try {\n *     await processTask(task);\n *   } catch (error) {\n *     errors.push(error);\n *   }\n * }\n *\n * if (errors.length > 0) {\n *   throw new AggregateError(errors);\n * }\n * ```\n */\nexport class AggregateError extends BaseServiceError {\n  /** Array of individual errors that occurred */\n  public readonly errors: BaseServiceError[];\n\n  /**\n   * Creates an AggregateError from multiple errors\n   *\n   * @param {BaseServiceError[]} errors - Array of errors to aggregate\n   * @param {ErrorContext} [context] - Error context\n   */\n  constructor(errors: BaseServiceError[], context?: ErrorContext) {\n    const errorMessages = errors.map(e => e.message).join('; ');\n    super(\n      'AGGREGATE_ERROR',\n      `Multiple errors occurred: ${String(errorMessages)}`,\n      500,\n      { errors: errors.map(e => e.toJSON()) } as ErrorDetails,\n      context\n    );\n    this.errors = errors;\n  }\n}\n\n/**\n * Safely serializes any error to a JSON-compatible object\n *\n * @function serializeError\n * @param {unknown} error - The error to serialize\n * @returns {Record<string, unknown>} JSON-safe error representation\n *\n * @description Handles various error types including BaseServiceError,\n * standard Error objects, and unknown values, ensuring safe serialization\n * for logging and API responses.\n *\n * @example\n * ```typescript\n * try {\n *   await someOperation();\n * } catch (error) {\n *   const serialized = serializeError(error);\n *   logger.error('Operation failed', serialized);\n *   res.status(500).json({ error: serialized });\n * }\n * ```\n */\nexport function serializeError(error: unknown): Record<string, unknown> {\n  if (error instanceof BaseServiceError) {\n    return error.toJSON();\n  }\n\n  if (isError(error)) {\n    return {\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n    };\n  }\n\n  if (isRecord(error)) {\n    return error;\n  }\n\n  return {\n    message: getErrorMessage(error),\n    type: typeof error,\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/externalDataValidation.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 12,
        "column": 71,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 12,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 142,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 142,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 159,
        "column": 15,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 159,
        "endColumn": 43
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 173,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 173,
        "endColumn": 39
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * External data validation utilities for API responses, query parameters, and WebSocket messages\n */\n\nimport { z } from 'zod';\nimport { isRecord, isString, hasProperty, getErrorMessage } from './typeGuards';\n\n/**\n * Base API response schema\n */\nexport const ApiResponseSchema = <T extends z.ZodType>(dataSchema: T) =>\n  z.object({\n    success: z.boolean(),\n    data: dataSchema.optional(),\n    error: z.string().optional(),\n    message: z.string().optional(),\n  });\n\n/**\n * Pagination query schema\n */\nexport const PaginationQuerySchema = z.object({\n  page: z.coerce.number().int().positive().optional().default(1),\n  limit: z.coerce.number().int().positive().max(100).optional().default(20),\n  sort: z.string().optional(),\n  order: z.enum(['asc', 'desc']).optional().default('asc'),\n});\n\n/**\n * Common query filter schema\n */\nexport const FilterQuerySchema = z.object({\n  search: z.string().optional(),\n  status: z.string().optional(),\n  tags: z.union([z.string(), z.array(z.string())]).optional(),\n  boardId: z.coerce.number().int().positive().optional(),\n  columnId: z.coerce.number().int().positive().optional(),\n  priority: z.enum(['low', 'medium', 'high', 'urgent']).optional(),\n  assignee: z.string().optional(),\n  startDate: z.string().datetime().optional(),\n  endDate: z.string().datetime().optional(),\n});\n\n/**\n * Validate and parse API response\n */\nexport function validateApiResponse<T>(\n  data: unknown,\n  schema: z.ZodType<T>\n): { success: true; data: T } | { success: false; error: string } {\n  try {\n    const validated = schema.parse(data);\n    return { success: true, data: validated };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        error: `Validation error: ${error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`,\n      };\n    }\n    return { success: false, error: getErrorMessage(error) };\n  }\n}\n\n/**\n * Validate query parameters with schema\n */\nexport function validateQueryParams<T>(params: unknown, schema: z.ZodType<T>): T {\n  // Convert query string arrays to actual arrays if needed\n  if (isRecord(params)) {\n    const normalized = { ...params };\n    for (const [key, value] of Object.entries(normalized)) {\n      // Express query parser may return string or string[] for array params\n      if (key === 'tags' && isString(value) && value.includes(',')) {\n        normalized[key] = value.split(',').map(s => s.trim());\n      }\n    }\n    return schema.parse(normalized);\n  }\n\n  return schema.parse(params);\n}\n\n/**\n * WebSocket message schemas\n */\nexport const WebSocketMessageBaseSchema = z.object({\n  type: z.string(),\n  id: z.string().optional(),\n  timestamp: z.string().datetime().optional(),\n});\n\nexport const SubscribeMessageSchema = WebSocketMessageBaseSchema.extend({\n  type: z.literal('subscribe'),\n  payload: z.object({\n    channel: z.enum(['boards', 'tasks', 'notes', 'tags']),\n    filters: z.record(z.unknown()).optional(),\n  }),\n});\n\nexport const UnsubscribeMessageSchema = WebSocketMessageBaseSchema.extend({\n  type: z.literal('unsubscribe'),\n  payload: z.object({\n    channel: z.enum(['boards', 'tasks', 'notes', 'tags']),\n  }),\n});\n\n/**\n * Validate WebSocket message\n */\nexport function validateWebSocketMessage(\n  message: unknown\n): { type: string; payload?: unknown; id?: string | undefined } | null {\n  if (!isRecord(message) || !isString(message.type)) {\n    return null;\n  }\n\n  try {\n    // Validate base structure\n    const base = WebSocketMessageBaseSchema.parse(message);\n\n    // Return with original payload for specific handlers to validate\n    return {\n      type: base.type,\n      id: base.id,\n      payload: hasProperty(message, 'payload') ? message.payload : undefined,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * JSON parse with validation\n */\nexport function parseJsonSafe<T>(\n  json: string,\n  schema: z.ZodType<T>\n): { success: true; data: T } | { success: false; error: string } {\n  try {\n    const parsed = JSON.parse(json);\n    return validateApiResponse(parsed, schema);\n  } catch (error) {\n    return { success: false, error: `JSON parse error: ${getErrorMessage(error)}` };\n  }\n}\n\n/**\n * Create a validated API response handler\n */\nexport function createApiResponseHandler<T>(schema: z.ZodType<T>) {\n  return async (response: Response): Promise<T> => {\n    if (!response.ok) {\n      const text = await response.text();\n      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n\n      try {\n        const errorData = JSON.parse(text);\n        if (isRecord(errorData) && isString(errorData.error)) {\n          errorMessage = errorData.error;\n        } else if (isRecord(errorData) && isString(errorData.message)) {\n          errorMessage = errorData.message;\n        }\n      } catch {\n        // Use text as error message if not JSON\n        if (text) errorMessage = text;\n      }\n\n      throw new Error(errorMessage);\n    }\n\n    const data = await response.json();\n    const result = validateApiResponse(data, schema);\n\n    if (!result.success) {\n      throw new Error(result.error);\n    }\n\n    return result.data;\n  };\n}\n\n/**\n * Type-safe fetch wrapper\n */\nexport async function typedFetch<T>(\n  url: string,\n  options: RequestInit,\n  schema: z.ZodType<T>\n): Promise<T> {\n  const response = await fetch(url, options);\n  return createApiResponseHandler(schema)(response);\n}\n\n/**\n * Validate environment variables\n */\nexport const EnvironmentSchema = z.object({\n  NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),\n  PORT: z.coerce.number().int().positive().default(3000),\n  DATABASE_PATH: z.string().default('./kanban.db'),\n  API_KEY: z.string().optional(),\n  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  CORS_ORIGIN: z.string().default('*'),\n  RATE_LIMIT_WINDOW: z.coerce.number().int().positive().default(60000),\n  RATE_LIMIT_MAX: z.coerce.number().int().positive().default(1000),\n});\n\nexport type Environment = z.infer<typeof EnvironmentSchema>;\n\nexport function validateEnvironment(env: unknown): Environment {\n  return EnvironmentSchema.parse(env);\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/formatConverters.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 74,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 74,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2194, 2197], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2194, 2197], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .is_active on an `any` value.",
        "line": 74,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 74,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Board`.",
        "line": 306,
        "column": 28,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 306,
        "endColumn": 39
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 306,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 306,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8762, 8765], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8762, 8765], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Task`.",
        "line": 310,
        "column": 27,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 310,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 310,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 310,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8885, 8888], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8885, 8888], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Tag`.",
        "line": 314,
        "column": 26,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 314,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 314,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 314,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9004, 9007], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9004, 9007], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `Note`.",
        "line": 318,
        "column": 27,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 318,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 318,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 318,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9127, 9130], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9127, 9130], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `{ task_id: string; tag_id: string; }`.",
        "line": 322,
        "column": 30,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeArgument",
        "endLine": 322,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 322,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 322,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9263, 9266], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9263, 9266], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 325,
        "column": 31,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 325,
        "endColumn": 56
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 325,
        "column": 53,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 325,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9363, 9366], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9363, 9366], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 326,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 326,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9396, 9399], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9396, 9399], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [item.key as string] on an `any` value.",
        "line": 326,
        "column": 34,
        "nodeType": "TSAsExpression",
        "messageId": "unsafeMemberExpression",
        "endLine": 326,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is assigned a value but never used.",
        "line": 364,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 364,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 398,
        "column": 53,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 398,
        "endColumn": 56,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11470, 11473], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11470, 11473], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .is_active on an `any` value.",
        "line": 398,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 398,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 399,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 399,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 400,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 400,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 426,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 426,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 428,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 428,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 429,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 429,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 450,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 450,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 467,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 467,
        "endColumn": 59
      },
      {
        "ruleId": "@typescript-eslint/restrict-template-expressions",
        "severity": 2,
        "message": "Invalid type \"Date\" of template literal expression.",
        "line": 468,
        "column": 44,
        "nodeType": "MemberExpression",
        "messageId": "invalidType",
        "endLine": 468,
        "endColumn": 59
      }
    ],
    "suppressedMessages": [],
    "errorCount": 13,
    "fatalErrorCount": 0,
    "warningCount": 14,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Format Converters - Convert between different export formats\n *\n * @module utils/formatConverters\n * @description Provides utilities to convert data between different export formats\n * including JSON, CSV, and other formats. Useful for data migration and format compatibility.\n */\n\nimport type { ExportData, ExportFileFormat } from '@/services/ExportService';\nimport { logger } from '@/utils/logger';\n\nexport interface FormatConverterOptions {\n  preserveMetadata?: boolean;\n  includeHeaders?: boolean;\n  delimiter?: string;\n  quoteChar?: string;\n  escapeChar?: string;\n  dateFormat?: string;\n  timezone?: string;\n}\n\nexport interface ConversionResult {\n  success: boolean;\n  data?: string;\n  format: string;\n  itemCount: number;\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * Convert JSON export data to CSV format\n */\nexport function jsonToCsv(\n  jsonData: ExportData | ExportFileFormat,\n  options: FormatConverterOptions = {}\n): ConversionResult {\n  const result: ConversionResult = {\n    success: false,\n    format: 'csv',\n    itemCount: 0,\n    errors: [],\n    warnings: [],\n  };\n\n  try {\n    const data = 'data' in jsonData ? jsonData.data : jsonData;\n    const csvLines: string[] = [];\n    let totalItems = 0;\n\n    const delimiter = options.delimiter ?? ',';\n    const quoteChar = options.quoteChar ?? '\"';\n    const escapeChar = options.escapeChar ?? '\\\\';\n\n    // Helper function to escape CSV values\n    const escapeCsvValue = (value: string): string => {\n      if (value.includes(delimiter) || value.includes(quoteChar) || value.includes('\\n')) {\n        return `${quoteChar}${value.replace(new RegExp(quoteChar, 'g'), `${escapeChar}${quoteChar}`)}${quoteChar}`;\n      }\n      return value;\n    };\n\n    // Convert boards to CSV\n    if (data.boards && data.boards.length > 0) {\n      csvLines.push('=== BOARDS ===');\n      const boardHeaders = ['id', 'name', 'description', 'is_active', 'created_at', 'updated_at'];\n      csvLines.push(boardHeaders.join(delimiter));\n\n      data.boards.forEach(board => {\n        const row = [\n          board.id,\n          escapeCsvValue(board.name),\n          board.description ? escapeCsvValue(board.description) : '',\n          (board as any).is_active ? 'true' : 'false',\n          board.created_at,\n          board.updated_at,\n        ];\n        csvLines.push(row.join(delimiter));\n        totalItems++;\n      });\n      csvLines.push(''); // Empty line separator\n    }\n\n    // Convert tasks to CSV\n    if (data.tasks && data.tasks.length > 0) {\n      csvLines.push('=== TASKS ===');\n      const taskHeaders = [\n        'id',\n        'title',\n        'description',\n        'board_id',\n        'column_id',\n        'position',\n        'priority',\n        'status',\n        'assignee',\n        'due_date',\n        'created_at',\n        'updated_at',\n      ];\n      csvLines.push(taskHeaders.join(delimiter));\n\n      data.tasks.forEach(task => {\n        const row = [\n          task.id,\n          escapeCsvValue(task.title),\n          task.description ? escapeCsvValue(task.description) : '',\n          task.board_id,\n          task.column_id,\n          task.position,\n          task.priority ?? '',\n          task.status,\n          task.assignee ? escapeCsvValue(task.assignee) : '',\n          task.due_date ?? '',\n          task.created_at,\n          task.updated_at,\n        ];\n        csvLines.push(row.join(delimiter));\n        totalItems++;\n      });\n      csvLines.push(''); // Empty line separator\n    }\n\n    // Convert tags to CSV\n    if (data.tags && data.tags.length > 0) {\n      csvLines.push('=== TAGS ===');\n      const tagHeaders = ['id', 'name', 'color', 'description', 'parent_tag_id', 'created_at'];\n      csvLines.push(tagHeaders.join(delimiter));\n\n      data.tags.forEach(tag => {\n        const row = [\n          tag.id,\n          escapeCsvValue(tag.name),\n          tag.color,\n          tag.description ? escapeCsvValue(tag.description) : '',\n          tag.parent_tag_id ?? '',\n          tag.created_at,\n        ];\n        csvLines.push(row.join(delimiter));\n        totalItems++;\n      });\n      csvLines.push(''); // Empty line separator\n    }\n\n    // Convert notes to CSV\n    if (data.notes && data.notes.length > 0) {\n      csvLines.push('=== NOTES ===');\n      const noteHeaders = [\n        'id',\n        'content',\n        'category',\n        'task_id',\n        'pinned',\n        'created_at',\n        'updated_at',\n      ];\n      csvLines.push(noteHeaders.join(delimiter));\n\n      data.notes.forEach(note => {\n        const row = [\n          note.id,\n          escapeCsvValue(note.content),\n          note.category,\n          note.task_id,\n          note.pinned ? 'true' : 'false',\n          note.created_at,\n          note.updated_at,\n        ];\n        csvLines.push(row.join(delimiter));\n        totalItems++;\n      });\n      csvLines.push(''); // Empty line separator\n    }\n\n    // Convert task-tag relationships to CSV\n    if (data.taskTags && data.taskTags.length > 0) {\n      csvLines.push('=== TASK_TAGS ===');\n      const taskTagHeaders = ['task_id', 'tag_id'];\n      csvLines.push(taskTagHeaders.join(delimiter));\n\n      data.taskTags.forEach(mapping => {\n        const row = [mapping.task_id, mapping.tag_id];\n        csvLines.push(row.join(delimiter));\n        totalItems++;\n      });\n      csvLines.push(''); // Empty line separator\n    }\n\n    // Add metadata if requested\n    if (options.preserveMetadata && data.metadata) {\n      csvLines.push('=== METADATA ===');\n      csvLines.push('key,value');\n      csvLines.push(`exportDate,${data.metadata.exportDate}`);\n      csvLines.push(`version,${data.metadata.version}`);\n      csvLines.push(`totalItems,${data.metadata.totalItems}`);\n    }\n\n    result.success = true;\n    result.data = csvLines.join('\\n');\n    result.itemCount = totalItems;\n\n    logger.info('JSON to CSV conversion completed', { itemCount: totalItems });\n  } catch (error) {\n    result.errors.push(\n      `Conversion failed: ${error instanceof Error ? error.message : String(error)}`\n    );\n    logger.error('JSON to CSV conversion failed:', error);\n  }\n\n  return result;\n}\n\n/**\n * Convert CSV data to JSON format\n */\nexport function csvToJson(csvData: string, options: FormatConverterOptions = {}): ConversionResult {\n  const result: ConversionResult = {\n    success: false,\n    format: 'json',\n    itemCount: 0,\n    errors: [],\n    warnings: [],\n  };\n\n  try {\n    const lines = csvData.split('\\n').filter(line => line.trim() !== '');\n    const data: ExportData = {};\n    let currentSection = '';\n    let headers: string[] = [];\n    let totalItems = 0;\n\n    const delimiter = options.delimiter ?? ',';\n    const quoteChar = options.quoteChar ?? '\"';\n\n    // Helper function to parse CSV line\n    const parseCsvLine = (line: string): string[] => {\n      const values: string[] = [];\n      let current = '';\n      let inQuotes = false;\n      let i = 0;\n\n      while (i < line.length) {\n        const char = line[i];\n        const nextChar = line[i + 1];\n\n        if (char === quoteChar && !inQuotes) {\n          inQuotes = true;\n        } else if (char === quoteChar && inQuotes && nextChar === quoteChar) {\n          current += quoteChar;\n          i++; // Skip next quote\n        } else if (char === quoteChar && inQuotes) {\n          inQuotes = false;\n        } else if (char === delimiter && !inQuotes) {\n          values.push(current.trim());\n          current = '';\n        } else {\n          current += char;\n        }\n        i++;\n      }\n\n      values.push(current.trim());\n      return values;\n    };\n\n    for (const line of lines) {\n      if (line.startsWith('===') && line.endsWith('===')) {\n        // Section header\n        currentSection = line.replace(/===/g, '').trim().toLowerCase();\n        headers = [];\n        continue;\n      }\n\n      if (headers.length === 0) {\n        // First line after section header is headers\n        headers = parseCsvLine(line);\n        continue;\n      }\n\n      // Data line\n      const values = parseCsvLine(line);\n      if (values.length !== headers.length) {\n        result.warnings.push(`Skipping malformed line in ${currentSection}: ${line}`);\n        continue;\n      }\n\n      const item: Record<string, unknown> = {};\n      headers.forEach((header, index) => {\n        const value = values[index];\n        // Convert string values to appropriate types\n        if (value === 'true') {\n          item[header] = true;\n        } else if (value === 'false') {\n          item[header] = false;\n        } else if (value === '') {\n          item[header] = null;\n        } else {\n          item[header] = value;\n        }\n      });\n\n      // Add to appropriate section\n      switch (currentSection) {\n        case 'boards':\n          if (!data.boards) data.boards = [];\n          data.boards.push(item as any);\n          break;\n        case 'tasks':\n          if (!data.tasks) data.tasks = [];\n          data.tasks.push(item as any);\n          break;\n        case 'tags':\n          if (!data.tags) data.tags = [];\n          data.tags.push(item as any);\n          break;\n        case 'notes':\n          if (!data.notes) data.notes = [];\n          data.notes.push(item as any);\n          break;\n        case 'task_tags':\n          if (!data.taskTags) data.taskTags = [];\n          data.taskTags.push(item as any);\n          break;\n        case 'metadata':\n          if (!data.metadata) data.metadata = {} as any;\n          (data.metadata as any)[item.key as string] = item.value;\n          break;\n        default:\n          result.warnings.push(`Unknown section: ${currentSection}`);\n      }\n\n      totalItems++;\n    }\n\n    // Add metadata if not present\n    if (!data.metadata) {\n      data.metadata = {\n        exportDate: new Date().toISOString(),\n        version: '1.0',\n        totalItems,\n      };\n    }\n\n    result.success = true;\n    result.data = JSON.stringify(data, null, 2);\n    result.itemCount = totalItems;\n\n    logger.info('CSV to JSON conversion completed', { itemCount: totalItems });\n  } catch (error) {\n    result.errors.push(\n      `Conversion failed: ${error instanceof Error ? error.message : String(error)}`\n    );\n    logger.error('CSV to JSON conversion failed:', error);\n  }\n\n  return result;\n}\n\n/**\n * Convert data to XML format (basic implementation)\n */\nexport function jsonToXml(\n  jsonData: ExportData | ExportFileFormat,\n  options: FormatConverterOptions = {}\n): ConversionResult {\n  const result: ConversionResult = {\n    success: false,\n    format: 'xml',\n    itemCount: 0,\n    errors: [],\n    warnings: [],\n  };\n\n  try {\n    const data = 'data' in jsonData ? jsonData.data : jsonData;\n    const xmlLines: string[] = ['<?xml version=\"1.0\" encoding=\"UTF-8\"?>', '<kanban-export>'];\n    let totalItems = 0;\n\n    // Helper function to escape XML content\n    const escapeXml = (text: string): string =>\n      text\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n\n    // Convert boards to XML\n    if (data.boards && data.boards.length > 0) {\n      xmlLines.push('  <boards>');\n      data.boards.forEach(board => {\n        xmlLines.push('    <board>');\n        xmlLines.push(`      <id>${escapeXml(board.id)}</id>`);\n        xmlLines.push(`      <name>${escapeXml(board.name)}</name>`);\n        if (board.description) {\n          xmlLines.push(`      <description>${escapeXml(board.description)}</description>`);\n        }\n        xmlLines.push(`      <is_active>${(board as any).is_active}</is_active>`);\n        xmlLines.push(`      <created_at>${board.created_at}</created_at>`);\n        xmlLines.push(`      <updated_at>${board.updated_at}</updated_at>`);\n        xmlLines.push('    </board>');\n        totalItems++;\n      });\n      xmlLines.push('  </boards>');\n    }\n\n    // Convert tasks to XML\n    if (data.tasks && data.tasks.length > 0) {\n      xmlLines.push('  <tasks>');\n      data.tasks.forEach(task => {\n        xmlLines.push('    <task>');\n        xmlLines.push(`      <id>${escapeXml(task.id)}</id>`);\n        xmlLines.push(`      <title>${escapeXml(task.title)}</title>`);\n        if (task.description) {\n          xmlLines.push(`      <description>${escapeXml(task.description)}</description>`);\n        }\n        xmlLines.push(`      <board_id>${escapeXml(task.board_id)}</board_id>`);\n        xmlLines.push(`      <column_id>${escapeXml(task.column_id)}</column_id>`);\n        xmlLines.push(`      <position>${task.position}</position>`);\n        xmlLines.push(`      <priority>${task.priority ?? ''}</priority>`);\n        xmlLines.push(`      <status>${escapeXml(task.status)}</status>`);\n        if (task.assignee) {\n          xmlLines.push(`      <assignee>${escapeXml(task.assignee)}</assignee>`);\n        }\n        if (task.due_date) {\n          xmlLines.push(`      <due_date>${task.due_date}</due_date>`);\n        }\n        xmlLines.push(`      <created_at>${task.created_at}</created_at>`);\n        xmlLines.push(`      <updated_at>${task.updated_at}</updated_at>`);\n        xmlLines.push('    </task>');\n        totalItems++;\n      });\n      xmlLines.push('  </tasks>');\n    }\n\n    // Convert tags to XML\n    if (data.tags && data.tags.length > 0) {\n      xmlLines.push('  <tags>');\n      data.tags.forEach(tag => {\n        xmlLines.push('    <tag>');\n        xmlLines.push(`      <id>${escapeXml(tag.id)}</id>`);\n        xmlLines.push(`      <name>${escapeXml(tag.name)}</name>`);\n        xmlLines.push(`      <color>${escapeXml(tag.color)}</color>`);\n        if (tag.description) {\n          xmlLines.push(`      <description>${escapeXml(tag.description)}</description>`);\n        }\n        if (tag.parent_tag_id) {\n          xmlLines.push(`      <parent_tag_id>${escapeXml(tag.parent_tag_id)}</parent_tag_id>`);\n        }\n        xmlLines.push(`      <created_at>${tag.created_at}</created_at>`);\n        xmlLines.push('    </tag>');\n        totalItems++;\n      });\n      xmlLines.push('  </tags>');\n    }\n\n    // Convert notes to XML\n    if (data.notes && data.notes.length > 0) {\n      xmlLines.push('  <notes>');\n      data.notes.forEach(note => {\n        xmlLines.push('    <note>');\n        xmlLines.push(`      <id>${escapeXml(note.id)}</id>`);\n        xmlLines.push(`      <content>${escapeXml(note.content)}</content>`);\n        xmlLines.push(`      <category>${escapeXml(note.category)}</category>`);\n        xmlLines.push(`      <task_id>${escapeXml(note.task_id)}</task_id>`);\n        xmlLines.push(`      <pinned>${note.pinned}</pinned>`);\n        xmlLines.push(`      <created_at>${note.created_at}</created_at>`);\n        xmlLines.push(`      <updated_at>${note.updated_at}</updated_at>`);\n        xmlLines.push('    </note>');\n        totalItems++;\n      });\n      xmlLines.push('  </notes>');\n    }\n\n    // Add metadata\n    if (data.metadata) {\n      xmlLines.push('  <metadata>');\n      xmlLines.push(`    <exportDate>${data.metadata.exportDate}</exportDate>`);\n      xmlLines.push(`    <version>${data.metadata.version}</version>`);\n      xmlLines.push(`    <totalItems>${data.metadata.totalItems}</totalItems>`);\n      xmlLines.push('  </metadata>');\n    }\n\n    xmlLines.push('</kanban-export>');\n\n    result.success = true;\n    result.data = xmlLines.join('\\n');\n    result.itemCount = totalItems;\n\n    logger.info('JSON to XML conversion completed', { itemCount: totalItems });\n  } catch (error) {\n    result.errors.push(\n      `Conversion failed: ${error instanceof Error ? error.message : String(error)}`\n    );\n    logger.error('JSON to XML conversion failed:', error);\n  }\n\n  return result;\n}\n\n/**\n * Get supported format conversions\n */\nexport function getSupportedConversions(): Record<string, string[]> {\n  return {\n    from: ['json', 'csv'],\n    to: ['json', 'csv', 'xml'],\n    conversions: [\n      { from: 'json', to: 'csv', function: 'jsonToCsv' },\n      { from: 'csv', to: 'json', function: 'csvToJson' },\n      { from: 'json', to: 'xml', function: 'jsonToXml' },\n    ],\n  };\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/savepoint.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 3,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 6,
        "endColumn": 7
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 6,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 6,
        "endColumn": 7
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 9,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 9,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .exec on an `any` value.",
        "line": 9,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 9,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 13,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 13,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .exec on an `any` value.",
        "line": 13,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 13,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 17,
        "column": 11,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 17,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .exec on an `any` value.",
        "line": 17,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 17,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 5,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 5,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [156, 159], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [156, 159], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/* eslint-disable @typescript-eslint/no-explicit-any */\nexport class Savepoint {\n  constructor(\n    private readonly name: string,\n    private readonly db: any\n  ) {}\n\n  async create(): Promise<void> {\n    await this.db.exec(`SAVEPOINT ${this.name}`);\n  }\n\n  async release(): Promise<void> {\n    await this.db.exec(`RELEASE SAVEPOINT ${this.name}`);\n  }\n\n  async rollback(): Promise<void> {\n    await this.db.exec(`ROLLBACK TO SAVEPOINT ${this.name}`);\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/transaction-monitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/transactions.ts",
    "messages": [
      {
        "ruleId": "no-useless-constructor",
        "severity": 2,
        "message": "Useless constructor.",
        "line": 176,
        "column": 3,
        "nodeType": "MethodDefinition",
        "messageId": "noUselessConstructor",
        "endLine": 176,
        "endColumn": 58
      },
      {
        "ruleId": "no-empty-function",
        "severity": 2,
        "message": "Unexpected empty constructor.",
        "line": 176,
        "column": 56,
        "nodeType": "FunctionExpression",
        "messageId": "unexpected",
        "endLine": 176,
        "endColumn": 58
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'operation'.",
        "line": 257,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 257,
        "endColumn": 20
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'operation'.",
        "line": 280,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 280,
        "endColumn": 20
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'operation'.",
        "line": 281,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 281,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 442,
        "column": 12,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 442,
        "endColumn": 21
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 442,
        "column": 12,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 442,
        "endColumn": 21
      },
      {
        "ruleId": "no-param-reassign",
        "severity": 1,
        "message": "Assignment to property of function parameter 'descriptor'.",
        "line": 445,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "assignmentToFunctionParamProp",
        "endLine": 445,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 445,
        "column": 26,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 445,
        "endColumn": 41
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed async function.",
        "line": 445,
        "column": 26,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 445,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `DatabaseConnection`.",
        "line": 446,
        "column": 59,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 446,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'addOperation'.",
        "line": 379,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 379,
        "endColumn": 15,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'addRollbackAction'.",
        "line": 409,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 409,
        "endColumn": 20,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 442,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 442,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14408, 14411], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14408, 14411], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 443,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 443,
        "endColumn": 46,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 445,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 445,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [14566, 14569], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [14566, 14569], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async arrow function has no 'await' expression.",
        "line": 448,
        "column": 26,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "missingAwait",
        "endLine": 448,
        "endColumn": 28,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 448,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "unsafeReturn",
        "endLine": 448,
        "endColumn": 61,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 448,
        "column": 29,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 448,
        "endColumn": 49,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .apply on an `any` value.",
        "line": 448,
        "column": 44,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 448,
        "endColumn": 49,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class async method 'executeRollback'.",
        "line": 476,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 476,
        "endColumn": 32,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class async method 'setIsolationLevel'.",
        "line": 513,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 513,
        "endColumn": 34,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 514,
        "column": 9,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 514,
        "endColumn": 12,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16848, 16851], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16848, 16851], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 528,
        "column": 13,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 528,
        "endColumn": 20,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .exec on an `any` value.",
        "line": 528,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 528,
        "endColumn": 20,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 579,
        "column": 7,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 579,
        "endColumn": 34,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 579,
        "column": 14,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 579,
        "endColumn": 31,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Database transaction management utilities\n *\n * @module utils/transactions\n * @description Provides a comprehensive transaction management system for database operations\n * with support for ACID properties, isolation levels, timeout handling, automatic rollback,\n * and retry logic. Ensures data consistency across complex multi-step operations.\n *\n * @example\n * ```typescript\n * // Basic transaction usage\n * const manager = new TransactionManager(db);\n * const result = await manager.executeTransaction(async (context) => {\n *   manager.addOperation(context, 'UserService', 'createUser');\n *   const user = await createUser(data);\n *\n *   manager.addRollbackAction(context, async () => {\n *     await deleteUser(user.id);\n *   });\n *\n *   return user;\n * });\n *\n * // Using the decorator pattern\n * class UserService {\n *   @TransactionManager.transactional({ isolationLevel: 'READ_COMMITTED' })\n *   async transferCredits(fromId: string, toId: string, amount: number) {\n *     // Implementation\n *   }\n * }\n * ```\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return, class-methods-use-this, no-await-in-loop, no-restricted-syntax, no-plusplus, @typescript-eslint/require-await */\nimport { logger } from '@/utils/logger';\nimport type { DatabaseConnection } from '@/database/connection';\nimport { BaseServiceError, DatabaseError } from '@/utils/errors';\nimport { isError, getErrorMessage } from './typeGuards';\n\n/**\n * Transaction context containing state and metadata for a running transaction\n *\n * @interface TransactionContext\n * @property {string} id - Unique transaction identifier\n * @property {Date} startTime - When the transaction started\n * @property {TransactionOperation[]} operations - List of operations performed\n * @property {(() => Promise<void>)[]} rollbackActions - Rollback functions to execute on failure\n * @property {Record<string, unknown>} [metadata] - Optional transaction metadata\n *\n * @example\n * ```typescript\n * const context: TransactionContext = {\n *   id: 'tx_1234567890_1',\n *   startTime: new Date(),\n *   operations: [],\n *   rollbackActions: [],\n *   metadata: { userId: 'user123' }\n * };\n * ```\n */\nexport interface TransactionContext {\n  id: string;\n  startTime: Date;\n  operations: TransactionOperation[];\n  rollbackActions: (() => Promise<void>)[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Represents a single operation within a transaction\n *\n * @interface TransactionOperation\n * @property {string} service - Service that performed the operation\n * @property {string} method - Method name that was executed\n * @property {Date} timestamp - When the operation was performed\n * @property {'pending' | 'completed' | 'failed'} status - Current operation status\n * @property {Error} [error] - Error if the operation failed\n *\n * @example\n * ```typescript\n * const operation: TransactionOperation = {\n *   service: 'TaskService',\n *   method: 'createTask',\n *   timestamp: new Date(),\n *   status: 'completed'\n * };\n * ```\n */\nexport interface TransactionOperation {\n  service: string;\n  method: string;\n  timestamp: Date;\n  status: 'pending' | 'completed' | 'failed';\n  error?: Error;\n}\n\n/**\n * Configuration options for transaction execution\n *\n * @interface TransactionOptions\n * @property {'READ_UNCOMMITTED' | 'READ_COMMITTED' | 'REPEATABLE_READ' | 'SERIALIZABLE'} [isolationLevel] - SQL isolation level\n * @property {number} [timeout] - Transaction timeout in milliseconds\n * @property {number} [retryAttempts] - Number of retry attempts for retryable errors\n * @property {boolean} [autoRollback] - Whether to automatically execute rollback actions on failure\n *\n * @example\n * ```typescript\n * const options: TransactionOptions = {\n *   isolationLevel: 'READ_COMMITTED',\n *   timeout: 30000,\n *   retryAttempts: 3,\n *   autoRollback: true\n * };\n * ```\n */\nexport interface TransactionOptions {\n  isolationLevel?: 'READ_UNCOMMITTED' | 'READ_COMMITTED' | 'REPEATABLE_READ' | 'SERIALIZABLE';\n  timeout?: number;\n  retryAttempts?: number;\n  autoRollback?: boolean;\n}\n\n/**\n * Type-safe transaction callback\n */\ntype TransactionCallback<T> = (context: TransactionContext) => Promise<T>;\n\n/**\n * Type-safe rollback action\n */\ntype RollbackAction = () => Promise<void>;\n\n/**\n * Manages database transactions with support for ACID properties, rollback, and retry logic\n *\n * @class TransactionManager\n * @description Provides a robust transaction management system that ensures data consistency\n * across complex operations. Supports isolation levels, timeouts, automatic rollback,\n * and retry mechanisms for handling transient failures.\n *\n * @example\n * ```typescript\n * const manager = new TransactionManager(db);\n *\n * // Execute a transaction with automatic rollback\n * const result = await manager.executeTransaction(async (context) => {\n *   const task = await createTask(data);\n *\n *   // Add rollback action\n *   manager.addRollbackAction(context, async () => {\n *     await deleteTask(task.id);\n *   });\n *\n *   return task;\n * }, { autoRollback: true });\n *\n * // Execute with retry logic\n * const resultWithRetry = await manager.executeTransactionWithRetry(\n *   async (context) => { // ... },\n *   { retryAttempts: 3 }\n * );\n * ```\n */\nexport class TransactionManager {\n  /** Map of active transactions by ID */\n  private readonly activeTransactions = new Map<string, TransactionContext>();\n\n  /** Counter for generating unique transaction IDs */\n  private static transactionCounter = 0;\n\n  /**\n   * Creates a new TransactionManager instance\n   *\n   * @param {DatabaseConnection} db - Database connection to manage transactions for\n   */\n  constructor(private readonly db: DatabaseConnection) {}\n\n  /**\n   * Executes a transaction with type-safe operations and automatic management\n   *\n   * @template T - Return type of the transaction\n   * @param {TransactionCallback<T>} operations - Async function containing transaction operations\n   * @param {TransactionOptions} [options={}] - Transaction configuration options\n   * @returns {Promise<T>} Result of the transaction operations\n   *\n   * @throws {BaseServiceError} When transaction times out\n   * @throws {Error} When transaction fails or is rolled back\n   *\n   * @description Executes database operations within a transaction boundary with support for:\n   * - Configurable isolation levels\n   * - Timeout handling with automatic cancellation\n   * - Operation tracking and status management\n   * - Automatic rollback on failure (if enabled)\n   * - Comprehensive logging and monitoring\n   *\n   * @example\n   * ```typescript\n   * const user = await manager.executeTransaction(\n   *   async (context) => {\n   *     manager.addOperation(context, 'UserService', 'createUser');\n   *     const user = await db.insert('users', userData);\n   *\n   *     manager.addOperation(context, 'UserService', 'createProfile');\n   *     await db.insert('profiles', { user_id: user.id });\n   *\n   *     return user;\n   *   },\n   *   {\n   *     isolationLevel: 'READ_COMMITTED',\n   *     timeout: 10000,\n   *     autoRollback: true\n   *   }\n   * );\n   * ```\n   */\n  async executeTransaction<T>(\n    operations: TransactionCallback<T>,\n    options: TransactionOptions = {}\n  ): Promise<T> {\n    const transactionId = TransactionManager.generateTransactionId();\n    const context: TransactionContext = {\n      id: transactionId,\n      startTime: new Date(),\n      operations: [],\n      rollbackActions: [],\n      metadata: options as Record<string, unknown>,\n    };\n\n    this.activeTransactions.set(transactionId, context);\n\n    try {\n      logger.info('Starting transaction', { transactionId, options });\n\n      const result = await this.db.transaction(async db => {\n        // Set isolation level if specified\n        if (options.isolationLevel) {\n          await this.setIsolationLevel(db, options.isolationLevel);\n        }\n\n        // Set timeout if specified\n        if (options.timeout) {\n          const timeoutPromise = new Promise<never>((_, reject) => {\n            setTimeout(() => {\n              reject(new BaseServiceError('TRANSACTION_TIMEOUT', 'Transaction timeout'));\n            }, options.timeout);\n          });\n\n          return Promise.race([operations(context), timeoutPromise]);\n        }\n\n        return operations(context);\n      });\n\n      // Mark operations as completed\n      context.operations.forEach(operation => {\n        if (operation.status === 'pending') {\n          operation.status = 'completed';\n        }\n      });\n\n      logger.info('Transaction completed successfully', {\n        transactionId,\n        duration: Date.now() - context.startTime.getTime(),\n        operationsCount: context.operations.length,\n      });\n\n      return result;\n    } catch (error) {\n      const errorMessage = getErrorMessage(error);\n\n      logger.error('Transaction failed', {\n        transactionId,\n        error: errorMessage,\n        operations: context.operations,\n      });\n\n      // Mark failed operations\n      context.operations.forEach(operation => {\n        if (operation.status === 'pending') {\n          operation.status = 'failed';\n          operation.error = isError(error) ? error : new Error(errorMessage);\n        }\n      });\n\n      // Execute rollback actions if autoRollback is enabled\n      if (options.autoRollback && context.rollbackActions.length > 0) {\n        await this.executeRollback(context);\n      }\n\n      throw error;\n    } finally {\n      this.activeTransactions.delete(transactionId);\n    }\n  }\n\n  /**\n   * Executes a transaction with automatic retry logic for transient failures\n   *\n   * @template T - Return type of the transaction\n   * @param {TransactionCallback<T>} operations - Async function containing transaction operations\n   * @param {TransactionOptions} [options={}] - Transaction configuration with retry settings\n   * @returns {Promise<T>} Result of the successful transaction\n   *\n   * @throws {Error} Final error after all retry attempts are exhausted\n   *\n   * @description Wraps executeTransaction with exponential backoff retry logic.\n   * Only retries on transient/retryable errors (e.g., deadlocks, temporary unavailability).\n   * Non-retryable errors fail immediately.\n   *\n   * @example\n   * ```typescript\n   * const result = await manager.executeTransactionWithRetry(\n   *   async (context) => {\n   *     // Operations that might fail due to deadlock\n   *     await updateInventory(items);\n   *     await createOrder(orderData);\n   *   },\n   *   {\n   *     retryAttempts: 5,\n   *     timeout: 30000\n   *   }\n   * );\n   * ```\n   */\n  async executeTransactionWithRetry<T>(\n    operations: TransactionCallback<T>,\n    options: TransactionOptions = {}\n  ): Promise<T> {\n    const maxAttempts = options.retryAttempts ?? 3;\n    let lastError: unknown;\n\n    for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {\n      try {\n        const restOptions = { ...options };\n        delete restOptions.retryAttempts;\n        return await this.executeTransaction(operations, restOptions);\n      } catch (error) {\n        lastError = error;\n\n        if (!TransactionManager.isRetryableError(error) || attempt === maxAttempts) {\n          throw error;\n        }\n\n        const delay = Math.min(100 * 2 ** (attempt - 1), 5000);\n        logger.info('Retrying transaction', {\n          attempt,\n          maxAttempts,\n          delay,\n          error: getErrorMessage(error),\n        });\n\n        await new Promise<void>(resolve => {\n          setTimeout(resolve, delay);\n        });\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Adds an operation record to the transaction context for tracking\n   *\n   * @param {TransactionContext} context - Current transaction context\n   * @param {string} service - Name of the service performing the operation\n   * @param {string} method - Name of the method being executed\n   *\n   * @description Records operations within a transaction for monitoring, debugging,\n   * and audit purposes. Each operation is tracked with a timestamp and initial\n   * 'pending' status.\n   *\n   * @example\n   * ```typescript\n   * manager.addOperation(context, 'TaskService', 'createTask');\n   * const task = await taskService.createTask(data);\n   * // Operation status is automatically updated on success/failure\n   * ```\n   */\n  addOperation(context: TransactionContext, service: string, method: string): void {\n    context.operations.push({\n      service,\n      method,\n      timestamp: new Date(),\n      status: 'pending',\n    });\n  }\n\n  /**\n   * Adds a rollback action to be executed if the transaction fails\n   *\n   * @param {TransactionContext} context - Current transaction context\n   * @param {RollbackAction} action - Async function to execute during rollback\n   *\n   * @description Registers compensating actions that undo operations performed\n   * during the transaction. Rollback actions are executed in reverse order\n   * (LIFO) to properly undo nested operations.\n   *\n   * @example\n   * ```typescript\n   * // After creating a resource\n   * const resource = await createResource(data);\n   *\n   * // Register cleanup\n   * manager.addRollbackAction(context, async () => {\n   *   await deleteResource(resource.id);\n   * });\n   * ```\n   */\n  addRollbackAction(context: TransactionContext, action: RollbackAction): void {\n    context.rollbackActions.push(action);\n  }\n\n  /**\n   * Decorator for making class methods transactional\n   *\n   * @static\n   * @param {TransactionOptions} [options={}] - Transaction configuration\n   * @returns {MethodDecorator} Decorator function\n   *\n   * @description Wraps a method in a transaction, automatically managing\n   * transaction lifecycle. The decorated method must be part of a class\n   * that has a 'db' property with a DatabaseConnection.\n   *\n   * @example\n   * ```typescript\n   * class OrderService {\n   *   constructor(private db: DatabaseConnection) {}\n   *\n   *   @TransactionManager.transactional({\n   *     isolationLevel: 'SERIALIZABLE',\n   *     timeout: 30000\n   *   })\n   *   async processPayment(orderId: string, amount: number) {\n   *     await this.debitAccount(amount);\n   *     await this.updateOrderStatus(orderId, 'paid');\n   *     await this.sendConfirmation(orderId);\n   *   }\n   * }\n   * ```\n   */\n  static transactional(options: TransactionOptions = {}) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n      const originalMethod = descriptor.value;\n\n      descriptor.value = async function (...args: any[]) {\n        const transactionManager = new TransactionManager(this.db);\n        return transactionManager.executeTransaction(\n          async _context => originalMethod.apply(this, args),\n          options\n        );\n      };\n\n      return descriptor;\n    };\n  }\n\n  /**\n   * Executes rollback actions in reverse order (LIFO)\n   *\n   * @private\n   * @param {TransactionContext} context - Transaction context with rollback actions\n   * @returns {Promise<void>}\n   *\n   * @description Executes all registered rollback actions in reverse order to properly\n   * undo operations. Continues executing even if individual rollback actions fail,\n   * logging any errors for debugging.\n   *\n   * @example\n   * ```typescript\n   * // Internally called when transaction fails\n   * // Rollback actions execute in reverse order:\n   * // 1. Delete profile (last action added)\n   * // 2. Delete user (first action added)\n   * ```\n   */\n  private async executeRollback(context: TransactionContext): Promise<void> {\n    logger.info('Executing rollback actions', {\n      transactionId: context.id,\n      rollbackActionsCount: context.rollbackActions.length,\n    });\n\n    for (let i = context.rollbackActions.length - 1; i >= 0; i -= 1) {\n      try {\n        await context.rollbackActions[i]();\n      } catch (error) {\n        logger.error('Rollback action failed', {\n          transactionId: context.id,\n          actionIndex: i,\n          error: getErrorMessage(error),\n        });\n      }\n    }\n  }\n\n  /**\n   * Sets the SQL isolation level for the current transaction\n   *\n   * @private\n   * @param {any} db - Database connection or transaction object\n   * @param {TransactionOptions['isolationLevel']} level - Desired isolation level\n   * @returns {Promise<void>}\n   *\n   * @description Configures the transaction isolation level to control concurrent\n   * access behavior. Higher isolation levels provide more consistency but may\n   * reduce performance.\n   *\n   * Isolation levels:\n   * - READ_UNCOMMITTED: Lowest isolation, allows dirty reads\n   * - READ_COMMITTED: Prevents dirty reads (default for many databases)\n   * - REPEATABLE_READ: Prevents dirty and non-repeatable reads\n   * - SERIALIZABLE: Highest isolation, prevents all phenomena\n   */\n  private async setIsolationLevel(\n    db: any,\n    level: TransactionOptions['isolationLevel']\n  ): Promise<void> {\n    if (!level) return;\n\n    const isolationLevelMap: Record<string, string> = {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE',\n    };\n\n    const sqlLevel = isolationLevelMap[level];\n    if (sqlLevel) {\n      await db.exec(`SET TRANSACTION ISOLATION LEVEL ${sqlLevel}`);\n    }\n  }\n\n  /**\n   * Generates a unique transaction identifier\n   *\n   * @private\n   * @static\n   * @returns {string} Unique transaction ID in format 'tx_<timestamp>_<counter>'\n   *\n   * @description Creates a unique identifier for tracking transactions using\n   * current timestamp and an incrementing counter to ensure uniqueness even\n   * for transactions started at the same millisecond.\n   *\n   * @example\n   * ```typescript\n   * const id = TransactionManager.generateTransactionId();\n   * // Returns: 'tx_1703123456789_42'\n   * ```\n   */\n  private static generateTransactionId(): string {\n    TransactionManager.transactionCounter += 1;\n    return `tx_${Date.now()}_${TransactionManager.transactionCounter}`;\n  }\n\n  /**\n   * Determines if an error is retryable based on its type and properties\n   *\n   * @private\n   * @static\n   * @param {unknown} error - Error to check\n   * @returns {boolean} True if the error is retryable\n   *\n   * @description Identifies transient errors that may succeed on retry, such as:\n   * - Database deadlocks\n   * - Temporary connection failures\n   * - Lock timeouts\n   * - Transient network errors\n   *\n   * @example\n   * ```typescript\n   * if (TransactionManager.isRetryableError(error)) {\n   *   // Retry the operation\n   * } else {\n   *   // Fail immediately\n   * }\n   * ```\n   */\n  private static isRetryableError(error: unknown): boolean {\n    if (error instanceof DatabaseError) {\n      return error.isRetryable();\n    }\n    return false;\n  }\n\n  /**\n   * Gets the current number of active transactions\n   *\n   * @returns {number} Count of active transactions\n   *\n   * @description Returns the number of transactions currently being executed.\n   * Useful for monitoring system load and debugging transaction leaks.\n   *\n   * @example\n   * ```typescript\n   * const activeCount = manager.getActiveTransactionCount();\n   * console.log(`Active transactions: ${activeCount}`);\n   * ```\n   */\n  getActiveTransactionCount(): number {\n    return this.activeTransactions.size;\n  }\n\n  /**\n   * Retrieves a specific transaction context by ID\n   *\n   * @param {string} transactionId - Transaction ID to look up\n   * @returns {TransactionContext | undefined} Transaction context if found\n   *\n   * @description Gets the context of an active transaction for monitoring\n   * or debugging purposes. Returns undefined if the transaction has completed\n   * or doesn't exist.\n   *\n   * @example\n   * ```typescript\n   * const context = manager.getTransaction('tx_1703123456789_42');\n   * if (context) {\n   *   console.log(`Transaction started at: ${context.startTime}`);\n   *   console.log(`Operations: ${context.operations.length}`);\n   * }\n   * ```\n   */\n  getTransaction(transactionId: string): TransactionContext | undefined {\n    return this.activeTransactions.get(transactionId);\n  }\n}\n\n/**\n * Executes a function within a transaction context using a service's database connection\n *\n * @template TService - Service type that contains a db property\n * @template TResult - Return type of the operation\n * @param {TService} service - Service instance with database connection\n * @param {(service: TService, context: TransactionContext) => Promise<TResult>} operation - Operation to execute\n * @param {TransactionOptions} [options={}] - Transaction configuration\n * @returns {Promise<TResult>} Result of the operation\n *\n * @description Utility function that wraps service operations in a transaction,\n * providing both the service instance and transaction context to the operation.\n *\n * @example\n * ```typescript\n * const result = await withTransaction(\n *   taskService,\n *   async (service, context) => {\n *     const task = await service.createTask(data);\n *     manager.addRollbackAction(context, async () => {\n *       await service.deleteTask(task.id);\n *     });\n *     return task;\n *   },\n *   { isolationLevel: 'READ_COMMITTED' }\n * );\n * ```\n */\nexport function withTransaction<TService extends { db: DatabaseConnection }, TResult>(\n  service: TService,\n  operation: (service: TService, context: TransactionContext) => Promise<TResult>,\n  options: TransactionOptions = {}\n): Promise<TResult> {\n  const transactionManager = new TransactionManager(service.db);\n  return transactionManager.executeTransaction(\n    async context => operation(service, context),\n    options\n  );\n}\n\n/**\n * Executes batch operations within transactions with configurable batch sizes\n *\n * @template T - Type of items to process\n * @template R - Type of operation results\n * @param {DatabaseConnection} db - Database connection\n * @param {T[]} items - Array of items to process\n * @param {(item: T, index: number) => Promise<R>} operation - Operation to perform on each item\n * @param {TransactionOptions & { batchSize?: number }} [options={}] - Transaction and batch options\n * @returns {Promise<R[]>} Array of operation results\n *\n * @description Processes large datasets in batches within separate transactions to:\n * - Avoid long-running transactions that block other operations\n * - Reduce memory usage for large datasets\n * - Provide better error isolation (only current batch fails)\n * - Enable progress tracking between batches\n *\n * @example\n * ```typescript\n * // Process 1000 users in batches of 100\n * const results = await batchInTransaction(\n *   db,\n *   users,\n *   async (user, index) => {\n *     console.log(`Processing user ${index + 1}/${users.length}`);\n *     return await updateUserStatus(user.id, 'active');\n *   },\n *   {\n *     batchSize: 100,\n *     isolationLevel: 'READ_COMMITTED',\n *     timeout: 60000\n *   }\n * );\n * ```\n */\nexport async function batchInTransaction<T, R>(\n  db: DatabaseConnection,\n  items: T[],\n  operation: (item: T, index: number) => Promise<R>,\n  options: TransactionOptions & { batchSize?: number } = {}\n): Promise<R[]> {\n  const { batchSize = 100, ...transactionOptions } = options;\n  const transactionManager = new TransactionManager(db);\n  const results: R[] = [];\n\n  for (let i = 0; i < items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize);\n    const batchResults = await transactionManager.executeTransaction(async () => {\n      const batchPromises = batch.map((item, index) => operation(item, i + index));\n      return Promise.all(batchPromises);\n    }, transactionOptions);\n    results.push(...batchResults);\n  }\n\n  return results;\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/typeGuards.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 110,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 110,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Type guard utilities for runtime type checking and validation\n */\n\n/**\n * Checks if a value is an Error instance\n */\nexport function isError(value: unknown): value is Error {\n  return value instanceof Error;\n}\n\n/**\n * Checks if a value is an Error with a message property\n */\nexport function isErrorWithMessage(value: unknown): value is Error & { message: string } {\n  return isError(value) && typeof value.message === 'string';\n}\n\n/**\n * Checks if a value is a record (object) type\n */\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Checks if a value is a string\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if a value is a number\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !Number.isNaN(value);\n}\n\n/**\n * Checks if a value is a boolean\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === 'boolean';\n}\n\n/**\n * Checks if a value is null or undefined\n */\nexport function isNullish(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Checks if a value is defined (not null or undefined)\n */\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\n/**\n * Checks if a value is an array\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  return Array.isArray(value);\n}\n\n/**\n * Checks if a value is an array of strings\n */\nexport function isStringArray(value: unknown): value is string[] {\n  return isArray(value) && value.every(isString);\n}\n\n/**\n * Checks if a value is an array of numbers\n */\nexport function isNumberArray(value: unknown): value is number[] {\n  return isArray(value) && value.every(isNumber);\n}\n\n/**\n * Type guard for checking if an object has a specific property\n */\nexport function hasProperty<K extends PropertyKey>(\n  obj: unknown,\n  prop: K\n): obj is Record<K, unknown> {\n  return isRecord(obj) && prop in obj;\n}\n\n/**\n * Type guard for checking multiple properties exist\n */\nexport function hasProperties<K extends PropertyKey>(\n  obj: unknown,\n  ...props: K[]\n): obj is Record<K, unknown> {\n  return isRecord(obj) && props.every(prop => prop in obj);\n}\n\n/**\n * Safe JSON parse with type guard\n */\nexport function safeJsonParse<T>(\n  json: string,\n  validator: (value: unknown) => value is T\n): T | null {\n  try {\n    const parsed = JSON.parse(json);\n    return validator(parsed) ? parsed : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Type guard for API response validation\n */\nexport interface ApiResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\nexport function isApiResponse<T>(\n  value: unknown,\n  dataValidator?: (data: unknown) => data is T\n): value is ApiResponse<T> {\n  if (!isRecord(value)) return false;\n  if (!isBoolean(value.success)) return false;\n\n  if (hasProperty(value, 'data') && dataValidator && !dataValidator(value.data)) {\n    return false;\n  }\n\n  if (hasProperty(value, 'error') && !isString(value.error)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Type guard for pagination parameters\n */\nexport interface PaginationParams {\n  page?: number;\n  limit?: number;\n  sort?: string;\n  order?: 'asc' | 'desc';\n}\n\nexport function isPaginationParams(value: unknown): value is PaginationParams {\n  if (!isRecord(value)) return false;\n\n  if (hasProperty(value, 'page') && !isNumber(value.page)) return false;\n  if (hasProperty(value, 'limit') && !isNumber(value.limit)) return false;\n  if (hasProperty(value, 'sort') && !isString(value.sort)) return false;\n  if (hasProperty(value, 'order') && value.order !== 'asc' && value.order !== 'desc') {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Safely extract error message from unknown error\n */\nexport function getErrorMessage(error: unknown): string {\n  if (isErrorWithMessage(error)) {\n    return error.message;\n  }\n\n  if (isString(error)) {\n    return error;\n  }\n\n  if (isRecord(error) && isString(error.message)) {\n    return error.message;\n  }\n\n  return 'An unknown error occurred';\n}\n\n/**\n * Type guard for WebSocket message validation\n */\nexport interface WebSocketMessage<T = unknown> {\n  type: string;\n  payload?: T;\n  id?: string;\n}\n\nexport function isWebSocketMessage<T>(\n  value: unknown,\n  payloadValidator?: (payload: unknown) => payload is T\n): value is WebSocketMessage<T> {\n  if (!isRecord(value)) return false;\n  if (!isString(value.type)) return false;\n\n  if (hasProperty(value, 'payload') && payloadValidator && !payloadValidator(value.payload)) {\n    return false;\n  }\n\n  if (hasProperty(value, 'id') && !isString(value.id)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Assert that a value matches a type guard, throwing if not\n */\nexport function assertType<T>(\n  value: unknown,\n  guard: (value: unknown) => value is T,\n  errorMessage = 'Type assertion failed'\n): asserts value is T {\n  if (!guard(value)) {\n    throw new TypeError(errorMessage);\n  }\n}\n\n/**\n * Create a type guard for a literal union type\n */\nexport function isLiteralUnion<T extends string | number>(\n  validValues: readonly T[]\n): (value: unknown) => value is T {\n  const valueSet = new Set(validValues);\n  return (value: unknown): value is T =>\n    (isString(value) || isNumber(value)) && valueSet.has(value as T);\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/typeImprovements.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 162,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 162,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any[]` typed value.",
        "line": 181,
        "column": 3,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 181,
        "endColumn": 47
      },
      {
        "ruleId": "new-cap",
        "severity": 2,
        "message": "A constructor name should not start with a lowercase letter.",
        "line": 193,
        "column": 23,
        "nodeType": "NewExpression",
        "messageId": "lower",
        "endLine": 193,
        "endColumn": 32
      },
      {
        "ruleId": "no-promise-executor-return",
        "severity": 2,
        "message": "Return values from promise executor functions cannot be read.",
        "line": 227,
        "column": 38,
        "nodeType": "CallExpression",
        "messageId": "returnsValue",
        "endLine": 227,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "wrapBraces",
            "fix": { "range": [5922, 5950], "text": "{setTimeout(resolve, delayMs)}" },
            "desc": "Wrap the expression in `{}`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Type Improvements Utilities\n *\n * This module provides common type replacements and improvements for the codebase\n * to help systematically improve TypeScript type coverage.\n */\n\nimport type { QueryParameters } from '../database/connection';\n\n/**\n * Common type replacements for better type safety\n */\n\n// Database-related types\nexport type DatabaseParams = QueryParameters;\nexport type DatabaseResult<T = unknown> = T[];\n\n// API-related types\nexport interface ApiRequest {\n  body?: unknown;\n  query?: Record<string, unknown>;\n  params?: Record<string, unknown>;\n  headers?: Record<string, string>;\n}\n\nexport interface ApiResponse<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  message?: string;\n}\n\n// Error handling types\nexport type ErrorHandler = (error: unknown) => void;\nexport type AsyncErrorHandler = (error: unknown) => Promise<void>;\n\n// Event handling types\nexport interface EventData {\n  type: string;\n  payload?: unknown;\n  timestamp?: Date;\n  id?: string;\n}\n\nexport type EventHandler<T = unknown> = (event: EventData, data?: T) => void;\nexport type AsyncEventHandler<T = unknown> = (event: EventData, data?: T) => Promise<void>;\n\n// Configuration types\nexport interface ConfigValue {\n  value: unknown;\n  type: 'string' | 'number' | 'boolean' | 'object' | 'array';\n  required?: boolean;\n}\n\nexport type ConfigData = Record<string, ConfigValue>;\n\n// CLI-related types\nexport interface CliOptions {\n  [key: string]: unknown;\n}\n\nexport interface CliCommand {\n  name: string;\n  description: string;\n  options?: CliOptions;\n  action: (...args: unknown[]) => Promise<void> | void;\n}\n\n// WebSocket types\nexport interface WebSocketMessage<T = unknown> {\n  type: string;\n  payload?: T;\n  id?: string;\n  timestamp?: Date;\n}\n\nexport interface WebSocketConnection {\n  id: string;\n  connected: boolean;\n  subscriptions: string[];\n  lastActivity: Date;\n}\n\n// Validation types\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport type Validator<T = unknown> = (value: T) => ValidationResult;\n\n// Utility types for common patterns\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\nexport type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;\n\n// Function types\nexport type AsyncFunction<TArgs extends unknown[] = unknown[], TReturn = unknown> = (\n  ...args: TArgs\n) => Promise<TReturn>;\n\nexport type SyncFunction<TArgs extends unknown[] = unknown[], TReturn = unknown> = (\n  ...args: TArgs\n) => TReturn;\n\n// Collection types\nexport type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;\nexport type ObjectValues<T> = T[keyof T];\n\n// Type guards for common patterns\nexport function isApiRequest(value: unknown): value is ApiRequest {\n  return (\n    (typeof value === 'object' && value !== null && (value as ApiRequest).body !== undefined) ||\n    (value as ApiRequest).query !== undefined ||\n    (value as ApiRequest).params !== undefined\n  );\n}\n\nexport function isApiResponse<T = unknown>(value: unknown): value is ApiResponse<T> {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof (value as ApiResponse).success === 'boolean'\n  );\n}\n\nexport function isEventData(value: unknown): value is EventData {\n  return (\n    typeof value === 'object' && value !== null && typeof (value as EventData).type === 'string'\n  );\n}\n\nexport function isWebSocketMessage<T = unknown>(value: unknown): value is WebSocketMessage<T> {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof (value as WebSocketMessage).type === 'string'\n  );\n}\n\nexport function isCliOptions(value: unknown): value is CliOptions {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nexport function isConfigData(value: unknown): value is ConfigData {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    !Array.isArray(value) &&\n    Object.values(value).every(\n      v => typeof v === 'object' && v !== null && typeof (v as ConfigValue).type === 'string'\n    )\n  );\n}\n\n// Type-safe utility functions\nexport function safeJsonParse<T>(\n  json: string,\n  validator?: (value: unknown) => value is T\n): T | null {\n  try {\n    const parsed = JSON.parse(json);\n    if (validator && !validator(parsed)) {\n      return null;\n    }\n    return parsed as T;\n  } catch {\n    return null;\n  }\n}\n\nexport function safeStringify(value: unknown): string {\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return String(value);\n  }\n}\n\nexport function createTypedArray<T>(length: number, defaultValue: T): T[] {\n  return new Array(length).fill(defaultValue);\n}\n\nexport function createTypedRecord<K extends string, V>(entries: Array<[K, V]>): Record<K, V> {\n  return Object.fromEntries(entries) as Record<K, V>;\n}\n\n// Type-safe error handling\nexport function createErrorHandler<T extends Error = Error>(\n  errorType: new (message: string) => T\n): (message: string, cause?: unknown) => T {\n  return (message: string, cause?: unknown) => {\n    const error = new errorType(message);\n    if (cause && error instanceof Error) {\n      (error as Error & { cause?: unknown }).cause = cause;\n    }\n    return error;\n  };\n}\n\n// Type-safe async operations\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  timeoutMessage = 'Operation timed out'\n): Promise<T> {\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    setTimeout(() => reject(new Error(timeoutMessage)), timeoutMs);\n  });\n\n  return Promise.race([promise, timeoutPromise]);\n}\n\nexport async function retryOperation<T>(\n  operation: () => Promise<T>,\n  maxRetries: number,\n  delayMs: number\n): Promise<T> {\n  let lastError: unknown;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      if (attempt < maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, delayMs));\n      }\n    }\n  }\n\n  throw lastError;\n}\n\n// Type-safe validation utilities\nexport function createValidator<T>(rules: Array<(value: T) => string | null>): Validator<T> {\n  return (value: T): ValidationResult => {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    for (const rule of rules) {\n      const result = rule(value);\n      if (result) {\n        errors.push(result);\n      }\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  };\n}\n\n// Type-safe transformation utilities\nexport function mapValues<T, U>(\n  obj: Record<string, T>,\n  transform: (value: T, key: string) => U\n): Record<string, U> {\n  const result: Record<string, U> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    result[key] = transform(value, key);\n  }\n\n  return result;\n}\n\nexport function filterValues<T>(\n  obj: Record<string, T>,\n  predicate: (value: T, key: string) => boolean\n): Record<string, T> {\n  const result: Record<string, T> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (predicate(value, key)) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n// Type-safe async utilities\nexport async function mapAsync<T, U>(\n  items: T[],\n  transform: (item: T, index: number) => Promise<U>\n): Promise<U[]> {\n  const promises = items.map((item, index) => transform(item, index));\n  return Promise.all(promises);\n}\n\nexport async function filterAsync<T>(\n  items: T[],\n  predicate: (item: T, index: number) => Promise<boolean>\n): Promise<T[]> {\n  const results: T[] = [];\n\n  // eslint-disable-next-line no-await-in-loop\n  for (let i = 0; i < items.length; i++) {\n    if (await predicate(items[i], i)) {\n      results.push(items[i]);\n    }\n  }\n\n  return results;\n}\n\n// Type-safe memoization\nexport function memoize<TArgs extends unknown[], TReturn>(\n  fn: (...args: TArgs) => TReturn,\n  keyGenerator?: (...args: TArgs) => string\n): (...args: TArgs) => TReturn {\n  const cache = new Map<string, TReturn>();\n\n  return (...args: TArgs): TReturn => {\n    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);\n\n    const cached = cache.get(key);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Type-safe debouncing\nexport function debounce<TArgs extends unknown[]>(\n  fn: (...args: TArgs) => void,\n  delayMs: number\n): (...args: TArgs) => void {\n  let timeoutId: NodeJS.Timeout | undefined;\n\n  return (...args: TArgs): void => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => fn(...args), delayMs);\n  };\n}\n\n// Type-safe throttling\nexport function throttle<TArgs extends unknown[]>(\n  fn: (...args: TArgs) => void,\n  delayMs: number\n): (...args: TArgs) => void {\n  let lastCall = 0;\n\n  return (...args: TArgs): void => {\n    const now = Date.now();\n\n    if (now - lastCall >= delayMs) {\n      lastCall = now;\n      fn(...args);\n    }\n  };\n}\n\n// Export common type replacements for easy import\nexport const TypeReplacements = {\n  // Database\n  'params: any[]': 'params: QueryParameters',\n  'params: any': 'params: QueryParameters',\n\n  // Error handling\n  'error: any': 'error: unknown',\n  'err: any': 'err: unknown',\n\n  // Data handling\n  'data: any': 'data: unknown',\n  'result: any': 'result: unknown',\n  'response: any': 'response: unknown',\n  'value: any': 'value: unknown',\n\n  // Collections\n  'items: any[]': 'items: unknown[]',\n  'array: any[]': 'array: unknown[]',\n  'list: any[]': 'list: unknown[]',\n\n  // Objects\n  'obj: any': 'obj: Record<string, unknown>',\n  'object: any': 'object: Record<string, unknown>',\n  'config: any': 'config: ConfigData',\n  'options: any': 'options: CliOptions',\n\n  // Functions\n  'callback: any': 'callback: (...args: unknown[]) => void',\n  'handler: any': 'handler: (event: EventData) => void',\n  'fn: any': 'fn: (...args: unknown[]) => unknown',\n} as const;\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/validation.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 211,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 211,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7941, 7944], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7941, 7944], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 219,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 219,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8160, 8163], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8160, 8163], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 222,
        "column": 5,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 222,
        "endColumn": 27
      },
      {
        "ruleId": "no-restricted-globals",
        "severity": 2,
        "message": "Unexpected use of 'isNaN'. Use Number.isNaN instead https://github.com/airbnb/javascript#standard-library--isnan",
        "line": 550,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "customMessage",
        "endLine": 550,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 602,
        "column": 5,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 602,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 603,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 603,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 603,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 603,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [19963, 19966], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [19963, 19966], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [propKey] on an `any` value.",
        "line": 603,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 603,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 606,
        "column": 9,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 606,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 611,
        "column": 9,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 611,
        "endColumn": 31
      },
      {
        "ruleId": "func-names",
        "severity": 1,
        "message": "Unexpected unnamed function.",
        "line": 614,
        "column": 14,
        "nodeType": "FunctionExpression",
        "messageId": "unnamed",
        "endLine": 614,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 614,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 614,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20237, 20240], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20237, 20240], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 614,
        "column": 44,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 614,
        "endColumn": 47,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20251, 20254], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20251, 20254], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-return",
        "severity": 1,
        "message": "Unsafe return of an `any` typed value.",
        "line": 620,
        "column": 9,
        "nodeType": "ReturnStatement",
        "messageId": "unsafeReturn",
        "endLine": 620,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 620,
        "column": 16,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 620,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .apply on an `any` value.",
        "line": 620,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 620,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 15,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Validation utilities and schemas for MCP Kanban\n *\n * @module utils/validation\n * @description Provides comprehensive input validation using Zod schemas and business rules.\n * Includes validation schemas for all entity types, common validation patterns, business rule\n * enforcement, and error handling utilities. Ensures data integrity and provides clear\n * validation error messages for API consumers.\n *\n * @example\n * ```typescript\n * import { BoardValidation, validateInput, BusinessRules } from '@/utils/validation';\n *\n * // Validate board creation data\n * const boardData = validateInput(BoardValidation.create, {\n *   name: 'Project Board',\n *   description: 'Main project tracking',\n *   color: '#2196F3'\n * });\n *\n * // Apply business rules\n * BusinessRules.board.validateName(boardData.name);\n * BusinessRules.board.validateColor(boardData.color);\n *\n * // Validate task data\n * const taskData = validateInput(TaskValidation.create, {\n *   title: 'Implement feature',\n *   board_id: 'uuid-here',\n *   column_id: 'uuid-here'\n * });\n * ```\n */\n\nimport { z } from 'zod';\nimport type { ServiceError } from '@/types';\nimport { optionalWithUndefined } from './zod-helpers';\n\n/**\n * Board validation schemas\n *\n * @constant {Object} BoardValidation\n * @description Zod validation schemas for board operations including creation and updates\n */\nexport const BoardValidation = {\n  create: z.object({\n    name: z.string().min(1, 'Board name is required').max(100, 'Board name too long'),\n    description: optionalWithUndefined(z.string().max(500, 'Description too long')),\n    color: optionalWithUndefined(z.string().regex(/^#[0-9A-F]{6}$/i, 'Invalid color format')),\n  }),\n\n  update: z.object({\n    name: optionalWithUndefined(\n      z.string().min(1, 'Board name is required').max(100, 'Board name too long')\n    ),\n    description: optionalWithUndefined(z.string().max(500, 'Description too long')),\n    color: optionalWithUndefined(z.string().regex(/^#[0-9A-F]{6}$/i, 'Invalid color format')),\n    archived: optionalWithUndefined(z.boolean()),\n  }),\n};\n\n/**\n * Task validation schemas\n *\n * @constant {Object} TaskValidation\n * @description Zod validation schemas for task operations including creation, updates, and dependencies\n */\nexport const TaskValidation = {\n  create: z.object({\n    title: z.string().min(1, 'Task title is required').max(200, 'Title too long'),\n    description: optionalWithUndefined(z.string().max(2000, 'Description too long')),\n    board_id: z.string().uuid('Invalid board ID'),\n    column_id: z.string().uuid('Invalid column ID'),\n    position: optionalWithUndefined(z.number().int().min(0)),\n    priority: optionalWithUndefined(z.number().int().min(0).max(10)),\n    status: optionalWithUndefined(z.enum(['todo', 'in_progress', 'done', 'blocked', 'archived'])),\n    assignee: optionalWithUndefined(z.string().max(100, 'Assignee name too long')),\n    due_date: optionalWithUndefined(z.date()),\n    estimated_hours: optionalWithUndefined(z.number().positive()),\n    parent_task_id: optionalWithUndefined(z.string().uuid('Invalid parent task ID')),\n    metadata: optionalWithUndefined(z.string().max(5000, 'Metadata too long')),\n  }),\n\n  update: z.object({\n    title: optionalWithUndefined(\n      z.string().min(1, 'Task title is required').max(200, 'Title too long')\n    ),\n    description: optionalWithUndefined(z.string().max(2000, 'Description too long')),\n    column_id: optionalWithUndefined(z.string().uuid('Invalid column ID')),\n    position: optionalWithUndefined(z.number().int().min(0)),\n    priority: optionalWithUndefined(z.number().int().min(0).max(10)),\n    status: optionalWithUndefined(z.enum(['todo', 'in_progress', 'done', 'blocked', 'archived'])),\n    assignee: optionalWithUndefined(z.string().max(100, 'Assignee name too long')),\n    due_date: optionalWithUndefined(z.date()),\n    estimated_hours: optionalWithUndefined(z.number().positive()),\n    actual_hours: optionalWithUndefined(z.number().positive()),\n    parent_task_id: optionalWithUndefined(z.string().uuid('Invalid parent task ID')),\n    metadata: optionalWithUndefined(z.string().max(5000, 'Metadata too long')),\n  }),\n\n  dependency: z.object({\n    task_id: z.string().uuid('Invalid task ID'),\n    depends_on_task_id: z.string().uuid('Invalid dependency task ID'),\n    dependency_type: z.enum(['blocks', 'relates_to', 'duplicates']).optional(),\n  }),\n};\n\n/**\n * Note validation schemas\n *\n * @constant {Object} NoteValidation\n * @description Zod validation schemas for note operations including creation, updates, and search\n */\nexport const NoteValidation = {\n  create: z.object({\n    task_id: z.string().uuid('Invalid task ID'),\n    content: z.string().min(1, 'Note content is required').max(5000, 'Content too long'),\n    category: optionalWithUndefined(\n      z.enum(['general', 'progress', 'blocker', 'decision', 'question'])\n    ),\n    pinned: optionalWithUndefined(z.boolean()),\n  }),\n\n  update: z.object({\n    content: optionalWithUndefined(\n      z.string().min(1, 'Note content is required').max(5000, 'Content too long')\n    ),\n    category: optionalWithUndefined(\n      z.enum(['general', 'progress', 'blocker', 'decision', 'question'])\n    ),\n    pinned: optionalWithUndefined(z.boolean()),\n  }),\n\n  search: z.object({\n    query: z.string().min(1, 'Search query is required').max(200, 'Query too long'),\n    task_id: z.string().uuid('Invalid task ID').optional(),\n    board_id: z.string().uuid('Invalid board ID').optional(),\n    category: z.enum(['general', 'progress', 'blocker', 'decision', 'question']).optional(),\n    pinned_only: z.boolean().optional(),\n    highlight: z.boolean().optional(),\n    limit: z.number().int().min(1).max(100).optional(),\n    offset: z.number().int().min(0).optional(),\n  }),\n};\n\n/**\n * Tag validation schemas\n *\n * @constant {Object} TagValidation\n * @description Zod validation schemas for tag operations including creation, updates, and assignments\n */\nexport const TagValidation = {\n  create: z.object({\n    name: z.string().min(1, 'Tag name is required').max(50, 'Tag name too long'),\n    color: optionalWithUndefined(z.string().regex(/^#[0-9A-F]{6}$/i, 'Invalid color format')),\n    description: optionalWithUndefined(z.string().max(200, 'Description too long')),\n    parent_tag_id: optionalWithUndefined(z.string().uuid('Invalid parent tag ID')),\n  }),\n\n  update: z.object({\n    name: optionalWithUndefined(\n      z.string().min(1, 'Tag name is required').max(50, 'Tag name too long')\n    ),\n    color: optionalWithUndefined(z.string().regex(/^#[0-9A-F]{6}$/i, 'Invalid color format')),\n    description: optionalWithUndefined(z.string().max(200, 'Description too long')),\n    parent_tag_id: optionalWithUndefined(z.string().uuid('Invalid parent tag ID')),\n  }),\n\n  assignment: z.object({\n    task_id: z.string().uuid('Invalid task ID'),\n    tag_id: z.string().uuid('Invalid tag ID'),\n  }),\n};\n\n/**\n * Pagination validation schema\n *\n * @constant {z.ZodSchema} PaginationValidation\n * @description Validates pagination parameters for list operations\n */\nexport const PaginationValidation = z.object({\n  limit: z.number().int().min(1).max(100).optional(),\n  offset: z.number().int().min(0).optional(),\n  sortBy: z.string().max(50).optional(),\n  sortOrder: z.enum(['asc', 'desc']).optional(),\n});\n\n/**\n * Filter validation schema\n *\n * @constant {z.ZodSchema} FilterValidation\n * @description Validates filtering parameters for search and list operations\n */\nexport const FilterValidation = z.object({\n  archived: z.boolean().optional(),\n  search: z.string().max(200).optional(),\n});\n\n/**\n * Custom validation error class\n *\n * @class ValidationError\n * @extends Error\n * @implements ServiceError\n * @description Standardized error class for validation failures with structured details\n */\nexport class ValidationError extends Error implements ServiceError {\n  public readonly code = 'VALIDATION_ERROR';\n\n  public readonly statusCode = 400;\n\n  public readonly details: any;\n\n  /**\n   * Create a validation error\n   *\n   * @param {string} message - Error message\n   * @param {any} [details] - Additional error details (e.g., Zod error array)\n   */\n  constructor(message: string, details?: any) {\n    super(message);\n    this.name = 'ValidationError';\n    this.details = details;\n  }\n}\n\n/**\n * Validate input data against a Zod schema\n *\n * @template T - Expected return type after validation\n * @param {z.ZodSchema<T>} schema - Zod schema to validate against\n * @param {unknown} data - Input data to validate\n * @returns {T} Validated and typed data\n * @throws {ValidationError} If validation fails with detailed error information\n *\n * @example\n * ```typescript\n * const boardData = validateInput(BoardValidation.create, {\n *   name: 'My Board',\n *   description: 'Project board'\n * });\n * // boardData is now typed and validated\n * ```\n */\nexport function validateInput<T>(schema: z.ZodSchema<T>, data: unknown): T {\n  try {\n    return schema.parse(data);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const messages = error.errors.map(\n        err => `${String(String(err.path.join('.')))}: ${String(String(err.message))}`\n      );\n      throw new ValidationError(\n        `Validation failed: ${String(String(messages.join(', ')))}`,\n        error.errors\n      );\n    }\n    throw error;\n  }\n}\n\n/**\n * Validate optional input data against a Zod schema\n *\n * @template T - Expected return type after validation\n * @param {z.ZodSchema<T>} schema - Zod schema to validate against\n * @param {unknown} data - Input data to validate (may be null/undefined)\n * @returns {T | undefined} Validated data or undefined if input was null/undefined\n * @throws {ValidationError} If validation fails\n *\n * @example\n * ```typescript\n * const updateData = validateOptionalInput(BoardValidation.update, requestBody);\n * if (updateData) {\n *   // updateData is validated and can be used safely\n * }\n * ```\n */\nexport function validateOptionalInput<T>(schema: z.ZodSchema<T>, data: unknown): T | undefined {\n  if (data === undefined || data === null) {\n    return undefined;\n  }\n  return validateInput(schema, data);\n}\n\n/**\n * Business rules and domain-specific validation functions\n *\n * @constant {Object} BusinessRules\n * @description Collection of business rule validators organized by entity type.\n * These enforce domain-specific constraints beyond basic schema validation.\n */\nexport const BusinessRules = {\n  /**\n   * Board-specific business rules\n   */\n  board: {\n    /**\n     * Validate board name format and content\n     *\n     * @param {string} name - Board name to validate\n     * @throws {ValidationError} If name format is invalid\n     */\n    validateName: (name: string): void => {\n      if (name.trim() !== name) {\n        throw new ValidationError('Board name cannot have leading or trailing whitespace');\n      }\n      if (name.includes('  ')) {\n        throw new ValidationError('Board name cannot contain multiple consecutive spaces');\n      }\n    },\n\n    /**\n     * Validate board color against recommended palette\n     *\n     * @param {string} color - Hex color code to validate\n     */\n    validateColor: (color: string): void => {\n      const validColors = [\n        '#FF6B6B',\n        '#4ECDC4',\n        '#45B7D1',\n        '#96CEB4',\n        '#FFEAA7',\n        '#DDA0DD',\n        '#98D8C8',\n        '#F7DC6F',\n        '#BB8FCE',\n        '#85C1E9',\n      ];\n      if (!validColors.includes(color.toUpperCase())) {\n        // Allow any valid hex color, but warn about recommended colors\n      }\n    },\n  },\n\n  /**\n   * Task-specific business rules\n   */\n  task: {\n    /**\n     * Validate task title format and length\n     *\n     * @param {string} title - Task title to validate\n     * @throws {ValidationError} If title format is invalid\n     */\n    validateTitle: (title: string): void => {\n      if (title.trim() !== title) {\n        throw new ValidationError('Task title cannot have leading or trailing whitespace');\n      }\n      if (title.length < 3) {\n        throw new ValidationError('Task title must be at least 3 characters long');\n      }\n    },\n\n    /**\n     * Validate task priority value\n     *\n     * @param {number} priority - Priority value to validate (0-10)\n     * @throws {ValidationError} If priority is invalid\n     */\n    validatePriority: (priority: number): void => {\n      if (!Number.isInteger(priority)) {\n        throw new ValidationError('Priority must be an integer');\n      }\n      if (priority < 0 || priority > 10) {\n        throw new ValidationError('Priority must be between 0 and 10');\n      }\n    },\n\n    /**\n     * Validate estimated hours value\n     *\n     * @param {number} hours - Estimated hours to validate\n     * @throws {ValidationError} If hours value is invalid\n     */\n    validateEstimatedHours: (hours: number): void => {\n      if (hours <= 0) {\n        throw new ValidationError('Estimated hours must be positive');\n      }\n      if (hours > 1000) {\n        throw new ValidationError('Estimated hours cannot exceed 1000');\n      }\n    },\n\n    /**\n     * Validate due date constraints\n     *\n     * @param {Date} dueDate - Due date to validate\n     * @throws {ValidationError} If due date is invalid\n     */\n    validateDueDate: (dueDate: Date): void => {\n      const now = new Date();\n      const oneYearFromNow = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate());\n\n      if (dueDate < now) {\n        // Allow past due dates for historical tasks\n      }\n      if (dueDate > oneYearFromNow) {\n        throw new ValidationError('Due date cannot be more than one year in the future');\n      }\n    },\n\n    /**\n     * Validate task status transitions\n     *\n     * @param {string} currentStatus - Current task status\n     * @param {string} newStatus - Target status\n     * @throws {ValidationError} If transition is invalid\n     */\n    validateStatusTransition: (currentStatus: string, newStatus: string): void => {\n      const validTransitions: Record<string, string[]> = {\n        todo: ['in_progress', 'blocked', 'archived'],\n        in_progress: ['done', 'todo', 'blocked', 'archived'],\n        done: ['todo', 'in_progress', 'archived'],\n        blocked: ['todo', 'in_progress', 'archived'],\n        archived: ['todo', 'in_progress', 'done', 'blocked'],\n      };\n\n      if (!validTransitions[currentStatus]?.includes(newStatus)) {\n        throw new ValidationError(\n          `Invalid status transition from ${String(currentStatus)} to ${String(newStatus)}`\n        );\n      }\n    },\n  },\n\n  /**\n   * Note-specific business rules\n   */\n  note: {\n    /**\n     * Validate note content format\n     *\n     * @param {string} content - Note content to validate\n     * @throws {ValidationError} If content format is invalid\n     */\n    validateContent: (content: string): void => {\n      if (content.trim() !== content) {\n        throw new ValidationError('Note content cannot have leading or trailing whitespace');\n      }\n      if (content.length < 1) {\n        throw new ValidationError('Note content cannot be empty');\n      }\n    },\n\n    /**\n     * Validate note category\n     *\n     * @param {string} category - Note category to validate\n     * @throws {ValidationError} If category is invalid\n     */\n    validateCategory: (category: string): void => {\n      const validCategories = ['general', 'progress', 'blocker', 'decision', 'question'];\n      if (!validCategories.includes(category)) {\n        throw new ValidationError(`Invalid note category: ${String(category)}`);\n      }\n    },\n  },\n\n  /**\n   * Tag-specific business rules\n   */\n  tag: {\n    /**\n     * Validate tag name format and characters\n     *\n     * @param {string} name - Tag name to validate\n     * @throws {ValidationError} If name format is invalid\n     */\n    validateName: (name: string): void => {\n      if (name.trim() !== name) {\n        throw new ValidationError('Tag name cannot have leading or trailing whitespace');\n      }\n      if (name.includes(' ')) {\n        throw new ValidationError('Tag name cannot contain spaces');\n      }\n      if (!/^[a-zA-Z0-9_-]+$/.test(name)) {\n        throw new ValidationError(\n          'Tag name can only contain letters, numbers, underscores, and hyphens'\n        );\n      }\n    },\n\n    /**\n     * Validate tag hierarchy depth\n     *\n     * @param {number} depth - Hierarchy depth to validate\n     * @throws {ValidationError} If depth exceeds limit\n     */\n    validateHierarchyDepth: (depth: number): void => {\n      if (depth > 5) {\n        throw new ValidationError('Tag hierarchy cannot exceed 5 levels deep');\n      }\n    },\n  },\n\n  /**\n   * Context service-specific business rules\n   */\n  context: {\n    /**\n     * Validate lookback days parameter\n     *\n     * @param {number} days - Number of days to validate\n     * @throws {ValidationError} If days value is invalid\n     */\n    validateLookbackDays: (days: number): void => {\n      if (days < 1) {\n        throw new ValidationError('Lookback days must be at least 1');\n      }\n      if (days > 365) {\n        throw new ValidationError('Lookback days cannot exceed 365');\n      }\n    },\n\n    /**\n     * Validate maximum items parameter\n     *\n     * @param {number} maxItems - Maximum items count to validate\n     * @throws {ValidationError} If maxItems value is invalid\n     */\n    validateMaxItems: (maxItems: number): void => {\n      if (maxItems < 1) {\n        throw new ValidationError('Max items must be at least 1');\n      }\n      if (maxItems > 1000) {\n        throw new ValidationError('Max items cannot exceed 1000');\n      }\n    },\n  },\n};\n\n/**\n * Common validation patterns and reusable schemas\n *\n * @constant {Object} CommonValidations\n * @description Collection of commonly used validation patterns for consistent validation across the application\n */\nexport const CommonValidations = {\n  /** UUID validation schema */\n  uuid: z.string().uuid('Invalid UUID format'),\n\n  /** Positive integer validation schema */\n  positiveInteger: z.number().int().positive('Must be a positive integer'),\n\n  /** Non-negative integer validation schema */\n  nonNegativeInteger: z.number().int().min(0, 'Must be non-negative'),\n\n  /** Date string validation schema */\n  dateString: z.string().refine(date => !isNaN(Date.parse(date)), 'Invalid date format'),\n\n  /** Email validation schema */\n  email: z.string().email('Invalid email format'),\n\n  /** URL validation schema */\n  url: z.string().url('Invalid URL format'),\n\n  /** Hex color validation schema */\n  color: z.string().regex(/^#[0-9A-F]{6}$/i, 'Invalid hex color format'),\n\n  /** URL slug validation schema */\n  slug: z.string().regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/, 'Invalid slug format'),\n\n  /** Sanitized string validation schema (prevents XSS) */\n  sanitizedString: z.string().refine(str => {\n    // Check for potential XSS/injection patterns\n    const dangerousPatterns = [\n      /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      /javascript:/gi,\n      /on\\w+\\s*=/gi,\n    ];\n    return !dangerousPatterns.some(pattern => pattern.test(str));\n  }, 'String contains potentially dangerous content'),\n};\n\n/**\n * Create a validated service proxy that automatically validates method inputs\n *\n * @template T - Service type\n * @param {T} service - Service instance to wrap with validation\n * @param {Record<string, z.ZodSchema>} validationConfig - Mapping of method names to validation schemas\n * @returns {T} Proxied service with automatic validation\n *\n * @example\n * ```typescript\n * const validatedBoardService = createValidatedService(boardService, {\n *   createBoard: BoardValidation.create,\n *   updateBoard: BoardValidation.update\n * });\n *\n * // Calls will be automatically validated\n * const board = await validatedBoardService.createBoard({\n *   name: 'Test Board'\n * }); // Validates input before calling original method\n * ```\n */\nexport function createValidatedService<T extends object>(\n  service: T,\n  validationConfig: Record<string, z.ZodSchema>\n): T {\n  return new Proxy(service, {\n    get(target, propKey) {\n      const originalMethod = (target as any)[propKey];\n\n      if (typeof originalMethod !== 'function') {\n        return originalMethod;\n      }\n\n      const validationSchema = validationConfig[propKey as string];\n      if (!validationSchema) {\n        return originalMethod;\n      }\n\n      return function (this: any, ...args: any[]) {\n        // Validate the first argument (usually the data)\n        if (args.length > 0 && args[0] !== undefined) {\n          validateInput(validationSchema, args[0]);\n        }\n\n        return originalMethod.apply(this, args);\n      };\n    },\n  });\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/utils/zod-helpers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/prefer-nullish-coalescing",
        "severity": 1,
        "message": "Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.",
        "line": 57,
        "column": 35,
        "nodeType": "ConditionalExpression",
        "messageId": "preferNullishOverTernary",
        "endLine": 57,
        "endColumn": 70,
        "suggestions": [
          {
            "messageId": "suggestNullish",
            "fix": { "range": [1711, 1746], "text": "val ?? undefined" },
            "desc": "Fix to nullish coalescing operator (`??`)."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 202,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 202,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Zod helper utilities for handling optional properties with exactOptionalPropertyTypes\n *\n * @module utils/zod-helpers\n * @description Provides utilities to work with Zod schemas when TypeScript's\n * exactOptionalPropertyTypes is enabled. This ensures optional properties\n * explicitly include undefined in their type union.\n */\n\nimport { z } from 'zod';\n\n/**\n * Creates an optional Zod schema that is compatible with exactOptionalPropertyTypes\n *\n * @template T - The inner schema type\n * @param {z.ZodType<T>} schema - The inner Zod schema\n * @returns {z.ZodOptional<z.ZodUnion<[z.ZodType<T>, z.ZodUndefined]>>}\n *          An optional schema that explicitly includes undefined\n *\n * @example\n * ```typescript\n * // Instead of:\n * const schema = z.object({\n *   name: z.string().optional()\n * });\n *\n * // Use:\n * const schema = z.object({\n *   name: optionalWithUndefined(z.string())\n * });\n * ```\n */\nexport function optionalWithUndefined<T>(\n  schema: z.ZodType<T>\n): z.ZodOptional<z.ZodUnion<[z.ZodType<T>, z.ZodUndefined]>> {\n  return z.union([schema, z.undefined()]).optional();\n}\n\n/**\n * Transform function for Zod schemas to handle undefined values properly\n *\n * @template T - The schema output type\n * @param {z.ZodType<T>} schema - The Zod schema to transform\n * @returns {z.ZodEffects<z.ZodType<T>, T | undefined, T | undefined>}\n *          A transformed schema that handles undefined values\n *\n * @example\n * ```typescript\n * const schema = z.object({\n *   name: withUndefinedTransform(z.string().optional())\n * });\n * ```\n */\nexport function withUndefinedTransform<T>(\n  schema: z.ZodType<T>\n): z.ZodEffects<z.ZodType<T>, T | undefined, T | undefined> {\n  return schema.transform(val => (val === undefined ? undefined : val));\n}\n\n/**\n * Creates a preprocessed optional string that handles empty strings as undefined\n *\n * @param {z.ZodString} [baseSchema] - Optional base string schema with additional validations\n * @returns {z.ZodEffects<z.ZodOptional<z.ZodString>, string | undefined, unknown>}\n *          A preprocessed optional string schema\n *\n * @example\n * ```typescript\n * const schema = z.object({\n *   description: optionalString(z.string().max(500))\n * });\n * ```\n */\nexport function optionalString(\n  baseSchema?: z.ZodString\n): z.ZodEffects<z.ZodOptional<z.ZodString>, string | undefined, unknown> {\n  const stringSchema = baseSchema ?? z.string();\n\n  return z.preprocess(val => {\n    if ((val === '' || val === null) ?? val === undefined) {\n      return undefined;\n    }\n    return val;\n  }, stringSchema.optional());\n}\n\n/**\n * Creates an object schema with all optional properties properly typed for exactOptionalPropertyTypes\n *\n * @template T - The shape of the object schema\n * @param {T} shape - The object shape definition\n * @returns {z.ZodObject<T>} An object schema with properly typed optional properties\n *\n * @example\n * ```typescript\n * const UpdateSchema = createOptionalSchema({\n *   name: z.string().min(1).max(100),\n *   description: z.string().max(500),\n *   priority: z.number().int().min(0).max(10)\n * });\n * ```\n */\nexport function createOptionalSchema<T extends z.ZodRawShape>(\n  shape: T\n): z.ZodObject<{ [K in keyof T]: z.ZodOptional<T[K]> }> {\n  const optionalShape = {} as { [K in keyof T]: z.ZodOptional<T[K]> };\n\n  Object.keys(shape).forEach(key => {\n    if (Object.prototype.hasOwnProperty.call(shape, key) && shape[key]) {\n      (optionalShape as Record<string, z.ZodOptional<z.ZodTypeAny>>)[key] = shape[key].optional();\n    }\n  });\n\n  return z.object(optionalShape);\n}\n\n/**\n * Helper to create update schemas where all fields are optional\n * and properly handle undefined values for exactOptionalPropertyTypes\n *\n * @template T - The shape of the create schema\n * @param {z.ZodObject<T>} createSchema - The create schema to base the update schema on\n * @returns {z.ZodObject<{ [K in keyof T]: z.ZodOptional<T[K]> }>}\n *          An update schema with all fields optional\n *\n * @example\n * ```typescript\n * const CreateTaskSchema = z.object({\n *   title: z.string().min(1),\n *   description: z.string(),\n *   priority: z.number()\n * });\n *\n * const UpdateTaskSchema = createUpdateSchema(CreateTaskSchema);\n * ```\n */\nexport function createUpdateSchema<T extends z.ZodRawShape>(\n  createSchema: z.ZodObject<T>\n): z.ZodObject<{ [K in keyof T]: z.ZodOptional<T[K]> }> {\n  const { shape } = createSchema;\n  return createOptionalSchema(shape);\n}\n\n/**\n * Utility type to extract the inferred type from a Zod schema with proper optional handling\n *\n * @template T - The Zod schema type\n */\nexport type InferWithOptionals<T extends z.ZodType> = {\n  [K in keyof z.infer<T>]?: z.infer<T>[K] | undefined;\n};\n\n/**\n * Create a schema preprocessor that filters out undefined values from objects\n *\n * @template T - The schema type\n * @param {z.ZodType<T>} schema - The schema to preprocess\n * @returns {z.ZodEffects<z.ZodType<T>, T, unknown>} A preprocessed schema\n *\n * @example\n * ```typescript\n * const schema = filterUndefined(z.object({\n *   name: z.string().optional(),\n *   age: z.number().optional()\n * }));\n * ```\n */\nexport function filterUndefined<T>(schema: z.ZodType<T>): z.ZodEffects<z.ZodType<T>, T, unknown> {\n  return z.preprocess(obj => {\n    if (typeof obj !== 'object' || obj === null) {\n      return obj;\n    }\n\n    const filtered: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if (value !== undefined) {\n        filtered[key] = value;\n      }\n    }\n    return filtered;\n  }, schema);\n}\n\n/**\n * Create a partial schema where all properties are optional and handle undefined\n *\n * @template T - The shape of the schema\n * @param {z.ZodObject<T>} schema - The schema to make partial\n * @returns {z.ZodObject<{ [K in keyof T]?: z.ZodOptional<T[K]> }>} A partial schema\n *\n * @example\n * ```typescript\n * const FullSchema = z.object({\n *   id: z.string(),\n *   name: z.string(),\n *   age: z.number()\n * });\n *\n * const PartialSchema = createPartialSchema(FullSchema);\n * ```\n */\nexport function createPartialSchema<T extends z.ZodRawShape>(schema: z.ZodObject<T>) {\n  return schema.partial();\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/auth.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'bcrypt' is defined but never used.",
        "line": 2,
        "column": 8,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'dbConnection' is defined but never used.",
        "line": 4,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 4,
        "endColumn": 22
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'authenticateWithJWT'.",
        "line": 76,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 76,
        "endColumn": 30
      },
      {
        "ruleId": "no-promise-executor-return",
        "severity": 2,
        "message": "Return values from promise executor functions cannot be read.",
        "line": 146,
        "column": 38,
        "nodeType": "CallExpression",
        "messageId": "returnsValue",
        "endLine": 146,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "wrapBraces",
            "fix": { "range": [4221, 4243], "text": "{setTimeout(resolve, 1)}" },
            "desc": "Wrap the expression in `{}`."
          }
        ]
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'authenticateWithCredentials'.",
        "line": 166,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 166,
        "endColumn": 38
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'hasPermission'.",
        "line": 249,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 249,
        "endColumn": 16
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'generateJWT'.",
        "line": 290,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 290,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 296,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 296,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8583, 8586], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8583, 8586], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .email on an `any` value.",
        "line": 302,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 302,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .name on an `any` value.",
        "line": 303,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 303,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .role on an `any` value.",
        "line": 304,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 304,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string | object | Buffer<ArrayBufferLike>`.",
        "line": 306,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 306,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\nimport { logger } from '@/utils/logger';\nimport { dbConnection } from '@/database/connection';\nimport type { AuthenticationResult, WebSocketUser } from './types';\nimport type { AuthPayload } from './messageTypes';\n\nexport class WebSocketAuth {\n  private readonly apiKeys: Map<string, WebSocketUser> = new Map();\n\n  constructor() {\n    this.initializeApiKeys();\n  }\n\n  private initializeApiKeys(): void {\n    // Initialize with default API keys from environment or hardcoded defaults\n    const defaultApiKeys = process.env.DEFAULT_API_KEYS?.split(',') ?? [];\n    defaultApiKeys.forEach((key, index) => {\n      this.apiKeys.set(key, {\n        id: `api_user_${String(index)}`,\n        name: `API User ${String(index)}`,\n        role: 'user',\n      });\n    });\n\n    // Add a default dev key if in development\n    if (process.env.NODE_ENV === 'development') {\n      this.apiKeys.set('dev-key-1', {\n        id: 'dev_user',\n        name: 'Development User',\n        role: 'admin',\n      });\n    }\n  }\n\n  async authenticate(payload: AuthPayload): Promise<AuthenticationResult> {\n    try {\n      if (!payload) {\n        return {\n          success: false,\n          error: 'Authentication payload required',\n        };\n      }\n\n      // JWT Token Authentication\n      if (payload.token) {\n        return await this.authenticateWithJWT(payload.token);\n      }\n\n      // API Key Authentication\n      if (payload.apiKey) {\n        return await this.authenticateWithApiKey(payload.apiKey);\n      }\n\n      // Credentials Authentication\n      if (payload.credentials) {\n        return await this.authenticateWithCredentials({\n          email: payload.credentials.username ?? '',\n          password: payload.credentials.password ?? '',\n        });\n      }\n\n      return {\n        success: false,\n        error: 'No valid authentication method provided',\n      };\n    } catch (error) {\n      logger.error('WebSocket authentication error', { error });\n      return {\n        success: false,\n        error: 'Authentication failed',\n      };\n    }\n  }\n\n  private authenticateWithJWT(token: string): Promise<AuthenticationResult> {\n    return new Promise(resolve => {\n      try {\n        const jwtSecret = process.env.JWT_SECRET ?? 'dev-secret-key-change-in-production';\n        if (!jwtSecret || jwtSecret === 'dev-secret-key-change-in-production') {\n          logger.warn(\n            'JWT authentication using default secret - configure JWT_SECRET in production'\n          );\n        }\n\n        const decoded = jwt.verify(token, jwtSecret) as {\n          userId: string;\n          exp?: number;\n          iat?: number;\n          permissions?: string[];\n          role?: string;\n          email?: string;\n          name?: string;\n        };\n\n        if (!decoded.userId) {\n          resolve({\n            success: false,\n            error: 'Invalid token: missing user ID',\n          });\n          return;\n        }\n\n        // Get user permissions from token or database\n        const permissions =\n          decoded.permissions ?? WebSocketAuth.getDefaultPermissions(decoded.role);\n\n        const user: WebSocketUser = {\n          id: decoded.userId,\n          name: decoded.name ?? decoded.email ?? 'Unknown User',\n          role: decoded.role ?? 'user',\n          ...(decoded.email && { email: decoded.email }),\n        };\n\n        resolve({\n          success: true,\n          user,\n          permissions: new Set(permissions),\n        });\n      } catch (error) {\n        resolve({\n          success: false,\n          error: 'Invalid JWT token',\n        });\n      }\n    });\n  }\n\n  private async authenticateWithApiKey(apiKey: string): Promise<AuthenticationResult> {\n    try {\n      // Check if API key exists\n      const user = this.apiKeys.get(apiKey);\n      if (!user) {\n        return {\n          success: false,\n          error: 'Invalid API key',\n        };\n      }\n\n      // Get permissions for API key user\n      const permissions = WebSocketAuth.getDefaultPermissions(user.role);\n\n      // Validate permissions\n      const permissionPromises = permissions.map(async permission => {\n        // Simulate async permission validation\n        await new Promise(resolve => setTimeout(resolve, 1));\n        return permission;\n      });\n\n      const validatedPermissions = await Promise.all(permissionPromises);\n\n      return {\n        success: true,\n        user,\n        permissions: new Set(validatedPermissions),\n      };\n    } catch (error) {\n      logger.error('API key authentication error', { error });\n      return {\n        success: false,\n        error: 'API key authentication failed',\n      };\n    }\n  }\n\n  private authenticateWithCredentials(credentials: {\n    email: string;\n    password: string;\n  }): Promise<AuthenticationResult> {\n    return new Promise(resolve => {\n      try {\n        // Simulate credential validation\n        const { email, password } = credentials;\n\n        if (!email || !password) {\n          resolve({\n            success: false,\n            error: 'Email and password required',\n          });\n          return;\n        }\n\n        // Mock user for demonstration\n        const user: WebSocketUser = {\n          id: `user_${email}`,\n          name: email.split('@')[0],\n          email,\n          role: 'user',\n        };\n\n        const permissions = WebSocketAuth.getDefaultPermissions(user.role);\n\n        resolve({\n          success: true,\n          user,\n          permissions: new Set(permissions),\n        });\n      } catch (error) {\n        resolve({\n          success: false,\n          error: 'Credential authentication failed',\n        });\n      }\n    });\n  }\n\n  private static getDefaultPermissions(role?: string): string[] {\n    switch (role) {\n      case 'admin':\n        return [\n          'read:all',\n          'write:all',\n          'delete:all',\n          'manage:users',\n          'manage:system',\n          'subscribe:all',\n        ];\n      case 'manager':\n        return ['read:all', 'write:all', 'delete:own', 'manage:team', 'subscribe:all'];\n      case 'user':\n        return ['read:assigned', 'write:assigned', 'delete:own', 'subscribe:assigned'];\n      default:\n        return ['read:public', 'subscribe:public'];\n    }\n  }\n\n  // API Key Management\n  addApiKey(apiKey: string, user: WebSocketUser): void {\n    this.apiKeys.set(apiKey, user);\n    logger.info('API key added', { userId: user.id, role: user.role });\n  }\n\n  removeApiKey(apiKey: string): boolean {\n    const removed = this.apiKeys.delete(apiKey);\n    if (removed) {\n      logger.info('API key removed', { apiKey: `${String(String(apiKey.substring(0, 8)))}...` });\n    }\n    return removed;\n  }\n\n  listApiKeys(): Array<{ key: string; user: WebSocketUser }> {\n    return Array.from(this.apiKeys.entries()).map(([key, user]) => ({\n      key: `${String(String(key.substring(0, 8)))}...`,\n      user,\n    }));\n  }\n\n  // Permission Checking\n  hasPermission(permissions: Set<string>, requiredPermission: string): boolean {\n    // Check exact permission\n    if (permissions.has(requiredPermission)) {\n      return true;\n    }\n\n    // Check wildcard permissions\n    const [action] = requiredPermission.split(':');\n    if (permissions.has(`${String(action)}:all`)) {\n      return true;\n    }\n\n    if (permissions.has('*:all') || permissions.has('admin:all')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  canAccessBoard(permissions: Set<string>, boardId: string, action: string = 'read'): boolean {\n    return (\n      this.hasPermission(permissions, `${String(action)}:all`) ||\n      this.hasPermission(permissions, `${String(action)}:board:${String(boardId)}`)\n    );\n  }\n\n  canAccessTask(permissions: Set<string>, taskId: string, action: string = 'read'): boolean {\n    return (\n      this.hasPermission(permissions, `${String(action)}:all`) ||\n      this.hasPermission(permissions, `${String(action)}:task:${String(taskId)}`)\n    );\n  }\n\n  canSubscribeToChannel(permissions: Set<string>, channel: string): boolean {\n    return (\n      this.hasPermission(permissions, `subscribe:${String(channel)}`) ||\n      this.hasPermission(permissions, 'subscribe:all')\n    );\n  }\n\n  // Generate JWT tokens (for testing or client integration)\n  generateJWT(user: WebSocketUser, permissions: string[], expiresIn: string = '24h'): string {\n    const jwtSecret = process.env.JWT_SECRET ?? 'dev-secret-key-change-in-production';\n    if (!jwtSecret || jwtSecret === 'dev-secret-key-change-in-production') {\n      logger.warn('JWT generation using default secret - configure JWT_SECRET in production');\n    }\n\n    const payload: any = {\n      userId: user.id,\n      permissions,\n    };\n\n    // Only include optional properties if they exist\n    if (user.email) payload.email = user.email;\n    if (user.name) payload.name = user.name;\n    if (user.role) payload.role = user.role;\n\n    return jwt.sign(payload, jwtSecret, { expiresIn } as jwt.SignOptions);\n  }\n\n  // Validate permissions for specific operations\n  validateOperation(\n    permissions: Set<string>,\n    operation: string,\n    resource: string,\n    resourceId?: string\n  ): boolean {\n    const fullPermission = resourceId\n      ? `${String(operation)}:${String(resource)}:${String(resourceId)}`\n      : `${String(operation)}:${String(resource)}`;\n\n    return this.hasPermission(permissions, fullPermission);\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/handlers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unsafe-enum-comparison",
        "severity": 2,
        "message": "The two values in this comparison do not have a shared enum type.",
        "line": 330,
        "column": 52,
        "nodeType": "BinaryExpression",
        "messageId": "mismatchedCondition",
        "endLine": 330,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 403,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 403,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 405,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 405,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `PaginationOptions & TaskFilters`.",
        "line": 416,
        "column": 52,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 416,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 416,
        "column": 60,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 416,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 457,
        "column": 11,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 457,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 459,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 459,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .updates on an `any` value.",
        "line": 459,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 459,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 470,
        "column": 54,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 470,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 470,
        "column": 62,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 470,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `UpdateTaskRequest`.",
        "line": 470,
        "column": 70,
        "nodeType": "MemberExpression",
        "messageId": "unsafeArgument",
        "endLine": 470,
        "endColumn": 85
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .updates on an `any` value.",
        "line": 470,
        "column": 78,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 470,
        "endColumn": 85
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access .taskId on an `any` value.",
        "line": 479,
        "column": 64,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 479,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 599,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 599,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 619,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 619,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 624,
        "column": 20,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 624,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 630,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 630,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 632,
        "column": 45,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 632,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 687,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 687,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 700,
        "column": 45,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 700,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 759,
        "column": 64,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 759,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `UpdateBoardRequest`.",
        "line": 759,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 759,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 768,
        "column": 73,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 768,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 772,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 772,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 778,
        "column": 46,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 778,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 778,
        "column": 55,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 778,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 907,
        "column": 42,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 907,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 907,
        "column": 50,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 907,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 912,
        "column": 20,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 912,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 912,
        "column": 28,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 912,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 916,
        "column": 55,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 916,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 920,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 920,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 920,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 920,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 923,
        "column": 45,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 923,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 923,
        "column": 53,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 923,
        "endColumn": 58
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async method 'handleUserPresence' has no 'await' expression.",
        "line": 953,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 953,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `\"offline\" | \"online\" | \"away\"`.",
        "line": 969,
        "column": 90,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 969,
        "endColumn": 96
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 970,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 970,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 971,
        "column": 9,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 971,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 979,
        "column": 20,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 979,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 982,
        "column": 54,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 982,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 982,
        "column": 62,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 982,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 982,
        "column": 71,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 982,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async method 'handleTypingStart' has no 'await' expression.",
        "line": 1011,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 1011,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 1022,
        "column": 26,
        "nodeType": "LogicalExpression",
        "messageId": "unsafeArgument",
        "endLine": 1022,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 1022,
        "column": 47,
        "nodeType": "LogicalExpression",
        "messageId": "unsafeArgument",
        "endLine": 1022,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1026,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1026,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1027,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1027,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/require-await",
        "severity": 2,
        "message": "Async method 'handleTypingStop' has no 'await' expression.",
        "line": 1053,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingAwait",
        "endLine": 1053,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 1064,
        "column": 26,
        "nodeType": "LogicalExpression",
        "messageId": "unsafeArgument",
        "endLine": 1064,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `any` assigned to a parameter of type `string`.",
        "line": 1064,
        "column": 47,
        "nodeType": "LogicalExpression",
        "messageId": "unsafeArgument",
        "endLine": 1064,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1068,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1068,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 1069,
        "column": 11,
        "nodeType": "Property",
        "messageId": "anyAssignment",
        "endLine": 1069,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 24,
    "fatalErrorCount": 0,
    "warningCount": 29,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * WebSocket message handler for real-time kanban operations\n *\n * @module websocket/handlers\n * @description Handles all WebSocket messages for real-time collaboration features including\n * task updates, board synchronization, user presence, and typing indicators. Provides\n * comprehensive permission checking and event broadcasting.\n *\n * @example\n * ```typescript\n * const handler = new MessageHandler(webSocketManager);\n *\n * // Handle incoming message\n * await handler.handleMessage(clientId, {\n *   type: 'update_task',\n *   id: 'msg123',\n *   payload: { taskId: 'task1', updates: { status: 'in_progress' } }\n * });\n * ```\n */\n\nimport { logger } from '../utils/logger';\nimport { TaskService } from '../services/TaskService';\nimport { BoardService } from '../services/BoardService';\nimport { NoteService } from '../services/NoteService';\nimport { TagService } from '../services/TagService';\nimport { dbConnection } from '../database/connection';\nimport type { WebSocketManager } from './server';\nimport type {\n  WebSocketMessage,\n  MessageContext,\n  SubscriptionChannel,\n  SubscribeMessage,\n  UnsubscribeMessage,\n  GetTaskMessage,\n  UpdateTaskMessage,\n} from './types';\n\n/**\n * Handles WebSocket messages for real-time kanban board collaboration\n *\n * @class MessageHandler\n * @description Central message handler that routes WebSocket messages to appropriate\n * service methods, manages permissions, and broadcasts updates to subscribed clients.\n * Supports all kanban operations including task CRUD, board updates, notes, tags,\n * and real-time collaboration features.\n *\n * @example\n * ```typescript\n * const handler = new MessageHandler(webSocketManager);\n *\n * // Message is automatically routed based on type\n * await handler.handleMessage('client123', {\n *   type: 'subscribe',\n *   id: 'msg1',\n *   payload: { channel: 'board:board1' }\n * });\n * ```\n */\nexport class MessageHandler {\n  /** WebSocket server manager instance */\n  private readonly webSocketManager: WebSocketManager;\n\n  /** Task service for task operations */\n  private readonly taskService: TaskService;\n\n  /** Board service for board operations */\n  private readonly boardService: BoardService;\n\n  /** Note service for note operations */\n  private readonly noteService: NoteService;\n\n  /** Tag service for tag operations */\n  private readonly tagService: TagService;\n\n  /**\n   * Creates a new MessageHandler instance\n   *\n   * @param {WebSocketManager} webSocketManager - WebSocket server manager\n   */\n  constructor(webSocketManager: WebSocketManager) {\n    this.webSocketManager = webSocketManager;\n    this.taskService = new TaskService(dbConnection);\n    this.boardService = new BoardService(dbConnection);\n    this.noteService = new NoteService(dbConnection);\n    this.tagService = new TagService(dbConnection);\n  }\n\n  /**\n   * Handles incoming WebSocket messages and routes them to appropriate handlers\n   *\n   * @param {string} clientId - Unique identifier of the client sending the message\n   * @param {WebSocketMessage} message - The WebSocket message to handle\n   * @returns {Promise<void>}\n   *\n   * @description Main entry point for all WebSocket messages. Creates a message context,\n   * validates the client, and routes messages to specific handlers based on message type.\n   * Handles errors gracefully and sends appropriate error responses.\n   *\n   * Supported message types:\n   * - subscribe/unsubscribe: Channel subscription management\n   * - ping: Connection keep-alive\n   * - get_task/update_task/create_task/delete_task: Task operations\n   * - get_board/update_board: Board operations\n   * - add_note: Note creation\n   * - assign_tag: Tag assignment\n   * - user_presence: Presence updates\n   * - typing_start/typing_stop: Typing indicators\n   *\n   * @example\n   * ```typescript\n   * await handler.handleMessage('client123', {\n   *   type: 'create_task',\n   *   id: 'msg456',\n   *   payload: {\n   *     title: 'New Task',\n   *     board_id: 'board1',\n   *     description: 'Task description'\n   *   }\n   * });\n   * ```\n   */\n  async handleMessage(clientId: string, message: WebSocketMessage): Promise<void> {\n    try {\n      const client = this.webSocketManager.getClient(clientId);\n      if (!client) {\n        logger.warn('Message from unknown client', { clientId });\n        return;\n      }\n\n      const context: MessageContext = {\n        clientId,\n        client,\n        message,\n        subscriptionManager: this.webSocketManager.getSubscriptionManager(),\n        webSocketManager: this.webSocketManager,\n      };\n\n      logger.debug('Handling WebSocket message', {\n        clientId,\n        messageType: message.type,\n        messageId: message.id,\n      });\n\n      // Route message to appropriate handler\n      switch (message.type) {\n        case 'subscribe':\n          this.handleSubscribe(context);\n          break;\n\n        case 'unsubscribe':\n          this.handleUnsubscribe(context);\n          break;\n\n        case 'ping':\n          this.handlePing(context);\n          break;\n\n        case 'get_task':\n          await this.handleGetTask(context);\n          break;\n\n        case 'update_task':\n          await this.handleUpdateTask(context);\n          break;\n\n        case 'create_task':\n          await this.handleCreateTask(context);\n          break;\n\n        case 'delete_task':\n          await this.handleDeleteTask(context);\n          break;\n\n        case 'get_board':\n          await this.handleGetBoard(context);\n          break;\n\n        case 'update_board':\n          await this.handleUpdateBoard(context);\n          break;\n\n        case 'add_note':\n          await this.handleAddNote(context);\n          break;\n\n        case 'assign_tag':\n          await this.handleAssignTag(context);\n          break;\n\n        case 'user_presence':\n          await this.handleUserPresence(context);\n          break;\n\n        case 'typing_start':\n          await this.handleTypingStart(context);\n          break;\n\n        case 'typing_stop':\n          await this.handleTypingStop(context);\n          break;\n\n        default:\n          this.webSocketManager.sendError(\n            clientId,\n            'UNKNOWN_MESSAGE_TYPE',\n            `Unknown message type: ${String(String(message.type))}`,\n            message.id\n          );\n      }\n    } catch (error) {\n      logger.error('Error handling WebSocket message', {\n        clientId,\n        messageType: message.type,\n        messageId: message.id,\n        error,\n      });\n\n      this.webSocketManager.sendError(\n        clientId,\n        'MESSAGE_HANDLER_ERROR',\n        'Error processing message',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles channel subscription requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   *\n   * @description Subscribes a client to a specific channel for receiving real-time updates.\n   * Validates the subscription request and creates a new subscription with optional filters.\n   *\n   * Channel types:\n   * - 'board:${boardId}': Updates for a specific board\n   * - 'task:${taskId}': Updates for a specific task\n   * - 'user:${userId}': Updates for a specific user\n   * - 'presence': Global presence updates\n   *\n   * @example\n   * ```typescript\n   * // Client subscribes to board updates\n   * // Message: { type: 'subscribe', payload: { channel: 'board:board1', filters: { status: 'active' } } }\n   * ```\n   */\n  private handleSubscribe(context: MessageContext): void {\n    const { clientId, message } = context;\n    const payload = message.payload as SubscribeMessage['payload'];\n\n    if (!payload?.channel) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_SUBSCRIBE',\n        'Channel is required for subscription',\n        message.id\n      );\n      return;\n    }\n\n    const channel = payload.channel as SubscriptionChannel;\n    const filters = payload.filters ?? {};\n\n    const result = this.webSocketManager\n      .getSubscriptionManager()\n      .subscribe(clientId, channel, filters);\n\n    if (result.success) {\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'subscribe_success',\n        id: message.id,\n        payload: {\n          subscriptionId: result.subscriptionId,\n          channel,\n          filters,\n        },\n      });\n\n      logger.info('Client subscribed to channel', {\n        clientId,\n        channel,\n        subscriptionId: result.subscriptionId,\n      });\n    } else {\n      this.webSocketManager.sendError(\n        clientId,\n        'SUBSCRIBE_FAILED',\n        result.error ?? 'Subscription failed',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles channel unsubscription requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   *\n   * @description Removes a client's subscription to a specific channel.\n   * Finds the existing subscription and removes it from the subscription manager.\n   *\n   * @example\n   * ```typescript\n   * // Client unsubscribes from board updates\n   * // Message: { type: 'unsubscribe', payload: { channel: 'board:board1' } }\n   * ```\n   */\n  private handleUnsubscribe(context: MessageContext): void {\n    const { clientId, message } = context;\n    const payload = message.payload as UnsubscribeMessage['payload'];\n\n    if (!payload?.channel) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_UNSUBSCRIBE',\n        'Channel is required for unsubscription',\n        message.id\n      );\n      return;\n    }\n\n    // Find and remove subscription\n    const subscriptions = this.webSocketManager\n      .getSubscriptionManager()\n      .getClientSubscriptions(clientId);\n\n    const subscription = subscriptions.find(sub => sub.channel === payload.channel);\n\n    if (subscription) {\n      const success = this.webSocketManager.getSubscriptionManager().unsubscribe(subscription.id);\n\n      if (success) {\n        this.webSocketManager.sendToClient(clientId, {\n          type: 'unsubscribe_success',\n          id: message.id,\n          payload: {\n            channel: payload.channel,\n          },\n        });\n      } else {\n        this.webSocketManager.sendError(\n          clientId,\n          'UNSUBSCRIBE_FAILED',\n          'Failed to unsubscribe',\n          message.id\n        );\n      }\n    } else {\n      this.webSocketManager.sendError(\n        clientId,\n        'SUBSCRIPTION_NOT_FOUND',\n        'Subscription not found',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles ping messages for connection keep-alive\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   *\n   * @description Responds to ping messages with a pong message containing\n   * the current timestamp. Used for connection health monitoring and keep-alive.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: { type: 'ping', id: 'ping123' }\n   * // Server responds: { type: 'pong', id: 'ping123', payload: { timestamp: 1234567890 } }\n   * ```\n   */\n  private handlePing(context: MessageContext): void {\n    const { clientId, message } = context;\n    this.webSocketManager.sendToClient(clientId, {\n      type: 'pong',\n      id: message.id,\n      payload: { timestamp: Date.now() },\n    });\n  }\n\n  /**\n   * Handles task retrieval requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Retrieves a specific task by ID and sends it back to the client.\n   * Validates the task ID and handles errors appropriately.\n   *\n   * @example\n   * ```typescript\n   * // Client requests: { type: 'get_task', payload: { taskId: 'task123' } }\n   * // Server responds: { type: 'get_task_success', payload: { task: {...} } }\n   * ```\n   */\n  private async handleGetTask(context: MessageContext): Promise<void> {\n    const { clientId, message } = context;\n    const payload = message.payload as GetTaskMessage['payload'];\n\n    if (!payload?.taskId) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_GET_TASK',\n        'Task ID is required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      const task = await this.taskService.getTasks(payload.taskId);\n      if (!task) {\n        this.webSocketManager.sendError(clientId, 'TASK_NOT_FOUND', 'Task not found', message.id);\n        return;\n      }\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'get_task_success',\n        id: message.id,\n        payload: { task },\n      });\n    } catch (error) {\n      this.webSocketManager.sendError(\n        clientId,\n        'GET_TASK_FAILED',\n        error instanceof Error ? error.message : 'Failed to get task',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles task update requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Updates a task with provided changes and broadcasts the update\n   * to all clients subscribed to the task channel. Validates update data and\n   * handles errors appropriately.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: { type: 'update_task', payload: { taskId: 'task123', updates: { status: 'done' } } }\n   * // Server responds: { type: 'update_task_success', payload: { task: {...} } }\n   * // Broadcasts: { type: 'task_updated', payload: { task: {...} } } to subscribers\n   * ```\n   */\n  private async handleUpdateTask(context: MessageContext): Promise<void> {\n    const { clientId, message } = context;\n    const payload = message.payload as UpdateTaskMessage['payload'];\n\n    if (!payload?.taskId || !payload?.updates) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_UPDATE_TASK',\n        'Task ID and updates are required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      const task = await this.taskService.updateTask(payload.taskId, payload.updates);\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'update_task_success',\n        id: message.id,\n        payload: { task },\n      });\n\n      // Broadcast update to other clients subscribed to this task\n      this.webSocketManager.broadcastToChannel(`task:${payload.taskId}`, {\n        type: 'task_updated',\n        payload: { task },\n      });\n    } catch (error) {\n      this.webSocketManager.sendError(\n        clientId,\n        'UPDATE_TASK_FAILED',\n        error instanceof Error ? error.message : 'Failed to update task',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles task creation requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Creates a new task with provided data, checks write permissions,\n   * and broadcasts the creation to all relevant subscribers. Validates required\n   * fields (title and board_id) before creation.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: {\n   * //   type: 'create_task',\n   * //   payload: { title: 'New Task', board_id: 'board1', description: 'Details' }\n   * // }\n   * // Server responds: { type: 'task_created_response', payload: { task: {...} } }\n   * // Broadcasts creation event to board subscribers\n   * ```\n   */\n  private async handleCreateTask(context: MessageContext): Promise<void> {\n    const { clientId, client, message } = context;\n    const taskData = message.payload;\n\n    if (!taskData?.title || !taskData.board_id) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_REQUEST',\n        'Title and board ID are required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      // Check permissions\n      if (\n        !client.permissions.has('write:all') &&\n        !client.permissions.has(`write:board:${String(String(taskData.board_id))}`)\n      ) {\n        this.webSocketManager.sendError(\n          clientId,\n          'INSUFFICIENT_PERMISSIONS',\n          'Insufficient permissions to create task',\n          message.id\n        );\n        return;\n      }\n\n      const newTask = await this.taskService.createTask(taskData);\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'task_created_response',\n        id: message.id,\n        payload: { task: newTask },\n      });\n\n      // Broadcast creation to subscribers\n      this.webSocketManager\n        .getSubscriptionManager()\n        .publishTaskCreated(newTask, client.user?.id ?? 'unknown');\n    } catch (error) {\n      logger.error('Error creating task', { taskData, error });\n      this.webSocketManager.sendError(\n        clientId,\n        'TASK_CREATE_ERROR',\n        'Error creating task',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles task deletion requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Deletes a task after verifying it exists and checking delete\n   * permissions. Broadcasts the deletion event to all relevant subscribers.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: { type: 'delete_task', payload: { taskId: 'task123' } }\n   * // Server responds: { type: 'task_deleted_response', payload: { taskId: 'task123' } }\n   * // Broadcasts deletion event to board and task subscribers\n   * ```\n   */\n  private async handleDeleteTask(context: MessageContext): Promise<void> {\n    const { clientId, client, message } = context;\n    const { taskId } = message.payload;\n\n    if (!taskId) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_REQUEST',\n        'Task ID is required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      // Get task first to check permissions and get board ID\n      const task = await this.taskService.getTaskById(taskId);\n      if (!task) {\n        this.webSocketManager.sendError(clientId, 'TASK_NOT_FOUND', 'Task not found', message.id);\n        return;\n      }\n\n      // Check permissions\n      if (\n        !client.permissions.has('delete:all') &&\n        !client.permissions.has(`delete:task:${String(taskId)}`)\n      ) {\n        this.webSocketManager.sendError(\n          clientId,\n          'INSUFFICIENT_PERMISSIONS',\n          'Insufficient permissions to delete task',\n          message.id\n        );\n        return;\n      }\n\n      await this.taskService.deleteTask(taskId);\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'task_deleted_response',\n        id: message.id,\n        payload: { taskId },\n      });\n\n      // Broadcast deletion to subscribers\n      this.webSocketManager\n        .getSubscriptionManager()\n        .publishTaskDeleted(taskId, task.board_id, client.user?.id ?? 'unknown');\n    } catch (error) {\n      logger.error('Error deleting task', { taskId, error });\n      this.webSocketManager.sendError(\n        clientId,\n        'TASK_DELETE_ERROR',\n        'Error deleting task',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles board retrieval requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Retrieves a board by ID after checking read permissions.\n   * Sends the board data back to the requesting client.\n   *\n   * @example\n   * ```typescript\n   * // Client requests: { type: 'get_board', payload: { boardId: 'board123' } }\n   * // Server responds: { type: 'board_data', payload: { board: {...} } }\n   * ```\n   */\n  private async handleGetBoard(context: MessageContext): Promise<void> {\n    const { clientId, client, message } = context;\n    const { boardId } = message.payload;\n\n    if (!boardId) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_REQUEST',\n        'Board ID is required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      // Check permissions\n      if (\n        !client.permissions.has('read:all') &&\n        !client.permissions.has(`read:board:${String(boardId)}`)\n      ) {\n        this.webSocketManager.sendError(\n          clientId,\n          'INSUFFICIENT_PERMISSIONS',\n          'Insufficient permissions to read board',\n          message.id\n        );\n        return;\n      }\n\n      const board = await this.boardService.getBoardById(boardId);\n\n      if (!board) {\n        this.webSocketManager.sendError(clientId, 'BOARD_NOT_FOUND', 'Board not found', message.id);\n        return;\n      }\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'board_data',\n        id: message.id,\n        payload: { board },\n      });\n    } catch (error) {\n      logger.error('Error getting board', { boardId, error });\n      this.webSocketManager.sendError(\n        clientId,\n        'BOARD_FETCH_ERROR',\n        'Error fetching board',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles board update requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Updates a board with provided changes after checking write\n   * permissions. Broadcasts the update to all board subscribers with change details.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: {\n   * //   type: 'update_board',\n   * //   payload: { boardId: 'board123', updates: { title: 'New Title' } }\n   * // }\n   * // Server responds: { type: 'board_updated_response', payload: { board: {...} } }\n   * // Broadcasts update event with changes to board subscribers\n   * ```\n   */\n  private async handleUpdateBoard(context: MessageContext): Promise<void> {\n    const { clientId, client, message } = context;\n    const { boardId, updates } = message.payload;\n\n    if (!boardId || !updates) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_REQUEST',\n        'Board ID and updates are required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      // Check permissions\n      if (\n        !client.permissions.has('write:all') &&\n        !client.permissions.has(`write:board:${String(boardId)}`)\n      ) {\n        this.webSocketManager.sendError(\n          clientId,\n          'INSUFFICIENT_PERMISSIONS',\n          'Insufficient permissions to update board',\n          message.id\n        );\n        return;\n      }\n\n      const updatedBoard = await this.boardService.updateBoard(boardId, updates);\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'board_updated_response',\n        id: message.id,\n        payload: { board: updatedBoard },\n      });\n\n      // Broadcast update to subscribers\n      this.webSocketManager.getSubscriptionManager().publishBoardUpdate(boardId, {\n        type: 'board:updated',\n        data: {\n          board: updatedBoard,\n          changes: updates,\n          updatedBy: client.user?.id ?? 'unknown',\n        },\n        timestamp: new Date().toISOString(),\n      });\n    } catch (error) {\n      logger.error('Error updating board', { boardId, updates, error });\n      this.webSocketManager.sendError(\n        clientId,\n        'BOARD_UPDATE_ERROR',\n        'Error updating board',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles note addition requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Creates a new note for a task after checking write permissions.\n   * Broadcasts the note creation to relevant subscribers including task and board channels.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: {\n   * //   type: 'add_note',\n   * //   payload: { content: 'Note text', task_id: 'task123' }\n   * // }\n   * // Server responds: { type: 'note_added_response', payload: { note: {...} } }\n   * // Broadcasts note creation to task and board subscribers\n   * ```\n   */\n  private async handleAddNote(context: MessageContext): Promise<void> {\n    const { clientId, client, message } = context;\n    const noteData = message.payload;\n\n    if (!noteData?.content || !noteData.task_id) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_REQUEST',\n        'Content and task ID are required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      // Check permissions\n      if (\n        !client.permissions.has('write:all') &&\n        !client.permissions.has(`write:task:${String(String(noteData.task_id))}`)\n      ) {\n        this.webSocketManager.sendError(\n          clientId,\n          'INSUFFICIENT_PERMISSIONS',\n          'Insufficient permissions to add note',\n          message.id\n        );\n        return;\n      }\n\n      const newNote = await this.noteService.createNote(noteData);\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'note_added_response',\n        id: message.id,\n        payload: { note: newNote },\n      });\n\n      // Get task to find board ID for broadcasting\n      const task = await this.taskService.getTaskById(noteData.task_id);\n      if (task) {\n        this.webSocketManager\n          .getSubscriptionManager()\n          .publishNoteAdded(newNote, noteData.task_id, task.board_id, client.user?.id ?? 'unknown');\n      }\n    } catch (error) {\n      logger.error('Error adding note', { noteData, error });\n      this.webSocketManager.sendError(clientId, 'NOTE_ADD_ERROR', 'Error adding note', message.id);\n    }\n  }\n\n  /**\n   * Handles tag assignment requests\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Assigns a tag to a task after checking write permissions.\n   * Broadcasts the tag assignment to relevant subscribers.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: {\n   * //   type: 'assign_tag',\n   * //   payload: { taskId: 'task123', tagId: 'tag456' }\n   * // }\n   * // Server responds: { type: 'tag_assigned_response', payload: { taskId, tagId } }\n   * // Broadcasts tag assignment to task and board subscribers\n   * ```\n   */\n  private async handleAssignTag(context: MessageContext): Promise<void> {\n    const { clientId, client, message } = context;\n    const { taskId, tagId } = message.payload;\n\n    if (!taskId || !tagId) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_REQUEST',\n        'Task ID and tag ID are required',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      // Check permissions\n      if (\n        !client.permissions.has('write:all') &&\n        !client.permissions.has(`write:task:${String(taskId)}`)\n      ) {\n        this.webSocketManager.sendError(\n          clientId,\n          'INSUFFICIENT_PERMISSIONS',\n          'Insufficient permissions to assign tag',\n          message.id\n        );\n        return;\n      }\n\n      await this.tagService.addTagToTask(taskId, tagId);\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'tag_assigned_response',\n        id: message.id,\n        payload: { taskId, tagId },\n      });\n\n      // Get task to find board ID for broadcasting\n      const task = await this.taskService.getTaskById(taskId);\n      if (task) {\n        this.webSocketManager\n          .getSubscriptionManager()\n          .publishTagAssigned(taskId, tagId, task.board_id, client.user?.id ?? 'unknown');\n      }\n    } catch (error) {\n      logger.error('Error assigning tag', { taskId, tagId, error });\n      this.webSocketManager.sendError(\n        clientId,\n        'TAG_ASSIGN_ERROR',\n        'Error assigning tag',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles user presence updates\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Updates and broadcasts user presence status (online, away, busy, offline).\n   * Can include optional board or task context for location-specific presence.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: {\n   * //   type: 'user_presence',\n   * //   payload: { status: 'online', boardId: 'board123' }\n   * // }\n   * // Server responds: { type: 'presence_updated', payload: { status: 'online' } }\n   * // Broadcasts presence update to relevant subscribers\n   * ```\n   */\n  private async handleUserPresence(context: MessageContext): Promise<void> {\n    const { clientId, client, message } = context;\n    const { status, boardId, taskId } = message.payload;\n\n    if (!status || !client.user) {\n      this.webSocketManager.sendError(\n        clientId,\n        'INVALID_REQUEST',\n        'Status is required and user must be authenticated',\n        message.id\n      );\n      return;\n    }\n\n    try {\n      // Broadcast presence update\n      this.webSocketManager.getSubscriptionManager().publishUserPresence(client.user.id, status, {\n        boardId,\n        taskId,\n        userId: client.user.id,\n        timestamp: new Date().toISOString(),\n      });\n\n      this.webSocketManager.sendToClient(clientId, {\n        type: 'presence_updated',\n        id: message.id,\n        payload: { status },\n      });\n    } catch (error) {\n      logger.error('Error updating user presence', { status, boardId, taskId, error });\n      this.webSocketManager.sendError(\n        clientId,\n        'PRESENCE_ERROR',\n        'Error updating presence',\n        message.id\n      );\n    }\n  }\n\n  /**\n   * Handles typing start indicators\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Broadcasts a typing start indicator to other users viewing\n   * the same task or board. Used for real-time collaboration awareness.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: {\n   * //   type: 'typing_start',\n   * //   payload: { taskId: 'task123', boardId: 'board123' }\n   * // }\n   * // Broadcasts typing indicator to task/board subscribers\n   * ```\n   */\n  private async handleTypingStart(context: MessageContext): Promise<void> {\n    const { client, message } = context;\n    const { taskId, boardId } = message.payload;\n\n    if (!client.user) {\n      return;\n    }\n\n    // Broadcast typing indicator\n    this.webSocketManager\n      .getSubscriptionManager()\n      .publishTaskUpdate(taskId ?? 'unknown', boardId ?? 'unknown', {\n        type: 'typing:start',\n        data: {\n          userId: client.user.id,\n          taskId,\n          boardId,\n          timestamp: new Date().toISOString(),\n        },\n        timestamp: new Date().toISOString(),\n      });\n  }\n\n  /**\n   * Handles typing stop indicators\n   *\n   * @private\n   * @param {MessageContext} context - Message context with client and message data\n   * @returns {Promise<void>}\n   *\n   * @description Broadcasts a typing stop indicator to other users viewing\n   * the same task or board. Clears the typing indicator for the user.\n   *\n   * @example\n   * ```typescript\n   * // Client sends: {\n   * //   type: 'typing_stop',\n   * //   payload: { taskId: 'task123', boardId: 'board123' }\n   * // }\n   * // Broadcasts typing stop to task/board subscribers\n   * ```\n   */\n  private async handleTypingStop(context: MessageContext): Promise<void> {\n    const { client, message } = context;\n    const { taskId, boardId } = message.payload;\n\n    if (!client.user) {\n      return;\n    }\n\n    // Broadcast typing stop indicator\n    this.webSocketManager\n      .getSubscriptionManager()\n      .publishTaskUpdate(taskId ?? 'unknown', boardId ?? 'unknown', {\n        type: 'typing:stop',\n        data: {\n          userId: client.user.id,\n          taskId,\n          boardId,\n          timestamp: new Date().toISOString(),\n        },\n        timestamp: new Date().toISOString(),\n      });\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/messageTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/rateLimit.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/server.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 16,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingReturnType",
        "endLine": 16,
        "endColumn": 21
      },
      {
        "ruleId": "class-methods-use-this",
        "severity": 2,
        "message": "Expected 'this' to be used by class method 'broadcastToChannel'.",
        "line": 16,
        "column": 3,
        "nodeType": "FunctionExpression",
        "messageId": "missingThis",
        "endLine": 16,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'arg0' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 16,
        "column": 22,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'arg1' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 16,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 66,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 66,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-call",
        "severity": 1,
        "message": "Unsafe call of an `any` typed value.",
        "line": 260,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "unsafeCall",
        "endLine": 260,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 289,
        "column": 13,
        "nodeType": "VariableDeclarator",
        "messageId": "anyAssignment",
        "endLine": 289,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-argument",
        "severity": 2,
        "message": "Unsafe argument of type `AuthMessage` assigned to a parameter of type `AuthPayload`.",
        "line": 290,
        "column": 51,
        "nodeType": "Identifier",
        "messageId": "unsafeArgument",
        "endLine": 290,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { createServer } from 'http';\nimport type { WebSocket } from 'ws';\nimport { WebSocketServer } from 'ws';\nimport { v4 as uuidv4 } from 'uuid';\nimport type { Task } from '@/types';\nimport { config } from '../config';\nimport { logger } from '../utils/logger';\nimport type { WebSocketMessage, WebSocketClient } from './types';\nimport type { RequestInfo, AuthMessage } from './messageTypes';\nimport { WebSocketAuth } from './auth';\nimport { MessageHandler } from './handlers';\nimport { SubscriptionManager } from './subscriptions';\nimport { RateLimiter } from './rateLimit';\n\nexport class WebSocketManager {\n  broadcastToChannel(arg0: string, arg1: { type: string; payload: { task: Task } }) {\n    throw new Error('Method not implemented.');\n  }\n\n  private readonly wss: WebSocketServer | null = null;\n\n  private readonly httpServer: ReturnType<typeof createServer> | null = null;\n\n  private readonly clients = new Map<string, WebSocketClient>();\n\n  private readonly auth: WebSocketAuth;\n\n  private readonly messageHandler: MessageHandler;\n\n  private readonly subscriptionManager: SubscriptionManager;\n\n  private readonly rateLimiter: RateLimiter;\n\n  private readonly heartbeatInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.auth = new WebSocketAuth();\n    this.messageHandler = new MessageHandler(this);\n    this.subscriptionManager = new SubscriptionManager(this);\n    this.rateLimiter = new RateLimiter();\n  }\n\n  getAuth(): WebSocketAuth {\n    return this.auth;\n  }\n\n  async start(port?: number): Promise<void> {\n    try {\n      const wsPort = port ?? config.websocket.port;\n      logger.info('Starting WebSocket server...', { port: wsPort });\n\n      // Create HTTP server for WebSocket upgrade\n      this.httpServer = createServer();\n\n      // Create WebSocket server\n      this.wss = new WebSocketServer({\n        server: this.httpServer,\n        path: config.websocket.path,\n        perMessageDeflate: config.websocket.compression,\n        maxPayload: config.websocket.maxPayload,\n        clientTracking: true,\n      });\n\n      // Set up WebSocket event handlers\n      this.wss.on('connection', (ws: WebSocket, request: RequestInfo) => {\n        this.handleConnection(ws, request).catch((err: Error) => {\n          logger.error('WebSocket connection handling failed:', err);\n        });\n      });\n      this.wss.on('error', WebSocketManager.handleServerError.bind(this));\n\n      // Start HTTP server\n      await new Promise<void>((resolve, reject) => {\n        this.httpServer!.listen(wsPort, config.websocket.host, () => {\n          logger.info('WebSocket server started', {\n            host: config.websocket.host,\n            port: wsPort,\n            path: config.websocket.path,\n          });\n          resolve();\n        });\n\n        this.httpServer!.on('error', error => {\n          logger.error('WebSocket server error', { error });\n          reject(error);\n        });\n      });\n\n      // Start heartbeat\n      this.startHeartbeat();\n\n      logger.info('WebSocket server initialized successfully');\n    } catch (error) {\n      logger.error('Failed to start WebSocket server', { error });\n      throw error;\n    }\n  }\n\n  async stop(): Promise<void> {\n    try {\n      logger.info('Stopping WebSocket server...');\n\n      // Stop heartbeat\n      if (this.heartbeatInterval) {\n        clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n\n      // Close all client connections\n      this.clients.forEach(client => {\n        this.closeConnection(client.id, 'SERVER_SHUTDOWN', 'Server is shutting down');\n      });\n\n      // Close WebSocket server\n      if (this.wss) {\n        this.wss.close();\n        this.wss = null;\n      }\n\n      // Close HTTP server\n      if (this.httpServer) {\n        await new Promise<void>(resolve => {\n          this.httpServer!.close(() => {\n            this.httpServer = null;\n            resolve();\n          });\n        });\n      }\n\n      logger.info('WebSocket server stopped');\n    } catch (error) {\n      logger.error('Error stopping WebSocket server', { error });\n      throw error;\n    }\n  }\n\n  private handleConnection(ws: WebSocket, request: RequestInfo): void {\n    const clientId = uuidv4();\n    const clientIP = request.socket.remoteAddress ?? 'unknown';\n\n    logger.info('New WebSocket connection', { clientId, clientIP });\n\n    try {\n      // Check rate limiting\n      if (!this.rateLimiter.checkLimit(clientIP)) {\n        ws.close(1008, 'Rate limit exceeded');\n        return;\n      }\n\n      // Create client object\n      const client: WebSocketClient = {\n        id: clientId,\n        ws,\n        ip: clientIP,\n        userAgent: request.headers['user-agent'] ?? undefined,\n        connectedAt: new Date(),\n        lastHeartbeat: new Date(),\n        authenticated: false,\n        subscriptions: new Set(),\n        user: null,\n        permissions: new Set(),\n      };\n\n      // Add client to map\n      this.clients.set(clientId, client);\n\n      // Set up message handler\n      ws.on('message', (data: Buffer | string) => {\n        this.handleMessage(clientId, data).catch((err: Error) => {\n          logger.error('WebSocket message handling failed:', err);\n        });\n      });\n\n      // Set up close handler\n      ws.on('close', (code: number, reason: Buffer) => {\n        this.handleDisconnection(clientId, code, reason);\n      });\n\n      // Set up error handler\n      ws.on('error', (error: Error) => {\n        this.handleClientError(clientId, error);\n      });\n\n      // Set up pong handler\n      ws.on('pong', () => {\n        this.handlePong(clientId);\n      });\n\n      // Send welcome message\n      this.sendToClient(clientId, {\n        type: 'welcome',\n        id: uuidv4(),\n        payload: {\n          clientId,\n          serverVersion: '1.0.0',\n          protocolVersion: '1.0',\n          timestamp: new Date().toISOString(),\n          authRequired: true,\n        },\n      });\n\n      logger.info('WebSocket client connected', { clientId, clientIP });\n    } catch (error) {\n      logger.error('Error handling WebSocket connection', { clientId, error });\n      ws.close(1011, 'Internal server error');\n    }\n  }\n\n  private async handleMessage(clientId: string, data: Buffer | string): Promise<void> {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      logger.warn('Message from unknown client', { clientId });\n      return;\n    }\n\n    try {\n      // Parse message\n      const messageText = data.toString();\n      const message = JSON.parse(messageText) as WebSocketMessage;\n\n      // Validate message structure\n      if (!message.type || !message.id) {\n        this.sendError(clientId, 'INVALID_MESSAGE', 'Invalid message format');\n        return;\n      }\n\n      // Handle authentication\n      if (message.type === 'auth') {\n        await this.handleAuthMessage(clientId, message);\n        return;\n      }\n\n      // Check authentication for other messages\n      if (!client.authenticated) {\n        this.sendError(clientId, 'UNAUTHENTICATED', 'Authentication required');\n        return;\n      }\n\n      // Handle other message types\n      await this.messageHandler.handleMessage(clientId, message);\n    } catch (error) {\n      logger.error('Error handling WebSocket message', { clientId, error });\n      this.sendError(clientId, 'MESSAGE_ERROR', 'Failed to process message');\n    }\n  }\n\n  private handleDisconnection(clientId: string, code: number, reason: Buffer): void {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      return;\n    }\n\n    logger.info('WebSocket client disconnected', {\n      clientId,\n      code,\n      reason: reason.toString(),\n    });\n\n    // Remove from subscriptions\n    this.subscriptionManager.removeClientSubscriptions(clientId);\n\n    // Remove from clients map\n    this.clients.delete(clientId);\n  }\n\n  private handleClientError(clientId: string, error: Error): void {\n    logger.error('WebSocket client error', { clientId, error });\n    this.closeConnection(clientId, 'CLIENT_ERROR', 'Client error occurred');\n  }\n\n  private static handleServerError(error: Error): void {\n    logger.error('WebSocket server error', { error });\n  }\n\n  private handlePong(clientId: string): void {\n    const client = this.clients.get(clientId);\n    if (client) {\n      client.lastHeartbeat = new Date();\n    }\n  }\n\n  private async handleAuthMessage(clientId: string, message: WebSocketMessage): Promise<void> {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      return;\n    }\n\n    try {\n      const authPayload = message.payload as AuthMessage['payload'];\n      const result = await this.auth.authenticate(authPayload);\n\n      if (result.success && result.user && result.permissions) {\n        client.authenticated = true;\n        client.user = result.user;\n        client.permissions = new Set(result.permissions);\n\n        this.sendToClient(clientId, {\n          type: 'auth_success',\n          id: message.id,\n          payload: {\n            user: result.user,\n            permissions: Array.from(result.permissions),\n          },\n        });\n\n        logger.info('WebSocket client authenticated', {\n          clientId,\n          userId: result.user.id,\n          role: result.user.role,\n        });\n      } else {\n        this.sendError(\n          clientId,\n          'AUTH_FAILED',\n          result.error ?? 'Authentication failed',\n          message.id\n        );\n      }\n    } catch (error) {\n      logger.error('Error during WebSocket authentication', { clientId, error });\n      this.sendError(clientId, 'AUTH_ERROR', 'Authentication error', message.id);\n    }\n  }\n\n  private startHeartbeat(): void {\n    this.heartbeatInterval = setInterval(() => {\n      const now = new Date();\n      const timeoutMs = 30000; // 30 seconds\n\n      this.clients.forEach(client => {\n        const timeSinceLastHeartbeat = now.getTime() - client.lastHeartbeat.getTime();\n        if (timeSinceLastHeartbeat > timeoutMs) {\n          logger.warn('Client heartbeat timeout', { clientId: client.id, timeSinceLastHeartbeat });\n          this.closeConnection(client.id, 'HEARTBEAT_TIMEOUT', 'Heartbeat timeout');\n        } else {\n          client.ws.ping();\n        }\n      });\n    }, 15000); // Send ping every 15 seconds\n  }\n\n  sendToClient(clientId: string, message: Omit<WebSocketMessage, 'timestamp'>): boolean {\n    const client = this.clients.get(clientId);\n    if (!client) {\n      return false;\n    }\n\n    try {\n      const fullMessage: WebSocketMessage = {\n        ...message,\n        timestamp: new Date().toISOString(),\n      };\n\n      client.ws.send(JSON.stringify(fullMessage));\n      return true;\n    } catch (error) {\n      logger.error('Error sending message to client', { clientId, error });\n      return false;\n    }\n  }\n\n  sendError(clientId: string, code: string, message: string, requestId?: string): boolean {\n    return this.sendToClient(clientId, {\n      type: 'error',\n      id: requestId ?? uuidv4(),\n      payload: { code, message },\n    });\n  }\n\n  broadcast(\n    message: Omit<WebSocketMessage, 'timestamp'>,\n    filter?: (client: WebSocketClient) => boolean\n  ): number {\n    let sentCount = 0;\n\n    this.clients.forEach(client => {\n      if (!filter || filter(client)) {\n        if (this.sendToClient(client.id, message)) {\n          sentCount += 1;\n        }\n      }\n    });\n\n    return sentCount;\n  }\n\n  closeConnection(clientId: string, _code: string, reason: string): void {\n    const client = this.clients.get(clientId);\n    if (client) {\n      try {\n        client.ws.close(1000, reason);\n      } catch (error) {\n        logger.error('Error closing WebSocket connection', { clientId, error });\n      }\n    }\n  }\n\n  getClient(clientId: string): WebSocketClient | undefined {\n    return this.clients.get(clientId);\n  }\n\n  getConnectedClients(): WebSocketClient[] {\n    return Array.from(this.clients.values());\n  }\n\n  getClientCount(): number {\n    return this.clients.size;\n  }\n\n  getSubscriptionManager(): SubscriptionManager {\n    return this.subscriptionManager;\n  }\n}\n\n// Singleton instance\nexport const webSocketManager = new WebSocketManager();\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/subscriptions.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 385,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 385,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11312, 11315], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11312, 11315], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-assignment",
        "severity": 1,
        "message": "Unsafe assignment of an `any` value.",
        "line": 389,
        "column": 9,
        "nodeType": "AssignmentExpression",
        "messageId": "anyAssignment",
        "endLine": 389,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unsafe-member-access",
        "severity": 1,
        "message": "Unsafe member access [key] on an `any` value.",
        "line": 389,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "unsafeMemberExpression",
        "endLine": 389,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 2,
        "message": "`import()` type annotations are forbidden.",
        "line": 399,
        "column": 28,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 399,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 2,
        "message": "`import()` type annotations are forbidden.",
        "line": 412,
        "column": 11,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 412,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/consistent-type-imports",
        "severity": 2,
        "message": "`import()` type annotations are forbidden.",
        "line": 441,
        "column": 11,
        "nodeType": "TSImportType",
        "messageId": "noImportTypeAnnotations",
        "endLine": 441,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { logger } from '../utils/logger';\nimport type { WebSocketClient, SubscriptionFilter } from './types';\nimport { SubscriptionChannel } from './types';\nimport type { WebSocketManager } from './server';\nimport type { AllWebSocketMessages, SystemNotification, PublicationContext } from './messageTypes';\n\nexport interface Subscription {\n  id: string;\n  clientId: string;\n  channel: SubscriptionChannel;\n  filters: SubscriptionFilter;\n  createdAt: Date;\n  lastActivity: Date;\n}\n\nexport class SubscriptionManager {\n  private readonly subscriptions = new Map<string, Subscription>();\n\n  private readonly clientSubscriptions = new Map<string, Set<string>>();\n\n  private readonly channelSubscriptions = new Map<SubscriptionChannel, Set<string>>();\n\n  private readonly webSocketManager: WebSocketManager;\n\n  constructor(webSocketManager: WebSocketManager) {\n    this.webSocketManager = webSocketManager;\n  }\n\n  // Subscribe to a channel\n  subscribe(\n    clientId: string,\n    channel: SubscriptionChannel,\n    filters: SubscriptionFilter = {}\n  ): { success: boolean; subscriptionId?: string; error?: string } {\n    try {\n      const client = this.webSocketManager.getClient(clientId);\n      if (!client) {\n        return { success: false, error: 'Client not found' };\n      }\n\n      // Check permissions\n      if (!this.webSocketManager.getAuth().canSubscribeToChannel(client.permissions, channel)) {\n        return { success: false, error: 'Insufficient permissions' };\n      }\n\n      // Check subscription limits\n      const currentSubscriptions = this.clientSubscriptions.get(clientId) ?? new Set();\n      if (currentSubscriptions.size >= 50) {\n        // Max 50 subscriptions per client\n        return { success: false, error: 'Subscription limit exceeded' };\n      }\n\n      // Create subscription ID\n      const subscriptionId = `${String(clientId)}_${String(channel)}_${String(Date.now())}`;\n\n      // Create subscription\n      const subscription: Subscription = {\n        id: subscriptionId,\n        clientId,\n        channel,\n        filters,\n        createdAt: new Date(),\n        lastActivity: new Date(),\n      };\n\n      // Store subscription\n      this.subscriptions.set(subscriptionId, subscription);\n\n      // Update client subscriptions\n      if (!this.clientSubscriptions.has(clientId)) {\n        this.clientSubscriptions.set(clientId, new Set());\n      }\n      this.clientSubscriptions.get(clientId)!.add(subscriptionId);\n      client.subscriptions.add(subscriptionId);\n\n      // Update channel subscriptions\n      if (!this.channelSubscriptions.has(channel)) {\n        this.channelSubscriptions.set(channel, new Set());\n      }\n      this.channelSubscriptions.get(channel)!.add(subscriptionId);\n\n      logger.info('Client subscribed to channel', {\n        clientId,\n        channel,\n        subscriptionId,\n        filters,\n      });\n\n      return { success: true, subscriptionId };\n    } catch (error) {\n      logger.error('Subscription error', { clientId, channel, error });\n      return { success: false, error: 'Subscription failed' };\n    }\n  }\n\n  // Unsubscribe from a channel\n  unsubscribe(subscriptionId: string): boolean {\n    try {\n      const subscription = this.subscriptions.get(subscriptionId);\n      if (!subscription) {\n        return false;\n      }\n\n      const { clientId, channel } = subscription;\n\n      // Remove from subscriptions\n      this.subscriptions.delete(subscriptionId);\n\n      // Remove from client subscriptions\n      const clientSubs = this.clientSubscriptions.get(clientId);\n      if (clientSubs) {\n        clientSubs.delete(subscriptionId);\n        if (clientSubs.size === 0) {\n          this.clientSubscriptions.delete(clientId);\n        }\n      }\n\n      // Remove from client object\n      const client = this.webSocketManager.getClient(clientId);\n      if (client) {\n        client.subscriptions.delete(subscriptionId);\n      }\n\n      // Remove from channel subscriptions\n      const channelSubs = this.channelSubscriptions.get(channel);\n      if (channelSubs) {\n        channelSubs.delete(subscriptionId);\n        if (channelSubs.size === 0) {\n          this.channelSubscriptions.delete(channel);\n        }\n      }\n\n      logger.info('Client unsubscribed from channel', {\n        clientId,\n        channel,\n        subscriptionId,\n      });\n\n      return true;\n    } catch (error) {\n      logger.error('Unsubscription error', { subscriptionId, error });\n      return false;\n    }\n  }\n\n  // Unsubscribe client from all channels\n  unsubscribeAll(clientId: string): number {\n    let unsubscribedCount = 0;\n    const clientSubs = this.clientSubscriptions.get(clientId);\n\n    if (clientSubs) {\n      const subscriptionIds = Array.from(clientSubs);\n      subscriptionIds.forEach(subscriptionId => {\n        if (this.unsubscribe(subscriptionId)) {\n          unsubscribedCount += 1;\n        }\n      });\n    }\n\n    return unsubscribedCount;\n  }\n\n  // Publish message to all subscribers of a channel\n  publishToChannel(\n    channel: SubscriptionChannel,\n    message: AllWebSocketMessages,\n    filterCallback?: (subscription: Subscription, client: WebSocketClient) => boolean\n  ): number {\n    let publishedCount = 0;\n    const channelSubs = this.channelSubscriptions.get(channel);\n\n    if (!channelSubs) {\n      return 0;\n    }\n\n    const subscriptionIds = Array.from(channelSubs);\n    subscriptionIds.forEach(subscriptionId => {\n      const subscription = this.subscriptions.get(subscriptionId);\n      if (!subscription) {\n        return;\n      }\n\n      const client = this.webSocketManager.getClient(subscription.clientId);\n      if (!client) {\n        return;\n      }\n\n      // Check if message matches subscription filters\n      if (!SubscriptionManager.matchesFilters(message, subscription.filters)) {\n        return;\n      }\n\n      // Apply custom filter if provided\n      if (filterCallback && !filterCallback(subscription, client)) {\n        return;\n      }\n\n      // Send message to client\n      const success = this.webSocketManager.sendToClient(subscription.clientId, message);\n      if (success) {\n        publishedCount += 1;\n        subscription.lastActivity = new Date();\n      }\n    });\n\n    return publishedCount;\n  }\n\n  // Publish to specific board subscribers\n  publishBoardUpdate(boardId: string, message: AllWebSocketMessages): number {\n    return this.publishToChannel(\n      SubscriptionChannel.BOARD,\n      message,\n      subscription => !subscription.filters.boardId || subscription.filters.boardId === boardId\n    );\n  }\n\n  // Publish to specific task subscribers\n  publishTaskUpdate(taskId: string, boardId: string, message: AllWebSocketMessages): number {\n    let count = 0;\n\n    // Send to task subscribers\n    count += this.publishToChannel(\n      SubscriptionChannel.TASK,\n      message,\n      subscription => !subscription.filters.taskId || subscription.filters.taskId === taskId\n    );\n\n    // Send to board subscribers\n    count += this.publishToChannel(\n      SubscriptionChannel.BOARD,\n      message,\n      subscription => !subscription.filters.boardId || subscription.filters.boardId === boardId\n    );\n\n    return count;\n  }\n\n  // Publish user presence updates\n  publishUserPresence(\n    userId: string,\n    status: 'online' | 'offline' | 'away',\n    context?: PublicationContext\n  ): number {\n    const message = {\n      type: 'connection:status' as const,\n      data: {\n        status: status === 'online' ? ('connected' as const) : ('disconnected' as const),\n        timestamp: new Date().toISOString(),\n        clientId: userId,\n      },\n      timestamp: new Date().toISOString(),\n      ...context,\n    };\n\n    return this.publishToChannel(\n      SubscriptionChannel.USER_PRESENCE,\n      message,\n      subscription => !subscription.filters.userId || subscription.filters.userId === userId\n    );\n  }\n\n  // Publish system notifications\n  publishSystemNotification(notification: SystemNotification, targetUsers?: string[]): number {\n    const message = {\n      type: 'system:notification' as const,\n      data: notification,\n      timestamp: new Date().toISOString(),\n    };\n\n    return this.publishToChannel(\n      SubscriptionChannel.SYSTEM_NOTIFICATIONS,\n      message,\n      (_subscription, client) => {\n        if (!targetUsers) return true;\n        return !!(client.user && targetUsers.includes(client.user.id));\n      }\n    );\n  }\n\n  // Get client subscriptions\n  getClientSubscriptions(clientId: string): Subscription[] {\n    const clientSubs = this.clientSubscriptions.get(clientId);\n    if (!clientSubs) return [];\n\n    return Array.from(clientSubs)\n      .map(id => this.subscriptions.get(id))\n      .filter(Boolean) as Subscription[];\n  }\n\n  // Get channel subscribers\n  getChannelSubscribers(channel: SubscriptionChannel): Subscription[] {\n    const channelSubs = this.channelSubscriptions.get(channel);\n    if (!channelSubs) return [];\n\n    return Array.from(channelSubs)\n      .map(id => this.subscriptions.get(id))\n      .filter(Boolean) as Subscription[];\n  }\n\n  // Get subscription statistics\n  getStats(): {\n    totalSubscriptions: number;\n    activeClients: number;\n    channelStats: Record<string, number>;\n    averageSubscriptionsPerClient: number;\n  } {\n    const channelStats: Record<string, number> = {};\n\n    for (const [channel, subs] of this.channelSubscriptions) {\n      channelStats[channel] = subs.size;\n    }\n\n    const activeClients = this.clientSubscriptions.size;\n    const totalSubscriptions = this.subscriptions.size;\n\n    return {\n      totalSubscriptions,\n      activeClients,\n      channelStats,\n      averageSubscriptionsPerClient: activeClients > 0 ? totalSubscriptions / activeClients : 0,\n    };\n  }\n\n  // Clean up expired subscriptions\n  cleanupExpiredSubscriptions(maxIdleTime: number = 30 * 60 * 1000): number {\n    // 30 minutes\n    const now = new Date();\n    const expiredSubscriptions: string[] = [];\n\n    for (const [id, subscription] of this.subscriptions) {\n      if (now.getTime() - subscription.lastActivity.getTime() > maxIdleTime) {\n        expiredSubscriptions.push(id);\n      }\n    }\n\n    let cleanedCount = 0;\n    for (const id of expiredSubscriptions) {\n      if (this.unsubscribe(id)) {\n        cleanedCount++;\n      }\n    }\n\n    if (cleanedCount > 0) {\n      logger.info('Cleaned up expired subscriptions', { count: cleanedCount });\n    }\n\n    return cleanedCount;\n  }\n\n  // Private helper methods\n  private static matchesFilters(\n    message: AllWebSocketMessages,\n    filters: SubscriptionFilter\n  ): boolean {\n    // If no filters, match all\n    if (!filters || Object.keys(filters).length === 0) {\n      return true;\n    }\n\n    // Check each filter\n    for (const [key, value] of Object.entries(filters)) {\n      if (value === undefined || value === null) continue;\n\n      const messageValue = this.getNestedProperty(message, key);\n\n      if (Array.isArray(value)) {\n        if (!value.includes(messageValue)) return false;\n      } else if (messageValue !== value) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private static getNestedProperty(obj: AllWebSocketMessages, path: string): unknown {\n    // For our message structure, common paths are:\n    // - type: message.type\n    // - boardId: message.data.boardId\n    // - taskId: message.data.taskId\n    // - userId: message.data.userId\n\n    const keys = path.split('.');\n    let current: any = obj;\n\n    for (const key of keys) {\n      if (current && typeof current === 'object' && key in current) {\n        current = current[key];\n      } else {\n        return undefined;\n      }\n    }\n\n    return current;\n  }\n\n  // Message type specific publishing methods\n  publishTaskCreated(task: import('../types').Task, createdBy: string): number {\n    return this.publishTaskUpdate(task.id, task.board_id, {\n      type: 'task:created',\n      data: {\n        task,\n        createdBy,\n        boardId: task.board_id,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  publishTaskUpdated(\n    task: import('../types').Task,\n    changes: Record<string, unknown>,\n    updatedBy: string\n  ): number {\n    return this.publishTaskUpdate(task.id, task.board_id, {\n      type: 'task:updated',\n      data: {\n        task,\n        changes,\n        updatedBy,\n        boardId: task.board_id,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  publishTaskDeleted(taskId: string, boardId: string, deletedBy: string): number {\n    return this.publishTaskUpdate(taskId, boardId, {\n      type: 'task:deleted',\n      data: {\n        taskId,\n        deletedBy,\n        boardId,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  publishNoteAdded(\n    note: import('../types').Note,\n    taskId: string,\n    boardId: string,\n    addedBy: string\n  ): number {\n    return this.publishTaskUpdate(taskId, boardId, {\n      type: 'note:added',\n      data: {\n        note,\n        taskId,\n        boardId,\n        addedBy,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n\n  publishTagAssigned(taskId: string, tagId: string, boardId: string, assignedBy: string): number {\n    return this.publishTaskUpdate(taskId, boardId, {\n      type: 'tag:assigned',\n      data: {\n        taskId,\n        tagId,\n        boardId,\n        assignedBy,\n      },\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n",
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  },
  {
    "filePath": "/Users/adammanuel/Projects/Agents/mcp-kanban/src/websocket/types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": [
      { "ruleId": "template-curly-spacing", "replacedBy": [] },
      { "ruleId": "arrow-spacing", "replacedBy": [] },
      { "ruleId": "generator-star-spacing", "replacedBy": [] },
      { "ruleId": "space-before-function-paren", "replacedBy": [] },
      { "ruleId": "lines-between-class-members", "replacedBy": [] },
      { "ruleId": "lines-around-directive", "replacedBy": ["padding-line-between-statements"] },
      { "ruleId": "no-new-object", "replacedBy": ["no-object-constructor"] },
      { "ruleId": "spaced-comment", "replacedBy": [] },
      { "ruleId": "global-require", "replacedBy": [] },
      { "ruleId": "no-buffer-constructor", "replacedBy": [] },
      { "ruleId": "no-new-require", "replacedBy": [] },
      { "ruleId": "no-path-concat", "replacedBy": [] },
      { "ruleId": "no-return-await", "replacedBy": [] }
    ]
  }
]
